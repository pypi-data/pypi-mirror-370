# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-06-20T09:40:38+00:00

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import UUID4, BaseModel, Field, RootModel, conint, constr

PropertySyntax = Literal["blobl", "snowflake", "bigquery"]


class ApplyResponse(BaseModel):
    status: Literal["applied", "nothing to apply"] = Field(..., title="Status")


class BatchSource(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the batch source.", title="Name"
    )
    timestamp_field: Optional[str] = Field(
        default=None,
        description="Event timestamp field used for point-in-time joins of attribute values.",
        title="Timestamp Field",
    )
    created_timestamp_column: Optional[str] = Field(
        default=None,
        description="Timestamp column indicating when the row was created, used for deduplicating rows.",
        title="Created Timestamp Column",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the data source, typically the email of the primary maintainer.",
        title="Owner",
    )
    date_partition_column: Optional[str] = Field(
        default=None,
        description="Timestamp column used for partitioning.",
        title="Date Partition Column",
    )
    database: str = Field(
        ..., description="Database where the attributes are stored.", title="Database"
    )
    schema_: str = Field(
        ...,
        alias="schema",
        description="Schema in which the table is located.",
        title="Schema",
    )
    table: str = Field(
        ..., description="Table where the attributes are stored.", title="Table"
    )


class ClearAttributeContext(BaseModel):
    field_attributes: Optional[Dict[str, Any]] = Field(
        default=None, alias="$attributes", title="$Attributes"
    )
    attribute: constr(
        pattern=r"^[A-Za-z0-9_]{1,128}:[A-Za-z0-9_]{1,128}$",
        min_length=3,
        max_length=257,
    ) = Field(
        ...,
        description="An unversioned reference to a view and attribute, delimited by a colon.",
        title="Attribute",
    )


class DeliveryStatus(BaseModel):
    status: Literal["failure", "success", "undelivered"] = Field(..., title="Status")


class Entity(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    key: Optional[constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128)] = (
        Field(
            default=None,
            description="The key used to join this entity to an attribute table. If not specified, the name is used.",
            title="Key",
        )
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the entity, typically the email of the primary maintainer.",
        title="Owner",
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time that attributes for the entity will live in the online store. If not specified both here and in the View, the ttl is not limited.",
        title="Ttl",
    )


class EntityIdentifiers(RootModel[Optional[Dict[str, Optional[List]]]]):
    root: Optional[Dict[str, Optional[List]]] = None


class Event(BaseModel):
    name: Optional[
        constr(pattern=r"^[a-zA-Z0-9-_]+$", min_length=1, max_length=128)
    ] = Field(
        default=None,
        description="Name of the event (`event_name` column in atomic.events table).",
        title="Name",
    )
    vendor: Optional[
        constr(pattern=r"^[a-zA-Z0-9-_.]+$", min_length=1, max_length=128)
    ] = Field(
        default=None,
        description="Vendor of the event (`event_vendor` column in atomic.events table).",
        title="Vendor",
    )
    version: Optional[constr(pattern=r"^[0-9]+-[0-9]+-[0-9]+$")] = Field(
        default=None,
        description="Version of the event (`event_version` column in atomic.events table).",
        title="Version",
    )


class FeatureRef(BaseModel):
    name: constr(min_length=1, max_length=128) = Field(
        ...,
        description="The name of a feature in the prompt to be replaced. Will be inside double curly brackets in the prompt.",
        examples=["count_of_clicks", "avg_cart_value"],
        title="Name",
    )
    reference: str = Field(
        ...,
        description="The reference of the feature stored in the online store. Format is {view}:{feature_name}.",
        examples=[
            "session_features:count_of_clicks",
            "ecommerce_features:avg_cart_value",
        ],
        title="Feature reference",
    )


class FieldModel(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The name of the field.", title="Name"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )


class GetOnlineAttributesRequest(BaseModel):
    entities: EntityIdentifiers
    service: Optional[str] = Field(default=None, title="Service")
    attributes: Optional[List[str]] = Field(default=None, title="Attributes")
    full_attribute_names: Optional[bool] = Field(
        default=False, title="Full Attribute Names"
    )


class LinkEntity(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )


class PromptBase(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The name of the prompt, given by the user. Also used by the SDK as reference to fetch a prompt.",
        examples=["my_prompt"],
        title="Prompt name",
    )
    version: conint(ge=1) = Field(
        ...,
        description="The version of the prompt, incremented automatically when updating the prompt.",
        title="Prompt version",
    )
    prompt: constr(min_length=1) = Field(
        ...,
        description="The contents of the prompt, written by the user.",
        examples=["Has clicked {{session_button_clicks}} times."],
        title="Prompt text",
    )
    features: List[FeatureRef] = Field(
        ..., description="The features the prompt references by name.", title="Features"
    )
    labels: List[Literal["production", "latest"]] = Field(
        ...,
        description="A list of labels that are only added by the system. E.g. 'production', 'latest'",
        examples=[["production"]],
        title="Labels",
    )
    tags: List[str] = Field(
        ...,
        description="A list of tags to categorize the prompt.",
        examples=[["tag1", "tag2"]],
        title="Tags",
    )
    author: str = Field(
        ...,
        description="The author of the prompt.",
        examples=["peter@snowplowanalytics.com"],
        title="Author",
    )
    commit_msg: Optional[str] = Field(
        ...,
        description="The commit message explaining the changes for the next version.",
        examples=["Updated prompt text"],
        title="Commit message",
    )


class PromptDeletedResponse(BaseModel):
    ok: bool = Field(..., title="Ok")


class PromptHydrateResponse(BaseModel):
    prompt: str = Field(..., title="Prompt")


class PromptResponse(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The name of the prompt, given by the user. Also used by the SDK as reference to fetch a prompt.",
        examples=["my_prompt"],
        title="Prompt name",
    )
    version: conint(ge=1) = Field(
        ...,
        description="The version of the prompt, incremented automatically when updating the prompt.",
        title="Prompt version",
    )
    prompt: constr(min_length=1) = Field(
        ...,
        description="The contents of the prompt, written by the user.",
        examples=["Has clicked {{session_button_clicks}} times."],
        title="Prompt text",
    )
    features: List[FeatureRef] = Field(
        ..., description="The features the prompt references by name.", title="Features"
    )
    labels: List[Literal["production", "latest"]] = Field(
        ...,
        description="A list of labels that are only added by the system. E.g. 'production', 'latest'",
        examples=[["production"]],
        title="Labels",
    )
    tags: List[str] = Field(
        ...,
        description="A list of tags to categorize the prompt.",
        examples=[["tag1", "tag2"]],
        title="Tags",
    )
    author: str = Field(
        ...,
        description="The author of the prompt.",
        examples=["peter@snowplowanalytics.com"],
        title="Author",
    )
    commit_msg: Optional[str] = Field(
        ...,
        description="The commit message explaining the changes for the next version.",
        examples=["Updated prompt text"],
        title="Commit message",
    )
    id: UUID4 = Field(..., title="Id")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class PushAttributesRequest(BaseModel):
    push_source_name: str = Field(..., title="Push Source Name")
    df: Dict[str, List] = Field(..., title="Df")
    allow_registry_cache: Optional[bool] = Field(
        default=True, title="Allow Registry Cache"
    )
    to: Optional[Literal["online", "online_and_offline"]] = Field(
        default="online", title="To"
    )


class SetAttributeContext(BaseModel):
    field_attributes: Optional[Dict[str, Any]] = Field(
        default=None, alias="$attributes", title="$Attributes"
    )
    attribute: constr(
        pattern=r"^[A-Za-z0-9_]{1,128}:[A-Za-z0-9_]{1,128}$",
        min_length=3,
        max_length=257,
    ) = Field(
        ...,
        description="An unversioned reference to a view and attribute, delimited by a colon.",
        title="Attribute",
    )
    value: Optional[Any] = Field(default=None, title="Value")
    path: Optional[
        constr(
            pattern=r"^[A-Za-z0-9_]{1,128}:[A-Za-z0-9_]{1,128}$",
            min_length=3,
            max_length=257,
        )
    ] = Field(
        default=None,
        description="An unversioned reference to a view and attribute, delimited by a colon.",
        title="Path",
    )
    clear_history: Optional[bool] = Field(default=None, title="Clear History")


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class VersionedLinkView(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )


class SignalsApiModelsInterventionCriterionCriterion(BaseModel):
    attribute: constr(
        pattern=r"^[A-Za-z0-9_]{1,128}:[A-Za-z0-9_]{1,128}$",
        min_length=3,
        max_length=257,
    ) = Field(
        ...,
        description="The name of the attribute to evaluate for this criterion using operator and value. The attribute name should be qualified, including the name of the view that contains it",
        title="Attribute",
    )
    operator: Literal[
        "=",
        "!=",
        "<",
        ">",
        "<=",
        ">=",
        "like",
        "not like",
        "rlike",
        "not rlike",
        "in",
        "not in",
        "is null",
        "is not null",
    ] = Field(
        ...,
        description="The operator used to compare the attribute to the value.",
        title="Operator",
    )
    value: Optional[
        Union[str, int, float, bool, List[str], List[int], List[float], List[bool]]
    ] = Field(
        default=None,
        description="The value to be compared using operator against the attribute value for this criterion.",
        title="Value",
    )


class SignalsApiModelsViewCriterionCriterion(BaseModel):
    property_syntax: PropertySyntax = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: str = Field(
        ...,
        description="The path to the property on the event or entity you wish to filter.",
        title="Property",
    )
    operator: Literal["=", "!=", "<", ">", "<=", ">=", "like", "in"] = Field(
        ...,
        description="The operator used to compare the property to the value.",
        title="Operator",
    )
    value: Union[
        str, int, float, bool, List[str], List[int], List[float], List[bool]
    ] = Field(..., description="The value to compare the property to.", title="Value")


class BaseIntervention(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    method: Literal[
        "clear_attribute",
        "set_attribute",
        "script",
        "computer_use_agent",
        "remote_agent",
    ] = Field(
        ...,
        description="Type of intervention capabilities that are required to handle the intervention",
        title="Method",
    )
    target_agents: Optional[List[str]] = Field(
        default=None,
        description="List of identifiers for agents that should handle this intervention. If not provided, generic intervention all agents should be allowed to process",
        title="Target Agents",
    )
    script_uri: Optional[str] = Field(
        default=None,
        description="Script text or content that should be interpreted by the handling agent(s)",
        title="Script Uri",
    )
    context: Optional[
        Union[SetAttributeContext, ClearAttributeContext, Dict[str, Any]]
    ] = Field(
        default=None,
        description="Additional context that is passed to the agent alongside the script content",
        title="Context",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )


class Criteria(BaseModel):
    all: Optional[List[SignalsApiModelsViewCriterionCriterion]] = Field(
        default=None,
        description="An array of conditions used to filter the events. All conditions must be met.",
        title="All",
    )
    any: Optional[List[SignalsApiModelsViewCriterionCriterion]] = Field(
        default=None,
        description="An array of conditions used to filter the events. At least one condition must be met.",
        title="Any",
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(default=None, title="Detail")


class InterventionInstance(BaseModel):
    method: Literal[
        "clear_attribute",
        "set_attribute",
        "script",
        "computer_use_agent",
        "remote_agent",
    ] = Field(
        ...,
        description="Type of intervention capabilities that are required to handle the intervention",
        title="Method",
    )
    target_agents: Optional[List[str]] = Field(
        default=None,
        description="List of identifiers for agents that should handle this intervention. If not provided, generic intervention all agents should be allowed to process",
        title="Target Agents",
    )
    script_uri: Optional[str] = Field(
        default=None,
        description="Script text or content that should be interpreted by the handling agent(s)",
        title="Script Uri",
    )
    context: Optional[
        Union[SetAttributeContext, ClearAttributeContext, Dict[str, Any]]
    ] = Field(
        default=None,
        description="Additional context that is passed to the agent alongside the script content",
        title="Context",
    )
    intervention_id: Optional[UUID] = Field(default=None, title="Intervention Id")
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the intervention.", title="Name"
    )
    version: int = Field(..., description="The version of the object.", title="Version")


class Service(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    views: Optional[List[VersionedLinkView]] = Field(
        default=None,
        description="A list containing views, representing the features in the service.",
        max_length=100,
        min_length=1,
        title="Views",
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the service, typically the email of the primary maintainer.",
        title="Owner",
    )


class AttributeInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The name of the field.", title="Name"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    events: List[Event] = Field(
        ...,
        description="An array of event schemas that the attribute should be calculated for.",
        min_length=1,
        title="Events",
    )
    aggregation: Literal[
        "counter", "sum", "min", "max", "mean", "first", "last", "unique_list"
    ] = Field(
        ..., description="The aggregation type of the attribute.", title="Aggregation"
    )
    property_syntax: PropertySyntax = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: Optional[str] = Field(
        default=None,
        description="The path to the property on the event or entity you wish to use in the aggregation.",
        title="Property",
    )
    criteria: Optional[Criteria] = Field(
        default=None, description="An array of conditions used to filter the events."
    )
    period: Optional[timedelta] = Field(
        default=None,
        description="The time period over which the aggregation should be calculated.",
        title="Period",
    )
    default_value: Optional[
        Union[str, int, float, bool, List[Union[str, int, float, bool]]]
    ] = Field(
        default=None,
        description="The default value to use if the aggregation returns no results. If not set, the default value is automatically assigned based on the `type`.",
        title="Default Value",
    )


class AttributeOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The name of the field.", title="Name"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    events: List[Event] = Field(
        ...,
        description="An array of event schemas that the attribute should be calculated for.",
        min_length=1,
        title="Events",
    )
    aggregation: Literal[
        "counter", "sum", "min", "max", "mean", "first", "last", "unique_list"
    ] = Field(
        ..., description="The aggregation type of the attribute.", title="Aggregation"
    )
    property_syntax: PropertySyntax = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: Optional[str] = Field(
        default=None,
        description="The path to the property on the event or entity you wish to use in the aggregation.",
        title="Property",
    )
    criteria: Optional[Criteria] = Field(
        default=None, description="An array of conditions used to filter the events."
    )
    period: Optional[timedelta] = Field(
        default=None,
        description="The time period over which the aggregation should be calculated.",
        title="Period",
    )
    default_value: Optional[
        Union[str, int, float, bool, List[Union[str, int, float, bool]]]
    ] = Field(
        default=None,
        description="The default value to use if the aggregation returns no results. If not set, the default value is automatically assigned based on the `type`.",
        title="Default Value",
    )


class ViewInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeInput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )


class ViewOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeOutput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )
    feast_name: str = Field(..., title="Feast Name")
    stream_source_name: Optional[str] = Field(..., title="Stream Source Name")


class ViewResponse(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeOutput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )
    entity_key: str = Field(
        ..., description="The key of the associated entity.", title="Entity Key"
    )
    view_or_entity_ttl: Optional[timedelta] = Field(
        default=None,
        description="The TTL of the view or entity.",
        title="View Or Entity Ttl",
    )
    feast_name: str = Field(..., title="Feast Name")
    stream_source_name: Optional[str] = Field(..., title="Stream Source Name")


class AppliedAttributesForStream(BaseModel):
    views: List[ViewResponse] = Field(..., title="Views")
    applied_at: Optional[datetime] = Field(default=None, title="Applied At")


class TestViewRequest(BaseModel):
    view: ViewInput = Field(..., description="View to test")
    app_ids: Optional[List[str]] = Field(
        default=None,
        description="List of app_ids to test. If empty, all app_ids will be tested",
        title="App Ids",
    )
    window: Optional[timedelta] = Field(
        default="PT1H",
        description="The time window to consider when querying the atomic events table",
        title="Window",
    )
    entity_ids: Optional[List[str]] = Field(
        default=None,
        description="List of entity IDs to test (e.g., list of domain_userid). If empty, a sample of 10 random IDs will be used",
        title="Entity Ids",
    )


class AppliedInterventionsForStream(BaseModel):
    interventions: List[Union[RuleInterventionOutput, BaseIntervention]] = Field(
        ..., title="Interventions"
    )
    applied_at: Optional[datetime] = Field(default=None, title="Applied At")


class CriteriaAllInput(BaseModel):
    all: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. All conditions must be met.",
        title="All",
    )


class CriteriaAllOutput(BaseModel):
    all: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. All conditions must be met.",
        title="All",
    )


class CriteriaAnyInput(BaseModel):
    any: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. At least one condition must be met.",
        title="Any",
    )


class CriteriaAnyOutput(BaseModel):
    any: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. At least one condition must be met.",
        title="Any",
    )


class CriteriaNoneInput(BaseModel):
    none: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. None of the conditions may be met.",
        title="None",
    )


class CriteriaNoneOutput(BaseModel):
    none: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. None of the conditions may be met.",
        title="None",
    )


class RuleInterventionInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    method: Literal[
        "clear_attribute",
        "set_attribute",
        "script",
        "computer_use_agent",
        "remote_agent",
    ] = Field(
        ...,
        description="Type of intervention capabilities that are required to handle the intervention",
        title="Method",
    )
    target_agents: Optional[List[str]] = Field(
        default=None,
        description="List of identifiers for agents that should handle this intervention. If not provided, generic intervention all agents should be allowed to process",
        title="Target Agents",
    )
    script_uri: Optional[str] = Field(
        default=None,
        description="Script text or content that should be interpreted by the handling agent(s)",
        title="Script Uri",
    )
    context: Optional[
        Union[SetAttributeContext, ClearAttributeContext, Dict[str, Any]]
    ] = Field(
        default=None,
        description="Additional context that is passed to the agent alongside the script content",
        title="Context",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )
    criteria: Union[
        CriteriaAllInput,
        CriteriaAnyInput,
        CriteriaNoneInput,
        SignalsApiModelsInterventionCriterionCriterion,
    ] = Field(
        ...,
        description="Rule or group of rules defining features that should be evaluated to determine if the intervention should be triggered",
        title="Criteria",
    )


class RuleInterventionOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ..., description="The unique name of the object.", title="Name"
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    method: Literal[
        "clear_attribute",
        "set_attribute",
        "script",
        "computer_use_agent",
        "remote_agent",
    ] = Field(
        ...,
        description="Type of intervention capabilities that are required to handle the intervention",
        title="Method",
    )
    target_agents: Optional[List[str]] = Field(
        default=None,
        description="List of identifiers for agents that should handle this intervention. If not provided, generic intervention all agents should be allowed to process",
        title="Target Agents",
    )
    script_uri: Optional[str] = Field(
        default=None,
        description="Script text or content that should be interpreted by the handling agent(s)",
        title="Script Uri",
    )
    context: Optional[
        Union[SetAttributeContext, ClearAttributeContext, Dict[str, Any]]
    ] = Field(
        default=None,
        description="Additional context that is passed to the agent alongside the script content",
        title="Context",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )
    criteria: Union[
        CriteriaAllOutput,
        CriteriaAnyOutput,
        CriteriaNoneOutput,
        SignalsApiModelsInterventionCriterionCriterion,
    ] = Field(
        ...,
        description="Rule or group of rules defining features that should be evaluated to determine if the intervention should be triggered",
        title="Criteria",
    )


AppliedInterventionsForStream.model_rebuild()
CriteriaAllInput.model_rebuild()
CriteriaAllOutput.model_rebuild()
CriteriaAnyInput.model_rebuild()
CriteriaAnyOutput.model_rebuild()
