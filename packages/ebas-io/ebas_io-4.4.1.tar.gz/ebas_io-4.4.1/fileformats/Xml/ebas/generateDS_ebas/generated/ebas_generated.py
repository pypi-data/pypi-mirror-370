#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Aug 25 00:38:10 2014 by generateDS.py version 2.12e.
#
# Command line options:
#   ('--external-encoding', 'utf-8')
#   ('--no-process-includes', '')
#   ('-o', 'ebas_generated.py')
#
# Command line arguments:
#   schema/ebas.xsd
#
# Command line:
#   /Library/Frameworks/Python.framework/Versions/2.7/bin/generateDS.py --external-encoding="utf-8" --no-process-includes -o "ebas_generated.py" schema/ebas.xsd
#
# Current working directory (os.getcwd()):
#   generated
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_
from six import string_types

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, string_types) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, string_types) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Result(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResultSet=None):
        self.original_tagname_ = None
        if ResultSet is None:
            self.ResultSet = []
        else:
            self.ResultSet = ResultSet
    def factory(*args_, **kwargs_):
        if Result.subclass:
            return Result.subclass(*args_, **kwargs_)
        else:
            return Result(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResultSet(self): return self.ResultSet
    def set_ResultSet(self, ResultSet): self.ResultSet = ResultSet
    def add_ResultSet(self, value): self.ResultSet.append(value)
    def insert_ResultSet_at(self, index, value): self.ResultSet.insert(index, value)
    def replace_ResultSet_at(self, index, value): self.ResultSet[index] = value
    def hasContent_(self):
        if (
            self.ResultSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='Result', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Result')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='Result', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='Result'):
        pass
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='Result', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResultSet_ in self.ResultSet:
            ResultSet_.export(outfile, level, namespace_, name_='ResultSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Result'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ResultSet=[\n')
        level += 1
        for ResultSet_ in self.ResultSet:
            showIndent(outfile, level)
            outfile.write('model_.ResultSetType(\n')
            ResultSet_.exportLiteral(outfile, level, name_='ResultSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResultSet':
            obj_ = ResultSetType.factory()
            obj_.build(child_)
            self.ResultSet.append(obj_)
            obj_.original_tagname_ = 'ResultSet'
# end class Result


class ResultSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TimeDimension=None, DataSet=None):
        self.original_tagname_ = None
        self.TimeDimension = TimeDimension
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
    def factory(*args_, **kwargs_):
        if ResultSetType.subclass:
            return ResultSetType.subclass(*args_, **kwargs_)
        else:
            return ResultSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeDimension(self): return self.TimeDimension
    def set_TimeDimension(self, TimeDimension): self.TimeDimension = TimeDimension
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def hasContent_(self):
        if (
            self.TimeDimension is not None or
            self.DataSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='ResultSetType', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='ResultSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='ResultSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='ResultSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeDimension is not None:
            self.TimeDimension.export(outfile, level, namespace_, name_='TimeDimension', pretty_print=pretty_print)
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_, name_='DataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResultSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeDimension is not None:
            showIndent(outfile, level)
            outfile.write('TimeDimension=model_.TimeDimensionType(\n')
            self.TimeDimension.exportLiteral(outfile, level, name_='TimeDimension')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSetType(\n')
            DataSet_.exportLiteral(outfile, level, name_='DataSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeDimension':
            obj_ = TimeDimensionType.factory()
            obj_.build(child_)
            self.TimeDimension = obj_
            obj_.original_tagname_ = 'TimeDimension'
        elif nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
# end class ResultSetType


class TimeDimensionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartTimes=None, EndTimes=None):
        self.original_tagname_ = None
        if isinstance(StartTimes, string_types):
            initvalue_ = datetime_.datetime.strptime(StartTimes, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTimes
        self.StartTimes = initvalue_
        if isinstance(EndTimes, string_types):
            initvalue_ = datetime_.datetime.strptime(EndTimes, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EndTimes
        self.EndTimes = initvalue_
    def factory(*args_, **kwargs_):
        if TimeDimensionType.subclass:
            return TimeDimensionType.subclass(*args_, **kwargs_)
        else:
            return TimeDimensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartTimes(self): return self.StartTimes
    def set_StartTimes(self, StartTimes): self.StartTimes = StartTimes
    def get_EndTimes(self): return self.EndTimes
    def set_EndTimes(self, EndTimes): self.EndTimes = EndTimes
    def validate_DateTimeListType(self, value):
        # Validate type DateTimeListType, a restriction on xs:dateTime.
        pass
    def hasContent_(self):
        if (
            self.StartTimes is not None or
            self.EndTimes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='TimeDimensionType', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeDimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='TimeDimensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='TimeDimensionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='TimeDimensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartTimes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTimes>%s</%sStartTimes>%s' % (namespace_, self.gds_format_datetime(self.StartTimes, input_name='StartTimes'), namespace_, eol_))
        if self.EndTimes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTimes>%s</%sEndTimes>%s' % (namespace_, self.gds_format_datetime(self.EndTimes, input_name='EndTimes'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeDimensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartTimes is not None:
            showIndent(outfile, level)
            outfile.write('StartTimes=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.StartTimes, input_name='StartTimes'))
        if self.EndTimes is not None:
            showIndent(outfile, level)
            outfile.write('EndTimes=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.EndTimes, input_name='EndTimes'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartTimes':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTimes = dval_
            self.StartTimes = self.StartTimes.split()
            self.validate_DateTimeListType(self.StartTimes)    # validate type DateTimeListType
        elif nodeName_ == 'EndTimes':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EndTimes = dval_
            self.EndTimes = self.EndTimes.split()
            self.validate_DateTimeListType(self.EndTimes)    # validate type DateTimeListType
# end class TimeDimensionType


class DataSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, setkey=None, StationCode=None, StationName=None, InstrumentType=None, ComponentName=None, Location=None, Wavelength=None, D=None, Dmin=None, Dmax=None, Matrix=None, Unit=None, Statistics=None, ResolutionCode=None, DataLevel=None, MeasurementUncertainty=None, Position=None, HeightAGL=None, Values=None):
        self.original_tagname_ = None
        self.setkey = _cast(int, setkey)
        self.StationCode = StationCode
        self.StationName = StationName
        self.InstrumentType = InstrumentType
        self.ComponentName = ComponentName
        self.Location = Location
        self.Wavelength = Wavelength
        self.D = D
        self.Dmin = Dmin
        self.Dmax = Dmax
        self.Matrix = Matrix
        self.Unit = Unit
        self.Statistics = Statistics
        self.ResolutionCode = ResolutionCode
        self.DataLevel = DataLevel
        self.MeasurementUncertainty = MeasurementUncertainty
        self.Position = Position
        self.HeightAGL = HeightAGL
        self.Values = Values
    def factory(*args_, **kwargs_):
        if DataSetType.subclass:
            return DataSetType.subclass(*args_, **kwargs_)
        else:
            return DataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StationCode(self): return self.StationCode
    def set_StationCode(self, StationCode): self.StationCode = StationCode
    def get_StationName(self): return self.StationName
    def set_StationName(self, StationName): self.StationName = StationName
    def get_InstrumentType(self): return self.InstrumentType
    def set_InstrumentType(self, InstrumentType): self.InstrumentType = InstrumentType
    def get_ComponentName(self): return self.ComponentName
    def set_ComponentName(self, ComponentName): self.ComponentName = ComponentName
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_Wavelength(self): return self.Wavelength
    def set_Wavelength(self, Wavelength): self.Wavelength = Wavelength
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_Dmin(self): return self.Dmin
    def set_Dmin(self, Dmin): self.Dmin = Dmin
    def get_Dmax(self): return self.Dmax
    def set_Dmax(self, Dmax): self.Dmax = Dmax
    def get_Matrix(self): return self.Matrix
    def set_Matrix(self, Matrix): self.Matrix = Matrix
    def get_Unit(self): return self.Unit
    def set_Unit(self, Unit): self.Unit = Unit
    def get_Statistics(self): return self.Statistics
    def set_Statistics(self, Statistics): self.Statistics = Statistics
    def get_ResolutionCode(self): return self.ResolutionCode
    def set_ResolutionCode(self, ResolutionCode): self.ResolutionCode = ResolutionCode
    def get_DataLevel(self): return self.DataLevel
    def set_DataLevel(self, DataLevel): self.DataLevel = DataLevel
    def get_MeasurementUncertainty(self): return self.MeasurementUncertainty
    def set_MeasurementUncertainty(self, MeasurementUncertainty): self.MeasurementUncertainty = MeasurementUncertainty
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_HeightAGL(self): return self.HeightAGL
    def set_HeightAGL(self, HeightAGL): self.HeightAGL = HeightAGL
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    def get_setkey(self): return self.setkey
    def set_setkey(self, setkey): self.setkey = setkey
    def validate_LocationType(self, value):
        # Validate type LocationType, a restriction on xs:string.
        pass
    def validate_ValueListType(self, value):
        # Validate type ValueListType, a restriction on xs:float.
        pass
    def hasContent_(self):
        if (
            self.StationCode is not None or
            self.StationName is not None or
            self.InstrumentType is not None or
            self.ComponentName is not None or
            self.Location is not None or
            self.Wavelength is not None or
            self.D is not None or
            self.Dmin is not None or
            self.Dmax is not None or
            self.Matrix is not None or
            self.Unit is not None or
            self.Statistics is not None or
            self.ResolutionCode is not None or
            self.DataLevel is not None or
            self.MeasurementUncertainty is not None or
            self.Position is not None or
            self.HeightAGL is not None or
            self.Values is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='DataSetType', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='DataSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='DataSetType'):
        if self.setkey is not None and 'setkey' not in already_processed:
            already_processed.add('setkey')
            outfile.write(' setkey="%s"' % self.gds_format_integer(self.setkey, input_name='setkey'))
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='DataSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StationCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStationCode>%s</%sStationCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.StationCode).encode(ExternalEncoding), input_name='StationCode'), namespace_, eol_))
        if self.StationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStationName>%s</%sStationName>%s' % (namespace_, self.gds_format_string(quote_xml(self.StationName).encode(ExternalEncoding), input_name='StationName'), namespace_, eol_))
        if self.InstrumentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstrumentType>%s</%sInstrumentType>%s' % (namespace_, self.gds_format_string(quote_xml(self.InstrumentType).encode(ExternalEncoding), input_name='InstrumentType'), namespace_, eol_))
        if self.ComponentName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComponentName>%s</%sComponentName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComponentName).encode(ExternalEncoding), input_name='ComponentName'), namespace_, eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation>%s</%sLocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.Location).encode(ExternalEncoding), input_name='Location'), namespace_, eol_))
        if self.Wavelength is not None:
            self.Wavelength.export(outfile, level, namespace_, name_='Wavelength', pretty_print=pretty_print)
        if self.D is not None:
            self.D.export(outfile, level, namespace_, name_='D', pretty_print=pretty_print)
        if self.Dmin is not None:
            self.Dmin.export(outfile, level, namespace_, name_='Dmin', pretty_print=pretty_print)
        if self.Dmax is not None:
            self.Dmax.export(outfile, level, namespace_, name_='Dmax', pretty_print=pretty_print)
        if self.Matrix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMatrix>%s</%sMatrix>%s' % (namespace_, self.gds_format_string(quote_xml(self.Matrix).encode(ExternalEncoding), input_name='Matrix'), namespace_, eol_))
        if self.Unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnit>%s</%sUnit>%s' % (namespace_, self.gds_format_string(quote_xml(self.Unit).encode(ExternalEncoding), input_name='Unit'), namespace_, eol_))
        if self.Statistics is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatistics>%s</%sStatistics>%s' % (namespace_, self.gds_format_string(quote_xml(self.Statistics).encode(ExternalEncoding), input_name='Statistics'), namespace_, eol_))
        if self.ResolutionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResolutionCode>%s</%sResolutionCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ResolutionCode).encode(ExternalEncoding), input_name='ResolutionCode'), namespace_, eol_))
        if self.DataLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataLevel>%s</%sDataLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataLevel).encode(ExternalEncoding), input_name='DataLevel'), namespace_, eol_))
        if self.MeasurementUncertainty is not None:
            self.MeasurementUncertainty.export(outfile, level, namespace_, name_='MeasurementUncertainty', pretty_print=pretty_print)
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.HeightAGL is not None:
            self.HeightAGL.export(outfile, level, namespace_, name_='HeightAGL', pretty_print=pretty_print)
        if self.Values is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValues>%s</%sValues>%s' % (namespace_, self.gds_format_float_list(self.Values, input_name='Values'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DataSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.setkey is not None and 'setkey' not in already_processed:
            already_processed.add('setkey')
            showIndent(outfile, level)
            outfile.write('setkey=%d,\n' % (self.setkey,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StationCode is not None:
            showIndent(outfile, level)
            outfile.write('StationCode=%s,\n' % quote_python(self.StationCode).encode(ExternalEncoding))
        if self.StationName is not None:
            showIndent(outfile, level)
            outfile.write('StationName=%s,\n' % quote_python(self.StationName).encode(ExternalEncoding))
        if self.InstrumentType is not None:
            showIndent(outfile, level)
            outfile.write('InstrumentType=%s,\n' % quote_python(self.InstrumentType).encode(ExternalEncoding))
        if self.ComponentName is not None:
            showIndent(outfile, level)
            outfile.write('ComponentName=%s,\n' % quote_python(self.ComponentName).encode(ExternalEncoding))
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=%s,\n' % quote_python(self.Location).encode(ExternalEncoding))
        if self.Wavelength is not None:
            showIndent(outfile, level)
            outfile.write('Wavelength=model_.WavelengthType(\n')
            self.Wavelength.exportLiteral(outfile, level, name_='Wavelength')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.ParticleDiameterType(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dmin is not None:
            showIndent(outfile, level)
            outfile.write('Dmin=model_.ParticleDiameterType(\n')
            self.Dmin.exportLiteral(outfile, level, name_='Dmin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dmax is not None:
            showIndent(outfile, level)
            outfile.write('Dmax=model_.ParticleDiameterType(\n')
            self.Dmax.exportLiteral(outfile, level, name_='Dmax')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Matrix is not None:
            showIndent(outfile, level)
            outfile.write('Matrix=%s,\n' % quote_python(self.Matrix).encode(ExternalEncoding))
        if self.Unit is not None:
            showIndent(outfile, level)
            outfile.write('Unit=%s,\n' % quote_python(self.Unit).encode(ExternalEncoding))
        if self.Statistics is not None:
            showIndent(outfile, level)
            outfile.write('Statistics=%s,\n' % quote_python(self.Statistics).encode(ExternalEncoding))
        if self.ResolutionCode is not None:
            showIndent(outfile, level)
            outfile.write('ResolutionCode=%s,\n' % quote_python(self.ResolutionCode).encode(ExternalEncoding))
        if self.DataLevel is not None:
            showIndent(outfile, level)
            outfile.write('DataLevel=%s,\n' % quote_python(self.DataLevel).encode(ExternalEncoding))
        if self.MeasurementUncertainty is not None:
            showIndent(outfile, level)
            outfile.write('MeasurementUncertainty=model_.MeasurementUncertainty(\n')
            self.MeasurementUncertainty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Position is not None:
            showIndent(outfile, level)
            outfile.write('Position=model_.Position(\n')
            self.Position.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HeightAGL is not None:
            showIndent(outfile, level)
            outfile.write('HeightAGL=model_.HeightAGL(\n')
            self.HeightAGL.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Values is not None:
            showIndent(outfile, level)
            outfile.write('Values=%f,\n' % self.Values)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('setkey', node)
        if value is not None and 'setkey' not in already_processed:
            already_processed.add('setkey')
            try:
                self.setkey = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StationCode':
            StationCode_ = child_.text
            StationCode_ = self.gds_validate_string(StationCode_, node, 'StationCode')
            self.StationCode = StationCode_
        elif nodeName_ == 'StationName':
            StationName_ = child_.text
            StationName_ = self.gds_validate_string(StationName_, node, 'StationName')
            self.StationName = StationName_
        elif nodeName_ == 'InstrumentType':
            InstrumentType_ = child_.text
            InstrumentType_ = self.gds_validate_string(InstrumentType_, node, 'InstrumentType')
            self.InstrumentType = InstrumentType_
        elif nodeName_ == 'ComponentName':
            ComponentName_ = child_.text
            ComponentName_ = self.gds_validate_string(ComponentName_, node, 'ComponentName')
            self.ComponentName = ComponentName_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
            self.validate_LocationType(self.Location)    # validate type LocationType
        elif nodeName_ == 'Wavelength':
            obj_ = WavelengthType.factory()
            obj_.build(child_)
            self.Wavelength = obj_
            obj_.original_tagname_ = 'Wavelength'
        elif nodeName_ == 'D':
            obj_ = ParticleDiameterType.factory()
            obj_.build(child_)
            self.D = obj_
            obj_.original_tagname_ = 'D'
        elif nodeName_ == 'Dmin':
            obj_ = ParticleDiameterType.factory()
            obj_.build(child_)
            self.Dmin = obj_
            obj_.original_tagname_ = 'Dmin'
        elif nodeName_ == 'Dmax':
            obj_ = ParticleDiameterType.factory()
            obj_.build(child_)
            self.Dmax = obj_
            obj_.original_tagname_ = 'Dmax'
        elif nodeName_ == 'Matrix':
            Matrix_ = child_.text
            Matrix_ = self.gds_validate_string(Matrix_, node, 'Matrix')
            self.Matrix = Matrix_
        elif nodeName_ == 'Unit':
            Unit_ = child_.text
            Unit_ = self.gds_validate_string(Unit_, node, 'Unit')
            self.Unit = Unit_
        elif nodeName_ == 'Statistics':
            Statistics_ = child_.text
            Statistics_ = self.gds_validate_string(Statistics_, node, 'Statistics')
            self.Statistics = Statistics_
        elif nodeName_ == 'ResolutionCode':
            ResolutionCode_ = child_.text
            ResolutionCode_ = self.gds_validate_string(ResolutionCode_, node, 'ResolutionCode')
            self.ResolutionCode = ResolutionCode_
        elif nodeName_ == 'DataLevel':
            DataLevel_ = child_.text
            DataLevel_ = self.gds_validate_string(DataLevel_, node, 'DataLevel')
            self.DataLevel = DataLevel_
        elif nodeName_ == 'MeasurementUncertainty':
            obj_ = MeasurementUncertainty.factory()
            obj_.build(child_)
            self.MeasurementUncertainty = obj_
            obj_.original_tagname_ = 'MeasurementUncertainty'
        elif nodeName_ == 'Position':
            obj_ = Position.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'HeightAGL':
            obj_ = HeightAGL.factory()
            obj_.build(child_)
            self.HeightAGL = obj_
            obj_.original_tagname_ = 'HeightAGL'
        elif nodeName_ == 'Values':
            Values_ = child_.text
            Values_ = self.gds_validate_float_list(Values_, node, 'Values')
            self.Values = Values_
            self.Values = self.Values.split()
            self.validate_ValueListType(self.Values)    # validate type ValueListType
# end class DataSetType


class Statistics(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if Statistics.subclass:
            return Statistics.subclass(*args_, **kwargs_)
        else:
            return Statistics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='Statistics', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Statistics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='Statistics', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='Statistics'):
        pass
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='Statistics', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Statistics'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Statistics


class MeasurementUncertainty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MeasurementUncertainty.subclass:
            return MeasurementUncertainty.subclass(*args_, **kwargs_)
        else:
            return MeasurementUncertainty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='MeasurementUncertainty', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeasurementUncertainty')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='MeasurementUncertainty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='MeasurementUncertainty'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='MeasurementUncertainty', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MeasurementUncertainty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MeasurementUncertainty


class Position(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Point=None):
        self.original_tagname_ = None
        self.Point = Point
    def factory(*args_, **kwargs_):
        if Position.subclass:
            return Position.subclass(*args_, **kwargs_)
        else:
            return Position(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Point(self): return self.Point
    def set_Point(self, Point): self.Point = Point
    def hasContent_(self):
        if (
            self.Point is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='Position', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS" xmlns:gml="http://www.opengis.net/gml/3.2" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Position')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='Position', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='Position'):
        pass
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='Position', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Point is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPoint>%s</%sPoint>%s' % ('gml:', self.gds_format_string(quote_xml(self.Point).encode(ExternalEncoding), input_name='Point'), 'gml:', eol_))
    def exportLiteral(self, outfile, level, name_='Position'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Point is not None:
            showIndent(outfile, level)
            outfile.write('Point=%s,\n' % quote_python(self.Point).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Point':
            Point_ = child_.text
            Point_ = self.gds_validate_string(Point_, node, 'Point')
            self.Point = Point_
# end class Position


class HeightAGL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HeightAGL.subclass:
            return HeightAGL.subclass(*args_, **kwargs_)
        else:
            return HeightAGL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='HeightAGL', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeightAGL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='HeightAGL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='HeightAGL'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='HeightAGL', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='HeightAGL'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HeightAGL


class WavelengthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if WavelengthType.subclass:
            return WavelengthType.subclass(*args_, **kwargs_)
        else:
            return WavelengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='WavelengthType', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WavelengthType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='WavelengthType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='WavelengthType'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='WavelengthType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='WavelengthType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WavelengthType


class ParticleDiameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ParticleDiameterType.subclass:
            return ParticleDiameterType.subclass(*args_, **kwargs_)
        else:
            return ParticleDiameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ebas:', name_='ParticleDiameterType', namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParticleDiameterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ebas:', name_='ParticleDiameterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ebas:', name_='ParticleDiameterType'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='ebas:', name_='ParticleDiameterType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ParticleDiameterType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParticleDiameterType


GDSClassesMapping = {
    'D': ParticleDiameterType,
    'ResultSet': ResultSetType,
    'DataSet': DataSetType,
    'Dmin': ParticleDiameterType,
    'TimeDimension': TimeDimensionType,
    'Wavelength': WavelengthType,
    'Dmax': ParticleDiameterType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Result'
        rootClass = Result
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Result'
        rootClass = Result
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from six import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Result'
        rootClass = Result
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ebas="http://ebas.nilu.no/EBAS"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Result'
        rootClass = Result
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ebas_generated import *\n\n')
        sys.stdout.write('import ebas_generated as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DataSetType",
    "HeightAGL",
    "MeasurementUncertainty",
    "ParticleDiameterType",
    "Position",
    "Result",
    "ResultSetType",
    "Statistics",
    "TimeDimensionType",
    "WavelengthType"
]
