"""
Property-based tests for chunk identifier generation.

This module provides property-based tests for the `_norm_source` utility function
located in `ingenious.chunk.utils.id_path`. It specifically validates the
"hash" mode branch of the function.

Purpose & Context:
    The `ingenious.chunk` subsystem is responsible for breaking down large data
    sources into manageable chunks and storing them with stable identifiers. The
    `_norm_source` function plays a critical role by converting a source, such
    as a file path, into a unique, filesystem-safe identifier string. This test
    module ensures that the hashing mechanism for this conversion is robust,
    correct, and configurable.

Key Algorithms & Design Choices:
    - **Property-Based Testing**: We use the `hypothesis` library to generate a
      wide variety of random, valid file paths. This approach is superior to
      fixed examples (table-driven tests) as it can uncover edge cases in path
      parsing and hashing that might not be obvious to a human tester.
    - **Dynamic Length Validation**: The test does not hard-code the expected
      hash length. Instead, it derives the length from the `ChunkConfig` object
      (specifically, `id_hash_bits / 4$`). This design choice makes the
      test suite resilient to future changes in the application's default hash
      size, preventing test failures caused by configuration updates.
"""

from __future__ import annotations

from pathlib import Path

from hypothesis import given
from hypothesis import strategies as st

from ingenious.chunk.config import ChunkConfig
from ingenious.chunk.utils.id_path import _norm_source


# ────────────────────────────────────────────────────────────────────────────
# Hypothesis strategy
#   • Generate *absolute* POSIX-style paths of arbitrary depth.
#     (We split a random string on "/" and pass the segments to Path.)
# ────────────────────────────────────────────────────────────────────────────
@given(
    path=st.builds(
        lambda s: Path("/", *filter(None, s.split("/"))),  # avoid empty parts
        st.text(min_size=1),
    )
)
def test_hash_mode_length(path: Path) -> None:
    """Verifies digest length and format in "hash" mode.

    Rationale:
        Property-based testing with `hypothesis` is chosen over static examples
        to ensure the hashing logic is robust. It validates correctness across a
        vast, unpredictable input space of file paths, which is more rigorous
        for a critical utility function. The test's assertions are dynamically
        tied to `ChunkConfig` to prevent brittleness if default hash settings
        are changed in the future.

    Args:
        path: A `pathlib.Path` object representing an absolute POSIX-style
            file path, automatically generated by `hypothesis`.

    Raises:
        AssertionError: If the generated digest's length is not equal to
            `cfg.id_hash_bits // 4` or if it contains non-hexadecimal
            characters.

    Implementation Notes:
        - The `hypothesis` strategy builds paths by splitting a random text
          string on `/`, which effectively generates paths of arbitrary depth
          and with varied segment contents. `filter(None, ...)` prevents empty
          segments that would result from a `//` in the path string.
        - The test explicitly sets `id_path_mode="hash"` to ensure the correct
          code branch within `_norm_source` is exercised.
        - The original test was updated from a hard-coded 12-character check
          (48 bits) to a dynamic check based on the configurable
          `id_hash_bits` (defaulting to 64 bits, or 16 hex characters).
    """
    cfg = ChunkConfig(id_path_mode="hash")  # uses the *default* bit length
    out = _norm_source(path, cfg)

    # Expected length in hex digits (4 bits per nibble)
    expected_len = cfg.id_hash_bits // 4

    # ── Assertions ──────────────────────────────────────────────────────
    assert len(out) == expected_len, (
        f"Digest length {len(out)} != {expected_len} "
        f"(cfg.id_hash_bits={cfg.id_hash_bits})"
    )
    assert all(c in "0123456789abcdef" for c in out), "Digest is not lower-case hex"
