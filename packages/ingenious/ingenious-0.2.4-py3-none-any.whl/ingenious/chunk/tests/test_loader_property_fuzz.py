"""
Tests the robustness of the TXT document loader against arbitrary text.

Purpose & Context
-----------------
This module provides property-based tests for the `load_documents` function
in `ingenious.chunk.loader`. Its primary goal is to verify that any arbitrary
UTF-8 encoded text can survive the file loading process without corruption or
unintended modification. This is a critical quality assurance step for the data
ingestion pipeline of the Insight Ingenious architecture, ensuring that data
integrity is maintained from the very first step.

Key Algorithms / Design Choices
-------------------------------
The tests employ the `hypothesis` library for property-based testing instead of
relying on a fixed set of examples. The `hypothesis.strategies.text()` strategy
generates a vast range of string inputs, including complex Unicode characters,
various whitespace patterns, and symbols, which are then written to a temporary
file and loaded. This approach is far more comprehensive than manual example-based
testing for discovering edge cases.

A helper function, `_norm`, is used to normalize line endings to ensure that
comparisons are not affected by OS-specific differences (`LF` vs. `CRLF`).
"""

from __future__ import annotations

from pathlib import Path

from hypothesis import HealthCheck, assume, given, settings
from hypothesis import strategies as st

from ingenious.chunk.loader import load_documents


def _norm(s: str) -> str:
    """Normalizes all line endings in a string to a single line feed (LF).

    Rationale:
        File systems and text editors on different operating systems may use
        different line endings (LF, CR, CRLF). The document loader might also
        perform its own normalization. This helper ensures that the comparison
        between the original text and the loaded content is consistent and
        immune to line-ending variations.

    Args:
        s: The input string, which may contain mixed line endings.

    Returns:
        The string with all carriage returns (`\r`) and carriage return/line
        feed pairs (`\r\n`) replaced by a single line feed (`\n`).
    """
    return s.replace("\r\n", "\n").replace("\r", "\n")


@settings(suppress_health_check=[HealthCheck.function_scoped_fixture])
@given(payload=st.text(min_size=1, max_size=80))
def test_loader_random_txt(tmp_path: Path, payload: str) -> None:
    """Verifies `load_documents` correctly loads arbitrary UTF-8 text.

    Rationale:
        This property-based test ensures the robustness of the core text loader.
        By using `hypothesis` to generate a wide range of text inputs, we can
        be confident that the loader handles Unicode, symbols, and various text
        structures correctly, which is fundamental for data integrity. The test
        is configured to ignore `hypothesis` health checks related to fixtures,
        as using `tmp_path` is standard and safe `pytest` practice.

    Args:
        tmp_path: A `pytest` fixture providing a temporary directory path.
        payload: An arbitrary string generated by `hypothesis` to be used as
            the file content. It is guaranteed to be non-empty.

    Raises:
        AssertionError: If the content of the loaded document does not match
            the normalized original payload.

    Implementation Notes:
        - A temporary file (`rand.txt`) is created in the `tmp_path` directory.
        - The `payload` is written to this file using UTF-8 encoding.
        - `assume(not payload.isspace())` is used to instruct `hypothesis` to
          skip test cases where the payload consists only of whitespace. This
          is because the current loader implementation is expected to treat
          such files as empty and skip them, which is a different behavior
          than what is being tested here.
        - The loaded content is normalized for line endings before being
          compared against the normalized original payload.
    """
    f = tmp_path / "rand.txt"
    f.write_text(payload, encoding="utf-8")

    # The loader is designed to skip documents that only contain whitespace.
    # We filter these cases out to focus this test on content preservation.
    assume(not payload.isspace())
    docs = load_documents(str(f))

    assert len(docs) == 1, "Expected exactly one document to be loaded."
    assert _norm(docs[0].page_content) == _norm(payload)
