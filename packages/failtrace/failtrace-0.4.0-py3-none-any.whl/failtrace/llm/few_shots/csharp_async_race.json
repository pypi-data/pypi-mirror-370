[
  {
    "input": "[EXAMPLE — STYLE & STRUCTURE ONLY, DO NOT COPY ASSUMPTIONS]\nGRAPH SUMMARY: 210 nodes, 402 edges.\n\nTEST SUMMARY:\n• Total: 65\n• Executed: 65 (✅58, ❌2, ⚠️5)\n• Failures detail:\n  - Tests.AsyncQueueTests::EnqueueDequeue_Race: InvalidOperationException: queue empty\n\nCRITICAL PATHS for each failed test:\n\nTest: Tests.AsyncQueueTests::EnqueueDequeue_Race\nError: InvalidOperationException: queue empty\nUpstream:\n  • AsyncQueue.cs::DequeueAsync → AsyncQueue.cs::TryDequeue\nDownstream:\n  • Tests.AsyncQueueTests::EnqueueDequeue_Race\n\nFUNCTION SNIPPETS:\n\nAsyncQueue.cs::DequeueAsync (line 74):\n    public async Task<T> DequeueAsync() {\n        return TryDequeue(); // no await on producer signal\n    }\n\nAsyncQueue.cs::TryDequeue (line 33):\n    public T TryDequeue() { /* returns default if empty */ }",
    "output": "{\n  \"analysis\": [\n    {\n      \"test_name\": \"Tests.AsyncQueueTests::EnqueueDequeue_Race\",\n      \"error\": \"InvalidOperationException: queue empty\",\n      \"call_path\": [\"AsyncQueue.cs::DequeueAsync\", \"AsyncQueue.cs::TryDequeue\"],\n      \"reasoning\": [\n        \"1) DequeueAsync بدون انتظار سیگنال تولیدکننده فوراً TryDequeue را اجرا می‌کند\",\n        \"2) در رقابت زمان‌بندی، مصرف‌کننده جلوتر از تولیدکننده اجرا می‌شود\",\n        \"3) TryDequeue روی صف خالی اجرا شده و استثنا ایجاد می‌شود\"\n      ],\n      \"root_cause\": \"نبود همگام‌سازی/سیگنالینگ مناسب بین producer/consumer\",\n      \"suggested_fixes\": [\n        \"استفاده از SemaphoreSlim/TaskCompletionSource برای سیگنال آماده بودن آیتم\",\n        \"در TryDequeue رفتار کنترل‌شده برای empty و تست‌های هم‌زمانی اضافه کنید\"\n      ]\n    }\n  ]\n}"
  },
  {
    "input": "[EXAMPLE — STYLE & STRUCTURE ONLY, DO NOT COPY ASSUMPTIONS]\nGRAPH SUMMARY: 176 nodes, 358 edges.\n\nTEST SUMMARY:\n• Total: 54\n• Executed: 54 (✅50, ❌1, ⚠️3)\n• Failures detail:\n  - Tests.ConfigCacheTests::Reads_After_Refresh: AssertionException: expected updated value\n\nCRITICAL PATHS for each failed test:\n\nTest: Tests.ConfigCacheTests::Reads_After_Refresh\nError: AssertionException: expected updated value\nUpstream:\n  • ConfigCache.cs::Get → ConfigCache.cs::Refresh\nDownstream:\n  • Tests.ConfigCacheTests::Reads_After_Refresh\n\nFUNCTION SNIPPETS:\n\nConfigCache.cs::Get (line 21):\n    public string Get(string key) {\n        return _store[key]; // uses static shared store\n    }\n\nConfigCache.cs::Refresh (line 47):\n    public void Refresh() {\n        // reloads _store conditionally; missing clear()\n    }",
    "output": "{\n  \"analysis\": [\n    {\n      \"test_name\": \"Tests.ConfigCacheTests::Reads_After_Refresh\",\n      \"error\": \"AssertionException: expected updated value\",\n      \"call_path\": [\"ConfigCache.cs::Get\", \"ConfigCache.cs::Refresh\"],\n      \"reasoning\": [\n        \"1) حدس اولیه: مشکل از خواندن/نوشتن هم‌زمان\",\n        \"2) اما شواهد نشان می‌دهد state مشترکِ static بین تست‌ها پاک‌سازی نمی‌شود\",\n        \"3) Refresh بدون clear() دادهٔ قدیمی را نگه می‌دارد و تست به مقدار جدید نمی‌رسد\"\n      ],\n      \"root_cause\": \"state مشترک ثابت (static) بدون reset بین تست‌ها/refresh\",\n      \"suggested_fixes\": [\n        \"افزودن clear() یا نسخه‌گذاری state در Refresh\",\n        \"تزریق store غیر‌استاتیک برای ایزوله‌سازی تست‌ها\"\n      ]\n    }\n  ]\n}"
  }
]
