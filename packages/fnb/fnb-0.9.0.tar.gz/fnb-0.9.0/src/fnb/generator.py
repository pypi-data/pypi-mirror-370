"""generator.py

This module handles the generation of configuration files for fnb.
It creates starter configuration files based on templates.

Usage:
    fnb init [--force] [--no-env]
    fnb init config [--force]
    fnb init env [--force]
"""

import importlib.resources
import sys
from enum import Enum
from pathlib import Path
from datetime import datetime

import typer


class ConfigKind(str, Enum):
    """Types of configuration files that can be generated.

    This enum inherits from str to all:
    1. Direct string comparison (kind == "all")
    2. Automatic string conversion (str(kind))
    3. Easy conversion from string input (ConfigKind("all"))
    """

    ALL = "all"
    CONFIG = "config"
    ENV = "env"


def find_template(template_name: str) -> Path | None:
    """Find a template file in possible locations.

    Args:
        template_name (str): Name of the template file.

    Returns:
        Path | None: Path to the template if found, None otherwise.
    """
    # Try multiple possible paths to find the template
    possible_sources = [
        importlib.resources.files("fnb.assets").joinpath(
            template_name
        ),  # Installed package
        Path(__file__).parent.parent
        / "assets"
        / template_name,  # Relative to this file
        Path(f"src/fnb/assets/{template_name}"),  # Project root in dev
    ]

    return next((p for p in possible_sources if p.exists()), None)


def create_file_from_template(
    template_name: str,
    dest_path: Path,
    force: bool = False,
    replacements: dict[str, str] | None = None,
    header_comment: str | None = None,
) -> bool:
    """Create a file from a template.

    Args:
        template_name (str): Name of the template file.
        dest_path (Path): Destination path for the file.
        force (bool): If True, overwrite existing file without confirmation.
        replacements (dict[str, str] | None): Dictionary of text replacements to apply.
        header_comment (str | None): Header comment to add to the file.

    Returns:
        bool: True if successful, False otherwise.
    """
    if dest_path.exists() and not force:
        typer.echo(f"❌ {dest_path} already exists. Use --force to overwrite.")
        return False

    # Find the template
    src = find_template(template_name)
    if not src:
        typer.echo(
            f"❌ Template file {template_name} not found. Check if fnb is installed correctly."
        )
        return False

    try:
        # Create parent directories if needed
        dest_path.parent.mkdir(parents=True, exist_ok=True)

        # Read the template
        with src.open("r") as source_file:
            content = source_file.read()

        # Add header comment if provided
        if header_comment and not content.startswith(header_comment):
            content = f"{header_comment}\n\n{content}"

        # Apply replacements if provided
        if replacements:
            for old, new in replacements.items():
                content = content.replace(old, new)

        # Write the modified content
        with dest_path.open("w") as dest_file:
            dest_file.write(content)

        typer.echo(f"✅ Created {dest_path} from template.")
        return True

    except Exception as e:
        typer.echo(f"❌ Error creating file: {e}")
        return False


def create_config_file(force: bool = False) -> bool:
    """Create a default fnb.toml file in the current directory.

    Args:
        force (bool): If True, overwrite existing file without confirmation.

    Returns:
        bool: True if successful, False otherwise.
    """
    dest = Path("./fnb.toml")

    header_comment = (
        "# >>>>> Generated by fnb init",
        f"# >>>>> At {datetime.now().isoformat()}",
    )
    replacements = {"enabled = true": "enabled = false  # Set to true once configured"}

    success = create_file_from_template(
        template_name="config.toml",
        dest_path=dest,
        force=force,
        replacements=replacements,
        header_comment=("\n").join(header_comment),
    )

    if success:
        typer.echo("Edit this file to configure your backup tasks.")

    return success


def create_env_file(force: bool = False) -> bool:
    """Create a .env.plain file from the sample template.

    Args:
        force (bool): If True, overwrite existing file without confirmation.

    Returns:
        bool: True if successful, False otherwise.
    """
    dest = Path("./.env.plain")

    header_comment = (
        "# >>>>> Generated by fnb init",
        f"# >>>>> At {datetime.now().isoformat()}",
    )

    success = create_file_from_template(
        template_name="env.sample",
        dest_path=dest,
        force=force,
        header_comment=("\n").join(header_comment),
    )

    if success:
        typer.echo("Edit this file to configure your SSH passwords.")

    return success


def run(kind: ConfigKind = ConfigKind.ALL, force: bool = False) -> None:
    """CLI entry point for config file generation.

    Args:
        kind (str): Kind of configuration file to generate.
        force (bool): If True, overwrite existing file without confirmation.
    """
    try:
        config_kind = ConfigKind(kind.lower())
    except ValueError:
        typer.echo(f"❌ Invalid configuration kind: {kind}")
        typer.echo("Valid kinds: all, config, env")
        sys.exit(1)

    # Track overall success
    success = True

    # Generate config.toml if requested
    if config_kind in [ConfigKind.ALL, ConfigKind.CONFIG]:
        config_success = create_config_file(force)
        success = success and config_success

    # Generate .env if requested
    if config_kind in [ConfigKind.ALL, ConfigKind.ENV]:
        env_success = create_env_file(force)
        success = success and env_success

    # Exit with error if any file creation failed
    if not success:
        sys.exit(1)


if __name__ == "__main__":
    """Self test.

    $ uv run src/fnb/generator.py
    """
    run(kind=ConfigKind.ALL, force=True)
