from __future__ import annotations

from typing import Any, ClassVar, Optional

from lionagi.libs.concurrency import shield
from lionagi.protocols.types import Node
from pydantic import field_validator
from typing_extensions import TypedDict

from khive.utils import EventBroadcaster, get_logger

hook_event_logger = get_logger("ClaudeHooks", "🪝 [CLAUDE-HOOKS]")


class HookEventContent(TypedDict, total=False):
    event_type: str
    tool_name: str
    command: Optional[str]
    output: Optional[str]
    session_id: Optional[str]
    file_paths: list[str]
    metadata: dict[str, Any]


class HookEvent(Node):
    """Event generated by Claude Code hooks."""

    content: HookEventContent
    _initialized: ClassVar[bool] = False

    @field_validator("content", mode="before")
    def _validate_event_type(cls, value) -> dict:
        if value is None:
            raise ValueError("Content is required")

        if isinstance(value, dict):
            if "event_type" not in value:
                raise ValueError("Event type is required")
            if "tool_name" not in value:
                raise ValueError("Tool name is required")
            return value
        else:
            raise ValueError("Content must be a dictionary")

    async def save(self):
        # Save to database
        result = await self.adapt_to_async(
            obj_key="lionagi_async_pg",
            dsn="sqlite+aiosqlite:///claude_hooks.db",
            table="hook_events",
        )

        await HookEventBroadcaster.broadcast(self)

        return result

    @classmethod
    async def get_all(cls, limit: int | None = None):
        """Get all hook events from database."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_recent(cls, limit: int = 100) -> list[HookEvent]:
        """Get recent hook events."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "order_by": "created_at DESC",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_by_type(
        cls, event_type: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events by event type."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"content->>'event_type' = '{event_type}'",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_by_session(
        cls, session_id: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events by session ID."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"content->>'session_id' = '{session_id}'",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )

    @classmethod
    async def get_since(
        cls, timestamp: str, limit: int | None = None
    ) -> list[HookEvent]:
        """Get hook events since a specific timestamp."""
        params = {
            "dsn": "sqlite+aiosqlite:///claude_hooks.db",
            "table": "hook_events",
            "where": f"created_at >= '{timestamp}'",
            "order_by": "created_at DESC",
        }
        if limit:
            params["limit"] = limit

        return await cls.adapt_from_async(
            params,
            obj_key="lionagi_async_pg",
            many=True,
        )


def _initialize_adapter():
    """Initialize the async adapter for SQLite database."""
    if HookEvent._initialized:
        return

    from pydapter.exceptions import AdapterNotFoundError

    try:
        HookEvent._async_registry.get("lionagi_async_pg")
    except AdapterNotFoundError:
        print("🔄 Initializing database adapter for Claude hooks...")
        from lionagi.adapters.async_postgres_adapter import LionAGIAsyncPostgresAdapter

        HookEvent.register_async_adapter(LionAGIAsyncPostgresAdapter)

    HookEvent._initialized = True
    print("✅ Database adapter initialized successfully")


_initialize_adapter()
HookEvent = HookEvent


class HookEventBroadcaster(EventBroadcaster):
    _event_type: ClassVar[type] = HookEvent


__all__ = (
    "HookEvent",
    "HookEventContent",
    "hook_event_logger",
    "shield",
    "HookEventBroadcaster",
)
