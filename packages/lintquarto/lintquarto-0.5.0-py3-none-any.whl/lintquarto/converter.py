"""
Convert .qmd file to python file.

Acknowledgements
----------------
Some parts of this module were generated by and adapted from Perplexity.
"""

import re
import warnings

from pathlib import Path
from typing import List, Union, Optional

from .args import CustomArgumentParser
from .linelength import LineLengthDetector
from .linters import Linters


class QmdToPyConverter:
    """
    Convert lines from a .qmd file to .py file.

    Attributes
    ----------
    in_chunk_options : bool
        True if currently at the start of a code chunk, parsing Quarto chunk
        options or leading blank lines.
    in_python : bool
        True if currently processing lines inside a Python code chunk.
    py_lines : list
        Stores the lines to be written to the output Python file.
    """
    in_chunk_options: bool = False
    in_python: bool = False
    py_lines: list = []

    def __init__(self, linter: str) -> None:
        """
        Initialise a class object.

        Parameters
        ----------
        linter : str
            Name of the linter that will be used.
        """
        self.linter = linter
        Linters().check_supported(self.linter)
        if self.linter == "radon-raw":
            self.preserve_line_count = False
        else:
            self.preserve_line_count = True

    def reset(self) -> None:
        """
        Reset the state (except linter).
        """
        self.py_lines = []
        self.in_python = False
        self.in_chunk_options = False

    def convert(self, qmd_lines: List[str]) -> List[str]:
        """
        Run converter on the provided lines.

        Parameters
        ----------
        qmd_lines : List[str]
            List containing each line from the Quarto file.

        Returns
        -------
        py_lines : List[str]
            List of each line for the output Python file.
        """
        self.reset()
        for original_line in qmd_lines:
            self.process_line(original_line)
        return self.py_lines

    def process_line(self, original_line: str) -> None:
        """
        Process individual lines with state tracking.

        Parameters
        ----------
        original_line : str
            Line to process.
        """
        # Remove the trailing new line
        line = original_line.rstrip("\n")

        # Check if it is the start of a python code chunk
        if re.match(r"^```\{python\}", line):
            self.in_python = True
            self.in_chunk_options = True
            if self.preserve_line_count:
                self.py_lines.append("# %% [python]")

        # Check if it is the end of a code chunk
        elif line.strip() == "```":
            self.in_python = False
            self.in_chunk_options = False
            if self.preserve_line_count:
                self.py_lines.append("# -")

        # Check if it is within a python code chunk
        elif self.in_python:
            self._handle_python_chunk(line)

        # For all other lines, set to # -
        else:
            if self.preserve_line_count:
                self.py_lines.append("# -")

    def _handle_python_chunk(self, line: str) -> None:
        """
        Process a line within a Python code chunk.

        - Handles Quarto chunk options (lines starting with '#| '), converting
        them to '# |'.
        - Skips blank lines at the start of the chunk.
        - For the first actual code line after options/blanks:
            - Appends '# noqa: E305' to suppress false positives for missing
            blank lines after previous cell's function/class.
            - If the line starts with 'def' or 'class', also appends
            '# noqa: E302' to suppress false positives for missing blank lines
            before a function/class.
            - If the line was under the character limit, then add E501 to
            prevent a false line length warning when the temporary noqa flag
            takes the line length over the limit - but do not add if the line
            was already too long.
        - All subsequent lines are appended unchanged.

        Parameters
        ----------
        line : str
            The line to process.

        Returns
        -------
        None
        """
        if not self.in_chunk_options:
            # After the first code line, append all lines unchanged
            self.py_lines.append(line)
            return

        # If line is blank, just append it and keep looking for options
        if line.strip() == "":
            self.py_lines.append(line)
            return

        # Handle Quarto chunk options
        stripped = line.lstrip()
        if stripped.startswith("#| "):
            indent = line[:len(line) - len(stripped)]
            modified_line = indent + "# |" + stripped[3:]
            if self.preserve_line_count:
                self.py_lines.append(modified_line)
            return

        # First code line after options/blanks:
        # - Always suppress E305
        # - If it is a function or class, suppress E302
        # - If it was under line limit, suppress E501
        if self.linter in ["flake8", "ruff", "pycodestyle"]:
            len_detect = LineLengthDetector(linter=self.linter)
            max_line = len_detect.get_line_length()
            is_def_or_class = re.match(r"^(def|class)\b", stripped)
            line_was_short = len(line) <= max_line

            # If it is a function or class, suppress E302
            if is_def_or_class:
                if line_was_short:
                    line = f"{line.rstrip()}  # noqa: E302,E305,E501"
                else:
                    line = f"{line.rstrip()}  # noqa: E302,E305"
            else:
                if line_was_short:
                    line = f"{line.rstrip()}  # noqa: E305,E501"
                else:
                    line = f"{line.rstrip()}  # noqa: E305"

        self.py_lines.append(line)
        self.in_chunk_options = False


def get_unique_filename(path: Union[str, Path]) -> Path:
    """
    Generate a unique file path by appending " (n)" before the file extension
    if needed.

    If the given path already exists, this function appends an incrementing
    number in parentheses before the file extension (e.g., "file (1).py") until
    an unused filename is found.

    Parameters
    ----------
    path : Union[str, Path]
        The initial file path to check.

    Returns
    -------
    Path
        A unique file path that does not currently exist.

    Examples
    --------
    >>> get_unique_filename("script.py")
    PosixPath('script.py')  # if 'script.py' does not exist
    >>> get_unique_filename("script.py")
    PosixPath('script (1).py')  # if 'script.py' exists
    """
    path = Path(path)
    if not path.exists():
        return path

    stem = path.stem
    suffix = path.suffix
    parent = path.parent

    n = 1
    while True:
        new_name = f"{stem} ({n}){suffix}"
        new_path = parent / new_name
        if not new_path.exists():
            return new_path
        n += 1


def convert_qmd_to_py(
    qmd_path: Union[str, Path],
    linter: str,
    output_path: Optional[Union[str, Path]] = None,
    verbose: bool = False
) -> Optional[Path]:
    """
    Convert a Quarto (.qmd) file to Python (.py) file, preserving line
    alignment.

    Parameters
    ----------
    qmd_path : Union[str, Path]
        Path to the input .qmd file.
    linter : str
        Name of the linter that will be used.
    output_path : Optional[Union[str, Path]]
        Path for the output .py file. If None, uses qmd_path with .py suffix.
    verbose : bool, optional
        If True, print detailed progress information.

    Returns
    -------
    output_path : Optional[Path]
        Path for the output .py file, or None if there was an error.

    Examples
    --------
    >>> convert_qmd_to_py("input.qmd", "output.py", True)
    # To use from the command line:
    # $ python converter.py input.qmd [output.py] [-v]
    """
    # Convert input path to a Path object
    qmd_path = Path(qmd_path)

    # Set up converter
    converter = QmdToPyConverter(linter=linter)

    # Determine output path. If provided, convert to a Path object. If not,
    # the file extension of the input file to `.py`
    if output_path is None:
        output_path = qmd_path.with_suffix(".py")
    else:
        output_path = Path(output_path)

    # Automatically generate a unique filename if needed
    output_path = get_unique_filename(output_path)

    if verbose:
        print(f"Converting {qmd_path} to {output_path}")

    try:
        # Open and read the QMD file, storing all lines in qmd_lines
        with open(qmd_path, "r", encoding="utf-8") as f:
            qmd_lines = f.readlines()

        # Iterate over lines, keeping python code, and setting rest to "# -"
        py_lines = converter.convert(qmd_lines=qmd_lines)

        # Write the output file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(py_lines) + "\n")

        if verbose:
            print(f"✓ Successfully converted {qmd_path} to {output_path}")

        # Check that line counts match (if intend to preserve them)
        if converter.preserve_line_count:
            qmd_len = len(qmd_lines)
            py_len = len(py_lines)
            if qmd_len == py_len:
                if verbose:
                    print(f"  Line count: {qmd_len} → {py_len} ")
            else:
                warnings.warn(f"Line count mismatch: {qmd_len} → {py_len}",
                              RuntimeWarning)

    # Error messages if issues finding/accessing files, or otherwise.
    except FileNotFoundError:
        print(f"Error: Input file '{qmd_path}' not found")
        return None
    except PermissionError:
        print(f"Error: Permission denied accessing '{qmd_path}' "
              f"or '{output_path}'")
        return None
    # Intentional broad catch for unexpected conversion errors
    # pylint: disable=broad-except
    except Exception as e:
        print(f"Error during conversion: {e}")
        return None
    return output_path


# To ensure it executes if run from terminal:
if __name__ == "__main__":

    # Set up argument parser with help statements
    parser = CustomArgumentParser(
        description="Convert .qmd file to python file.")
    parser.add_argument("qmd_path", help="Path to the input .qmd file.")
    parser.add_argument("output_path", nargs="?", default=None,
                        help="(Optional) path to the output .py file.")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Print detailed progress information.")
    args = parser.parse_args()

    # Pass arguments to function and run it
    convert_qmd_to_py(args.qmd_path, args.output_path, args.verbose)
