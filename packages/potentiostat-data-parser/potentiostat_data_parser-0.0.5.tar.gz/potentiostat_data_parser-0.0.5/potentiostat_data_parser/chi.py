"""Parses files from a CH Instruments potentiostat"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_chi.ipynb.

# %% auto 0
__all__ = ['parse_colon', 'parse_datetime', 'parse_line', 'parse_equals', 'parse_memo', 'parse_parameters', 'detect_column_sep',
           'parse_numeric_data', 'contains_memo', 'contains_parameters', 'find_parameters_end',
           'find_start_of_numeric_data', 'parse_chi_file']

# %% ../nbs/00_chi.ipynb 14
from dateutil import parser as date_parser
from datetime import datetime

def parse_datetime(
    chi_timestamp: str
) -> datetime:
    """
    Turn a CHI timestamp into a python datetime object.
    If parsing fails, this function returns `None`.
    """
    
    try:
        timestamp = date_parser.parse(chi_timestamp)
    except ValueError:
        timestamp = None

    return timestamp

# %% ../nbs/00_chi.ipynb 17
# Because colon parsing and equals parsing are very similar, let's create a generalized function
def parse_line(line, sep):
    # Parses a `sep` separated line into its two halves.
    # Returns a two-element tuple where the first element is the first part, the second element the other part
    # For instance, `Instrument Model:  CHI1040C` becomes `("Instrument Model", "CHI1040C")`
    # If the line doesn't have a colon, raises it raises a ValueError
    
    try:
        sep_index = line.index(sep)
    except ValueError:
        raise ValueError(f"Separator {sep!r} not found in line: {line!r}")
        
    first_part = line[:sep_index].strip()
    second_part = line[sep_index+1:].strip()

    return first_part, second_part

# %% ../nbs/00_chi.ipynb 18
# now we define colon parser as a line parser with a colon separator
parse_colon = lambda line: parse_line(line, ":")

# %% ../nbs/00_chi.ipynb 20
# equals parsing additionally converts the second number to a float
def parse_equals(
    line,
) -> tuple[str, str | float]:
    """
    Parse an equals line, e.g. `Init E (V) = 0.5`
    Automatically casts the value after the `"="` to a float if possible.
    """
    first, second = parse_line(line, "=")

    try:
        second = float(second)
    except ValueError: # can't cast
        pass
    
    return first, second

# %% ../nbs/00_chi.ipynb 24
def parse_memo(memo_lines: list[str]) -> dict[str, str]:
    """
    Parses lines containing a memo into a dictionary, e.g.
    ```python
    ['Feb. 6, 2025   17:35:06',
     'Differential Pulse Voltammetry',
     'File: iaa_7.8125um_mnge_gce_2_250206.bin',
     'Data Source:  Experiment',
     'Instrument Model:  CHI1040C',
     'Header: ',
     'Note: ']
     ```

     into
     
     ```python
     {'timestamp': '2025-02-06T17:35:06',
     'technique': 'Differential Pulse Voltammetry',
     'file': 'iaa_7.8125um_mnge_gce_2_250206.bin',
     'instrument_model': 'CHI1040C'}```
    """

    # Let's do a simple format check first:
    if len(memo_lines) != 7:
        raise ValueError(f"Expected the memo to be a list of seven strings. Instead received: {memo_lines!r}")

    # parse timestamp
    timestamp = parse_datetime(memo_lines[0])
    if timestamp == None:
        raise ValueError(f"Error parsing memo timestamp: {memo_lines[0]!r}")
    else:
        timestamp = timestamp.isoformat()
    
    return {
        "timestamp": timestamp,
        "technique": memo_lines[1],
        "file": parse_colon(memo_lines[2])[1],
        # skip memo[3], which is data source. it should always be experiment
        "instrument_model": parse_colon(memo_lines[4])[1],
        # skip memo[4], which is header, because nobody uses it
        # skip memo[5], which is note, because nobody uses it
    }

# %% ../nbs/00_chi.ipynb 28
def parse_parameters(lines: list[str]) -> dict[str, str | float]:
    parsed_lines = [parse_equals(line) for line in lines]
    return {param:val for param, val in parsed_lines}

# %% ../nbs/00_chi.ipynb 32
def detect_column_sep(
    line: str # line containing columns
) -> str: # seperator, usually either ", " or "\t"
    """
    Detects the separator for the line containing columns within a CHI numeric data section.
    
    e.g. `Potential/V, Current/A` returns `","`
    
    e.g. `Potential/V	Current/A` returns `"\t"`
    """
    if not line.startswith("Potential/V"):
        raise ValueError(f"Column line expected to start with 'Potential/V': {line!r}")
    sep = line[len("Potential/V")]

    if sep == ",":
        return ", " # CHI's comma separated actually adds a space, too
    
    return sep

# %% ../nbs/00_chi.ipynb 35
import numpy as np

def parse_numeric_data(
    lines: list[str] # data lines, starting with the column header
) -> dict[str, np.ndarray]: # a dictionary of column -> numpy float array
    """
    Parses numerical data within a CHI data file.
    """
    
    # parse column line
    col_line = lines[0]
    sep = detect_column_sep(col_line)
    cols = col_line.split(sep)
    
    # next line should be empty
    if lines[1] != "":
        raise ValueError(f"Expected an empty line after the column header, but found: {lines[1]!r}")
    
    # parse the data columns
    data = np.array([line.split(sep) for line in lines[2:]], dtype=float)
    
    # sometimes, CHI adds a Time/s column even when there's no time data. in that case, eliminate time
    if len(cols) == data.shape[1]+1 and "Time/s" in cols: # there's one more column than the data indicates and one of the columns is time
        cols.remove("Time/s")
    
    if len(cols) != data.shape[1]:
        raise ValueError(f"The number of columns does not match the data. Columns: {cols!r}; Data: {lines[2].split(sep)}")
    
    return {col: data[:, i] for i, col in enumerate(cols)}

# %% ../nbs/00_chi.ipynb 38
def contains_memo(lines: list[str]):
    file_line = lines[2].startswith("File:")
    data_source_line = lines[3].startswith("Data Source:")
    return file_line and data_source_line

# %% ../nbs/00_chi.ipynb 41
def contains_parameters(lines):
    return lines[0].startswith("Init E (V) = ")

# %% ../nbs/00_chi.ipynb 44
def find_parameters_end(lines: list[str]) -> int: # returns the index of line after the last parameter line
    if not isinstance(lines, list):
        raise TypeError(f"Expected a list of strings, got {type(lines).__name__}")
    
    if not contains_parameters(lines):
        raise ValueError(f"Expected lines to start with parameters, received: {lines[:5]!r}")

    for i in range(min(len(lines), 20)): # shouldn't be more than 20 lines down
        if lines[i].startswith("Sensitivity (A/V) = "):
            return i+1

    raise ValueError(f"Never found Sensitivty (A/V) = in lines: {lines[:20]!r}")

# %% ../nbs/00_chi.ipynb 46
def find_start_of_numeric_data(lines: list[str]) -> int:
    """
    Finds the index of the columns line by looking for Potential/V.
    """

    for i, line in enumerate(lines):
        if line.startswith("Potential/V"):
            return i

    raise ValueError(f"No line found starting with 'Potential/V'")

# %% ../nbs/00_chi.ipynb 48
def parse_chi_file(contents: str):
    lines = contents.splitlines()
    
    # extract the memo, if it's present
    lines_left = lines
    if contains_memo(lines):
        memo = parse_memo(lines_left[:7]) # the memo is always the first 7 lines
        lines_left = lines[8:]
    else:
        memo = {}
    
    # now extract parameters
    if contains_parameters(lines_left):
        end_line = find_parameters_end(lines_left)
        parameters = parse_parameters(lines_left[:end_line]) 
        lines_left = lines_left[end_line+1:]
    else:
        parameters = {}
    
    # now extract numerical data
    try:
        numeric_data_index = find_start_of_numeric_data(lines_left)
        lines_left = lines_left[numeric_data_index:]
        numeric_data = parse_numeric_data(lines_left)
    except ValueError:
        numeric_data = {}
    
    return {
        "memo": memo,
        "parameters": parameters,
        "numeric_data": numeric_data
    }
