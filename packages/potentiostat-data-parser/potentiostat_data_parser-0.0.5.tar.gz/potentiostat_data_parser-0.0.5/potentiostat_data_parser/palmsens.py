"""Parses .csv files from a Palmsens potentiostat"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_palmsens.ipynb.

# %% auto 0
__all__ = ['parse_columns', 'parse_datetime', 'parse_measurement_datetimes', 'validate_cols', 'organize_column_data',
           'retrieve_data', 'parse_palmsens_file']

# %% ../nbs/01_palmsens.ipynb 10
parse_columns = lambda ps_third_line: ps_third_line.split(",,")

# %% ../nbs/01_palmsens.ipynb 12
from datetime import datetime

def parse_datetime(ps_datetime: str) -> datetime:
    return datetime.strptime(ps_datetime, "%Y-%m-%d %H:%M:%S")

# %% ../nbs/01_palmsens.ipynb 15
def parse_measurement_datetimes(ps_fourth_line: str) -> list[datetime]:
    datetime_strings = ps_fourth_line.split("Date and time measurement:,")[1:] # note that these have a comma at the end, which we have to get rid of
    return [parse_datetime(dt_str[:-1]) for dt_str in datetime_strings]

# %% ../nbs/01_palmsens.ipynb 19
# make sure the file is alternating V and µA. Otherwise, the file format isn't supported
import numpy as np

def validate_cols(ps_fifth_line: str) -> bool: # True if the file has the expected columns
    cols = np.array(ps_fifth_line.split(","))
    if not all(cols[::2] == "V"): # every even element should be "V"
        return False

    if not all(cols[1::2] == "µA"): # every odd element should be "µA"
        return False

    return True

# %% ../nbs/01_palmsens.ipynb 25
def organize_column_data(
    ps_data_lines: list[str] # usually lines[6:-1] of a palmsens .csv file
) -> np.ndarray: # numpy array with shape (N, 2, L) where N is the number of columns, the second axis is [potential, current], and L is length of measurement
    step1 = np.array([line.split(",") for line in ps_data_lines], dtype=float).T # first, lets transpose it. so now it's rows of V1, uA1, V2, uA2, V3, uA3, ...
    step2 = step1.reshape(step1.shape[0]//2, 2, -1)
    return step2

def retrieve_data(
    col_index: int, # index of the column
    organized_data: np.ndarray # output of `organize_column_data`
) -> dict[str, np.ndarray]: # a dict with potential (in volts) and current (in A)
    col_data = organized_data[col_index]
    return {
        "potential": col_data[0],
        "current": col_data[1]*1e-6
    }

# %% ../nbs/01_palmsens.ipynb 27
def parse_palmsens_file(contents: str) -> list[dict[str, [any]]]:
    """
    Takes the contents of a Palmsens .csv file (usually encoded in utf-16) and returns a list of measurements.
    For instance,
    ```python
    [
        {
            'name': 'Differential Pulse Voltammetry [1]: S49',
            'timestamp': '2025-03-29T13:32:13',
            'potential': array([0.        , 0.01020757, 0.02041514, 0.03062271, ...]),
            'current': array([1.97511120e-08, 1.91575140e-08, 1.88103180e-08, ...])
        },
        {
            'name': 'Differential Pulse Voltammetry [8]: S48',
            'timestamp': '2025-03-29T14:28:03',
            'potential': array([0.        , 0.01020757, 0.02041514, ... ]),
            'current': array([4.0179824e-08, 3.9586228e-08, 3.8824632e-08, ...])
        }
    ]```
    """
    lines = contents.splitlines()

    cols = parse_columns(lines[3])
    timestamps = [ts.isoformat() for ts in parse_measurement_datetimes(lines[4])]

    if not len(cols) == len(timestamps):
        raise ValueError(f"Unexpected mismatch between column count ({len(cols)}) and timestamp count ({len(timestamps)})")
    
    # make sure the data is in the expected format
    if not validate_cols(lines[5]):
        raise ValueError("Expected all measurements to be DPVs or CVs, but columns have unexpected structure.")

    organized_data = organize_column_data(lines[6:-1])

    if not organized_data.shape[0] == len(cols):
        raise ValueError(f"Unexpected mismatch between data column count ({organized_data.shape[0]}) and column count ({len(cols)})")

    data_list = []
    for i, (col, timestamp) in enumerate(zip(cols, timestamps)):
        data_dict = retrieve_data(i, organized_data) # dict with potentiostat and current data
        
        data_list.append({
            "name": col,
            "timestamp": timestamp,
        } | data_dict)
    
    return data_list
