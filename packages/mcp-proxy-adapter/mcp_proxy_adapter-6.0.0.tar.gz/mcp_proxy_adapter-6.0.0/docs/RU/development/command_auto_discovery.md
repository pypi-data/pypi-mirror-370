# Автообнаружение команд и перезагрузка конфигурации

## Обзор

Система MCP Proxy Adapter поддерживает автоматическое обнаружение команд и возможность перезагрузки конфигурации без перезапуска сервера. При перезагрузке пользовательские команды сохраняются, а встроенные команды перезагружаются заново.

## Процесс автообнаружения команд

### Принцип работы

Автообнаружение команд работает по следующим принципам:

1. **Сканирование пакетов**: Система сканирует указанные пакеты на наличие модулей с именами, заканчивающимися на `_command`
2. **Анализ классов**: В каждом модуле ищутся классы, наследующие от `Command`
3. **Автоматическая регистрация**: Найденные команды автоматически регистрируются в реестре

### Конфигурация автообнаружения

```json
{
  "commands": {
    "auto_discovery": true,
    "discovery_path": "mcp_proxy_adapter.commands",
    "custom_commands_path": "./custom_commands"
  }
}
```

### Метод `discover_commands()`

```python
def discover_commands(self, package_path: str = "mcp_proxy_adapter.commands") -> int:
    """
    Автоматически обнаруживает и регистрирует команды в указанном пакете.
    
    Args:
        package_path: Путь к пакету с командами
        
    Returns:
        Количество обнаруженных и зарегистрированных команд
    """
```

## Типы команд

### 1. Встроенные команды (Built-in Commands)

Команды, поставляемые с фреймворком:
- `help` - справка по командам
- `health` - проверка состояния сервера
- `config` - управление конфигурацией
- `reload` - перезагрузка конфигурации
- `settings` - управление настройками
- `reload_settings` - перезагрузка настроек

### 2. Автообнаруженные команды (Auto-discovered Commands)

Команды, найденные автоматически в пакетах:
- Должны находиться в модулях с именами `*_command.py`
- Должны наследовать от базового класса `Command`
- Регистрируются автоматически при запуске

### 3. Пользовательские команды (Custom Commands)

Команды, зарегистрированные вручную:
- Регистрируются через `register_custom_command()`
- Имеют приоритет над встроенными командами
- Сохраняются при перезагрузке конфигурации

## Иерархия приоритетов команд

1. **Пользовательские команды** (высший приоритет)
2. **Автообнаруженные команды**
3. **Встроенные команды** (низший приоритет)

## Перезагрузка конфигурации

### Метод `reload_config_and_commands()`

```python
def reload_config_and_commands(self, package_path: str = "mcp_proxy_adapter.commands") -> Dict[str, Any]:
    """
    Перезагружает конфигурацию и переобнаруживает команды.
    
    Args:
        package_path: Путь к пакету с командами
        
    Returns:
        Словарь с информацией о перезагрузке:
        - config_reloaded: Успешность перезагрузки конфигурации
        - commands_discovered: Количество обнаруженных команд
        - custom_commands_preserved: Количество сохраненных пользовательских команд
        - total_commands: Общее количество команд после перезагрузки
        - built_in_commands: Количество встроенных команд
        - custom_commands: Количество пользовательских команд
    """
```

### Процесс перезагрузки

1. **Сохранение пользовательских команд**: Создается резервная копия пользовательских команд
2. **Перезагрузка конфигурации**: Загружается новая конфигурация из файла
3. **Переинициализация логирования**: Настраивается логирование с новыми параметрами
4. **Очистка реестра**: Удаляются все команды, кроме пользовательских
5. **Восстановление пользовательских команд**: Восстанавливаются сохраненные пользовательские команды
6. **Переобнаружение команд**: Заново обнаруживаются и регистрируются команды

### Сохранение пользовательских команд

Пользовательские команды сохраняются при перезагрузке благодаря:

```python
# Сохранение пользовательских команд
custom_commands_backup = self._custom_commands.copy()

# Очистка всех команд
self._commands.clear()
self._instances.clear()

# Восстановление пользовательских команд
self._custom_commands = custom_commands_backup
```

## Примеры использования

### Регистрация пользовательской команды

```python
from mcp_proxy_adapter.commands.command_registry import registry
from mcp_proxy_adapter.commands.base import Command

class MyCustomCommand(Command):
    name = "my_custom"
    
    async def execute(self, **kwargs):
        return SuccessResult(message="Custom command executed")

# Регистрация с приоритетом
registry.register_custom_command(MyCustomCommand)
```

### Перезагрузка конфигурации

```python
# Перезагрузка через команду
result = await reload_command.execute()

# Прямая перезагрузка
reload_info = registry.reload_config_and_commands()
print(f"Обнаружено команд: {reload_info['commands_discovered']}")
print(f"Сохранено пользовательских: {reload_info['custom_commands_preserved']}")
```

### Проверка типов команд

```python
# Проверка существования пользовательской команды
if registry.custom_command_exists("my_custom"):
    print("Пользовательская команда существует")

# Получение команды с учетом приоритета
command = registry.get_command_with_priority("my_custom")

# Получение всех команд с информацией
all_commands = registry.get_all_commands_info()
```

## Демонстрация работы

Создайте файл `demo_reload.py`:

```python
#!/usr/bin/env python3
"""
Демонстрация автообнаружения команд и перезагрузки конфигурации.
"""

from mcp_proxy_adapter.commands.command_registry import registry
from mcp_proxy_adapter.commands.base import Command
from mcp_proxy_adapter.commands.result import SuccessResult

class DemoCommand(Command):
    name = "demo"
    result_class = SuccessResult
    
    async def execute(self, message: str = "Hello!", **kwargs):
        return SuccessResult(message=f"Demo: {message}")

def main():
    # Регистрация пользовательской команды
    registry.register_custom_command(DemoCommand)
    print(f"До перезагрузки: {len(registry.get_all_commands())} команд")
    
    # Перезагрузка конфигурации
    result = registry.reload_config_and_commands()
    print(f"После перезагрузки: {result['total_commands']} команд")
    print(f"Сохранено пользовательских: {result['custom_commands_preserved']}")
    
    # Проверка сохранения
    if registry.custom_command_exists("demo"):
        print("✅ Пользовательская команда сохранена!")
    else:
        print("❌ Пользовательская команда потеряна!")

if __name__ == "__main__":
    main()
```

## Преимущества системы

1. **Гибкость**: Возможность добавления команд без изменения кода
2. **Надежность**: Сохранение пользовательских команд при перезагрузке
3. **Производительность**: Автоматическое обнаружение без ручной регистрации
4. **Приоритизация**: Пользовательские команды имеют приоритет над встроенными
5. **Мониторинг**: Детальная информация о процессе перезагрузки

## Поведение при удалении команд

### Что происходит при удалении файла команды

1. **До перезагрузки**: Команда остается доступной, так как она уже загружена в память
2. **После перезагрузки**: Команда исчезает из реестра, так как файл больше не существует

### Процесс обработки удаленных команд

```python
# При перезагрузке конфигурации:
def reload_config_and_commands(self, package_path: str = "mcp_proxy_adapter.commands") -> Dict[str, Any]:
    # 1. Сохранение пользовательских команд
    custom_commands_backup = self._custom_commands.copy()
    
    # 2. Очистка всех команд (кроме пользовательских)
    self._commands.clear()
    self._instances.clear()
    
    # 3. Переобнаружение команд (удаленные файлы игнорируются)
    commands_discovered = self.discover_commands(package_path)
    
    # 4. Восстановление пользовательских команд
    self._custom_commands = custom_commands_backup
```

### Обработка ошибок импорта

Система корректно обрабатывает ситуации, когда файлы команд удалены:

```python
try:
    module = importlib.import_module(module_path)
    # Обработка команды...
except Exception as e:
    logger.error(f"Error loading command module {module_path}: {e}")
    # Модуль пропускается, ошибка логируется
```

### Преимущества такого поведения

1. **Безопасность**: Удаленные команды не остаются в системе
2. **Консистентность**: Реестр команд всегда соответствует файловой системе
3. **Отказоустойчивость**: Ошибки импорта не прерывают работу системы
4. **Гибкость**: Можно динамически добавлять и удалять команды

## Ограничения

1. **Требования к именованию**: Модули должны заканчиваться на `_command`
2. **Наследование**: Команды должны наследовать от базового класса `Command`
3. **Перезапуск сервера**: Некоторые изменения конфигурации могут требовать перезапуска
4. **Зависимости**: Пользовательские команды с зависимостями должны регистрироваться как экземпляры
5. **Удаление команд**: Требуется перезагрузка конфигурации для удаления команд из реестра

## Рекомендации

1. **Используйте пользовательские команды** для переопределения встроенных
2. **Группируйте команды** в отдельные пакеты для лучшей организации
3. **Тестируйте перезагрузку** перед развертыванием в продакшене
4. **Мониторьте логи** для отслеживания процесса автообнаружения
5. **Документируйте пользовательские команды** для облегчения поддержки 