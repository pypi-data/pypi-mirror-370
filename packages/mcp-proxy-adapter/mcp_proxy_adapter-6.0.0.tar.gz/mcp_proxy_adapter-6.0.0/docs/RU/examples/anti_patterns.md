# Анти-паттерны

Этот пример демонстрирует распространенные анти-паттерны и плохие практики при разработке микросервисов. Эти примеры предоставляются в образовательных целях, чтобы помочь разработчикам понять, чего следует избегать.

## Структура

```
anti_patterns/
├── __init__.py                  # Инициализация пакета
├── README.md                    # Документация
├── bad_design/                  # Плохие шаблоны проектирования
│   ├── __init__.py
│   ├── large_command.py         # Монолитная команда с избыточной ответственностью
│   ├── tight_coupling.py        # Сильно связанные компоненты
│   └── magic_strings.py         # Жестко закодированные значения и "магические" строки
├── performance_issues/          # Проблемы производительности
│   ├── __init__.py
│   ├── blocking_operations.py   # Блокирующие операции в асинхронном коде
│   ├── memory_leaks.py          # Примеры утечек памяти
│   └── n_plus_one.py            # Проблема N+1 запроса
├── security_problems/           # Проблемы безопасности
│   ├── __init__.py
│   ├── command_injection.py     # Уязвимость внедрения команд
│   ├── insecure_deserialization.py # Небезопасная десериализация
│   └── no_input_validation.py   # Отсутствие валидации входных данных
└── tests/                       # Тесты, демонстрирующие проблемы
```

## Примеры плохого дизайна

### Монолитная команда

Файл `large_command.py` демонстрирует команду, которая пытается сделать слишком много в одном классе:

```python
class DoEverythingCommand(Command):
    """Команда, которая пытается делать всё в одном месте."""
    
    name = "do_everything"
    result_class = DoEverythingResult
    
    async def execute(
        self, 
        user_id: str,
        action: str,
        file_path: Optional[str] = None,
        data: Optional[Dict[str, Any]] = None, 
        format: str = "json",
        notify: bool = False,
        # ... множество других параметров
    ) -> DoEverythingResult:
        """
        Выполнение команды, которая пытается делать слишком много.
        
        Эта команда обрабатывает аутентификацию пользователя, операции с файлами,
        обработку данных, уведомления и отчетность в одном месте.
        """
        # Сотни строк кода с несколькими ответственностями
        # ...
```

### Сильная связанность

Файл `tight_coupling.py` показывает компоненты, которые сильно связаны и трудны для поддержки:

```python
class DatabaseCommand(Command):
    """Команда, сильно связанная с конкретной реализацией базы данных."""
    
    name = "db_operation"
    result_class = DatabaseResult
    
    async def execute(self, operation: str, data: Dict[str, Any]) -> DatabaseResult:
        # Прямое создание экземпляра конкретной реализации
        db = PostgreSQLDatabase(host="localhost", port=5432, user="admin")
        
        # Прямые вызовы методов, специфичных для реализации
        if operation == "insert":
            result = db.execute_insert_query("INSERT INTO table VALUES (...)")
        elif operation == "update":
            result = db.execute_update_query("UPDATE table SET ...")
        
        return DatabaseResult(result)
```

## Проблемы производительности

### Блокирующие операции

Файл `blocking_operations.py` демонстрирует неправильное использование блокирующих вызовов в асинхронном коде:

```python
class BlockingCommand(Command):
    """Команда, которая блокирует цикл событий синхронными операциями."""
    
    name = "blocking"
    result_class = BlockingResult
    
    async def execute(self, operation: str) -> BlockingResult:
        if operation == "sleep":
            # Блокирует весь цикл событий!
            time.sleep(5)  # Должно быть await asyncio.sleep(5)
            
        elif operation == "io":
            # Блокирующая операция ввода-вывода
            with open("large_file.txt", "r") as f:  # Должен использоваться асинхронный ввод-вывод
                content = f.read()
                
        return BlockingResult(True)
```

## Проблемы безопасности

### Отсутствие валидации входных данных

Файл `no_input_validation.py` показывает команду, которая не валидирует пользовательский ввод:

```python
class InsecureCommand(Command):
    """Команда без валидации входных данных."""
    
    name = "insecure"
    result_class = InsecureResult
    
    async def execute(self, filename: str, content: str) -> InsecureResult:
        # Нет валидации имени файла - может содержать обход пути
        # содержимое не санитизировано и не валидировано
        
        # Уязвимость обхода пути
        with open(filename, "w") as f:
            f.write(content)
            
        return InsecureResult(True)
```

## Как избежать анти-паттернов

Для каждого продемонстрированного анти-паттерна в этом примере также предоставляется исправленная версия, показывающая рекомендуемый подход:

1. **Разделите большие команды** на меньшие, с единой ответственностью
2. **Используйте внедрение зависимостей** и интерфейсы вместо сильной связи
3. **Всегда используйте async правильно** и избегайте блокирующих операций
4. **Валидируйте все входные данные** перед обработкой
5. **Используйте параметризованные запросы** для операций с базой данных
6. **Реализуйте правильную обработку ошибок** с содержательными сообщениями
7. **Следуйте лучшим практикам безопасности** для всех операций

## Демонстрируемые концепции

1. Распространенные анти-паттерны проектирования
2. Подводные камни в асинхронном коде
3. Уязвимости безопасности
4. Проблемы управления памятью
5. Проблемы сильной связанности
6. "Магические" значения и жесткое кодирование
7. Правильные альтернативы проектирования 