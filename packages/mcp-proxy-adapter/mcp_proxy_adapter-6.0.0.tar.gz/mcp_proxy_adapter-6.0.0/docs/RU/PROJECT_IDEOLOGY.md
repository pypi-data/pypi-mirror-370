# Идеология и архитектурные принципы mcp_microservice

## Основная цель

mcp_microservice предназначен для обеспечения надежного, стандартизированного и расширяемого механизма взаимодействия с MCP Proxy. Его задача — автоматически регистрировать команды и формировать по ним корректную JSON-схему, которую понимает MCP Proxy. Вся работа с командами осуществляется через единый RPC-эндпоинт `/cmd`.

## Ключевые принципы

### 1. Единая точка входа (Single Endpoint)
- **Взаимодействие с внешними системами происходит только через эндпоинт `/cmd`** (JSON-RPC 2.0).
- Все остальные эндпоинты (REST, вспомогательные) считаются дублирующими и не должны использоваться для интеграции с MCP Proxy.

### 2. Автоматическая регистрация команд
- **Команды регистрируются автоматически**: разработчик реализует функцию-обработчик, а система сама анализирует её сигнатуру, аннотации типов и docstring.
- Для каждой команды формируется подробное описание параметров, возвращаемого значения и ошибок.
- **Каждый параметр должен быть детально описан**: тип, обязательность, описание, возможные значения (enum), значения по умолчанию и т.д.
- Вся информация о командах агрегируется в единую структуру (`commands_info`), которая используется для генерации схемы.

### 3. Автоматическая генерация схемы
- **Схема (OpenAPI/JSON Schema) формируется автоматически** на основе зарегистрированных команд и их метаданных.
- Схема полностью соответствует требованиям MCP Proxy:
    - Описывает все команды, параметры, типы, ограничения, возвращаемые значения и возможные ошибки.
    - Каждый параметр обязательно снабжен подробным описанием.
    - Схема доступна по запросу (например, через curl на порт 8001).
- Пример запроса схемы:
    ```bash
    curl http://localhost:8001/openapi.json
    ```

### 4. Поддержка стандартных команд
- **Общепринятые команды (например, `help`, `version`, `health`) должны быть реализованы всегда**, даже если их нет в пользовательском коде.
- mcp_microservice автоматически добавляет такие команды в схему и реализует их обработчики по умолчанию.
- Это обеспечивает предсказуемость и совместимость с инфраструктурой MCP Proxy.

### 5. Расширяемость и строгая типизация
- Новые команды добавляются просто — достаточно реализовать функцию с корректной аннотацией типов и docstring.
- Вся валидация параметров и результатов происходит автоматически.
- Ошибки в описании команд (например, отсутствие описания параметра) выявляются на этапе генерации схемы.

### 6. Прозрачность и документация
- Вся логика регистрации, анализа и генерации схемы максимально прозрачна и документирована.
- Примеры кода и документация всегда актуальны и соответствуют реальному поведению системы.

---

## Пример жизненного цикла команды

1. **Разработчик реализует функцию-обработчик:**
    ```python
    async def add_note(text: str) -> dict:
        """
        Добавить заметку.
        
        Args:
            text (str): Текст заметки
        Returns:
            dict: Объект заметки
        """
        ...
    ```
2. **Микросервис автоматически регистрирует команду** и извлекает всю необходимую информацию.
3. **Генерируется схема**, где параметр `text` будет описан с типом, обязательностью и описанием.
4. **MCP Proxy получает схему** (например, через curl) и использует её для валидации и автогенерации UI.
5. **Вызов команды** происходит через `/cmd` с передачей параметров в формате JSON-RPC.

---

## Требования к параметрам и схеме
- Каждый параметр должен иметь:
    - Тип (string, integer, boolean, object, array и т.д.)
    - Описание (description)
    - Обязательность (required)
    - Значение по умолчанию (default, если применимо)
    - Возможные значения (enum, если применимо)
- Возвращаемое значение и возможные ошибки также должны быть описаны.
- Все эти данные попадают в итоговую схему.

---

## Поддержка REST и RPC-эндпоинтов

- Проект поддерживает возможность опроса команд как по REST, так и по RPC-схеме (JSON-RPC 2.0).
- Независимо от того, используется ли REST-эндпоинт или RPC-эндпоинт, **ответ всегда возвращается строго в формате JSON-RPC**.
- Результат выполнения команды должен быть абсолютно идентичен при любом способе обращения (REST или RPC).
- Это обеспечивает единообразие интеграции и предсказуемость поведения для всех клиентов MCP Proxy.

---

## Рекомендуемая структура проекта и архитектурные соглашения

### 1. Одна команда — один файл
- Каждая команда реализуется в отдельном файле (например, `add_note.py`, `delete_note.py`).
- Это облегчает поддержку, тестирование и расширение команд.

### 2. Отдельный файл с классом-регистратором
- Для регистрации всех команд используется отдельный файл с классом-регистратором (например, `registry.py`).
- Регистратор отвечает за автоматический поиск, регистрацию и анализ команд.

### 3. Отдельный файл с менеджером
- Менеджер (например, `manager.py`) использует регистратор для выполнения команд и управления жизненным циклом приложения.
- Менеджер инкапсулирует логику запуска сервера, интеграции с FastAPI и взаимодействия с MCP Proxy.

### 4. Импорт зависимостей
- Команды импортируют регистратор и необходимые настройки (в том числе логгер) из централизованных модулей.
- Это обеспечивает единообразие и повторное использование кода.

### 5. Служебные команды и правила именования
- Служебные аналоги общепринятых команд (например, служебный `help`, `version`, `health`) должны начинаться с символа `_` (например, `_help`).
- При публикации в OpenAPI и в cmd-эндпоинте такие команды автоматически подставляются без префикса `_` (например, `_help` становится доступен как `help`).
- Это позволяет отделять служебные реализации от пользовательских, но при этом всегда предоставлять стандартный набор команд.

### 6. Готовность сервера "из коробки"
- Проект должен быть готовым сервером даже без добавления пользовательских команд.
- По умолчанию сервер предоставляет:
    - Набор общепринятых эндпоинтов OpenAPI (например, `/openapi.json`, `/docs`, `/health`, `/version`, `/help` и др.)
    - Единый эндпоинт `/cmd` для выполнения команд по JSON-RPC
- Это обеспечивает мгновенную интеграцию с MCP Proxy и возможность расширения без дополнительной настройки.

---

## Абстракция команд и формирование схемы

- В архитектуре проекта предусмотрен слой абстракции для команд, чтобы бизнес-логика была полностью отделена от деталей получения параметров и форматирования результата.
- Для этого реализуется абстрактный класс `BaseCommand`, который определяет обязательные методы:
    - `get_metadata()` — возвращает описание команды, её параметров, типов, обязательности, значений по умолчанию и т.д.
    - (опционально) другие методы для описания возвращаемого значения и ошибок.
- Конкретные команды наследуются от `BaseCommand` и реализуют только бизнес-логику и описание параметров.
- Код текущего проекта (mcp_microservice) обеспечивает:
    - Получение параметров из запроса (REST/RPC)
    - Валидацию типов и обязательности
    - Форматирование результата в JSON-RPC
    - Автоматическую генерацию схемы на основе метаданных, возвращаемых `get_metadata()`
- В продакшн-проектах добавляются только подкоманды и их бизнес-логика, а все инфраструктурные задачи (валидация, схема, формат ответа) остаются на стороне mcp_microservice.

---

## Итог

**mcp_microservice — это инструмент, который обеспечивает автоматическую, строгую и прозрачную интеграцию с MCP Proxy, минимизируя ручную работу и ошибки, а также гарантируя совместимость и расширяемость.** 