# Принципы конфигурации

## Обзор

Система конфигурации в MCP Proxy Adapter разработана для обеспечения надежности, согласованности и гибкости. Этот документ описывает ключевые принципы и практики, связанные с управлением конфигурацией.

## Основные принципы

### 1. Единый источник истины

Файл конфигурации является единственным источником истины для всех настроек приложения. Это обеспечивает согласованность и предотвращает конфликты между различными частями системы.

- Все настройки компонентов должны происходить из файла конфигурации
- Жестко закодированные значения запрещены в кодовой базе
- Значения по умолчанию могут быть определены, но должны переопределяться конфигурацией

### 2. Проверка полноты

Приложение проверяет полноту конфигурации при запуске. Если отсутствуют необходимые настройки:

- В лог записывается подробное сообщение об ошибке
- Приложение корректно завершает работу
- Сообщение об ошибке включает информацию о отсутствующих настройках

### 3. Единый логгер

Система логирования настраивается через центральную конфигурацию:

- Уровни логирования определяются в конфигурации
- Все компоненты используют единый экземпляр логгера
- Формат логов и их назначение централизованно настраиваются
- Стандартный формат включает временную метку, уровень лога, компонент и сообщение

### 4. Возможность горячей перезагрузки

Конфигурация может быть перезагружена без перезапуска приложения:

- Изменения обнаруживаются и применяются во время выполнения
- Компоненты уведомляются об изменениях конфигурации
- Процесс перезагрузки атомарный и последовательный
- Неудачные перезагрузки не влияют на работающую систему

### 5. Источники конфигурации

Конфигурация загружается из нескольких источников в следующем порядке приоритета:

1. Аргументы командной строки
2. Переменные окружения
3. Файл конфигурации
4. Значения по умолчанию

### 6. Логирование ошибок

Все ошибки, связанные с stderr, перенаправляются в отдельный файл:

- Критические ошибки записываются в отдельный лог-файл
- Это гарантирует, что важные сообщения об ошибках не будут потеряны
- Файл лога stderr имеет собственную политику ротации

### 7. Интеграция с системными сервисами

Приложение обеспечивает полную интеграцию с системными сервисами:

- Скрипты инициализации, совместимые с SystemV
- Корректный запуск и завершение работы
- Мониторинг статуса сервиса
- Поддержка сигналов перезагрузки

## Формат файла конфигурации

Конфигурация использует формат JSON и имеет следующую структуру верхнего уровня:

```json
{
    "server": {
        "host": "0.0.0.0",
        "port": 8000
    },
    "logging": {
        "level": "DEBUG",
        "file": "adapter.log",
        "rotation": {
            "max_bytes": 10485760,
            "backup_count": 5
        },
        "stderr_file": "error.log"
    },
    "commands": {
        // Конфигурация, специфичная для команд
    }
}
```

## Переменные окружения

Переменные окружения могут переопределять значения конфигурации в следующем формате:

```
MCP_SERVER_HOST=127.0.0.1
MCP_SERVER_PORT=9000
MCP_LOGGING_LEVEL=INFO
MCP_CONFIG_PATH=/path/to/config.json
```

## Аргументы командной строки

Аргументы командной строки имеют наивысший приоритет и могут указывать:

```
--config-path /path/to/config.json
--host 127.0.0.1
--port 9000
--log-level INFO
```

## Детали реализации

Система конфигурации реализована в модуле `config.py` со следующими ключевыми компонентами:

- Класс `Settings` для управления конфигурацией
- Метод `_merge_configs` для объединения нескольких источников
- Метод `_ensure_dirs_exist` для создания необходимых директорий
- `get_auth_config` для настроек аутентификации

## Расширение конфигурации

Система конфигурации разработана с возможностью расширения для будущих проектов. Основная реализация основана на классовом подходе, который позволяет легко настраивать и расширять функциональность.

### Переопределение метода чтения

Для расширения функциональности конфигурации в будущих проектах вы можете наследоваться от базового класса `Settings` и переопределить методы чтения:

```python
from mcp_proxy_adapter.config import Settings

class ExtendedSettings(Settings):
    def _read_config_file(self, config_path):
        """
        Переопределяет метод чтения конфигурационного файла для поддержки
        дополнительных форматов или источников.
        
        Args:
            config_path: Путь к файлу конфигурации
            
        Returns:
            dict: Загруженные данные конфигурации
        """
        # Проверяем расширение файла для определения формата
        if config_path.endswith('.yaml') or config_path.endswith('.yml'):
            return self._read_yaml_config(config_path)
        elif config_path.endswith('.toml'):
            return self._read_toml_config(config_path)
        else:
            # Возвращаемся к стандартному JSON-ридеру
            return super()._read_config_file(config_path)
    
    def _read_yaml_config(self, config_path):
        """Чтение конфигурации из YAML файла"""
        import yaml
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def _read_toml_config(self, config_path):
        """Чтение конфигурации из TOML файла"""
        import toml
        with open(config_path, 'r') as f:
            return toml.load(f)
```

### Расширение поддержки переменных окружения

Вы также можете переопределить обработку переменных окружения для поддержки более сложных шаблонов:

```python
class EnhancedSettings(Settings):
    def _process_env_vars(self):
        """
        Переопределение для поддержки дополнительных форматов 
        переменных окружения или вложенных структур.
        
        Returns:
            dict: Конфигурация, извлеченная из переменных окружения
        """
        # Сначала получаем базовую реализацию
        config = super()._process_env_vars()
        
        # Добавляем поддержку JSON-значений в переменных окружения
        import os
        import json
        
        for key, value in os.environ.items():
            if key.startswith('MCP_JSON_'):
                try:
                    # Разбираем JSON-значения из переменных окружения
                    section_name = key[9:].lower()  # Удаляем префикс 'MCP_JSON_'
                    json_value = json.loads(value)
                    config[section_name] = json_value
                except json.JSONDecodeError:
                    self.logger.warning(f"Не удалось разобрать JSON из переменной окружения {key}")
        
        return config
```

### Добавление пользовательской логики валидации

Расширение процесса валидации для добавления требований, специфичных для проекта:

```python
class ValidatedSettings(Settings):
    def validate_configuration(self):
        """
        Расширенная валидация для проверки требований, специфичных для проекта.
        
        Raises:
            ConfigError: Если валидация не пройдена
        """
        # Сначала вызываем базовую валидацию
        super().validate_configuration()
        
        # Добавляем валидацию, специфичную для проекта
        if 'database' in self.config:
            db_config = self.config['database']
            required_db_fields = ['host', 'port', 'username', 'password', 'database_name']
            
            missing_fields = [field for field in required_db_fields if field not in db_config]
            if missing_fields:
                raise ConfigError(f"Отсутствуют обязательные поля конфигурации базы данных: {', '.join(missing_fields)}")
            
            # Валидация строки подключения
            if 'connection_string' in db_config and not db_config['connection_string'].startswith(('postgresql://', 'mysql://')):
                raise ConfigError("Неверный формат строки подключения к базе данных")
```

### Интеграция в новые проекты

Для использования расширенной конфигурации в новом проекте:

```python
# В коде инициализации вашего проекта
from myproject.config import ExtendedSettings

# Создаем экземпляр со всеми расширениями
settings = ExtendedSettings()

# Доступ к конфигурации как обычно
database_host = settings.database.host
```

Этот шаблон расширения позволяет гибко обрабатывать конфигурацию, сохраняя при этом основные принципы системы конфигурации.

## Примеры использования

```python
from mcp_proxy_adapter.config import Settings

# Загрузка конфигурации
settings = Settings()

# Доступ к значениям конфигурации
host = settings.server.host
port = settings.server.port

# Использование единого логгера
logger = settings.get_logger("имя_компонента")
logger.info("Компонент инициализирован")

# Регистрация для получения уведомлений об изменениях конфигурации
settings.on_reload(обработчик_изменений_конфигурации) 
```

## Структура проекта

Этот раздел предоставляет обзор полной файловой структуры проекта:

```
mcp_microservice/
├── __init__.py               # Инициализация пакета
├── config.py                 # Класс управления конфигурацией
├── api/                      # Реализация API
│   ├── __init__.py
│   ├── app.py                # Настройка FastAPI приложения
│   ├── handlers.py           # Обработчики запросов
│   ├── middleware.py         # Компоненты промежуточного ПО API
│   └── schemas.py            # Определения схем API
├── commands/                 # Реализации команд
│   ├── __init__.py
│   ├── base.py               # Базовый класс команды
│   ├── command_registry.py   # Регистрация команд
│   └── result.py             # Классы результатов команд
├── core/                     # Основная функциональность
│   ├── __init__.py
│   ├── errors.py             # Определения ошибок
│   ├── logging.py            # Настройка логирования
│   └── utils.py              # Вспомогательные функции
├── schemas/                  # JSON схемы
│   └── base_schema.json      # Определение базовой схемы
├── tests/                    # Директория тестов
│   ├── __init__.py
│   ├── conftest.py           # Конфигурация тестов
│   ├── test_config.py        # Тесты конфигурации
│   └── ...                   # Другие тестовые модули
└── main.py                   # Точка входа в приложение
```

Эта структура следует принципам проектирования, изложенным в этом документе, с четким разделением обязанностей и акцентом на сопровождаемость и расширяемость.