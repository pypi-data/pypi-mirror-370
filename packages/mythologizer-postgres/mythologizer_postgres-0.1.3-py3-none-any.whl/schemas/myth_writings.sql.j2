CREATE TABLE myth_writings (
    id              SERIAL PRIMARY KEY,
    myth_id         INT NOT NULL REFERENCES myths(id) ON DELETE CASCADE,
    written_text    TEXT NOT NULL,
    has_been_read   BOOLEAN NOT NULL DEFAULT FALSE,
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Notify on insert
CREATE OR REPLACE FUNCTION notify_myth_writings_insert() RETURNS trigger AS $$
BEGIN
  PERFORM pg_notify(
    'myth_writings_inserted',
    json_build_object(
      'id', NEW.id,
      'myth_id', NEW.myth_id,
      'created_at', NEW.created_at,
      'has_been_read', NEW.has_been_read
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER myth_writings_insert_notify
AFTER INSERT ON myth_writings
FOR EACH ROW
EXECUTE FUNCTION notify_myth_writings_insert();

-- Notify when has_been_read flips from false to true
CREATE OR REPLACE FUNCTION notify_myth_writings_mark_read() RETURNS trigger AS $$
BEGIN
  IF NEW.has_been_read AND NOT OLD.has_been_read THEN
    PERFORM pg_notify(
      'myth_writings_marked_read',
      json_build_object(
        'id', NEW.id,
        'myth_id', NEW.myth_id,
        'read_at', NOW()
      )::text
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER myth_writings_mark_read_notify
AFTER UPDATE OF has_been_read ON myth_writings
FOR EACH ROW
WHEN (NEW.has_been_read = TRUE AND OLD.has_been_read = FALSE)
EXECUTE FUNCTION notify_myth_writings_mark_read();