CREATE TABLE agent_myths (
    myth_id INT PRIMARY KEY REFERENCES myths(id) ON DELETE CASCADE,
    agent_id INT NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
    position INT NOT NULL CHECK (position > 0),
    retention DOUBLE PRECISION NOT NULL CHECK (retention > 0 ),
    UNIQUE (agent_id, position)
);

CREATE INDEX agent_myths_agent_pos_idx ON agent_myths (agent_id, position);

-- Push semantics with bottom = 1 and top = highest position
CREATE OR REPLACE FUNCTION push_agent_myth()
RETURNS TRIGGER AS $$
DECLARE
    max_size INT;
    cur_count INT;
    drop_id INT;
BEGIN
    -- lock the agent row for consistent capacity reads
    SELECT memory_size INTO max_size
    FROM agents
    WHERE id = NEW.agent_id
    FOR UPDATE;

    IF max_size IS NULL THEN
        RAISE EXCEPTION 'Agent % not found', NEW.agent_id;
    END IF;

    IF max_size = 0 THEN
        RAISE EXCEPTION 'Agent % has memory_size = 0. Cannot push myths', NEW.agent_id;
    END IF;

    -- a myth can belong to only one agent
    IF EXISTS (SELECT 1 FROM agent_myths WHERE myth_id = NEW.myth_id) THEN
        RAISE EXCEPTION 'Myth % already assigned to an agent', NEW.myth_id;
    END IF;

    -- Get current count without FOR UPDATE
    SELECT COUNT(*) INTO cur_count
    FROM agent_myths
    WHERE agent_id = NEW.agent_id;

    IF cur_count >= max_size THEN
        -- evict bottom at position 1
        SELECT myth_id INTO drop_id
        FROM agent_myths
        WHERE agent_id = NEW.agent_id
        ORDER BY position ASC
        LIMIT 1;

        DELETE FROM agent_myths
        WHERE myth_id = drop_id;

        -- shift remaining down by 1 so positions stay contiguous
        UPDATE agent_myths
        SET position = position - 1
        WHERE agent_id = NEW.agent_id;
        
        -- insert new myth at top
        NEW.position := max_size;
        RETURN NEW;
    ELSE
        -- not full. new myth goes to top which is current_count + 1
        NEW.position := cur_count + 1;
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_push_agent_myth
BEFORE INSERT ON agent_myths
FOR EACH ROW
EXECUTE FUNCTION push_agent_myth();



-- Trim on memory_size change. Drops from bottom and keeps top
CREATE OR REPLACE FUNCTION trim_agent_memory()
RETURNS TRIGGER AS $$
DECLARE
    keep INT;
BEGIN
    IF NEW.memory_size < 0 THEN
        RAISE EXCEPTION 'memory_size must be >= 0';
    END IF;

    keep := NEW.memory_size;

    IF keep = 0 THEN
        DELETE FROM agent_myths WHERE agent_id = NEW.id;
        RETURN NEW;
    END IF;

    -- keep highest positions first. delete the rest which are the bottom entries
    DELETE FROM agent_myths am
    USING (
        SELECT myth_id
        FROM agent_myths
        WHERE agent_id = NEW.id
        ORDER BY position DESC
        OFFSET GREATEST(keep, 0)
    ) to_drop
    WHERE am.myth_id = to_drop.myth_id;
    
    -- Reorder remaining positions to be contiguous starting from 1
    UPDATE agent_myths
    SET position = new_pos
    FROM (
        SELECT myth_id, ROW_NUMBER() OVER (ORDER BY position ASC) as new_pos
        FROM agent_myths
        WHERE agent_id = NEW.id
    ) reordered
    WHERE agent_myths.myth_id = reordered.myth_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_trim_agent_memory
AFTER UPDATE OF memory_size ON agents
FOR EACH ROW
WHEN (NEW.memory_size IS DISTINCT FROM OLD.memory_size)
EXECUTE FUNCTION trim_agent_memory();
