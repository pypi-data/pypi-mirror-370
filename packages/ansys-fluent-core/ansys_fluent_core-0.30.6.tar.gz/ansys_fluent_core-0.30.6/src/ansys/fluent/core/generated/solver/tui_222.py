"""Fluent solver TUI commands"""
#
# This is an auto-generated file.  DO NOT EDIT!
#
# pylint: disable=line-too-long

from ansys.fluent.core.services.datamodel_tui import PyMenu, TUIMenu, TUIMethod



class main_menu(TUIMenu):
    """
    Fluent solver main menu.
    """
    def __init__(self, service, version, mode, path):
        self.adjoint = self.__class__.adjoint(service, version, mode, path + ["adjoint"])
        self.display = self.__class__.display(service, version, mode, path + ["display"])
        self.define = self.__class__.define(service, version, mode, path + ["define"])
        self.file = self.__class__.file(service, version, mode, path + ["file"])
        self.icing = self.__class__.icing(service, version, mode, path + ["icing"])
        self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
        self.parameters__and__customization = self.__class__.parameters__and__customization(service, version, mode, path + ["parameters__and__customization"])
        self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
        self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
        self.preferences = self.__class__.preferences(service, version, mode, path + ["preferences"])
        self.report = self.__class__.report(service, version, mode, path + ["report"])
        self.results = self.__class__.results(service, version, mode, path + ["results"])
        self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
        self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
        self.setup = self.__class__.setup(service, version, mode, path + ["setup"])
        self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
        self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
        self.server = self.__class__.server(service, version, mode, path + ["server"])
        self.turbo_post = self.__class__.turbo_post(service, version, mode, path + ["turbo_post"])
        self.views = self.__class__.views(service, version, mode, path + ["views"])
        self.parametric_study = self.__class__.parametric_study(service, version, mode, path + ["parametric_study"])
        self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
        self.close_fluent = self.__class__.close_fluent(service, version, mode, path + ["close_fluent"])
        self.exit = self.__class__.exit(service, version, mode, path + ["exit"])
        self.switch_to_meshing_mode = self.__class__.switch_to_meshing_mode(service, version, mode, path + ["switch_to_meshing_mode"])
        self.print_license_usage = self.__class__.print_license_usage(service, version, mode, path + ["print_license_usage"])
        super().__init__(service, version, mode, path)
    class close_fluent(TUIMethod):
        """
        Exit program.
        """
    class exit(TUIMethod):
        """
        Exit program.
        """
    class switch_to_meshing_mode(TUIMethod):
        """
        Switches from the solution mode to the meshing mode. This text command is only available if you have not yet read a mesh or a case file.
        """
    class print_license_usage(TUIMethod):
        """
        Print license usage information.
        """

    class adjoint(TUIMenu):
        """
        Adjoint.
        """
        def __init__(self, service, version, mode, path):
            self.observable = self.__class__.observable(service, version, mode, path + ["observable"])
            self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
            self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
            self.run = self.__class__.run(service, version, mode, path + ["run"])
            self.reporting = self.__class__.reporting(service, version, mode, path + ["reporting"])
            self.postprocess_options = self.__class__.postprocess_options(service, version, mode, path + ["postprocess_options"])
            self.morphing = self.__class__.morphing(service, version, mode, path + ["morphing"])
            self.multi_objective = self.__class__.multi_objective(service, version, mode, path + ["multi_objective"])
            self.design_tool = self.__class__.design_tool(service, version, mode, path + ["design_tool"])
            self.optimizer = self.__class__.optimizer(service, version, mode, path + ["optimizer"])
            self.utilities = self.__class__.utilities(service, version, mode, path + ["utilities"])
            super().__init__(service, version, mode, path)
        class observable(TUIMethod):
            """
            Menu to create and configure observables of interest.
            """
        class methods(TUIMethod):
            """
            Menu to configure adjoint solver settings.
            """
        class controls(TUIMethod):
            """
            Menu to configure adjoint solver controls.
            """
        class monitors(TUIMethod):
            """
            Menu to configure monitors for the adjoint solver.
            """
        class expert(TUIMethod):
            """
            Provides text commands that allow you to undo enhancements to the default adjoint solver behavior.
            """
        class run(TUIMethod):
            """
            Menu to initialize and compute the adjoint solution.
            """
        class reporting(TUIMethod):
            """
            Menu to report sensitivity data from the adjoint solution.
            """
        class postprocess_options(TUIMethod):
            """
            Postprocess options.
            """
        class morphing(TUIMethod):
            """
            Morphing menu.
            """
        class multi_objective(TUIMethod):
            """
            Multi-Objective menu.
            """
        class design_tool(TUIMethod):
            """
            Enters the design-tool menu.
            """
        class optimizer(TUIMethod):
            """
            Enters the optimizer menu, where you can use a gradient-based optimizer to optimize the geometry to meet multiple goals for multiple observables at multiple operating conditions.
            """
        class utilities(TUIMethod):
            """
            Enters the utilities menu.
            """

    class display(TUIMenu):
        """
        Enter the display menu.
        """
        def __init__(self, service, version, mode, path):
            self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
            self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
            self.flamelet_data = self.__class__.flamelet_data(service, version, mode, path + ["flamelet_data"])
            self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
            self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
            self.pdf_data = self.__class__.pdf_data(service, version, mode, path + ["pdf_data"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
            self.views = self.__class__.views(service, version, mode, path + ["views"])
            self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
            self.view_sync = self.__class__.view_sync(service, version, mode, path + ["view_sync"])
            self.update_scene = self.__class__.update_scene(service, version, mode, path + ["update_scene"])
            self.inverse_dft = self.__class__.inverse_dft(service, version, mode, path + ["inverse_dft"])
            self.add_custom_vector = self.__class__.add_custom_vector(service, version, mode, path + ["add_custom_vector"])
            self.annotate = self.__class__.annotate(service, version, mode, path + ["annotate"])
            self.clear_annotations = self.__class__.clear_annotations(service, version, mode, path + ["clear_annotations"])
            self.close_window = self.__class__.close_window(service, version, mode, path + ["close_window"])
            self.close_window_by_name = self.__class__.close_window_by_name(service, version, mode, path + ["close_window_by_name"])
            self.contour = self.__class__.contour(service, version, mode, path + ["contour"])
            self.display_custom_vector = self.__class__.display_custom_vector(service, version, mode, path + ["display_custom_vector"])
            self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
            self.mesh_outline = self.__class__.mesh_outline(service, version, mode, path + ["mesh_outline"])
            self.hsf_file = self.__class__.hsf_file(service, version, mode, path + ["hsf_file"])
            self.mesh_partition_boundary = self.__class__.mesh_partition_boundary(service, version, mode, path + ["mesh_partition_boundary"])
            self.save_picture = self.__class__.save_picture(service, version, mode, path + ["save_picture"])
            self.multigrid_coarsening = self.__class__.multigrid_coarsening(service, version, mode, path + ["multigrid_coarsening"])
            self.open_window = self.__class__.open_window(service, version, mode, path + ["open_window"])
            self.graphics_window_layout = self.__class__.graphics_window_layout(service, version, mode, path + ["graphics_window_layout"])
            self.reacting_channel_curves = self.__class__.reacting_channel_curves(service, version, mode, path + ["reacting_channel_curves"])
            self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
            self.re_render = self.__class__.re_render(service, version, mode, path + ["re_render"])
            self.re_scale = self.__class__.re_scale(service, version, mode, path + ["re_scale"])
            self.set_window = self.__class__.set_window(service, version, mode, path + ["set_window"])
            self.set_window_by_name = self.__class__.set_window_by_name(service, version, mode, path + ["set_window_by_name"])
            self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
            self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
            self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
            self.velocity_vector = self.__class__.velocity_vector(service, version, mode, path + ["velocity_vector"])
            self.zone_mesh = self.__class__.zone_mesh(service, version, mode, path + ["zone_mesh"])
            self.set_list_tree_separator = self.__class__.set_list_tree_separator(service, version, mode, path + ["set_list_tree_separator"])
            self.update_layout = self.__class__.update_layout(service, version, mode, path + ["update_layout"])
            self.switch_to_post_processing_volume = self.__class__.switch_to_post_processing_volume(service, version, mode, path + ["switch_to_post_processing_volume"])
            self.switch_to_primary_volume = self.__class__.switch_to_primary_volume(service, version, mode, path + ["switch_to_primary_volume"])
            super().__init__(service, version, mode, path)
        class add_custom_vector(TUIMethod):
            """
            Adds new custom vector definition.
            """
        class annotate(TUIMethod):
            """
            Add a text annotation string to the active graphics window.
            """
        class clear_annotations(TUIMethod):
            """
            Removes all annotations and attachment lines from the active graphics window.
            """
        class close_window(TUIMethod):
            """
            Close a "user" graphics window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
        class close_window_by_name(TUIMethod):
            """
            Close a reserved graphics window (windows used for residuals, report plots, and animation definitions).
            """
        class contour(TUIMethod):
            """
            Prompts for a scalar field and minimum and maximum values, and then displays a contour plot.
            """
        class display_custom_vector(TUIMethod):
            """
            Displays custom vector.  This command is only visible when the /preferences/graphics/enable-non-object-based-workflow TUI command is set to yes.
            """
        class mesh(TUIMethod):
            """
            Displays the entire mesh. For 3D, you will be asked to confirm that you really want to draw the entire mesh (not just themesh-outline).
            """
        class mesh_outline(TUIMethod):
            """
            Displays the mesh boundaries.
            """
        class hsf_file(TUIMethod):
            """
            Loads an HSF file for viewing.
            """
        class mesh_partition_boundary(TUIMethod):
            """
            Displays mesh partition boundaries.
            """
        class save_picture(TUIMethod):
            """
            Generate a "hardcopy" of the active window.
            """
        class multigrid_coarsening(TUIMethod):
            """
            Displays a coarse mesh level from the last multigrid coarsening.
            """
        class open_window(TUIMethod):
            """
            Opens a graphics window.
            """
        class graphics_window_layout(TUIMethod):
            """
            Arranges the graphics window layout.
            """
        class reacting_channel_curves(TUIMethod):
            """
            Plots the reacting channel variables.
            """
        class profile(TUIMethod):
            """
            Displays profiles of a flow variable.
            """
        class re_render(TUIMethod):
            """
            Re-renders the last contour, profile, or vector plot with updated surfaces, meshed, lights, colormap, rendering options, and so on, without recalculating the contour data.
            """
        class re_scale(TUIMethod):
            """
            Re-renders the last contour, profile, or vector plot with updated scale, surfaces, meshes, lights, colormap, rendering options, and so on, but without recalculating the field data.
            """
        class set_window(TUIMethod):
            """
            Sets a "user" graphics window to be the active window. User windows are specified by number (1-50), with the associated number corresponding to the order, left-to-right, that the windows were created in.
            """
        class set_window_by_name(TUIMethod):
            """
            Sets the specified graphics window as active. The graphics windows specified using this command are "reserved" windows, that is, residual monitors, report plots, and animation definitions. The name will match the name you provided when creating the object (report plots and animation definitions).
            """
        class surface_cells(TUIMethod):
            """
            Draws the cells on the specified surfaces. You can include a wildcard (\*) within the surface names.
            """
        class surface_mesh(TUIMethod):
            """
            Draws the mesh defined by the specified surfaces. You can include a wildcard (\*) within the surface names.
            """
        class vector(TUIMethod):
            """
            Displays vectors of a space vector variable.
            """
        class velocity_vector(TUIMethod):
            """
            Prompts for a scalar field by which to color the vectors, the minimum and maximum values, and the scale factor, and then draws the velocity vectors.
            """
        class zone_mesh(TUIMethod):
            """
            Draws the mesh defined by specified face zones. Zone names can be indicated using wildcards (\*).
            """
        class set_list_tree_separator(TUIMethod):
            """
            Set the separator character for list tree.
            """
        class update_layout(TUIMethod):
            """
            Update the fluent layout.
            """
        class switch_to_post_processing_volume(TUIMethod):
            """
            Switch to post processing volume.
            """
        class switch_to_primary_volume(TUIMethod):
            """
            Switch to primary volume.
            """

        class embedded_windows(TUIMenu):
            """
            Enter the embedded window menu.
            """
            def __init__(self, service, version, mode, path):
                self.close = self.__class__.close(service, version, mode, path + ["close"])
                self.close_all = self.__class__.close_all(service, version, mode, path + ["close_all"])
                self.embed_in = self.__class__.embed_in(service, version, mode, path + ["embed_in"])
                self.move_out = self.__class__.move_out(service, version, mode, path + ["move_out"])
                self.move_out_all = self.__class__.move_out_all(service, version, mode, path + ["move_out_all"])
                super().__init__(service, version, mode, path)
            class close(TUIMethod):
                """
                Close an embedded window.
                """
            class close_all(TUIMethod):
                """
                Close all the embedded windows within the specified parent window.
                """
            class embed_in(TUIMethod):
                """
                Specify a window to embed and a parent window to receive the embedded window.
                """
            class move_out(TUIMethod):
                """
                Move an embedded window out of the parent window, returning the embedded window to a non-embedded state.
                """
            class move_out_all(TUIMethod):
                """
                Move all the embedded windows out of the specified parent window.
                """

        class objects(TUIMenu):
            """
            Enter to add, edit, delete or display graphics objects.
            """
            def __init__(self, service, version, mode, path):
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create new graphics object.
                """
            class edit(TUIMethod):
                """
                Edit graphics object.
                """
            class copy(TUIMethod):
                """
                Copy graphics object.
                """
            class delete(TUIMethod):
                """
                Delete graphics object.
                """
            class display(TUIMethod):
                """
                Display graphics object.
                """
            class add_to_graphics(TUIMethod):
                """
                Add graphics object to existing graphics.
                """

        class flamelet_data(TUIMenu):
            """
            Displays flamelet data.
            """
            def __init__(self, service, version, mode, path):
                self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                super().__init__(service, version, mode, path)
            class draw_number_box(TUIMethod):
                """
                Enables/disables display of the numbers box.
                """
            class plot_1d_slice(TUIMethod):
                """
                Enables/disables plot of the 1D-slice.
                """
            class write_to_file(TUIMethod):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """
            class carpet_plot(TUIMethod):
                """
                Enables/disables display of carpet plot of a property.
                """

        class particle_tracks(TUIMenu):
            """
            Enters the particle tracks menu.
            """
            def __init__(self, service, version, mode, path):
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                super().__init__(service, version, mode, path)
            class particle_tracks(TUIMethod):
                """
                Calculates and displays particle tracks from defined injections.
                """
            class plot_write_xy_plot(TUIMethod):
                """
                Plots or writes an XY plot of particle tracks.
                """

        class path_lines(TUIMenu):
            """
            Enters the pathlines menu.
            """
            def __init__(self, service, version, mode, path):
                self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                self.write_to_files = self.__class__.write_to_files(service, version, mode, path + ["write_to_files"])
                super().__init__(service, version, mode, path)
            class path_lines(TUIMethod):
                """
                Displays pathlines from a surface.
                """
            class plot_write_xy_plot(TUIMethod):
                """
                Plots or writes an XY plot of pathlines.
                """
            class write_to_files(TUIMethod):
                """
                Writes pathlines to a file.
                """

        class pdf_data(TUIMenu):
            """
            Enters the PDF data menu.
            """
            def __init__(self, service, version, mode, path):
                self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                super().__init__(service, version, mode, path)
            class draw_number_box(TUIMethod):
                """
                Enables/disables the display of the numbers box.
                """
            class plot_1d_slice(TUIMethod):
                """
                Enables/disables a plot of the 1D-slice.
                """
            class write_to_file(TUIMethod):
                """
                Enables/disables writing the 1D-slice to file instead of plot.
                """
            class carpet_plot(TUIMethod):
                """
                Enables/disables the display of a carpet plot of a property.
                """

        class set(TUIMenu):
            """
            Enter the set menu to set display parameters.
            """
            def __init__(self, service, version, mode, path):
                self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                self.velocity_vectors = self.__class__.velocity_vectors(service, version, mode, path + ["velocity_vectors"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.color_map = self.__class__.color_map(service, version, mode, path + ["color_map"])
                self.element_shrink = self.__class__.element_shrink(service, version, mode, path + ["element_shrink"])
                self.filled_mesh = self.__class__.filled_mesh(service, version, mode, path + ["filled_mesh"])
                self.mesh_level = self.__class__.mesh_level(service, version, mode, path + ["mesh_level"])
                self.mesh_partitions = self.__class__.mesh_partitions(service, version, mode, path + ["mesh_partitions"])
                self.mesh_surfaces = self.__class__.mesh_surfaces(service, version, mode, path + ["mesh_surfaces"])
                self.mesh_zones = self.__class__.mesh_zones(service, version, mode, path + ["mesh_zones"])
                self.line_weight = self.__class__.line_weight(service, version, mode, path + ["line_weight"])
                self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                self.marker_symbol = self.__class__.marker_symbol(service, version, mode, path + ["marker_symbol"])
                self.mesh_display_configuration = self.__class__.mesh_display_configuration(service, version, mode, path + ["mesh_display_configuration"])
                self.mirror_zones = self.__class__.mirror_zones(service, version, mode, path + ["mirror_zones"])
                self.n_stream_func = self.__class__.n_stream_func(service, version, mode, path + ["n_stream_func"])
                self.nodewt_based_interp = self.__class__.nodewt_based_interp(service, version, mode, path + ["nodewt_based_interp"])
                self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                self.periodic_instancing = self.__class__.periodic_instancing(service, version, mode, path + ["periodic_instancing"])
                self.proximity_zones = self.__class__.proximity_zones(service, version, mode, path + ["proximity_zones"])
                self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                self.reset_graphics = self.__class__.reset_graphics(service, version, mode, path + ["reset_graphics"])
                self.zero_angle_dir = self.__class__.zero_angle_dir(service, version, mode, path + ["zero_angle_dir"])
                self.duplicate_node_display = self.__class__.duplicate_node_display(service, version, mode, path + ["duplicate_node_display"])
                super().__init__(service, version, mode, path)
            class color_map(TUIMethod):
                """
                Enters the color map menu, which contains names of predefined and user-defined (in the Colormap Editor panel) colormaps that can be selected. It prompts you for the name of the colormap to be used.
                """
            class element_shrink(TUIMethod):
                """
                Sets shrinkage of both faces and cells. A value of zero indicates no shrinkage, while a value of one will shrink each face or cell to a point.
                """
            class filled_mesh(TUIMethod):
                """
                Determines whether the meshes are drawn as wireframe or solid.
                """
            class mesh_level(TUIMethod):
                """
                Sets coarse mesh level to be drawn.
                """
            class mesh_partitions(TUIMethod):
                """
                Enables/disables option to draw mesh partition boundaries.
                """
            class mesh_surfaces(TUIMethod):
                """
                Sets surface IDs to be drawn as meshes. You can include a wildcard  (\*) within the surface names.
                """
            class mesh_zones(TUIMethod):
                """
                Sets zone IDs to be drawn as meshes.
                """
            class line_weight(TUIMethod):
                """
                Set the line-weight factor for the window.
                """
            class marker_size(TUIMethod):
                """
                Sets the size of markers used to represent points.
                """
            class marker_symbol(TUIMethod):
                """
                Sets the type of markers used to represent points.
                """
            class mesh_display_configuration(TUIMethod):
                """
                Changes the default mesh display. If set tomeshing, it draws the mesh on edges and faces of the outline surfaces, colored by their zone ID with lighting enabled. If set tosolution, it draws the mesh on edges and faces of the outline surfaces, colored by their zone type with lighting enabled. If set to post-processing, it draws the object outline with lighting disabled. If set toclassic, it draws the mesh on all edges of the outline surfaces.  This only applies for 3D cases.
                """
            class mirror_zones(TUIMethod):
                """
                Sets the zones about which the domain is mirrored (symmetry planes).
                """
            class n_stream_func(TUIMethod):
                """
                Sets number of iterations used in computing stream function.
                """
            class nodewt_based_interp(TUIMethod):
                """
                Disables/enables the use of node weights for node-based gradients in postprocessing.
                """
            class overlays(TUIMethod):
                """
                Enable/disable overlays.
                """
            class periodic_instancing(TUIMethod):
                """
                Sets the number of periodic repetitions.
                """
            class proximity_zones(TUIMethod):
                """
                Sets zones to be used for boundary cell distance and boundary proximity.
                """
            class render_mesh(TUIMethod):
                """
                Enables/disables rendering the mesh on top of contours, vectors, and so on.
                """
            class reset_graphics(TUIMethod):
                """
                Reset the graphics system.
                """
            class zero_angle_dir(TUIMethod):
                """
                Sets the vector having zero angular coordinates.
                """
            class duplicate_node_display(TUIMethod):
                """
                Set flag to remove duplicate nodes in mesh display.
                """

            class colors(TUIMenu):
                """
                Enter the color options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                    self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                    self.background = self.__class__.background(service, version, mode, path + ["background"])
                    self.color_by_type = self.__class__.color_by_type(service, version, mode, path + ["color_by_type"])
                    self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                    self.far_field_faces = self.__class__.far_field_faces(service, version, mode, path + ["far_field_faces"])
                    self.inlet_faces = self.__class__.inlet_faces(service, version, mode, path + ["inlet_faces"])
                    self.interior_faces = self.__class__.interior_faces(service, version, mode, path + ["interior_faces"])
                    self.internal_faces = self.__class__.internal_faces(service, version, mode, path + ["internal_faces"])
                    self.outlet_faces = self.__class__.outlet_faces(service, version, mode, path + ["outlet_faces"])
                    self.overset_faces = self.__class__.overset_faces(service, version, mode, path + ["overset_faces"])
                    self.periodic_faces = self.__class__.periodic_faces(service, version, mode, path + ["periodic_faces"])
                    self.rans_les_interface_faces = self.__class__.rans_les_interface_faces(service, version, mode, path + ["rans_les_interface_faces"])
                    self.reset_user_colors = self.__class__.reset_user_colors(service, version, mode, path + ["reset_user_colors"])
                    self.show_user_colors = self.__class__.show_user_colors(service, version, mode, path + ["show_user_colors"])
                    self.symmetry_faces = self.__class__.symmetry_faces(service, version, mode, path + ["symmetry_faces"])
                    self.axis_faces = self.__class__.axis_faces(service, version, mode, path + ["axis_faces"])
                    self.free_surface_faces = self.__class__.free_surface_faces(service, version, mode, path + ["free_surface_faces"])
                    self.traction_faces = self.__class__.traction_faces(service, version, mode, path + ["traction_faces"])
                    self.user_color = self.__class__.user_color(service, version, mode, path + ["user_color"])
                    self.wall_faces = self.__class__.wall_faces(service, version, mode, path + ["wall_faces"])
                    self.interface_faces = self.__class__.interface_faces(service, version, mode, path + ["interface_faces"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.reset_colors = self.__class__.reset_colors(service, version, mode, path + ["reset_colors"])
                    self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                    self.skip_label = self.__class__.skip_label(service, version, mode, path + ["skip_label"])
                    self.automatic_skip = self.__class__.automatic_skip(service, version, mode, path + ["automatic_skip"])
                    self.graphics_color_theme = self.__class__.graphics_color_theme(service, version, mode, path + ["graphics_color_theme"])
                    super().__init__(service, version, mode, path)
                class background(TUIMethod):
                    """
                    Set the background (window) color.
                    """
                class color_by_type(TUIMethod):
                    """
                    Determine whether to color meshes by type or by surface (ID).
                    """
                class foreground(TUIMethod):
                    """
                    Set the foreground (text and window frame) color.
                    """
                class far_field_faces(TUIMethod):
                    """
                    Set the color of far field faces.
                    """
                class inlet_faces(TUIMethod):
                    """
                    Set the color of inlet faces.
                    """
                class interior_faces(TUIMethod):
                    """
                    Set the color of interior faces.
                    """
                class internal_faces(TUIMethod):
                    """
                    Set the color of internal interface faces.
                    """
                class outlet_faces(TUIMethod):
                    """
                    Set the color of outlet faces.
                    """
                class overset_faces(TUIMethod):
                    """
                    Set the color of overset faces.
                    """
                class periodic_faces(TUIMethod):
                    """
                    Set the color of periodic faces.
                    """
                class rans_les_interface_faces(TUIMethod):
                    """
                    Set the color of RANS/LES interface faces.
                    """
                class reset_user_colors(TUIMethod):
                    """
                    Reset all user colors.
                    """
                class show_user_colors(TUIMethod):
                    """
                    List currently defined user colors.
                    """
                class symmetry_faces(TUIMethod):
                    """
                    Set the color of symmetric faces.
                    """
                class axis_faces(TUIMethod):
                    """
                    Set the color of axisymmetric faces.
                    """
                class free_surface_faces(TUIMethod):
                    """
                    Set the color of free-surface faces.
                    """
                class traction_faces(TUIMethod):
                    """
                    Set the color of traction faces.
                    """
                class user_color(TUIMethod):
                    """
                    Explicitly set color of display zone.
                    """
                class wall_faces(TUIMethod):
                    """
                    Set the color of wall faces.
                    """
                class interface_faces(TUIMethod):
                    """
                    Set the color of mesh Interfaces.
                    """
                class list(TUIMethod):
                    """
                    List available colors.
                    """
                class reset_colors(TUIMethod):
                    """
                    Reset individual mesh surface colors to the defaults.
                    """
                class surface(TUIMethod):
                    """
                    Set the color of surfaces.
                    """
                class skip_label(TUIMethod):
                    """
                    Set the number of labels to be skipped in the colopmap scale.
                    """
                class automatic_skip(TUIMethod):
                    """
                    Determine whether to skip labels in the colopmap scale automatically.
                    """
                class graphics_color_theme(TUIMethod):
                    """
                    Enter the graphics color theme menu.
                    """

                class by_type(TUIMenu):
                    """
                    Enter the zone type color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.type_name = self.__class__.type_name(service, version, mode, path + ["type_name"])
                        self.only_list_case_boundaries = self.__class__.only_list_case_boundaries(service, version, mode, path + ["only_list_case_boundaries"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        super().__init__(service, version, mode, path)
                    class only_list_case_boundaries(TUIMethod):
                        """
                        Only list the boundary types that are assigned in this case.
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        Use inherent material color for boundary zones.
                        """
                    class reset(TUIMethod):
                        """
                        To reset colors and/or materials to the defaults.
                        """

                    class type_name(TUIMenu):
                        """
                        Select the boundary type to specify colors and/or materials.
                        """
                        def __init__(self, service, version, mode, path):
                            self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                            self.far_field = self.__class__.far_field(service, version, mode, path + ["far_field"])
                            self.free_surface = self.__class__.free_surface(service, version, mode, path + ["free_surface"])
                            self.inlet = self.__class__.inlet(service, version, mode, path + ["inlet"])
                            self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                            self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                            self.internal = self.__class__.internal(service, version, mode, path + ["internal"])
                            self.outlet = self.__class__.outlet(service, version, mode, path + ["outlet"])
                            self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                            self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                            self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                            self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                            self.traction = self.__class__.traction(service, version, mode, path + ["traction"])
                            self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                            super().__init__(service, version, mode, path)

                        class axis(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class far_field(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class free_surface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class inlet(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class interface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class interior(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class internal(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class outlet(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class overset(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class periodic(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class rans_les_interface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class surface(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class symmetry(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class traction(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                        class wall(TUIMenu):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.material = self.__class__.material(service, version, mode, path + ["material"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Set a color for the selected boundary type.
                                """
                            class material(TUIMethod):
                                """
                                Set a material for the selected boundary type.
                                """

                class by_surface(TUIMenu):
                    """
                    Enter the surface(s) color and material assignment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                        self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                        self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                        self.list_surfaces_by_color = self.__class__.list_surfaces_by_color(service, version, mode, path + ["list_surfaces_by_color"])
                        self.list_surfaces_by_material = self.__class__.list_surfaces_by_material(service, version, mode, path + ["list_surfaces_by_material"])
                        super().__init__(service, version, mode, path)
                    class surfaces(TUIMethod):
                        """
                        Select the surface(s) to specify colors and/or materials.
                        """
                    class use_inherent_material_color(TUIMethod):
                        """
                        Use inherent material color for surfaces.
                        """
                    class reset(TUIMethod):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                    class list_surfaces_by_color(TUIMethod):
                        """
                        To list the surfaces by its color.
                        """
                    class list_surfaces_by_material(TUIMethod):
                        """
                        To list the surfaces by its material.
                        """

            class contours(TUIMenu):
                """
                Enters the contour options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                    self.clip_to_range = self.__class__.clip_to_range(service, version, mode, path + ["clip_to_range"])
                    self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                    self.filled_contours = self.__class__.filled_contours(service, version, mode, path + ["filled_contours"])
                    self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                    self.line_contours = self.__class__.line_contours(service, version, mode, path + ["line_contours"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.n_contour = self.__class__.n_contour(service, version, mode, path + ["n_contour"])
                    self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                    self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                    self.coloring = self.__class__.coloring(service, version, mode, path + ["coloring"])
                    super().__init__(service, version, mode, path)
                class auto_range(TUIMethod):
                    """
                    Enables/disables auto-computation of the contour range.
                    """
                class clip_to_range(TUIMethod):
                    """
                    Turns the clip to range option for filled contours on/off.
                    """
                class surfaces(TUIMethod):
                    """
                    Sets the surfaces on which contours are drawn. You can include a wildcard (\*) within the surface names.
                    """
                class filled_contours(TUIMethod):
                    """
                    Turns the filled contours option on/off (deselects line-contours?).
                    """
                class global_range(TUIMethod):
                    """
                    Turns the global range for contours on/off.
                    """
                class line_contours(TUIMethod):
                    """
                    Turns the line contours option on/off (deselects filled-contours?).
                    """
                class log_scale(TUIMethod):
                    """
                    Specifies a decimal or logarithmic color scale for contours.
                    """
                class n_contour(TUIMethod):
                    """
                    Sets the number of contour levels.
                    """
                class node_values(TUIMethod):
                    """
                    Sets the option to use scalar field at nodes when computing the contours.
                    """
                class render_mesh(TUIMethod):
                    """
                    Determines whether or not to render the mesh on top of contours, vectors, and so on.
                    """
                class coloring(TUIMethod):
                    """
                    Specifies whether contours are displayed in bands or with smooth transitions. Note that you can only display smooth contours if node-values are enabled.
                    """

            class picture(TUIMenu):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                    self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                    self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                    self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                    self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                    self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                    self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                    self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                    self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                    super().__init__(service, version, mode, path)
                class invert_background(TUIMethod):
                    """
                    Use a white background when the picture is saved.
                    """
                class landscape(TUIMethod):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                class preview(TUIMethod):
                    """
                    Display a preview image of a hardcopy.
                    """
                class x_resolution(TUIMethod):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                class y_resolution(TUIMethod):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """
                class dpi(TUIMethod):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                class use_window_resolution(TUIMethod):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                class set_standard_resolution(TUIMethod):
                    """
                    Select from pre-defined resolution list.
                    """
                class jpeg_hardcopy_quality(TUIMethod):
                    """
                    To set jpeg hardcopy quality.
                    """

                class color_mode(TUIMenu):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                        self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                        self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        super().__init__(service, version, mode, path)
                    class color(TUIMethod):
                        """
                        Plot hardcopies in color.
                        """
                    class gray_scale(TUIMethod):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                    class mono_chrome(TUIMethod):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """
                    class list(TUIMethod):
                        """
                        Display the current hardcopy color mode.
                        """

                class driver(TUIMenu):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                        self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                        self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                        self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                        self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                        self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                        self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                        self.png = self.__class__.png(service, version, mode, path + ["png"])
                        self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                        self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                        self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                        self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.options = self.__class__.options(service, version, mode, path + ["options"])
                        super().__init__(service, version, mode, path)
                    class dump_window(TUIMethod):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                    class eps(TUIMethod):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                    class jpeg(TUIMethod):
                        """
                        Produce JPEG output for hardcopies.
                        """
                    class post_script(TUIMethod):
                        """
                        Produce PostScript output for hardcopies.
                        """
                    class ppm(TUIMethod):
                        """
                        Produce PPM output for hardcopies.
                        """
                    class tiff(TUIMethod):
                        """
                        Use TIFF output for hardcopies.
                        """
                    class png(TUIMethod):
                        """
                        Use PNG output for hardcopies.
                        """
                    class hsf(TUIMethod):
                        """
                        Use HSF output for hardcopies.
                        """
                    class avz(TUIMethod):
                        """
                        Use AVZ output for hardcopies.
                        """
                    class glb(TUIMethod):
                        """
                        Use GLB output for hardcopies.
                        """
                    class vrml(TUIMethod):
                        """
                        Use VRML output for hardcopies.
                        """
                    class list(TUIMethod):
                        """
                        List the current hardcopy driver.
                        """
                    class options(TUIMethod):
                        """
                        Set the hardcopy options. Available options are:
                        "no gamma correction", disables gamma correction of colors,
                        "physical size = (width,height)", where width and height
                        are the actual measurements of the printable area of the page
                        in centimeters.
                        "subscreen = (left,right,bottom,top)", where left,right,
                        bottom, and top are numbers in [-1,1] describing a subwindow on
                        the page in which to place the hardcopy.
                        The options may be combined by separating them with commas.
                        """

                    class post_format(TUIMenu):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                            self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                            self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                            self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                            super().__init__(service, version, mode, path)
                        class fast_raster(TUIMethod):
                            """
                            Use the new raster format.
                            """
                        class raster(TUIMethod):
                            """
                            Use the original raster format.
                            """
                        class rle_raster(TUIMethod):
                            """
                            Use the run-length encoded raster format.
                            """
                        class vector(TUIMethod):
                            """
                            Use vector format.
                            """

            class lights(TUIMenu):
                """
                Enter the lights menu.
                """
                def __init__(self, service, version, mode, path):
                    self.lighting_interpolation = self.__class__.lighting_interpolation(service, version, mode, path + ["lighting_interpolation"])
                    self.lights_on = self.__class__.lights_on(service, version, mode, path + ["lights_on"])
                    self.set_ambient_color = self.__class__.set_ambient_color(service, version, mode, path + ["set_ambient_color"])
                    self.set_light = self.__class__.set_light(service, version, mode, path + ["set_light"])
                    self.headlight_on = self.__class__.headlight_on(service, version, mode, path + ["headlight_on"])
                    super().__init__(service, version, mode, path)
                class lights_on(TUIMethod):
                    """
                    Turn all active lighting on/off.
                    """
                class set_ambient_color(TUIMethod):
                    """
                    Set the ambient light color for the scene.
                    """
                class set_light(TUIMethod):
                    """
                    Add or modify a directional, colored light.
                    """
                class headlight_on(TUIMethod):
                    """
                    Turn the light that moves with the camera on or off.
                    """

                class lighting_interpolation(TUIMenu):
                    """
                    Set lighting interpolation method.
                    """
                    def __init__(self, service, version, mode, path):
                        self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                        self.flat = self.__class__.flat(service, version, mode, path + ["flat"])
                        self.gouraud = self.__class__.gouraud(service, version, mode, path + ["gouraud"])
                        self.phong = self.__class__.phong(service, version, mode, path + ["phong"])
                        super().__init__(service, version, mode, path)
                    class automatic(TUIMethod):
                        """
                        Choose Automatic to automatically select the best lighting method for a given graphics object.
                        """
                    class flat(TUIMethod):
                        """
                        Use flat shading for meshes and polygons.
                        """
                    class gouraud(TUIMethod):
                        """
                        Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                        """
                    class phong(TUIMethod):
                        """
                        Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                        """

            class particle_tracks(TUIMenu):
                """
                Enters the particle-tracks menu to set parameters for display of particle tracks.
                """
                def __init__(self, service, version, mode, path):
                    self.sphere_settings = self.__class__.sphere_settings(service, version, mode, path + ["sphere_settings"])
                    self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                    self.filter_settings = self.__class__.filter_settings(service, version, mode, path + ["filter_settings"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.history_filename = self.__class__.history_filename(service, version, mode, path + ["history_filename"])
                    self.report_to = self.__class__.report_to(service, version, mode, path + ["report_to"])
                    self.report_type = self.__class__.report_type(service, version, mode, path + ["report_type"])
                    self.report_variables = self.__class__.report_variables(service, version, mode, path + ["report_variables"])
                    self.report_default_variables = self.__class__.report_default_variables(service, version, mode, path + ["report_default_variables"])
                    self.track_single_particle_stream = self.__class__.track_single_particle_stream(service, version, mode, path + ["track_single_particle_stream"])
                    self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                    self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                    self.coarsen_factor = self.__class__.coarsen_factor(service, version, mode, path + ["coarsen_factor"])
                    self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                    self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                    self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                    self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                    self.particle_skip = self.__class__.particle_skip(service, version, mode, path + ["particle_skip"])
                    super().__init__(service, version, mode, path)
                class display(TUIMethod):
                    """
                    Determines whether particle tracks shall be displayed or only tracked.
                    """
                class history_filename(TUIMethod):
                    """
                    Specifies the name of the particle history file.
                    """
                class report_to(TUIMethod):
                    """
                    Specifies the destination for the report (console, file, none).
                    """
                class report_type(TUIMethod):
                    """
                    Sets the report type for particle tracks.
                    """
                class report_variables(TUIMethod):
                    """
                    Sets the report variables.
                    """
                class report_default_variables(TUIMethod):
                    """
                    Sets the report variables to default.
                    """
                class track_single_particle_stream(TUIMethod):
                    """
                    Specifies the stream ID to be tracked.
                    """
                class arrow_scale(TUIMethod):
                    """
                    Sets the scale factor for arrows drawn on particle tracks.
                    """
                class arrow_space(TUIMethod):
                    """
                    Sets the spacing factor for arrows drawn on particle tracks.
                    """
                class coarsen_factor(TUIMethod):
                    """
                    Sets the coarsening factor for particle tracks.
                    """
                class line_width(TUIMethod):
                    """
                    Sets the width for particle track.
                    """
                class marker_size(TUIMethod):
                    """
                    Sets the size of markers used to represent particle tracks.
                    """
                class radius(TUIMethod):
                    """
                    Sets the radius for particle track (ribbon/cylinder only) cross-section.
                    """
                class style(TUIMethod):
                    """
                    Sets the display style for particle track (line/ribbon/cylinder/sphere).
                    """
                class twist_factor(TUIMethod):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """
                class sphere_attrib(TUIMethod):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                class particle_skip(TUIMethod):
                    """
                    Specifies how many particle tracks should be displayed.
                    """

                class sphere_settings(TUIMenu):
                    """
                    Provide sphere specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self.vary_diameter = self.__class__.vary_diameter(service, version, mode, path + ["vary_diameter"])
                        self.diameter = self.__class__.diameter(service, version, mode, path + ["diameter"])
                        self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        self.smooth_parameter = self.__class__.smooth_parameter(service, version, mode, path + ["smooth_parameter"])
                        self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                        self.size_variable = self.__class__.size_variable(service, version, mode, path + ["size_variable"])
                        super().__init__(service, version, mode, path)
                    class vary_diameter(TUIMethod):
                        """
                        Specifies whether the spheres can vary with another variable.
                        """
                    class diameter(TUIMethod):
                        """
                        Diameter of the spheres whenvary-diameter is disabled.
                        """
                    class auto_range(TUIMethod):
                        """
                        Specifies whether displayed spheres should include auto range of variable to size spheres.
                        """
                    class minimum(TUIMethod):
                        """
                        Sets the minimum value of the sphere to be displayed.
                        """
                    class maximum(TUIMethod):
                        """
                        Sets the maximum value of the sphere to be displayed.
                        """
                    class smooth_parameter(TUIMethod):
                        """
                        Specifies number of slices to be used in drawing spheres.
                        """
                    class scale_factor(TUIMethod):
                        """
                        Specifies a scale factor to enlarge/reduce the size of spheres.
                        """
                    class size_variable(TUIMethod):
                        """
                        Selects a particle variable to size the spheres.
                        """

                class vector_settings(TUIMenu):
                    """
                    Set vector specific input.
                    """
                    def __init__(self, service, version, mode, path):
                        self.style = self.__class__.style(service, version, mode, path + ["style"])
                        self.vector_length = self.__class__.vector_length(service, version, mode, path + ["vector_length"])
                        self.vector_length_variable = self.__class__.vector_length_variable(service, version, mode, path + ["vector_length_variable"])
                        self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                        self.length_variable = self.__class__.length_variable(service, version, mode, path + ["length_variable"])
                        self.length_to_head_ratio = self.__class__.length_to_head_ratio(service, version, mode, path + ["length_to_head_ratio"])
                        self.constant_color = self.__class__.constant_color(service, version, mode, path + ["constant_color"])
                        self.color_variable = self.__class__.color_variable(service, version, mode, path + ["color_variable"])
                        self.vector_variable = self.__class__.vector_variable(service, version, mode, path + ["vector_variable"])
                        super().__init__(service, version, mode, path)
                    class style(TUIMethod):
                        """
                        Enables and sets the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                        """
                    class vector_length(TUIMethod):
                        """
                        Specifies the length of constant vectors.
                        """
                    class vector_length_variable(TUIMethod):
                        """
                        Selects a particle variable to specify the length of vectors.
                        """
                    class scale_factor(TUIMethod):
                        """
                        Specifies a scale factor to enlarge/reduce the length of vectors.
                        """
                    class length_variable(TUIMethod):
                        """
                        Specifies whether the displayed vectors have length varying with another variable.
                        """
                    class length_to_head_ratio(TUIMethod):
                        """
                        Specifies ratio of length to head for vectors and length to diameter for cylinders.
                        """
                    class constant_color(TUIMethod):
                        """
                        Specifies a constant color for the vectors.
                        """
                    class color_variable(TUIMethod):
                        """
                        Specifies whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                        """
                    class vector_variable(TUIMethod):
                        """
                        Selects a particle vector function to specify vector direction.
                        """

                class filter_settings(TUIMenu):
                    """
                    Set filter for particle display.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_filtering = self.__class__.enable_filtering(service, version, mode, path + ["enable_filtering"])
                        self.inside = self.__class__.inside(service, version, mode, path + ["inside"])
                        self.filter_variable = self.__class__.filter_variable(service, version, mode, path + ["filter_variable"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        super().__init__(service, version, mode, path)
                    class enable_filtering(TUIMethod):
                        """
                        Specifies whether particle display is filtered.
                        """
                    class inside(TUIMethod):
                        """
                        Specifies whether filter variable must be inside min/max to be displayed (else outside min/max).
                        """
                    class filter_variable(TUIMethod):
                        """
                        Selects a variable used for filtering of particles.
                        """
                    class minimum(TUIMethod):
                        """
                        Specifies the lower bound for the filter variable.
                        """
                    class maximum(TUIMethod):
                        """
                        Specifies the upper bound for the filter variable.
                        """

            class path_lines(TUIMenu):
                """
                Sets parameters for display of pathlines.
                """
                def __init__(self, service, version, mode, path):
                    self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                    self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                    self.display_steps = self.__class__.display_steps(service, version, mode, path + ["display_steps"])
                    self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                    self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                    self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                    self.maximum_steps = self.__class__.maximum_steps(service, version, mode, path + ["maximum_steps"])
                    self.maximum_error = self.__class__.maximum_error(service, version, mode, path + ["maximum_error"])
                    self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                    self.relative_pathlines = self.__class__.relative_pathlines(service, version, mode, path + ["relative_pathlines"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                    self.step_size = self.__class__.step_size(service, version, mode, path + ["step_size"])
                    self.reverse = self.__class__.reverse(service, version, mode, path + ["reverse"])
                    self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                    self.track_in_phase = self.__class__.track_in_phase(service, version, mode, path + ["track_in_phase"])
                    super().__init__(service, version, mode, path)
                class arrow_scale(TUIMethod):
                    """
                    Sets the scale factor for arrows drawn on pathlines.
                    """
                class arrow_space(TUIMethod):
                    """
                    Sets the spacing factor for arrows drawn on pathlines.
                    """
                class display_steps(TUIMethod):
                    """
                    Sets the display stepping for pathlines.
                    """
                class error_control(TUIMethod):
                    """
                    Sets error control during pathline computation.
                    """
                class line_width(TUIMethod):
                    """
                    Sets the width for pathlines.
                    """
                class marker_size(TUIMethod):
                    """
                    Sets the marker size for particle drawing.
                    """
                class maximum_steps(TUIMethod):
                    """
                    Sets the maximum number of steps to take for pathlines.
                    """
                class maximum_error(TUIMethod):
                    """
                    Sets the maximum error allowed while computing the pathlines.
                    """
                class radius(TUIMethod):
                    """
                    Sets the radius for pathline (ribbons/cylinder only) cross-section.
                    """
                class relative_pathlines(TUIMethod):
                    """
                    Enables/disables the tracking of pathlines in a relative coordinate system.
                    """
                class style(TUIMethod):
                    """
                    Selects the pathline style (line, point, ribbon, triangle, cylinder).
                    """
                class twist_factor(TUIMethod):
                    """
                    Sets the scale factor for twisting (ribbons only).
                    """
                class step_size(TUIMethod):
                    """
                    Sets the step length between particle positions for pathlines.
                    """
                class reverse(TUIMethod):
                    """
                    Sets direction of path tracking.
                    """
                class sphere_attrib(TUIMethod):
                    """
                    Specifies the size and number of slices to be used in drawing spheres.
                    """
                class track_in_phase(TUIMethod):
                    """
                    Selects the phase in which particle pathlines will be computed (Multiphase Eulerian Model only).
                    """

            class rendering_options(TUIMenu):
                """
                Enter the rendering options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                    self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                    self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                    self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                    self.outer_face_cull = self.__class__.outer_face_cull(service, version, mode, path + ["outer_face_cull"])
                    self.surface_edge_visibility = self.__class__.surface_edge_visibility(service, version, mode, path + ["surface_edge_visibility"])
                    self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                    self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                    self.help_text_color = self.__class__.help_text_color(service, version, mode, path + ["help_text_color"])
                    self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                    self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    super().__init__(service, version, mode, path)
                class auto_spin(TUIMethod):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                class device_info(TUIMethod):
                    """
                    List information for the graphics device.
                    """
                class double_buffering(TUIMethod):
                    """
                    Enable/disable double-buffering.
                    """
                class driver(TUIMethod):
                    """
                    Change the current graphics driver.
                    """
                class hidden_surfaces(TUIMethod):
                    """
                    Enable/disable hidden surface removal.
                    """
                class hidden_surface_method(TUIMethod):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                class outer_face_cull(TUIMethod):
                    """
                    Enable/disable discarding outer faces during display.
                    """
                class surface_edge_visibility(TUIMethod):
                    """
                    Set edge visibility flags for surfaces.
                    """
                class animation_option(TUIMethod):
                    """
                    Using Wireframe / All option during animation.
                    """
                class color_map_alignment(TUIMethod):
                    """
                    Set the color bar alignment.
                    """
                class help_text_color(TUIMethod):
                    """
                    Set the color of screen help text.
                    """
                class face_displacement(TUIMethod):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                class set_rendering_options(TUIMethod):
                    """
                    Set the rendering options.
                    """
                class show_colormap(TUIMethod):
                    """
                    Enable/Disable colormap.
                    """

            class titles(TUIMenu):
                """
                Set problem title.
                """
                def __init__(self, service, version, mode, path):
                    self.left_top = self.__class__.left_top(service, version, mode, path + ["left_top"])
                    self.left_bottom = self.__class__.left_bottom(service, version, mode, path + ["left_bottom"])
                    self.right_top = self.__class__.right_top(service, version, mode, path + ["right_top"])
                    self.right_middle = self.__class__.right_middle(service, version, mode, path + ["right_middle"])
                    self.right_bottom = self.__class__.right_bottom(service, version, mode, path + ["right_bottom"])
                    super().__init__(service, version, mode, path)
                class left_top(TUIMethod):
                    """
                    Set the title text for left top in title segment.
                    """
                class left_bottom(TUIMethod):
                    """
                    Set the title text for left bottom in title segment.
                    """
                class right_top(TUIMethod):
                    """
                    Set the title text for right top in title segment.
                    """
                class right_middle(TUIMethod):
                    """
                    Set the title text for right middle in title segment.
                    """
                class right_bottom(TUIMethod):
                    """
                    Set the title text for right bottom in title segment.
                    """

            class velocity_vectors(TUIMenu):
                """
                Enters the menu to set parameters for display of velocity vectors.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                    self.color = self.__class__.color(service, version, mode, path + ["color"])
                    self.component_x = self.__class__.component_x(service, version, mode, path + ["component_x"])
                    self.component_y = self.__class__.component_y(service, version, mode, path + ["component_y"])
                    self.component_z = self.__class__.component_z(service, version, mode, path + ["component_z"])
                    self.constant_length = self.__class__.constant_length(service, version, mode, path + ["constant_length"])
                    self.color_levels = self.__class__.color_levels(service, version, mode, path + ["color_levels"])
                    self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                    self.in_plane = self.__class__.in_plane(service, version, mode, path + ["in_plane"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                    self.relative = self.__class__.relative(service, version, mode, path + ["relative"])
                    self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.scale_head = self.__class__.scale_head(service, version, mode, path + ["scale_head"])
                    self.style = self.__class__.style(service, version, mode, path + ["style"])
                    self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                    super().__init__(service, version, mode, path)
                class auto_scale(TUIMethod):
                    """
                    Auto-scales all vectors so that vector overlap is minimal.
                    """
                class color(TUIMethod):
                    """
                    Sets the color of all velocity vectors to the color specified. The color scale is ignored. This is useful when overlaying a vector plot over a contour plot.
                    """
                class component_x(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class component_y(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class component_z(TUIMethod):
                    """
                    Sets the option to use only the  component of the velocity vectors during display.
                    """
                class constant_length(TUIMethod):
                    """
                    Sets the option to draw velocity vectors of constant length. This shows only the direction of the velocity vectors.
                    """
                class color_levels(TUIMethod):
                    """
                    Sets the number of colors used from the colormap.
                    """
                class global_range(TUIMethod):
                    """
                    Turns global range for vectors on/off.
                    """
                class in_plane(TUIMethod):
                    """
                    Toggles the display of velocity vector components in the plane of the surface selected for display.
                    """
                class log_scale(TUIMethod):
                    """
                    Toggles whether color scale is logarithmic or linear.
                    """
                class node_values(TUIMethod):
                    """
                    Enables/disables the plotting of node values. Cell values will be plotted if "no".
                    """
                class relative(TUIMethod):
                    """
                    Toggles the display of relative velocity vectors.
                    """
                class render_mesh(TUIMethod):
                    """
                    Enables/disables rendering the mesh on top of contours, vectors, and so on.
                    """
                class scale(TUIMethod):
                    """
                    Sets the value by which the vector length will be scaled.
                    """
                class scale_head(TUIMethod):
                    """
                    Sets the value by which the vector head will be scaled.
                    """
                class style(TUIMethod):
                    """
                    Specifies the vector style that will be used when the vectors are displayed. You can choose from:3d arrow,3d arrowhead, cone,filled-arrow, arrow,harpoon, or headless.
                    """
                class surfaces(TUIMethod):
                    """
                    Sets surfaces on which vectors are drawn. You can include a wildcard (\*) within the surface names.
                    """

            class windows(TUIMenu):
                """
                Enter the window options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.aspect_ratio = self.__class__.aspect_ratio(service, version, mode, path + ["aspect_ratio"])
                    self.logo = self.__class__.logo(service, version, mode, path + ["logo"])
                    self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                    self.logo_color = self.__class__.logo_color(service, version, mode, path + ["logo_color"])
                    super().__init__(service, version, mode, path)
                class aspect_ratio(TUIMethod):
                    """
                    Set the aspect ratio of the active window.
                    """
                class logo(TUIMethod):
                    """
                    Enable/disable visibility of the logo in graphics window.
                    """
                class ruler(TUIMethod):
                    """
                    Enable/disable ruler visibility.
                    """
                class logo_color(TUIMethod):
                    """
                    Set logo color to white/black.
                    """

                class axes(TUIMenu):
                    """
                    Enter the axes window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of a border around the axes window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the axes window.
                        """
                    class clear(TUIMethod):
                        """
                        Set the transparency of the axes window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the axes window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable axes visibility.
                        """

                class main(TUIMenu):
                    """
                    Enter the main view window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the main viewing window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the main viewing window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the main viewing window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the main viewing window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the main viewing window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable visibility of the main viewing window.
                        """

                class scale(TUIMenu):
                    """
                    Enter the color scale window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.font_size = self.__class__.font_size(service, version, mode, path + ["font_size"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the color scale window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the color scale window.
                        """
                    class clear(TUIMethod):
                        """
                        Set the transparency of the scale window.
                        """
                    class format(TUIMethod):
                        """
                        Set the number format of the color scale window (e.g. %0.2e).
                        """
                    class font_size(TUIMethod):
                        """
                        Set the font size of the color scale window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the color scale window.
                        """
                    class margin(TUIMethod):
                        """
                        Set the margin of the color scale window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the color scale window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the color scale window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable visibility of the color scale window.
                        """
                    class alignment(TUIMethod):
                        """
                        Set colormap to bottom/left/top/right.
                        """

                class text(TUIMenu):
                    """
                    Enter the text window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.application = self.__class__.application(service, version, mode, path + ["application"])
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.company = self.__class__.company(service, version, mode, path + ["company"])
                        self.date = self.__class__.date(service, version, mode, path + ["date"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class application(TUIMethod):
                        """
                        Enable/disable the application name in the picture.
                        """
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the text window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the text window.
                        """
                    class clear(TUIMethod):
                        """
                        Enable/disable text window transparency.
                        """
                    class company(TUIMethod):
                        """
                        Enable/disable the company name in the picture.
                        """
                    class date(TUIMethod):
                        """
                        Enable/disable the date in the picture.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the text window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the text window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the text window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable text window transparency.
                        """

                class video(TUIMenu):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.background = self.__class__.background(service, version, mode, path + ["background"])
                        self.color_filter = self.__class__.color_filter(service, version, mode, path + ["color_filter"])
                        self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                        self.on = self.__class__.on(service, version, mode, path + ["on"])
                        self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                        super().__init__(service, version, mode, path)
                    class background(TUIMethod):
                        """
                        Set the background color in the video picture.
                        """
                    class color_filter(TUIMethod):
                        """
                        Set the color filter options for the picture.
                        """
                    class foreground(TUIMethod):
                        """
                        Set the foreground color in the video picture.
                        """
                    class on(TUIMethod):
                        """
                        Enable/disable video picture settings.
                        """
                    class pixel_size(TUIMethod):
                        """
                        Set the window size in pixels.
                        """

                class xy(TUIMenu):
                    """
                    Enter the X-Y plot window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of a border around the X-Y plotter window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the X-Y plotter window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the X-Y plotter window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the X-Y plotter window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the X-Y plotter window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable X-Y plotter window visibility.
                        """

        class surface(TUIMenu):
            """
            Enters the data surface-manipulation menu. For a description of the items in this menu, see surface/.
            """
            def __init__(self, service, version, mode, path):
                self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.circle_slice = self.__class__.circle_slice(service, version, mode, path + ["circle_slice"])
                self.delete_surface = self.__class__.delete_surface(service, version, mode, path + ["delete_surface"])
                self.group_surfaces = self.__class__.group_surfaces(service, version, mode, path + ["group_surfaces"])
                self.ungroup_surface = self.__class__.ungroup_surface(service, version, mode, path + ["ungroup_surface"])
                self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
                self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
                self.expression_volume = self.__class__.expression_volume(service, version, mode, path + ["expression_volume"])
                self.multiple_iso_surfaces = self.__class__.multiple_iso_surfaces(service, version, mode, path + ["multiple_iso_surfaces"])
                self.line_slice = self.__class__.line_slice(service, version, mode, path + ["line_slice"])
                self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
                self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                self.mouse_line = self.__class__.mouse_line(service, version, mode, path + ["mouse_line"])
                self.mouse_plane = self.__class__.mouse_plane(service, version, mode, path + ["mouse_plane"])
                self.mouse_rake = self.__class__.mouse_rake(service, version, mode, path + ["mouse_rake"])
                self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
                self.plane = self.__class__.plane(service, version, mode, path + ["plane"])
                self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
                self.multiple_plane_surfaces = self.__class__.multiple_plane_surfaces(service, version, mode, path + ["multiple_plane_surfaces"])
                self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
                self.point_array = self.__class__.point_array(service, version, mode, path + ["point_array"])
                self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
                self.structural_point_surface = self.__class__.structural_point_surface(service, version, mode, path + ["structural_point_surface"])
                self.quadric_slice = self.__class__.quadric_slice(service, version, mode, path + ["quadric_slice"])
                self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
                self.rename_surface = self.__class__.rename_surface(service, version, mode, path + ["rename_surface"])
                self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
                self.ellipsoid_slice = self.__class__.ellipsoid_slice(service, version, mode, path + ["ellipsoid_slice"])
                self.cone_slice = self.__class__.cone_slice(service, version, mode, path + ["cone_slice"])
                self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
                self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
                self.create_imprint_surface = self.__class__.create_imprint_surface(service, version, mode, path + ["create_imprint_surface"])
                self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
                self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
                self.multiple_zone_surfaces = self.__class__.multiple_zone_surfaces(service, version, mode, path + ["multiple_zone_surfaces"])
                self.edit_surface = self.__class__.edit_surface(service, version, mode, path + ["edit_surface"])
                super().__init__(service, version, mode, path)
            class circle_slice(TUIMethod):
                """
                Extract a circular slice.
                """
            class delete_surface(TUIMethod):
                """
                Remove a defined data surface.
                """
            class group_surfaces(TUIMethod):
                """
                Group a set of surfaces.
                """
            class ungroup_surface(TUIMethod):
                """
                Ungroup the surface(if grouped).
                """
            class iso_clip(TUIMethod):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
            class iso_surface(TUIMethod):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
            class expression_volume(TUIMethod):
                """
                Create volume with boolean expression.
                """
            class multiple_iso_surfaces(TUIMethod):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
            class line_slice(TUIMethod):
                """
                Extract a linear slice.
                """
            class line_surface(TUIMethod):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
            class list_surfaces(TUIMethod):
                """
                List the number of facets in the defined surfaces.
                """
            class mouse_line(TUIMethod):
                """
                Define a line surface using the mouse to select two points.
                """
            class mouse_plane(TUIMethod):
                """
                Define a plane surface using the mouse to select three points.
                """
            class mouse_rake(TUIMethod):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
            class partition_surface(TUIMethod):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
            class plane(TUIMethod):
                """
                Create a plane given 3 points bounded by the domain.
                """
            class plane_surface(TUIMethod):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
            class multiple_plane_surfaces(TUIMethod):
                """
                Create multiple plane surfaces at specified spacing.
                """
            class plane_slice(TUIMethod):
                """
                Extract a planar slice.
                """
            class point_array(TUIMethod):
                """
                Extract a rectangular array of data points.
                """
            class point_surface(TUIMethod):
                """
                Define a "point" surface by specifying the coordinates.
                """
            class structural_point_surface(TUIMethod):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
            class quadric_slice(TUIMethod):
                """
                Extract a quadric slice.
                """
            class rake_surface(TUIMethod):
                """
                Define a "rake" surface by specifying the end points.
                """
            class rename_surface(TUIMethod):
                """
                Rename a defined data surface.
                """
            class sphere_slice(TUIMethod):
                """
                Extract a spherical slice.
                """
            class ellipsoid_slice(TUIMethod):
                """
                Extract a ellipsoid slice.
                """
            class cone_slice(TUIMethod):
                """
                Extract a cone slice.
                """
            class surface_cells(TUIMethod):
                """
                Extract all cells intersected by a data surface.
                """
            class transform_surface(TUIMethod):
                """
                Transform surface.
                """
            class create_imprint_surface(TUIMethod):
                """
                Imprint surface.
                """
            class zone_surface(TUIMethod):
                """
                Define a data surface on a mesh zone.
                """
            class reset_zone_surfaces(TUIMethod):
                """
                Reset case surface list.
                """
            class multiple_zone_surfaces(TUIMethod):
                """
                Create multiple data surfaces at a time.
                """
            class edit_surface(TUIMethod):
                """
                Edit a defined data surface.
                """

            class post_processing_volume(TUIMenu):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create_from_file = self.__class__.create_from_file(service, version, mode, path + ["create_from_file"])
                    self.create_octree = self.__class__.create_octree(service, version, mode, path + ["create_octree"])
                    super().__init__(service, version, mode, path)
                class create_from_file(TUIMethod):
                    """
                    Read post-processing mesh from file.
                    """
                class create_octree(TUIMethod):
                    """
                    Create post-processing octree mesh based on current case.
                    """

            class query(TUIMenu):
                """
                Enter surface query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                    self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                    self.named_surface_list = self.__class__.named_surface_list(service, version, mode, path + ["named_surface_list"])
                    self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                    self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                    super().__init__(service, version, mode, path)
                class delete_query(TUIMethod):
                    """
                    Delete saved query.
                    """
                class list_surfaces(TUIMethod):
                    """
                    List surfaces.
                    """
                class named_surface_list(TUIMethod):
                    """
                    Create named list of surfaces.
                    """
                class list_named_selection(TUIMethod):
                    """
                    List named selection of surface type.
                    """
                class list_queries(TUIMethod):
                    """
                    List all saved queries.
                    """

        class views(TUIMenu):
            """
            Enter the view manipulation menu.
            """
            def __init__(self, service, version, mode, path):
                self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
                self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
                self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
                self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
                self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
                self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
                self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
                self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
                self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
                super().__init__(service, version, mode, path)
            class auto_scale(TUIMethod):
                """
                Scale and center the current scene.
                """
            class default_view(TUIMethod):
                """
                Reset view to front and center.
                """
            class delete_view(TUIMethod):
                """
                Remove a view from the list.
                """
            class last_view(TUIMethod):
                """
                Return to the camera position before the last manipulation.
                """
            class next_view(TUIMethod):
                """
                Return to the camera position after the current position in the stack.
                """
            class list_views(TUIMethod):
                """
                List predefined and saved views.
                """
            class restore_view(TUIMethod):
                """
                Use a saved view.
                """
            class read_views(TUIMethod):
                """
                Read views from a view file.
                """
            class save_view(TUIMethod):
                """
                Save the current view to the view list.
                """
            class write_views(TUIMethod):
                """
                Write selected views to a view file.
                """

            class camera(TUIMenu):
                """
                Enter the camera menu to modify the current viewing parameters.
                """
                def __init__(self, service, version, mode, path):
                    self.dolly_camera = self.__class__.dolly_camera(service, version, mode, path + ["dolly_camera"])
                    self.field = self.__class__.field(service, version, mode, path + ["field"])
                    self.orbit_camera = self.__class__.orbit_camera(service, version, mode, path + ["orbit_camera"])
                    self.pan_camera = self.__class__.pan_camera(service, version, mode, path + ["pan_camera"])
                    self.position = self.__class__.position(service, version, mode, path + ["position"])
                    self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                    self.roll_camera = self.__class__.roll_camera(service, version, mode, path + ["roll_camera"])
                    self.target = self.__class__.target(service, version, mode, path + ["target"])
                    self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                    self.zoom_camera = self.__class__.zoom_camera(service, version, mode, path + ["zoom_camera"])
                    super().__init__(service, version, mode, path)
                class dolly_camera(TUIMethod):
                    """
                    Adjust the camera position and target.
                    """
                class field(TUIMethod):
                    """
                    Set the field of view (width and height).
                    """
                class orbit_camera(TUIMethod):
                    """
                    Adjust the camera position without modifying the target.
                    """
                class pan_camera(TUIMethod):
                    """
                    Adjust the camera target without modifying the position.
                    """
                class position(TUIMethod):
                    """
                    Set the camera position.
                    """
                class projection(TUIMethod):
                    """
                    Set the camera projection type.
                    """
                class roll_camera(TUIMethod):
                    """
                    Adjust the camera up-vector.
                    """
                class target(TUIMethod):
                    """
                    Set the point to be the center of the camera view.
                    """
                class up_vector(TUIMethod):
                    """
                    Set the camera up-vector.
                    """
                class zoom_camera(TUIMethod):
                    """
                    Adjust the camera field of view.
                    """

        class display_states(TUIMenu):
            """
            Enter the display state manipulation menu.
            """
            def __init__(self, service, version, mode, path):
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.apply = self.__class__.apply(service, version, mode, path + ["apply"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.read = self.__class__.read(service, version, mode, path + ["read"])
                self.write = self.__class__.write(service, version, mode, path + ["write"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                super().__init__(service, version, mode, path)
            class list(TUIMethod):
                """
                Print the names of the available display states to the console.
                """
            class apply(TUIMethod):
                """
                Apply a display state to the active window.
                """
            class delete(TUIMethod):
                """
                Delete a display state.
                """
            class use_active(TUIMethod):
                """
                Update an existing display state's settings to match those of the active graphics window.
                """
            class copy(TUIMethod):
                """
                Create a new display state with settings copied from an existing display state.
                """
            class read(TUIMethod):
                """
                Read display states from a file.
                """
            class write(TUIMethod):
                """
                Write display states to a file.
                """
            class edit(TUIMethod):
                """
                Edit a particular display state setting.
                """
            class create(TUIMethod):
                """
                Create a new display state.
                """

        class view_sync(TUIMenu):
            """
            Synchronize window views.
            """
            def __init__(self, service, version, mode, path):
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.start = self.__class__.start(service, version, mode, path + ["start"])
                self.stop = self.__class__.stop(service, version, mode, path + ["stop"])
                self.remove_all = self.__class__.remove_all(service, version, mode, path + ["remove_all"])
                self.add_all = self.__class__.add_all(service, version, mode, path + ["add_all"])
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.remove = self.__class__.remove(service, version, mode, path + ["remove"])
                super().__init__(service, version, mode, path)
            class list(TUIMethod):
                """
                Print window ids of open windows.
                """
            class start(TUIMethod):
                """
                Start view synchronization.
                """
            class stop(TUIMethod):
                """
                Stop view synchronization.
                """
            class remove_all(TUIMethod):
                """
                Unsynchronize all windows.
                """
            class add_all(TUIMethod):
                """
                Synchronize all windows.
                """
            class add(TUIMethod):
                """
                Add list of window ids for synchronization.
                """
            class remove(TUIMethod):
                """
                Remove list of window ids from synchronization.
                """

        class update_scene(TUIMenu):
            """
            Enter the scene options menu.
            """
            def __init__(self, service, version, mode, path):
                self.select_geometry = self.__class__.select_geometry(service, version, mode, path + ["select_geometry"])
                self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                self.draw_frame = self.__class__.draw_frame(service, version, mode, path + ["draw_frame"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.transform = self.__class__.transform(service, version, mode, path + ["transform"])
                self.pathline = self.__class__.pathline(service, version, mode, path + ["pathline"])
                self.iso_sweep = self.__class__.iso_sweep(service, version, mode, path + ["iso_sweep"])
                self.time = self.__class__.time(service, version, mode, path + ["time"])
                self.set_frame = self.__class__.set_frame(service, version, mode, path + ["set_frame"])
                super().__init__(service, version, mode, path)
            class select_geometry(TUIMethod):
                """
                Select geometry to be updated.
                """
            class overlays(TUIMethod):
                """
                Enable/disable the overlays option.
                """
            class draw_frame(TUIMethod):
                """
                Enable/disable drawing of the bounding frame.
                """
            class delete(TUIMethod):
                """
                Delete selected geometries.
                """
            class display(TUIMethod):
                """
                Display selected geometries.
                """
            class transform(TUIMethod):
                """
                Apply transformation matrix on selected geometries.
                """
            class pathline(TUIMethod):
                """
                Change pathline attributes.
                """
            class iso_sweep(TUIMethod):
                """
                Change iso-sweep values.
                """
            class time(TUIMethod):
                """
                Change time-step value.
                """
            class set_frame(TUIMethod):
                """
                Change frame options.
                """

        class inverse_dft(TUIMenu):
            """
            Reconstruct DFT signal.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.reconstruct = self.__class__.reconstruct(service, version, mode, path + ["reconstruct"])
                super().__init__(service, version, mode, path)
            class set(TUIMethod):
                """
                Set reconstruction parameters.
                """
            class reconstruct(TUIMethod):
                """
                Make inverse DFT recontruction.
                """

    class define(TUIMenu):
        """
        Enter the define menu.
        """
        def __init__(self, service, version, mode, path):
            self.boundary_conditions = self.__class__.boundary_conditions(service, version, mode, path + ["boundary_conditions"])
            self.spectral = self.__class__.spectral(service, version, mode, path + ["spectral"])
            self.custom_field_functions = self.__class__.custom_field_functions(service, version, mode, path + ["custom_field_functions"])
            self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
            self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
            self.gap_model = self.__class__.gap_model(service, version, mode, path + ["gap_model"])
            self.materials = self.__class__.materials(service, version, mode, path + ["materials"])
            self.mixing_planes = self.__class__.mixing_planes(service, version, mode, path + ["mixing_planes"])
            self.models = self.__class__.models(service, version, mode, path + ["models"])
            self.overset_interfaces = self.__class__.overset_interfaces(service, version, mode, path + ["overset_interfaces"])
            self.operating_conditions = self.__class__.operating_conditions(service, version, mode, path + ["operating_conditions"])
            self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
            self.periodic_conditions = self.__class__.periodic_conditions(service, version, mode, path + ["periodic_conditions"])
            self.turbo_model = self.__class__.turbo_model(service, version, mode, path + ["turbo_model"])
            self.phases = self.__class__.phases(service, version, mode, path + ["phases"])
            self.profiles = self.__class__.profiles(service, version, mode, path + ["profiles"])
            self.solution_strategy = self.__class__.solution_strategy(service, version, mode, path + ["solution_strategy"])
            self.reference_frames = self.__class__.reference_frames(service, version, mode, path + ["reference_frames"])
            self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
            self.named_expressions = self.__class__.named_expressions(service, version, mode, path + ["named_expressions"])
            self.virtual_boundary = self.__class__.virtual_boundary(service, version, mode, path + ["virtual_boundary"])
            self.curvilinear_coordinate_system = self.__class__.curvilinear_coordinate_system(service, version, mode, path + ["curvilinear_coordinate_system"])
            self.beta_feature_access = self.__class__.beta_feature_access(service, version, mode, path + ["beta_feature_access"])
            self.physics = self.__class__.physics(service, version, mode, path + ["physics"])
            self.injections = self.__class__.injections(service, version, mode, path + ["injections"])
            self.enable_mesh_morpher_optimizer = self.__class__.enable_mesh_morpher_optimizer(service, version, mode, path + ["enable_mesh_morpher_optimizer"])
            self.units = self.__class__.units(service, version, mode, path + ["units"])
            self.set_unit_system = self.__class__.set_unit_system(service, version, mode, path + ["set_unit_system"])
            super().__init__(service, version, mode, path)
        class beta_feature_access(TUIMethod):
            """
            Enable access to beta features in the interface.
            """
        class physics(TUIMethod):
            """
            Manage Physics-regions.
            """
        class injections(TUIMethod):
            """
            Enters the injections menu.  For a description of the items in this menu, see define/models/dpm/injections.
            """
        class enable_mesh_morpher_optimizer(TUIMethod):
            """
            Enables the mesh morpher/optimizer. When the mesh morpher/optimizer is enabled, the define/mesh-morpher-optimizer text command becomes available.
            """
        class units(TUIMethod):
            """
            Sets unit conversion factors.
            """
        class set_unit_system(TUIMethod):
            """
            Applies a standard set of units to all quantities. The options include default,si, british, andcgs.
            """

        class boundary_conditions(TUIMenu):
            """
            Enters the boundary conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.modify_zones = self.__class__.modify_zones(service, version, mode, path + ["modify_zones"])
                self.non_reflecting_bc = self.__class__.non_reflecting_bc(service, version, mode, path + ["non_reflecting_bc"])
                self.rename_zone = self.__class__.rename_zone(service, version, mode, path + ["rename_zone"])
                self.bc_settings = self.__class__.bc_settings(service, version, mode, path + ["bc_settings"])
                self.perforated_walls = self.__class__.perforated_walls(service, version, mode, path + ["perforated_walls"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.impedance_data_fitting = self.__class__.impedance_data_fitting(service, version, mode, path + ["impedance_data_fitting"])
                self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                self.copy_bc = self.__class__.copy_bc(service, version, mode, path + ["copy_bc"])
                self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                self.network = self.__class__.network(service, version, mode, path + ["network"])
                self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                self.openchannel_threads = self.__class__.openchannel_threads(service, version, mode, path + ["openchannel_threads"])
                self.open_channel_wave_settings = self.__class__.open_channel_wave_settings(service, version, mode, path + ["open_channel_wave_settings"])
                self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                self.target_mass_flow_rate_settings = self.__class__.target_mass_flow_rate_settings(service, version, mode, path + ["target_mass_flow_rate_settings"])
                self.non_overlapping_zone_name = self.__class__.non_overlapping_zone_name(service, version, mode, path + ["non_overlapping_zone_name"])
                self.knudsen_number_calculator = self.__class__.knudsen_number_calculator(service, version, mode, path + ["knudsen_number_calculator"])
                super().__init__(service, version, mode, path)
            class axis(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class copy_bc(TUIMethod):
                """
                Copies boundary conditions to other zones.
                """
            class degassing(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class exhaust_fan(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class fan(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class fluid(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class geometry(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class inlet_vent(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class intake_fan(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class interface(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class interior(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class list_zones(TUIMethod):
                """
                Prints out the types and IDs of all zones in the console window. You can use your mouse to check a zone ID, following the instructions listed under Zone in the
                Boundary Conditions Task Page
                section of the User’s Guide.
                """
            class mass_flow_inlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class mass_flow_outlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class network(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class network_end(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class openchannel_threads(TUIMethod):
                """
                Lists open channel group IDs, names, types and variables.
                """
            class open_channel_wave_settings(TUIMethod):
                """
                Opens channel wave input analysis.
                """
            class outflow(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class outlet_vent(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class overset(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class periodic(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class porous_jump(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class pressure_far_field(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class pressure_inlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class pressure_outlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class radiator(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class rans_les_interface(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class recirculation_inlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class recirculation_outlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class shadow(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class solid(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class symmetry(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class velocity_inlet(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class wall(TUIMethod):
                """
                Sets boundary conditions for a zone of this type.
                """
            class zone_name(TUIMethod):
                """
                Gives a zone a new name.
                """
            class zone_type(TUIMethod):
                """
                Sets the type for a zone or multiple zones of the same category. You will be prompted for the name / ID of the zone to be changed and the new type for that zone. To change multiple zones, you can enter a list (separated by spaces and contained within a pair of parentheses) or use asterisks (\*) as wildcards.
                """
            class target_mass_flow_rate_settings(TUIMethod):
                """
                Enters the targeted mass flow rate settings menu.
                """
            class non_overlapping_zone_name(TUIMethod):
                """
                Displays the name of the non-overlapping zone associated with a specified interface zone. This text command is only available after a mesh interface has been created.
                """
            class knudsen_number_calculator(TUIMethod):
                """
                Computes the Knudsen number based on a characteristic physical length and the area-averaged flow quantities along an incoming-flow boundary. You can use this information to determine flow regime for selecting the appropriate wall boundary treatment. For details, see .
                """

            class advanced(TUIMenu):
                """
                Control settings while doing BC setup.
                """
                def __init__(self, service, version, mode, path):
                    self.delay_model_change_update = self.__class__.delay_model_change_update(service, version, mode, path + ["delay_model_change_update"])
                    self.batch_thread_update = self.__class__.batch_thread_update(service, version, mode, path + ["batch_thread_update"])
                    super().__init__(service, version, mode, path)
                class delay_model_change_update(TUIMethod):
                    """
                    Set model change call update.
                    """
                class batch_thread_update(TUIMethod):
                    """
                    Set batch thread update option.
                    """

            class modify_zones(TUIMenu):
                """
                Enters the modify zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self.activate_cell_zone = self.__class__.activate_cell_zone(service, version, mode, path + ["activate_cell_zone"])
                    self.append_mesh = self.__class__.append_mesh(service, version, mode, path + ["append_mesh"])
                    self.append_mesh_data = self.__class__.append_mesh_data(service, version, mode, path + ["append_mesh_data"])
                    self.copy_move_cell_zone = self.__class__.copy_move_cell_zone(service, version, mode, path + ["copy_move_cell_zone"])
                    self.create_all_shell_threads = self.__class__.create_all_shell_threads(service, version, mode, path + ["create_all_shell_threads"])
                    self.deactivate_cell_zone = self.__class__.deactivate_cell_zone(service, version, mode, path + ["deactivate_cell_zone"])
                    self.recreate_all_shells = self.__class__.recreate_all_shells(service, version, mode, path + ["recreate_all_shells"])
                    self.delete_all_shells = self.__class__.delete_all_shells(service, version, mode, path + ["delete_all_shells"])
                    self.delete_cell_zone = self.__class__.delete_cell_zone(service, version, mode, path + ["delete_cell_zone"])
                    self.extrude_face_zone_delta = self.__class__.extrude_face_zone_delta(service, version, mode, path + ["extrude_face_zone_delta"])
                    self.extrude_face_zone_para = self.__class__.extrude_face_zone_para(service, version, mode, path + ["extrude_face_zone_para"])
                    self.fuse_face_zones = self.__class__.fuse_face_zones(service, version, mode, path + ["fuse_face_zones"])
                    self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                    self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                    self.create_periodic_interface = self.__class__.create_periodic_interface(service, version, mode, path + ["create_periodic_interface"])
                    self.scale_zone = self.__class__.scale_zone(service, version, mode, path + ["scale_zone"])
                    self.rotate_zone = self.__class__.rotate_zone(service, version, mode, path + ["rotate_zone"])
                    self.translate_zone = self.__class__.translate_zone(service, version, mode, path + ["translate_zone"])
                    self.matching_tolerance = self.__class__.matching_tolerance(service, version, mode, path + ["matching_tolerance"])
                    self.merge_zones = self.__class__.merge_zones(service, version, mode, path + ["merge_zones"])
                    self.mrf_to_sliding_mesh = self.__class__.mrf_to_sliding_mesh(service, version, mode, path + ["mrf_to_sliding_mesh"])
                    self.convert_all_solid_mrf_to_solid_motion = self.__class__.convert_all_solid_mrf_to_solid_motion(service, version, mode, path + ["convert_all_solid_mrf_to_solid_motion"])
                    self.orient_face_zone = self.__class__.orient_face_zone(service, version, mode, path + ["orient_face_zone"])
                    self.replace_zone = self.__class__.replace_zone(service, version, mode, path + ["replace_zone"])
                    self.sep_cell_zone_mark = self.__class__.sep_cell_zone_mark(service, version, mode, path + ["sep_cell_zone_mark"])
                    self.sep_cell_zone_region = self.__class__.sep_cell_zone_region(service, version, mode, path + ["sep_cell_zone_region"])
                    self.sep_face_zone_angle = self.__class__.sep_face_zone_angle(service, version, mode, path + ["sep_face_zone_angle"])
                    self.sep_face_zone_face = self.__class__.sep_face_zone_face(service, version, mode, path + ["sep_face_zone_face"])
                    self.sep_face_zone_mark = self.__class__.sep_face_zone_mark(service, version, mode, path + ["sep_face_zone_mark"])
                    self.sep_face_zone_region = self.__class__.sep_face_zone_region(service, version, mode, path + ["sep_face_zone_region"])
                    self.slit_periodic = self.__class__.slit_periodic(service, version, mode, path + ["slit_periodic"])
                    self.slit_face_zone = self.__class__.slit_face_zone(service, version, mode, path + ["slit_face_zone"])
                    self.slit_interior_between_diff_solids = self.__class__.slit_interior_between_diff_solids(service, version, mode, path + ["slit_interior_between_diff_solids"])
                    self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                    self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                    self.copy_mrf_to_mesh_motion = self.__class__.copy_mrf_to_mesh_motion(service, version, mode, path + ["copy_mrf_to_mesh_motion"])
                    self.copy_mesh_to_mrf_motion = self.__class__.copy_mesh_to_mrf_motion(service, version, mode, path + ["copy_mesh_to_mrf_motion"])
                    self.change_zone_state = self.__class__.change_zone_state(service, version, mode, path + ["change_zone_state"])
                    self.change_zone_phase = self.__class__.change_zone_phase(service, version, mode, path + ["change_zone_phase"])
                    super().__init__(service, version, mode, path)
                class activate_cell_zone(TUIMethod):
                    """
                    Activates cell thread.
                    """
                class append_mesh(TUIMethod):
                    """
                    Appends new mesh.
                    """
                class append_mesh_data(TUIMethod):
                    """
                    Appends new mesh with data.
                    """
                class copy_move_cell_zone(TUIMethod):
                    """
                    Creates a copy of a cell zone that is offset from the original either by a translational 	distance or a rotational angle. In the copied zone, the 	bounding face zones are all converted to walls, any 	existing cell data is initialized to a constant value, 	and non-conformal interfaces and dynamic zones are not 	copied; otherwise, the model settings are the same as in 	the original zone. Note that if you want the copied zone 	to be connected to existing zones, you must either fuse 	the boundaries (see ) or set up a 	non-conformal interface (see ).
                    """
                class create_all_shell_threads(TUIMethod):
                    """
                    Marks all finite thickness walls for shell creation. Shell zones will be created at 	the start of the iterations.
                    """
                class deactivate_cell_zone(TUIMethod):
                    """
                    Deactivates cell thread.
                    """
                class recreate_all_shells(TUIMethod):
                    """
                    Recreates shells on all the walls that were deleted using the command delete-all-shells.
                    """
                class delete_all_shells(TUIMethod):
                    """
                    Deletes all shell zones and switches off shell conduction on all the walls. These 	zones can be recreated using the command recreate-all-shells.
                    """
                class delete_cell_zone(TUIMethod):
                    """
                    Deletes a cell thread.
                    """
                class extrude_face_zone_delta(TUIMethod):
                    """
                    Extrudes a face thread a specified distance based on a list of deltas.
                    """
                class extrude_face_zone_para(TUIMethod):
                    """
                    Extrudes a face thread a specified distance based on a distance and a list of 	parametric locations between 0 and 1, for example, 0 0.2 	0.4 0.8 1.0.
                    """
                class fuse_face_zones(TUIMethod):
                    """
                    Attempts to fuse zones by removing duplicate faces and nodes.
                    """
                class list_zones(TUIMethod):
                    """
                    Lists zone IDs, types, kinds, and names.
                    """
                class make_periodic(TUIMethod):
                    """
                    Attempts to establish periodic/shadow face zone connectivity.
                    """
                class create_periodic_interface(TUIMethod):
                    """
                    Creates a conformal or non-conformal periodic 	interface.
                    """
                class scale_zone(TUIMethod):
                    """
                    Scales individual cell zones.
                    """
                class rotate_zone(TUIMethod):
                    """
                    Rotates individual cell zones.
                    """
                class translate_zone(TUIMethod):
                    """
                    Translates individual cell zones.
                    """
                class matching_tolerance(TUIMethod):
                    """
                    Sets normalized tolerance used for finding coincident nodes.
                    """
                class merge_zones(TUIMethod):
                    """
                    Merges zones of same type and condition into one.
                    """
                class mrf_to_sliding_mesh(TUIMethod):
                    """
                    Changes the motion specification from MRF to moving mesh.
                    """
                class convert_all_solid_mrf_to_solid_motion(TUIMethod):
                    """
                    Converts all solid zones using frame motion to instead 	use solid motion, copying the motion variable values for 	origin, axis, and velocities.
                    """
                class orient_face_zone(TUIMethod):
                    """
                    Orients the face zone.
                    """
                class replace_zone(TUIMethod):
                    """
                    Replaces cell zone.
                    """
                class sep_cell_zone_mark(TUIMethod):
                    """
                    Separates cell zone based on cell marking.
                    """
                class sep_cell_zone_region(TUIMethod):
                    """
                    Separates cell zone based on contiguous regions.
                    """
                class sep_face_zone_angle(TUIMethod):
                    """
                    Separates face zone based on significant angle.
                    """
                class sep_face_zone_face(TUIMethod):
                    """
                    Separates each face in zone into unique zone.
                    """
                class sep_face_zone_mark(TUIMethod):
                    """
                    Separates face zone based on cell marking.
                    """
                class sep_face_zone_region(TUIMethod):
                    """
                    Separates face zone based on contiguous regions.
                    """
                class slit_periodic(TUIMethod):
                    """
                    Slits periodic zone into two symmetry zones.
                    """
                class slit_face_zone(TUIMethod):
                    """
                    Slits two-sided wall into two connected wall zones.
                    """
                class slit_interior_between_diff_solids(TUIMethod):
                    """
                    Slits the interior zone between solid zones of differing materials to create a 	coupled wall. You will generally be prompted by Fluent 	if this is necessary.
                    """
                class zone_name(TUIMethod):
                    """
                    Gives a zone a new name.
                    """
                class zone_type(TUIMethod):
                    """
                    Sets the type for a zone or multiple zones of the same 	category. You will be prompted for the name / ID of the 	zone to be changed and the new type for that zone. To 	change multiple zones, you can enter a list (separated 	by spaces and contained within a pair of parentheses) or 	use asterisks (\*) as wildcards.
                    """
                class copy_mrf_to_mesh_motion(TUIMethod):
                    """
                    Copies motion variable values for origin, axis, and velocities from Frame Motion to 	Mesh Motion.
                    """
                class copy_mesh_to_mrf_motion(TUIMethod):
                    """
                    Copies motion variable values for origin, axis, and velocities from Mesh Motion to 	Frame Motion.
                    """
                class change_zone_state(TUIMethod):
                    """
                    Sets the state (liquid or vapor) for a specific fluid zone.
                    """
                class change_zone_phase(TUIMethod):
                    """
                    Change the realgas phase for a zone.
                    """

            class non_reflecting_bc(TUIMenu):
                """
                Enters the non-reflecting boundary condition menu.
                """
                def __init__(self, service, version, mode, path):
                    self.general_nrbc = self.__class__.general_nrbc(service, version, mode, path + ["general_nrbc"])
                    self.turbo_specific_nrbc = self.__class__.turbo_specific_nrbc(service, version, mode, path + ["turbo_specific_nrbc"])
                    super().__init__(service, version, mode, path)

                class general_nrbc(TUIMenu):
                    """
                    Setting for general non-reflecting b.c.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        super().__init__(service, version, mode, path)

                    class set(TUIMenu):
                        """
                        Enters the setup menu for general non-reflecting b.c.’s.
                        """
                        def __init__(self, service, version, mode, path):
                            self.sigma = self.__class__.sigma(service, version, mode, path + ["sigma"])
                            self.sigma2 = self.__class__.sigma2(service, version, mode, path + ["sigma2"])
                            self.relax = self.__class__.relax(service, version, mode, path + ["relax"])
                            self.tangential_source = self.__class__.tangential_source(service, version, mode, path + ["tangential_source"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class sigma(TUIMethod):
                            """
                            Sets NRBC sigma factor (default value 0.15).
                            """
                        class sigma2(TUIMethod):
                            """
                            Sets NRBC sigma2 factor (default value 5.0).
                            """
                        class relax(TUIMethod):
                            """
                            Set NRBC relaxation factor (default value 0.5).
                            """
                        class tangential_source(TUIMethod):
                            """
                            Include or not NRBC tangential source (default value #t).
                            """
                        class verbosity(TUIMethod):
                            """
                            Enables/disables nrbc verbosity scheme output.
                            """

                class turbo_specific_nrbc(TUIMenu):
                    """
                    Enters the turbo specific nrbc menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
                        self.show_status = self.__class__.show_status(service, version, mode, path + ["show_status"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables non-reflecting b.c.’s.
                        """
                    class initialize(TUIMethod):
                        """
                        Initializes non-reflecting b.c.’s.
                        """
                    class show_status(TUIMethod):
                        """
                        Shows current status of non-reflecting b.c.’s.
                        """

                    class set(TUIMenu):
                        """
                        Enters the set menu for non-reflecting b.c. parameters.
                        """
                        def __init__(self, service, version, mode, path):
                            self.discretization = self.__class__.discretization(service, version, mode, path + ["discretization"])
                            self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class discretization(TUIMethod):
                            """
                            Enables use of higher-order reconstruction at boundaries if available.
                            """
                        class under_relaxation(TUIMethod):
                            """
                            Sets non-reflecting b.c. under-relaxation factor.
                            """
                        class verbosity(TUIMethod):
                            """
                            Sets non-reflecting b.c. verbosity level. 0 : silent, 1 : basic information (default), 2 : detailed information for debugging.
                            """

            class rename_zone(TUIMenu):
                """
                Enter the menu for renaming cell and face zones based on adjacency, adding suffixes or prefixes to names, and renaming zones based on the Fluent naming conventions.
                """
                def __init__(self, service, version, mode, path):
                    self.rename_by_adjacency = self.__class__.rename_by_adjacency(service, version, mode, path + ["rename_by_adjacency"])
                    self.rename_to_default = self.__class__.rename_to_default(service, version, mode, path + ["rename_to_default"])
                    self.add_suffix_or_prefix = self.__class__.add_suffix_or_prefix(service, version, mode, path + ["add_suffix_or_prefix"])
                    super().__init__(service, version, mode, path)
                class rename_by_adjacency(TUIMethod):
                    """
                    Append the name of the adjacent cell zone to the 	specified face zone. For example, if fluid is the adjacent cell 	zone, and you select a face zone named interior, the resulting name of 	the face zone would be interior-fluid.
                    """
                class rename_to_default(TUIMethod):
                    """
                    Rename a zone to use the Fluent naming 	convention.
                    """
                class add_suffix_or_prefix(TUIMethod):
                    """
                    Add a suffix or prefix to one or more zones.
                    """

            class bc_settings(TUIMenu):
                """
                Enters the boundary conditions settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    super().__init__(service, version, mode, path)
                class mass_flow(TUIMethod):
                    """
                    Selects method for setting the mass flow rate.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Sets advanced options for pressure outlet boundaries.
                    """

                class pressure_far_field(TUIMenu):
                    """
                    Sets advanced options for pressure far field 	boundaries.
                    """
                    def __init__(self, service, version, mode, path):
                        self.riemann_invariants_tangency_correction = self.__class__.riemann_invariants_tangency_correction(service, version, mode, path + ["riemann_invariants_tangency_correction"])
                        self.type = self.__class__.type(service, version, mode, path + ["type?"])
                        super().__init__(service, version, mode, path)
                    class riemann_invariants_tangency_correction(TUIMethod):
                        """
                        Enables/disables the Riemann-invariant tangency correction as described in .
                        """
                    class type(TUIMethod):
                        """
                        Choose pressure-far-field boundary-condition type.
                        """

            class perforated_walls(TUIMenu):
                """
                Enters the perforated walls menu.
                """
                def __init__(self, service, version, mode, path):
                    self.read_input_file = self.__class__.read_input_file(service, version, mode, path + ["read_input_file"])
                    self.model_setup = self.__class__.model_setup(service, version, mode, path + ["model_setup"])
                    super().__init__(service, version, mode, path)
                class read_input_file(TUIMethod):
                    """
                    Reads an input file for perforated walls.
                    """
                class model_setup(TUIMethod):
                    """
                    Sets up the perforated wall model for each effusion 	surface.
                    """

            class set(TUIMenu):
                """
                Allows you to define one or more settings at single or multiple boundaries/cell zones of a given type at once. Enter q to exit the define/boundary-conditions/set/<type> command.  For a description of the items in this menu, see corresponding define/boundary-conditions/<type>.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class interface(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class interior(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class network(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class overset(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class solid(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class wall(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """

            class impedance_data_fitting(TUIMenu):
                """
                Enters the impedance data fitting menu, which provides text commands that can be helpful when you are using the impedance boundary condition (IBC).
                """
                def __init__(self, service, version, mode, path):
                    self.impedance_data = self.__class__.impedance_data(service, version, mode, path + ["impedance_data"])
                    self.reflection_data = self.__class__.reflection_data(service, version, mode, path + ["reflection_data"])
                    self.absorption_data = self.__class__.absorption_data(service, version, mode, path + ["absorption_data"])
                    self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                    self.convergence_tolerance = self.__class__.convergence_tolerance(service, version, mode, path + ["convergence_tolerance"])
                    self.residue_tolerance = self.__class__.residue_tolerance(service, version, mode, path + ["residue_tolerance"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.import_parameters = self.__class__.import_parameters(service, version, mode, path + ["import_parameters"])
                    super().__init__(service, version, mode, path)
                class impedance_data(TUIMethod):
                    """
                    Reads an input file with experimental specific 	impedance data in the frequency domain and then computes 	the terms needed for an approximation of the reflection 	coefficient as a series of poles / residues in the time 	domain. The resulting terms are printed in the console, 	and can be written to a pole / residue file (which can 	be imported and the impedance parameters applied to a 	boundary condition using the define/boundary-conditions/impedance-data-fitting/import-parameters 	text command). You can also write a file with fitted 	frequency / impedance data, which can be compared to the 	input data to evaluate how well it fits.
                    """
                class reflection_data(TUIMethod):
                    """
                    Reads an input file with experimental reflection coefficient data in the frequency 	domain and then computes the terms needed for an 	approximation of the reflection coefficient as a series 	of poles / residues in the time domain. The resulting 	terms are printed in the console, and can be written to 	a pole / residue file (which can be imported and the 	impedance parameters applied to a boundary condition 	using the define/boundary-conditions/impedance-data-fitting/import-parameters 	text command). You can also write a file with fitted 	frequency / impedance data, which can be compared to the 	input data to evaluate how well it fits.
                    """
                class absorption_data(TUIMethod):
                    """
                    Reads an input file with experimental absorption coefficient data in the frequency 	domain and then computes the terms needed for an 	approximation of the reflection coefficient as a series 	of poles / residues in the time domain. The resulting 	terms are printed in the console, and can be written to 	a pole / residue file (which can be imported and the 	impedance parameters applied to a boundary condition 	using the define/boundary-conditions/impedance-data-fitting/import-parameters 	text command). You can also write a file with fitted 	frequency / impedance data, which can be compared to the 	input data to evaluate how well it fits.
                    """
                class iterations(TUIMethod):
                    """
                    Sets the number of internal iterations used for the calculations performed from the define/boundary-conditions/impedance-data-fitting/ 	text command menu. By default, the number of iterations 	is set to 20.
                    """
                class convergence_tolerance(TUIMethod):
                    """
                    Sets the convergence tolerance, which is an accuracy 	that is used for completing the iterative fitting 	procedure in the calculations performed from the define/boundary-conditions/impedance-data-fitting/ 	text command menu. By default, the tolerance is set to 	1e-6.
                    """
                class residue_tolerance(TUIMethod):
                    """
                    Sets the residue tolerance, which is the minimum value of residues that are kept in 	the fitting performed from the define/boundary-conditions/impedance-data-fitting/ 	text command menu. This residue check helps to eliminate 	parasitic poles. By default, the tolerance is set to 	1e-6.
                    """
                class verbosity(TUIMethod):
                    """
                    Sets the verbosity of the progress messages during the fitting performed from the define/boundary-conditions/impedance-data-fitting/ 	text command menu. Setting this to 1 results in messages being 	printed in the console as the fitting calculation 	progresses. The default value of 0 suppresses this 	output.
                    """
                class import_parameters(TUIMethod):
                    """
                    Reads a pole / residue file with impedance parameters 	in the time domain and applies them to a specified 	boundary condition.
                    """

        class spectral(TUIMenu):
            """
            Enter the Spectral menu.
            """
            def __init__(self, service, version, mode, path):
                self.calculate_fourier_coefficients = self.__class__.calculate_fourier_coefficients(service, version, mode, path + ["calculate_fourier_coefficients"])
                self.delete_fourier_coefficients = self.__class__.delete_fourier_coefficients(service, version, mode, path + ["delete_fourier_coefficients"])
                self.calculate_harmonic_exports = self.__class__.calculate_harmonic_exports(service, version, mode, path + ["calculate_harmonic_exports"])
                self.delete_harmonic_exports = self.__class__.delete_harmonic_exports(service, version, mode, path + ["delete_harmonic_exports"])
                super().__init__(service, version, mode, path)
            class calculate_fourier_coefficients(TUIMethod):
                """
                Calculates Fourier coefficient data.
                """
            class delete_fourier_coefficients(TUIMethod):
                """
                Deletes Fourier coefficient data.
                """
            class calculate_harmonic_exports(TUIMethod):
                """
                Calculates Harmonic Export data.
                """
            class delete_harmonic_exports(TUIMethod):
                """
                Deletes Harmonic Export data.
                """

        class custom_field_functions(TUIMenu):
            """
            Enters the custom field functions menu.
            """
            def __init__(self, service, version, mode, path):
                self.define = self.__class__.define(service, version, mode, path + ["define"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                self.load = self.__class__.load(service, version, mode, path + ["load"])
                self.list_valid_cell_function_names = self.__class__.list_valid_cell_function_names(service, version, mode, path + ["list_valid_cell_function_names"])
                self.example_cff_definitions = self.__class__.example_cff_definitions(service, version, mode, path + ["example_cff_definitions"])
                super().__init__(service, version, mode, path)
            class define(TUIMethod):
                """
                Defines a custom field function.
                """
            class delete(TUIMethod):
                """
                Deletes a custom field function.
                """
            class save(TUIMethod):
                """
                Saves a custom field function.
                """
            class load(TUIMethod):
                """
                Loads a custom field function.
                """
            class list_valid_cell_function_names(TUIMethod):
                """
                Lists the names of cell functions that can be used in a custom field function.
                """
            class example_cff_definitions(TUIMethod):
                """
                Lists example custom field functions.
                """

        class dynamic_mesh(TUIMenu):
            """
            Enters the dynamic mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                self.events = self.__class__.events(service, version, mode, path + ["events"])
                self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                self.actions = self.__class__.actions(service, version, mode, path + ["actions"])
                self.transient_settings = self.__class__.transient_settings(service, version, mode, path + ["transient_settings"])
                self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
                super().__init__(service, version, mode, path)
            class dynamic_mesh(TUIMethod):
                """
                Enables/disables the dynamic mesh solver.
                """

            class controls(TUIMenu):
                """
                Enters the dynamic mesh controls menu. This text command is only available when the define/dynamic-mesh/dynamic-mesh? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self.smoothing_parameters = self.__class__.smoothing_parameters(service, version, mode, path + ["smoothing_parameters"])
                    self.layering_parameters = self.__class__.layering_parameters(service, version, mode, path + ["layering_parameters"])
                    self.remeshing_parameters = self.__class__.remeshing_parameters(service, version, mode, path + ["remeshing_parameters"])
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(service, version, mode, path + ["in_cylinder_parameters"])
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(service, version, mode, path + ["implicit_update_parameters"])
                    self.six_dof_parameters = self.__class__.six_dof_parameters(service, version, mode, path + ["six_dof_parameters"])
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(service, version, mode, path + ["periodic_displacement_parameters"])
                    self.contact_parameters = self.__class__.contact_parameters(service, version, mode, path + ["contact_parameters"])
                    self.in_cylinder_output = self.__class__.in_cylinder_output(service, version, mode, path + ["in_cylinder_output"])
                    self.smoothing = self.__class__.smoothing(service, version, mode, path + ["smoothing"])
                    self.layering = self.__class__.layering(service, version, mode, path + ["layering"])
                    self.remeshing = self.__class__.remeshing(service, version, mode, path + ["remeshing"])
                    self.steady_pseudo_time_control = self.__class__.steady_pseudo_time_control(service, version, mode, path + ["steady_pseudo_time_control"])
                    super().__init__(service, version, mode, path)
                class in_cylinder_output(TUIMethod):
                    """
                    Enables/disables in-cylinder output.
                    """
                class smoothing(TUIMethod):
                    """
                    Enables/disables smoothing in cell zones.
                    """
                class layering(TUIMethod):
                    """
                    Enables/disables dynamic-layering in quad/hex cell zones.
                    """
                class remeshing(TUIMethod):
                    """
                    Enables/disables local remeshing in tri/tet and mixed cell zones.
                    """
                class steady_pseudo_time_control(TUIMethod):
                    """
                    Enables/disables the pseudo time step control in the 	graphical user interface.
                    """

                class smoothing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh smoothing-parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.smoothing_method = self.__class__.smoothing_method(service, version, mode, path + ["smoothing_method"])
                        self.constant_factor = self.__class__.constant_factor(service, version, mode, path + ["constant_factor"])
                        self.bnd_node_relaxation = self.__class__.bnd_node_relaxation(service, version, mode, path + ["bnd_node_relaxation"])
                        self.bnd_stiffness_factor = self.__class__.bnd_stiffness_factor(service, version, mode, path + ["bnd_stiffness_factor"])
                        self.convergence_tolerance = self.__class__.convergence_tolerance(service, version, mode, path + ["convergence_tolerance"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        self.spring_on_all_elements = self.__class__.spring_on_all_elements(service, version, mode, path + ["spring_on_all_elements"])
                        self.spring_on_simplex_elements = self.__class__.spring_on_simplex_elements(service, version, mode, path + ["spring_on_simplex_elements"])
                        self.skew_smooth_niter = self.__class__.skew_smooth_niter(service, version, mode, path + ["skew_smooth_niter"])
                        self.skew_smooth_cell_skew_max = self.__class__.skew_smooth_cell_skew_max(service, version, mode, path + ["skew_smooth_cell_skew_max"])
                        self.skew_smooth_face_skew_max = self.__class__.skew_smooth_face_skew_max(service, version, mode, path + ["skew_smooth_face_skew_max"])
                        self.skew_smooth_all_deforming_boundaries = self.__class__.skew_smooth_all_deforming_boundaries(service, version, mode, path + ["skew_smooth_all_deforming_boundaries"])
                        self.laplace_node_relaxation = self.__class__.laplace_node_relaxation(service, version, mode, path + ["laplace_node_relaxation"])
                        self.diffusion_coeff_function = self.__class__.diffusion_coeff_function(service, version, mode, path + ["diffusion_coeff_function"])
                        self.diffusion_coeff_parameter = self.__class__.diffusion_coeff_parameter(service, version, mode, path + ["diffusion_coeff_parameter"])
                        self.diffusion_fvm = self.__class__.diffusion_fvm(service, version, mode, path + ["diffusion_fvm"])
                        self.poisson_ratio = self.__class__.poisson_ratio(service, version, mode, path + ["poisson_ratio"])
                        self.smooth_from_reference_position = self.__class__.smooth_from_reference_position(service, version, mode, path + ["smooth_from_reference_position"])
                        self.relative_convergence_tolerance = self.__class__.relative_convergence_tolerance(service, version, mode, path + ["relative_convergence_tolerance"])
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.boundary_distance_method = self.__class__.boundary_distance_method(service, version, mode, path + ["boundary_distance_method"])
                        super().__init__(service, version, mode, path)
                    class smoothing_method(TUIMethod):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                    class constant_factor(TUIMethod):
                        """
                        Sets the spring constant relaxation factor.
                        """
                    class bnd_node_relaxation(TUIMethod):
                        """
                        The boundary node relaxation is used by spring smoothing. The boundary node relaxation allows you to relax the update of the node positions at deforming boundaries. A value of 0 prevents deforming boundary nodes from moving and a value of 1 indicates no under-relaxation.
                        """
                    class bnd_stiffness_factor(TUIMethod):
                        """
                        Sets the stiffness factor for springs connected to boundary nodes.
                        """
                    class convergence_tolerance(TUIMethod):
                        """
                        Sets the convergence tolerance for spring-based solver.
                        """
                    class max_iter(TUIMethod):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                    class spring_on_all_elements(TUIMethod):
                        """
                        Enables/disables spring-based smoothing for all cell shapes; if disabled, the spring-based smoothing is applied based on the setting of the define/dynamic-mesh/controls/smoothing-parameters/spring-on-simplex-shapes? text command.
                        """
                    class spring_on_simplex_elements(TUIMethod):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                    class skew_smooth_niter(TUIMethod):
                        """
                        Sets the number of skewness-based smoothing cycles.
                        """
                    class skew_smooth_cell_skew_max(TUIMethod):
                        """
                        Sets the skewness threshold, above which cells will be smoothed using the skewness method.
                        """
                    class skew_smooth_face_skew_max(TUIMethod):
                        """
                        Sets the skewness threshold, above which faces will be smoothed using the skewness method.
                        """
                    class skew_smooth_all_deforming_boundaries(TUIMethod):
                        """
                        Enables/disables skewness smoothing for all deforming dynamic boundary zones. This is enabled by default. If disabled, skewness smoothing is only applied to the deforming dynamic boundary zones that have smoothing explicitly enabled or use local face remeshing.
                        """
                    class laplace_node_relaxation(TUIMethod):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                    class diffusion_coeff_function(TUIMethod):
                        """
                        Specifies whether the diffusion coefficient for diffusion-based smoothing is based on the boundary distance or the cell volume.
                        """
                    class diffusion_coeff_parameter(TUIMethod):
                        """
                        Sets the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                    class diffusion_fvm(TUIMethod):
                        """
                        Answering yes at the prompt changes the diffusion-based smoothing method to the cell-based finite volume approach that was the default in releases prior to Fluent 15.0. Answering no at the prompt changes the diffusion-based smoothing method to the default node-based finite element method.
                        """
                    class poisson_ratio(TUIMethod):
                        """
                        Sets the Poisson’s ratio used for smoothing based on the linearly elastic solid model.
                        """
                    class smooth_from_reference_position(TUIMethod):
                        """
                        Enables/disables smoothing from a reference position. Such smoothing may produce greater mesh quality consistency for stationary or moving meshes with periodic or quasi-periodic motion, and is only available when the smoothing method is based on diffusion or the linearly elastic solid model.
                        """
                    class relative_convergence_tolerance(TUIMethod):
                        """
                        Sets the relative residual convergence tolerance for smoothing based on diffusion or the linearly elastic solid model.
                        """
                    class amg_stabilization(TUIMethod):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                    class verbosity(TUIMethod):
                        """
                        Set the verbosity for spring smoothing.
                        """
                    class boundary_distance_method(TUIMethod):
                        """
                        Sets the method used to evaluate the boundary distance for the diffusion coefficient calculation, when diffusion-based smoothing is enabled.
                        """

                class layering_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh layering menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.split_factor = self.__class__.split_factor(service, version, mode, path + ["split_factor"])
                        self.collapse_factor = self.__class__.collapse_factor(service, version, mode, path + ["collapse_factor"])
                        self.constant_height = self.__class__.constant_height(service, version, mode, path + ["constant_height"])
                        super().__init__(service, version, mode, path)
                    class split_factor(TUIMethod):
                        """
                        Sets the factor determining when to split dynamic layers.
                        """
                    class collapse_factor(TUIMethod):
                        """
                        Sets the factor determining when to collapse dynamic layers.
                        """
                    class constant_height(TUIMethod):
                        """
                        Enables/disables layering based on constant height, else layering based on constant ratio.
                        """

                class remeshing_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh remeshing menu to set 	parameters for all remeshing methods.
                    """
                    def __init__(self, service, version, mode, path):
                        self.prism_controls = self.__class__.prism_controls(service, version, mode, path + ["prism_controls"])
                        self.sizing_controls = self.__class__.sizing_controls(service, version, mode, path + ["sizing_controls"])
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(service, version, mode, path + ["prism_layer_parameters"])
                        self.unified_remeshing = self.__class__.unified_remeshing(service, version, mode, path + ["unified_remeshing"])
                        self.retain_size_distribution = self.__class__.retain_size_distribution(service, version, mode, path + ["retain_size_distribution"])
                        self.poly_remeshing = self.__class__.poly_remeshing(service, version, mode, path + ["poly_remeshing"])
                        self.remeshing_methods = self.__class__.remeshing_methods(service, version, mode, path + ["remeshing_methods"])
                        self.zone_remeshing = self.__class__.zone_remeshing(service, version, mode, path + ["zone_remeshing"])
                        self.length_min = self.__class__.length_min(service, version, mode, path + ["length_min"])
                        self.length_max = self.__class__.length_max(service, version, mode, path + ["length_max"])
                        self.cell_skew_max = self.__class__.cell_skew_max(service, version, mode, path + ["cell_skew_max"])
                        self.face_skew_max = self.__class__.face_skew_max(service, version, mode, path + ["face_skew_max"])
                        self.size_remesh_interval = self.__class__.size_remesh_interval(service, version, mode, path + ["size_remesh_interval"])
                        self.sizing_function = self.__class__.sizing_function(service, version, mode, path + ["sizing_function"])
                        self.sizing_funct_defaults = self.__class__.sizing_funct_defaults(service, version, mode, path + ["sizing_funct_defaults"])
                        self.sizing_funct_resolution = self.__class__.sizing_funct_resolution(service, version, mode, path + ["sizing_funct_resolution"])
                        self.sizing_funct_variation = self.__class__.sizing_funct_variation(service, version, mode, path + ["sizing_funct_variation"])
                        self.sizing_funct_rate = self.__class__.sizing_funct_rate(service, version, mode, path + ["sizing_funct_rate"])
                        self.parallel_remeshing = self.__class__.parallel_remeshing(service, version, mode, path + ["parallel_remeshing"])
                        self.remeshing_after_moving = self.__class__.remeshing_after_moving(service, version, mode, path + ["remeshing_after_moving"])
                        super().__init__(service, version, mode, path)
                    class unified_remeshing(TUIMethod):
                        """
                        Enables/disables unified remeshing, which specifies that an algorithm is used that combines aspects of a variety of remeshing methods. It is applied to triangular or tetrahedral cells and can produce wedge cells in 3D boundary layer meshes. Unified remeshing simplifies the remeshing setup and can provide increased robustness compared to methods-based remeshing, especially for parallel simulations.
                        """
                    class retain_size_distribution(TUIMethod):
                        """
                        Enables/disables the use of local size criteria when marking cells for unified remeshing (in an attempt to maintain the initial mesh size distribution even as the mesh moves), rather than marking cells based on the minimum and maximum length scale values of the cell zone in the initial mesh. Either marking can be overridden if more restrictive values are specified using the define/dynamic-mesh/controls/remeshing-parameters/length-min and define/dynamic-mesh/controls/remeshing-parameters/length-max text commands.
                        """
                    class poly_remeshing(TUIMethod):
                        """
                        Enable/disable poly remeshing.
                        """
                    class remeshing_methods(TUIMethod):
                        """
                        Enables/disables individual remeshing options as part of methods-based remeshing.
                        """
                    class zone_remeshing(TUIMethod):
                        """
                        Enables/disables the cell zone remeshing method as part of methods-based remeshing.
                        """
                    class length_min(TUIMethod):
                        """
                        Sets the length threshold below which cells will be remeshed.
                        """
                    class length_max(TUIMethod):
                        """
                        Sets the length threshold above which cells will be remeshed.
                        """
                    class cell_skew_max(TUIMethod):
                        """
                        Sets the cell skewness threshold above which cells will be remeshed.
                        """
                    class face_skew_max(TUIMethod):
                        """
                        Sets the face skewness threshold above which faces will be remeshed.
                        """
                    class size_remesh_interval(TUIMethod):
                        """
                        Sets the interval (in time steps) when remeshing based on size is done for methods-based remeshing.
                        """
                    class sizing_function(TUIMethod):
                        """
                        Enables/disables the sizing function as part of methods-based remeshing.
                        """
                    class sizing_funct_defaults(TUIMethod):
                        """
                        Sets sizing function defaults.
                        """
                    class sizing_funct_resolution(TUIMethod):
                        """
                        Sets the sizing function resolution with respect to shortest boundary.
                        """
                    class sizing_funct_variation(TUIMethod):
                        """
                        Sets the maximum sizing function increase/decrease in the interior.
                        """
                    class sizing_funct_rate(TUIMethod):
                        """
                        Determines how far from the boundary the increase/decrease happens.
                        """
                    class parallel_remeshing(TUIMethod):
                        """
                        Disables/enables parallel remeshing as part of methods-based remeshing..
                        """
                    class remeshing_after_moving(TUIMethod):
                        """
                        Enables a second round of remeshing based on the skewness parameters after the boundary has moved as part of methods-based remeshing.
                        """

                    class prism_controls(TUIMenu):
                        """
                        Enters the dynamic mesh prism controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each prism control definition is applied to one or more boundary zones, and then affects the height distribution and number of layers of the wedge cells in the adjacent boundary layers.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Add a new object.
                            """
                        class edit(TUIMethod):
                            """
                            Edit an object.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes an existing prism controls definition.
                            """
                        class list(TUIMethod):
                            """
                            Prints a list of the existing prism controls definitions in the console.
                            """
                        class list_properties(TUIMethod):
                            """
                            Prints the properties of an existing prism controls definition of your choice in the console.
                            """

                    class sizing_controls(TUIMenu):
                        """
                        Enters the dynamic mesh sizing controls menu, which provides text commands that can be useful when you want to modify the algorithm that attempts to retain the size distribution during unified remeshing. Each sizing control definition is applied to one or more boundary zones, and then affects the size of the cells throughout the mesh based on their distance from those boundary zone(s) and your settings in the definition.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Adds a new sizing controls definition.   After being prompted for a name, you can enter the following to complete the definition:
                            growth-rate  Sets the growth rate of the sizing controls definition.
                            max-length  Sets a maximum length threshold that is used when the type is set to auto or soft.
                            min-length  Sets a maximum length threshold that is used when the type is set to auto.
                            motion  Determines whether the size control definition affects the remeshing based on whether the mesh undergoes motion: auto specifies that it is applied whether or not there is motion; and static specifies that it is only applied if there is no motion.
                            name  Specifies the name of the sizing controls definition.
                            type  Specifies how the sizing is affected by the selected boundary zones: auto specifies that the default size distribution (rather than the initial size distribution in your selected boundary zones) is used, along with your specified max-length and min-length values; soft specifies that the maximum length scale of your selected boundary zones is used, along with your specified min-length value; and meshed specifies that the maximum and minimum length scales of your selected boundary zones are used, in order to respect their initial size distribution. This setting is only relevant if you have more than one sizing controls definition.
                            zones  Specifies all of the boundary zones on which the sizing controls definition is applied.
                            Enter q when the definition is complete to return to the text command menu.
                            """
                        class edit(TUIMethod):
                            """
                            Edits an existing sizing controls definition. You can revise the fields listed previously for the define/dynamic-mesh/controls/remeshing-parameters/sizing-controls/add text command.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes an existing sizing controls definition.
                            """
                        class list(TUIMethod):
                            """
                            Prints a list of the existing sizing controls definitions in the console.
                            """
                        class list_properties(TUIMethod):
                            """
                            Prints the properties of an existing sizing controls definition of your choice in the console.
                            """

                    class prism_layer_parameters(TUIMenu):
                        """
                        Enters the dynamic mesh prism layer parameters menu, where you can define the parameters of the prism layers as part of methods-based remeshing.
                        """
                        def __init__(self, service, version, mode, path):
                            self.first_height = self.__class__.first_height(service, version, mode, path + ["first_height"])
                            self.growth_rate = self.__class__.growth_rate(service, version, mode, path + ["growth_rate"])
                            self.number_of_layers = self.__class__.number_of_layers(service, version, mode, path + ["number_of_layers"])
                            super().__init__(service, version, mode, path)
                        class first_height(TUIMethod):
                            """
                            Sets the first cell height in the prism layer.
                            """
                        class growth_rate(TUIMethod):
                            """
                            Sets the geometric growth rate of the prism layer.
                            """
                        class number_of_layers(TUIMethod):
                            """
                            Sets the number of elements in the prism layer.
                            """

                class in_cylinder_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.starting_crank_angle = self.__class__.starting_crank_angle(service, version, mode, path + ["starting_crank_angle"])
                        self.crank_angle_step = self.__class__.crank_angle_step(service, version, mode, path + ["crank_angle_step"])
                        self.crank_period = self.__class__.crank_period(service, version, mode, path + ["crank_period"])
                        self.max_crank_angle_step = self.__class__.max_crank_angle_step(service, version, mode, path + ["max_crank_angle_step"])
                        self.piston_data = self.__class__.piston_data(service, version, mode, path + ["piston_data"])
                        self.piston_stroke_cutoff = self.__class__.piston_stroke_cutoff(service, version, mode, path + ["piston_stroke_cutoff"])
                        self.minimum_lift = self.__class__.minimum_lift(service, version, mode, path + ["minimum_lift"])
                        self.print_plot_lift = self.__class__.print_plot_lift(service, version, mode, path + ["print_plot_lift"])
                        self.modify_lift = self.__class__.modify_lift(service, version, mode, path + ["modify_lift"])
                        self.position_starting_mesh = self.__class__.position_starting_mesh(service, version, mode, path + ["position_starting_mesh"])
                        super().__init__(service, version, mode, path)
                    class starting_crank_angle(TUIMethod):
                        """
                        Specifies the initial value for the crank angle.
                        """
                    class crank_angle_step(TUIMethod):
                        """
                        Specifies crank angle step size.
                        """
                    class crank_period(TUIMethod):
                        """
                        Specifies the crank period.
                        """
                    class max_crank_angle_step(TUIMethod):
                        """
                        Specifies maximum crank angle step size.
                        """
                    class piston_data(TUIMethod):
                        """
                        Specifies the crank radius and connecting rod length.
                        """
                    class piston_stroke_cutoff(TUIMethod):
                        """
                        Specifies the cut off point for in-cylinder piston.
                        """
                    class minimum_lift(TUIMethod):
                        """
                        Specifies minimum lift for in-cylinder valves.
                        """
                    class print_plot_lift(TUIMethod):
                        """
                        Prints or plot valve lift curve.
                        """
                    class modify_lift(TUIMethod):
                        """
                        Modifies lift curve (shift or scale).
                        """
                    class position_starting_mesh(TUIMethod):
                        """
                        Moves mesh from top dead center to starting crank angle.
                        """

                class implicit_update_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh implicit update menu. This text command is only available 	when you enable implicit mesh updating using the prompts 	of the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        self.motion_relaxation = self.__class__.motion_relaxation(service, version, mode, path + ["motion_relaxation"])
                        self.residual_criteria = self.__class__.residual_criteria(service, version, mode, path + ["residual_criteria"])
                        super().__init__(service, version, mode, path)
                    class update_interval(TUIMethod):
                        """
                        Specifies the update interval (that is, the frequency in iterations) at which the mesh is updated within a time step.
                        """
                    class motion_relaxation(TUIMethod):
                        """
                        Specifies a value (within the range of 0 to 1) for the motion relaxation, which is applied during the implicit mesh update.
                        """
                    class residual_criteria(TUIMethod):
                        """
                        Specifies the relative residual threshold that is used to check the motion convergence during the implicit mesh update.
                        """

                class six_dof_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh six degrees of freedom (DOF) solver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.create_properties = self.__class__.create_properties(service, version, mode, path + ["create_properties"])
                        self.delete_properties = self.__class__.delete_properties(service, version, mode, path + ["delete_properties"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.x_component_of_gravity = self.__class__.x_component_of_gravity(service, version, mode, path + ["x_component_of_gravity"])
                        self.y_component_of_gravity = self.__class__.y_component_of_gravity(service, version, mode, path + ["y_component_of_gravity"])
                        self.z_component_of_gravity = self.__class__.z_component_of_gravity(service, version, mode, path + ["z_component_of_gravity"])
                        self.second_order = self.__class__.second_order(service, version, mode, path + ["second_order"])
                        self.motion_history = self.__class__.motion_history(service, version, mode, path + ["motion_history"])
                        self.motion_history_file_name = self.__class__.motion_history_file_name(service, version, mode, path + ["motion_history_file_name"])
                        super().__init__(service, version, mode, path)
                    class create_properties(TUIMethod):
                        """
                        Creates/edits a set of six DOF properties for rigid body motion.
                        """
                    class delete_properties(TUIMethod):
                        """
                        Deletes a set of six DOF properties for rigid body motion.
                        """
                    class list_properties(TUIMethod):
                        """
                        Prints summaries of the existing sets of six DOF properties for rigid body motion.
                        """
                    class x_component_of_gravity(TUIMethod):
                        """
                        Specifies x-component of gravity.
                        """
                    class y_component_of_gravity(TUIMethod):
                        """
                        Specifies y-component of gravity.
                        """
                    class z_component_of_gravity(TUIMethod):
                        """
                        Specifies z-component of gravity.
                        """
                    class second_order(TUIMethod):
                        """
                        Enables/disables the second order six degrees of freedom solver.
                        """
                    class motion_history(TUIMethod):
                        """
                        Enables/disables writing position/orientation of six DOF zones to file.
                        """
                    class motion_history_file_name(TUIMethod):
                        """
                        Specifies the name and location of the six DOF motion history file.
                        """

                class periodic_displacement_parameters(TUIMenu):
                    """
                    Enters the periodic displacement parameters 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.list_displacements = self.__class__.list_displacements(service, version, mode, path + ["list_displacements"])
                        self.create_displacement = self.__class__.create_displacement(service, version, mode, path + ["create_displacement"])
                        self.edit_displacement = self.__class__.edit_displacement(service, version, mode, path + ["edit_displacement"])
                        self.copy_displacement = self.__class__.copy_displacement(service, version, mode, path + ["copy_displacement"])
                        self.delete_displacement = self.__class__.delete_displacement(service, version, mode, path + ["delete_displacement"])
                        self.delete_all_displacements = self.__class__.delete_all_displacements(service, version, mode, path + ["delete_all_displacements"])
                        self.create_group = self.__class__.create_group(service, version, mode, path + ["create_group"])
                        self.list_groups = self.__class__.list_groups(service, version, mode, path + ["list_groups"])
                        self.edit_group = self.__class__.edit_group(service, version, mode, path + ["edit_group"])
                        self.delete_group = self.__class__.delete_group(service, version, mode, path + ["delete_group"])
                        self.delete_all_groups = self.__class__.delete_all_groups(service, version, mode, path + ["delete_all_groups"])
                        self.set_active_displacement = self.__class__.set_active_displacement(service, version, mode, path + ["set_active_displacement"])
                        super().__init__(service, version, mode, path)
                    class list_displacements(TUIMethod):
                        """
                        List Periodic Displacements.
                        """
                    class create_displacement(TUIMethod):
                        """
                        Create Periodic Displacement.
                        """
                    class edit_displacement(TUIMethod):
                        """
                        Edit Periodic Displacement.
                        """
                    class copy_displacement(TUIMethod):
                        """
                        Copy Periodic Displacement.
                        """
                    class delete_displacement(TUIMethod):
                        """
                        Delete Periodic Displacement.
                        """
                    class delete_all_displacements(TUIMethod):
                        """
                        Delete All Periodic Displacements.
                        """
                    class create_group(TUIMethod):
                        """
                        Create Periodic Displacement Group.
                        """
                    class list_groups(TUIMethod):
                        """
                        List Periodic Displacement Groups.
                        """
                    class edit_group(TUIMethod):
                        """
                        Edit Periodic Displacement Group.
                        """
                    class delete_group(TUIMethod):
                        """
                        Delete Periodic Displacement Group.
                        """
                    class delete_all_groups(TUIMethod):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                    class set_active_displacement(TUIMethod):
                        """
                        Set Active Periodic Displacement in Group.
                        """

                class contact_parameters(TUIMenu):
                    """
                    Enters the dynamic mesh contact-parameters menu. This text command is only available 	when you enable contact detection using the prompts of 	the define/dynamic-mesh/dynamic-mesh? 	text command.
                    """
                    def __init__(self, service, version, mode, path):
                        self.flow_control_parameters = self.__class__.flow_control_parameters(service, version, mode, path + ["flow_control_parameters"])
                        self.contact_face_zones = self.__class__.contact_face_zones(service, version, mode, path + ["contact_face_zones"])
                        self.contact_udf = self.__class__.contact_udf(service, version, mode, path + ["contact_udf"])
                        self.contact_threshold = self.__class__.contact_threshold(service, version, mode, path + ["contact_threshold"])
                        self.update_contact_marks = self.__class__.update_contact_marks(service, version, mode, path + ["update_contact_marks"])
                        self.flow_control = self.__class__.flow_control(service, version, mode, path + ["flow_control"])
                        self.contact_method = self.__class__.contact_method(service, version, mode, path + ["contact_method"])
                        self.render_contact_cells = self.__class__.render_contact_cells(service, version, mode, path + ["render_contact_cells"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class contact_face_zones(TUIMethod):
                        """
                        Selects face zones involved in contact detection.
                        """
                    class contact_udf(TUIMethod):
                        """
                        Selects the UDF to be invoked when contact is detected.
                        """
                    class contact_threshold(TUIMethod):
                        """
                        Specifies threshold distance for contact detection.
                        """
                    class update_contact_marks(TUIMethod):
                        """
                        Updates which cells are marked in order to block flow in the contact region as part of the contact marks method.
                        """
                    class flow_control(TUIMethod):
                        """
                        Enables/disables flow control in the contact region.
                        """
                    class contact_method(TUIMethod):
                        """
                        Selects the method used for flow control in the contact region. Enter 0 for the contact zones method (which restricts the flow using additional cell zones with porous zone properties) or 1 for the contact marks method (which blocks the flow using zero-mass-flux boundaries).
                        """
                    class render_contact_cells(TUIMethod):
                        """
                        Enables/disables the availability of a field variable (contact-cell-mark) that can be used to display contours of cells marked for flow blocking as part of the contact marks method, and allows you to postprocess other field variables on those cells.
                        """
                    class verbosity(TUIMethod):
                        """
                        Sets the level of detail printed in the console regarding contact detection.
                        """

                    class flow_control_parameters(TUIMenu):
                        """
                        Enters the flow control parameters menu, which provides settings related to controlling the flow in the contact region.
                        """
                        def __init__(self, service, version, mode, path):
                            self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                            self.create_flow_control_zone = self.__class__.create_flow_control_zone(service, version, mode, path + ["create_flow_control_zone"])
                            self.delete_flow_control_zone = self.__class__.delete_flow_control_zone(service, version, mode, path + ["delete_flow_control_zone"])
                            super().__init__(service, version, mode, path)
                        class solution_stabilization(TUIMethod):
                            """
                            Enables/disables the performance of additional iterations per time step and the application of solution controls to improve the stability of the solver as part of the contact marks method.
                            """
                        class create_flow_control_zone(TUIMethod):
                            """
                            Creates a flow control zone as part of the contact zones method.
                            """
                        class delete_flow_control_zone(TUIMethod):
                            """
                            Deletes a flow control zone as part of the contact zones method.
                            """

            class events(TUIMenu):
                """
                Enters the dynamic mesh events menu.
                """
                def __init__(self, service, version, mode, path):
                    self.import_event_file = self.__class__.import_event_file(service, version, mode, path + ["import_event_file"])
                    self.export_event_file = self.__class__.export_event_file(service, version, mode, path + ["export_event_file"])
                    super().__init__(service, version, mode, path)
                class import_event_file(TUIMethod):
                    """
                    Imports dynamic mesh event file.
                    """
                class export_event_file(TUIMethod):
                    """
                    Exports dynamic mesh events to file.
                    """

            class zones(TUIMenu):
                """
                Enters the dynamic mesh zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.insert_boundary_layer = self.__class__.insert_boundary_layer(service, version, mode, path + ["insert_boundary_layer"])
                    self.remove_boundary_layer = self.__class__.remove_boundary_layer(service, version, mode, path + ["remove_boundary_layer"])
                    self.insert_interior_layer = self.__class__.insert_interior_layer(service, version, mode, path + ["insert_interior_layer"])
                    self.remove_interior_layer = self.__class__.remove_interior_layer(service, version, mode, path + ["remove_interior_layer"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create dynamic zone.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a dynamic zone.
                    """
                class list(TUIMethod):
                    """
                    Lists the dynamic zones.
                    """
                class insert_boundary_layer(TUIMethod):
                    """
                    Inserts a new cell zone.
                    """
                class remove_boundary_layer(TUIMethod):
                    """
                    Removes a cell zone.
                    """
                class insert_interior_layer(TUIMethod):
                    """
                    Inserts a new layer cell zone at a specified location.
                    """
                class remove_interior_layer(TUIMethod):
                    """
                    Removes an interior layer cell zone.
                    """

            class actions(TUIMenu):
                """
                Enters the dynamic mesh action menu, where you can initiate manual remeshing (that is, remeshing without running a calculation).
                """
                def __init__(self, service, version, mode, path):
                    self.remesh_cell_zone = self.__class__.remesh_cell_zone(service, version, mode, path + ["remesh_cell_zone"])
                    super().__init__(service, version, mode, path)
                class remesh_cell_zone(TUIMethod):
                    """
                    Manually remeshes a cell zone with option to remesh adjacent dynamic face 	zones.
                    """

            class transient_settings(TUIMenu):
                """
                Enters the transient dynamic mesh settings menu. This text command is only available when you enable dynamic mesh using the prompts of the define/dynamic-mesh/dynamic-mesh? text command. Solver time must also be set to Transient.
                """
                def __init__(self, service, version, mode, path):
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.allow_second_order = self.__class__.allow_second_order(service, version, mode, path + ["allow_second_order"])
                    super().__init__(service, version, mode, path)
                class verbosity(TUIMethod):
                    """
                    Enables/disables transient scheme verbosity for dynamic mesh cases.
                    """
                class allow_second_order(TUIMethod):
                    """
                    Enables/disables second order transient scheme for dynamic mesh cases.
                    """

        class mesh_interfaces(TUIMenu):
            """
            Enters the mesh-interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(service, version, mode, path + ["non_conformal_interface_numerics"])
                self.mapped_interface_options = self.__class__.mapped_interface_options(service, version, mode, path + ["mapped_interface_options"])
                self.auto_options = self.__class__.auto_options(service, version, mode, path + ["auto_options"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.enforce_continuity_after_bc = self.__class__.enforce_continuity_after_bc(service, version, mode, path + ["enforce_continuity_after_bc"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                self.enable_si_with_nodes = self.__class__.enable_si_with_nodes(service, version, mode, path + ["enable_si_with_nodes"])
                self.enforce_coupled_wall_between_solids = self.__class__.enforce_coupled_wall_between_solids(service, version, mode, path + ["enforce_coupled_wall_between_solids"])
                self.improve_quality = self.__class__.improve_quality(service, version, mode, path + ["improve_quality"])
                self.one_to_one_pairing = self.__class__.one_to_one_pairing(service, version, mode, path + ["one_to_one_pairing"])
                self.auto_pairing = self.__class__.auto_pairing(service, version, mode, path + ["auto_pairing"])
                self.enable_visualization_of_interfaces = self.__class__.enable_visualization_of_interfaces(service, version, mode, path + ["enable_visualization_of_interfaces"])
                self.transfer_motion_across_interfaces = self.__class__.transfer_motion_across_interfaces(service, version, mode, path + ["transfer_motion_across_interfaces"])
                self.non_overlapping_zone_name = self.__class__.non_overlapping_zone_name(service, version, mode, path + ["non_overlapping_zone_name"])
                self.remove_left_handed_interface_faces = self.__class__.remove_left_handed_interface_faces(service, version, mode, path + ["remove_left_handed_interface_faces"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Creates mesh interfaces.
                """
            class turbo_create(TUIMethod):
                """
                Creates a general turbo interface. This text command is only available if the define/turbo-model/enable-turbo-model? text command is enabled.
                """
            class edit(TUIMethod):
                """
                Edits attributes of existing mesh interfaces. For one-to-one interfaces, you can edit the name; for many-to-many interfaces, you can edit the interface options and (for a single interface) the name and the list of interface zones assigned to the interface.
                """
            class delete(TUIMethod):
                """
                Deletes a mesh interface.
                """
            class display(TUIMethod):
                """
                Displays the specified mesh interface zone.
                """
            class list(TUIMethod):
                """
                Lists all mesh interfaces.
                """
            class make_periodic(TUIMethod):
                """
                Make interface zones periodic.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                Make interface zones phase lagged.
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                Convert periodic interface to phase lagged.
                """
            class delete_all(TUIMethod):
                """
                Deletes all mesh interfaces.
                """
            class enforce_continuity_after_bc(TUIMethod):
                """
                Enables/disables continuity across the boundary condition interface for contour plots in postprocessing.
                """
            class verbosity(TUIMethod):
                """
                Sets the mesh interface verbosity.
                """
            class enable_si_with_nodes(TUIMethod):
                """
                Enable sliding interfaces with nodes.
                """
            class enforce_coupled_wall_between_solids(TUIMethod):
                """
                Enables/disables automatic definition of solid-solid interfaces as coupled walls. By default this option is disabled and ANSYS Fluent creates interior boundaries at solid-solid interfaces.
                """
            class improve_quality(TUIMethod):
                """
                Checks the quality of all mapped interfaces. If Fluent finds any mapped interfaces that require improvement it will list them and ask you if you would like to increase the tolerance to improve the interfaces.
                """
            class one_to_one_pairing(TUIMethod):
                """
                Use the default one-to-one interface creation method?.
                """
            class auto_pairing(TUIMethod):
                """
                Automatically "pairs" some or all of the interface zones, in order to create mesh interfaces. This text command is only available when the define/mesh-interfaces/one-to-one-pairing? text command is disabled.
                """
            class enable_visualization_of_interfaces(TUIMethod):
                """
                Enables/disables the filling of node coordinates on the zones of mesh interfaces, so that they can be displayed in the graphics window.
                """
            class transfer_motion_across_interfaces(TUIMethod):
                """
                Enables/disables the automatic transfer of motion across a mesh interface when only one side is moving as a result of user-defined or system coupling motion. You can specify the method by which the motion is transferred: transfer-displacements (the default) interpolates nodal displacement from the active side of the interface to the passive side, and is recommended when there are gaps and/or penetrations in the mesh interface that must be maintained; project-nodes projects the passive nodes onto the faces of active side, and is recommended when the active side includes significant tangential motion (as only the normal displacement is effectively transferred in this method).
                """
            class non_overlapping_zone_name(TUIMethod):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
            class remove_left_handed_interface_faces(TUIMethod):
                """
                Removes left-handed faces (which can cause the mesh to be invalid) during mesh interface creation.
                """

            class non_conformal_interface_numerics(TUIMenu):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self.change_numerics = self.__class__.change_numerics(service, version, mode, path + ["change_numerics"])
                    super().__init__(service, version, mode, path)
                class change_numerics(TUIMethod):
                    """
                    Enable modified non-conformal interface numerics.
                    """

            class mapped_interface_options(TUIMenu):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.solution_controls = self.__class__.solution_controls(service, version, mode, path + ["solution_controls"])
                    self.tolerance = self.__class__.tolerance(service, version, mode, path + ["tolerance"])
                    self.convert_to_mapped_interface = self.__class__.convert_to_mapped_interface(service, version, mode, path + ["convert_to_mapped_interface"])
                    super().__init__(service, version, mode, path)
                class solution_controls(TUIMethod):
                    """
                    Specification of mapped frequency and under-relaxation factor for mapped interfaces.
                    """
                class tolerance(TUIMethod):
                    """
                    Specification of mapped interface tolerance.
                    """
                class convert_to_mapped_interface(TUIMethod):
                    """
                    Convert non-conformal mesh interface to mapped mesh interfaces.
                    """

            class auto_options(TUIMenu):
                """
                Enters the auto-options menu. This menu is only available when the define/mesh-interfaces/one-to-one-pairing? text command is enabled.
                """
                def __init__(self, service, version, mode, path):
                    self.proximity_tolerance = self.__class__.proximity_tolerance(service, version, mode, path + ["proximity_tolerance"])
                    self.naming_option = self.__class__.naming_option(service, version, mode, path + ["naming_option"])
                    self.set_default_name_prefix = self.__class__.set_default_name_prefix(service, version, mode, path + ["set_default_name_prefix"])
                    self.set_one_to_one_pairing_tolerance = self.__class__.set_one_to_one_pairing_tolerance(service, version, mode, path + ["set_one_to_one_pairing_tolerance"])
                    self.pairing_between_different_cell_zones_only = self.__class__.pairing_between_different_cell_zones_only(service, version, mode, path + ["pairing_between_different_cell_zones_only"])
                    self.pairing_between_interface_zones_only = self.__class__.pairing_between_interface_zones_only(service, version, mode, path + ["pairing_between_interface_zones_only"])
                    self.keep_empty_interface = self.__class__.keep_empty_interface(service, version, mode, path + ["keep_empty_interface"])
                    super().__init__(service, version, mode, path)
                class proximity_tolerance(TUIMethod):
                    """
                    Sets the tolerance used as part 	of the automatic grouping of zones to create mesh 	interfaces when the define/mesh-interfaces/one-to-one-pairing? 	text command is disabled. The proximity tolerance is 	defined relative to the edge lengths in the interface 	zones, and can range from 0 to 1 (representing the minimum 	and maximum edge lengths, respectively).
                    """
                class naming_option(TUIMethod):
                    """
                    Specifies whether the name of each new one-to-one mesh 	interface (as well as existing mesh interfaces, if you 	so desire) has no additional suffix, or a suffix that 	includes the names of the associated boundary zones, the 	IDs of the associated boundary zones, or the names of 	the adjacent cell zones.
                    """
                class set_default_name_prefix(TUIMethod):
                    """
                    Specifies the default interface 	name prefix used for one-to-one mesh interfaces.
                    """
                class set_one_to_one_pairing_tolerance(TUIMethod):
                    """
                    Enables/disables the use of adjustable tolerances to 	determine which of the selected boundary zones can be 	paired up to make the mesh interfaces, in order to 	account for gaps, thin layers, and/or complex 	geometries.
                    """
                class pairing_between_different_cell_zones_only(TUIMethod):
                    """
                    Specifies whether the 	one-to-one mesh interfaces are only created between 	different cell zones.
                    """
                class pairing_between_interface_zones_only(TUIMethod):
                    """
                    Pairing between interface zones only.
                    """
                class keep_empty_interface(TUIMethod):
                    """
                    Keep empty interfaces during one-to-one mesh interface creation.
                    """

        class gap_model(TUIMenu):
            """
            Enters the gap model menu, where you can define one or more gap regions where the flow is blocked or decelerated when face zones move within a specified proximity threshold of each other.
            """
            def __init__(self, service, version, mode, path):
                self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.list_gap_regions = self.__class__.list_gap_regions(service, version, mode, path + ["list_gap_regions"])
                self.list_gap_face_zones = self.__class__.list_gap_face_zones(service, version, mode, path + ["list_gap_face_zones"])
                self.list_gap_cell_zones = self.__class__.list_gap_cell_zones(service, version, mode, path + ["list_gap_cell_zones"])
                self.render_gap_regions = self.__class__.render_gap_regions(service, version, mode, path + ["render_gap_regions"])
                super().__init__(service, version, mode, path)
            class enable(TUIMethod):
                """
                Enables/disables the gap model.
                """
            class create(TUIMethod):
                """
                Creates a single gap region, so that when selected face zones move within a specified proximity threshold of each other, flow blockage / deceleration is applied to the cells that lie within the threshold.
                """
            class edit(TUIMethod):
                """
                Edits an existing gap region.
                """
            class delete(TUIMethod):
                """
                Deletes an existing gap region.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the existing gap regions.
                """
            class list_gap_regions(TUIMethod):
                """
                Lists the properties of the gap regions.
                """
            class list_gap_face_zones(TUIMethod):
                """
                Lists the names of the face zones that can be used for creating gap regions.
                """
            class list_gap_cell_zones(TUIMethod):
                """
                Lists the names of the cell zones that can be excluded for individual gap regions (so that such cells are not marked for flow blockage / deceleration).
                """
            class render_gap_regions(TUIMethod):
                """
                Update gap regions for postprocessing.
                """

            class advanced_options(TUIMenu):
                """
                Enters the advanced options menu for the gap model.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.alternative_marking = self.__class__.alternative_marking(service, version, mode, path + ["alternative_marking"])
                    self.cell_check_distance_factor = self.__class__.cell_check_distance_factor(service, version, mode, path + ["cell_check_distance_factor"])
                    self.flow_blocking_stabilization_parameters = self.__class__.flow_blocking_stabilization_parameters(service, version, mode, path + ["flow_blocking_stabilization_parameters"])
                    self.update_gap_regions = self.__class__.update_gap_regions(service, version, mode, path + ["update_gap_regions"])
                    self.clear_gap_regions = self.__class__.clear_gap_regions(service, version, mode, path + ["clear_gap_regions"])
                    self.precise_gap_marking = self.__class__.precise_gap_marking(service, version, mode, path + ["precise_gap_marking"])
                    self.render_flow_modeling_gaps = self.__class__.render_flow_modeling_gaps(service, version, mode, path + ["render_flow_modeling_gaps"])
                    self.reduce_gap_regions = self.__class__.reduce_gap_regions(service, version, mode, path + ["reduce_gap_regions"])
                    self.fill_data_in_gap_regions = self.__class__.fill_data_in_gap_regions(service, version, mode, path + ["fill_data_in_gap_regions"])
                    self.enhanced_data_interpolation = self.__class__.enhanced_data_interpolation(service, version, mode, path + ["enhanced_data_interpolation"])
                    self.sponge_layer = self.__class__.sponge_layer(service, version, mode, path + ["sponge_layer"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.include_coupled_walls = self.__class__.include_coupled_walls(service, version, mode, path + ["include_coupled_walls"])
                    self.check_cfl_condition = self.__class__.check_cfl_condition(service, version, mode, path + ["check_cfl_condition"])
                    self.extend_gap_regions = self.__class__.extend_gap_regions(service, version, mode, path + ["extend_gap_regions"])
                    self.revert_controls_to_default = self.__class__.revert_controls_to_default(service, version, mode, path + ["revert_controls_to_default"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.render_gap_interface = self.__class__.render_gap_interface(service, version, mode, path + ["render_gap_interface"])
                    super().__init__(service, version, mode, path)
                class expert(TUIMethod):
                    """
                    Enables/disables access to expert-level text commands 	for the gap model.
                    """
                class alternative_marking(TUIMethod):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                class cell_check_distance_factor(TUIMethod):
                    """
                    Enter value of the cell distance factor.
                    """
                class flow_blocking_stabilization_parameters(TUIMethod):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                class update_gap_regions(TUIMethod):
                    """
                    Update gap regions and gap model solution information.
                    """
                class clear_gap_regions(TUIMethod):
                    """
                    Clear gap model solution information and marks.
                    """
                class precise_gap_marking(TUIMethod):
                    """
                    Enables/disables the use of a more accurate search algorithm for marking cells in 	gap regions. Note that it can be costly, particularly 	for 3D cases or those with a large number of cells 	inside the gap regions. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class render_flow_modeling_gaps(TUIMethod):
                    """
                    Enables/disables the rendering of the solution in the cells of flow-modeling gap 	regions during postprocessing. This text command is only 	available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class reduce_gap_regions(TUIMethod):
                    """
                    Enables/disables a more restrictive algorithm for marking cells in gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class fill_data_in_gap_regions(TUIMethod):
                    """
                    Enables/disables the interpolation of solution data throughout the gap regions. This 	text command is only available if you have enabled the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class enhanced_data_interpolation(TUIMethod):
                    """
                    Enables/disables the use of enhanced data 	interpolation when updating information in gap regions. 	This text command is only available if you have enabled 	the 	define/gap-model/advanced-options/expert? 	text command.
                    """
                class sponge_layer(TUIMethod):
                    """
                    Allows you to edit the solution stabilization settings for flow-modeling gap regions 	that have sponge-layer local stabilization 	enabled.
                    """
                class solution_stabilization(TUIMethod):
                    """
                    Sets the global solution stabilization level for the gap 	regions.
                    """
                class include_coupled_walls(TUIMethod):
                    """
                    Include coupled walls in gap face zones.
                    """
                class check_cfl_condition(TUIMethod):
                    """
                    Enables/disables the printing of warnings if the time 	step size is too large based on a Courant (CFL) number 	automatically determined for your specified solution 	stability level.
                    """
                class extend_gap_regions(TUIMethod):
                    """
                    Enables/disables the extending of the gap regions by including additional cells in 	the vicinity of the gap interfaces during marking. This 	is useful when the default shape of the marked cells is 	negatively affecting solution stability or convergence 	behavior.
                    """
                class revert_controls_to_default(TUIMethod):
                    """
                    Reverts the global gap stabilization level and any related 	solver settings to the default.
                    """
                class verbosity(TUIMethod):
                    """
                    Sets the verbosity for messages printed in the console 	related to the gap model.
                    """
                class render_gap_interface(TUIMethod):
                    """
                    Enables/disables the rendering of the mesh surfaces inside the gap regions when 	displaying the mesh with contours. Note that the 	solution is still not rendered inside the flow-blocking 	gap regions.
                    """

        class materials(TUIMenu):
            """
            Enters the materials menu.
            """
            def __init__(self, service, version, mode, path):
                self.data_base = self.__class__.data_base(service, version, mode, path + ["data_base"])
                self.change_create = self.__class__.change_create(service, version, mode, path + ["change_create"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.copy_by_formula = self.__class__.copy_by_formula(service, version, mode, path + ["copy_by_formula"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class change_create(TUIMethod):
                """
                Changes the properties of a locally-stored material or create a new material.   Generally, the properties you enter at the prompts will be filtered according to your case and model settings. However, some of the listed properties may not match the selection choice in the Graphics User Interface. Typically, those excessive properties in the Text User Interface will not be used in your simulation.
                """
            class copy(TUIMethod):
                """
                Copies a material from the database.
                """
            class copy_by_formula(TUIMethod):
                """
                Copies a material from the database by formula.
                """
            class delete(TUIMethod):
                """
                Deletes a material from local storage.
                """
            class list_materials(TUIMethod):
                """
                Lists all locally-stored materials.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a locally-stored material.
                """

            class data_base(TUIMenu):
                """
                Enters the material database menu.
                """
                def __init__(self, service, version, mode, path):
                    self.database_type = self.__class__.database_type(service, version, mode, path + ["database_type"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.new = self.__class__.new(service, version, mode, path + ["new"])
                    self.save = self.__class__.save(service, version, mode, path + ["save"])
                    super().__init__(service, version, mode, path)
                class database_type(TUIMethod):
                    """
                    Sets the database type 	(fluent-database, 	granta-mds, or 	user-defined).
                    """
                class edit(TUIMethod):
                    """
                    Edits material.
                    """
                class list_materials(TUIMethod):
                    """
                    Lists all materials in the database.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of a material in the database.
                    """
                class new(TUIMethod):
                    """
                    Defines new material.
                    """
                class save(TUIMethod):
                    """
                    Saves user-defined database.
                    """

        class mixing_planes(TUIMenu):
            """
            Enters the mixing planes menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Creates a mixing plane.
                """
            class delete(TUIMethod):
                """
                Deletes a mixing plane.
                """
            class list(TUIMethod):
                """
                Lists defined mixing plane(s).
                """

            class set(TUIMenu):
                """
                Sets global parameters relevant to mixing planes.
                """
                def __init__(self, service, version, mode, path):
                    self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                    self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                    self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                    self.fix_pressure_level = self.__class__.fix_pressure_level(service, version, mode, path + ["fix_pressure_level"])
                    super().__init__(service, version, mode, path)
                class under_relaxation(TUIMethod):
                    """
                    Sets mixing plane under-relaxation factor.
                    """
                class averaging_method(TUIMethod):
                    """
                    Sets the mixing plane profile averaging method.
                    """
                class fix_pressure_level(TUIMethod):
                    """
                    Sets fixed pressure level using value based on define/reference-pressure-location.
                    """

                class conserve_swirl(TUIMenu):
                    """
                    Enters the menu to set swirl conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.report_swirl_integration = self.__class__.report_swirl_integration(service, version, mode, path + ["report_swirl_integration"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables swirl conservation in mixing plane.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enables/disables verbosity in swirl conservation calculations.
                        """
                    class report_swirl_integration(TUIMethod):
                        """
                        Reports swirl integration (Torque) on inflow and outflow zones.
                        """

                class conserve_total_enthalpy(TUIMenu):
                    """
                    Enters the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables total enthalpy conservation in mixing plane.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enables/disables verbosity in total-enthalpy conservation calculations.
                        """

        class models(TUIMenu):
            """
            Enters the models menu to configure the solver.
            """
            def __init__(self, service, version, mode, path):
                self.acoustics = self.__class__.acoustics(service, version, mode, path + ["acoustics"])
                self.optics = self.__class__.optics(service, version, mode, path + ["optics"])
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(service, version, mode, path + ["eulerian_wallfilm"])
                self.dpm = self.__class__.dpm(service, version, mode, path + ["dpm"])
                self.shell_conduction = self.__class__.shell_conduction(service, version, mode, path + ["shell_conduction"])
                self.system_coupling_settings = self.__class__.system_coupling_settings(service, version, mode, path + ["system_coupling_settings"])
                self.cht = self.__class__.cht(service, version, mode, path + ["cht"])
                self.two_temperature = self.__class__.two_temperature(service, version, mode, path + ["two_temperature"])
                self.multiphase = self.__class__.multiphase(service, version, mode, path + ["multiphase"])
                self.nox_parameters = self.__class__.nox_parameters(service, version, mode, path + ["nox_parameters"])
                self.soot_parameters = self.__class__.soot_parameters(service, version, mode, path + ["soot_parameters"])
                self.radiation = self.__class__.radiation(service, version, mode, path + ["radiation"])
                self.solver = self.__class__.solver(service, version, mode, path + ["solver"])
                self.species = self.__class__.species(service, version, mode, path + ["species"])
                self.viscous = self.__class__.viscous(service, version, mode, path + ["viscous"])
                self.structure = self.__class__.structure(service, version, mode, path + ["structure"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.electrolysis_setup = self.__class__.electrolysis_setup(service, version, mode, path + ["electrolysis_setup"])
                self.addon_module = self.__class__.addon_module(service, version, mode, path + ["addon_module"])
                self.axisymmetric = self.__class__.axisymmetric(service, version, mode, path + ["axisymmetric"])
                self.solidification_melting = self.__class__.solidification_melting(service, version, mode, path + ["solidification_melting"])
                self.crevice_model = self.__class__.crevice_model(service, version, mode, path + ["crevice_model"])
                self.crevice_model_controls = self.__class__.crevice_model_controls(service, version, mode, path + ["crevice_model_controls"])
                self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                self.noniterative_time_advance = self.__class__.noniterative_time_advance(service, version, mode, path + ["noniterative_time_advance"])
                self.nox = self.__class__.nox(service, version, mode, path + ["nox"])
                self.soot = self.__class__.soot(service, version, mode, path + ["soot"])
                self.steady = self.__class__.steady(service, version, mode, path + ["steady"])
                self.swirl = self.__class__.swirl(service, version, mode, path + ["swirl"])
                self.unsteady_1st_order = self.__class__.unsteady_1st_order(service, version, mode, path + ["unsteady_1st_order"])
                self.frozen_flux = self.__class__.frozen_flux(service, version, mode, path + ["frozen_flux"])
                self.unsteady_2nd_order = self.__class__.unsteady_2nd_order(service, version, mode, path + ["unsteady_2nd_order"])
                self.unsteady_2nd_order_bounded = self.__class__.unsteady_2nd_order_bounded(service, version, mode, path + ["unsteady_2nd_order_bounded"])
                self.unsteady_global_time = self.__class__.unsteady_global_time(service, version, mode, path + ["unsteady_global_time"])
                self.unsteady_structure_newmark = self.__class__.unsteady_structure_newmark(service, version, mode, path + ["unsteady_structure_newmark"])
                self.unsteady_structure_euler = self.__class__.unsteady_structure_euler(service, version, mode, path + ["unsteady_structure_euler"])
                self.battery_model = self.__class__.battery_model(service, version, mode, path + ["battery_model"])
                self.ablation = self.__class__.ablation(service, version, mode, path + ["ablation"])
                self.potential_and_li_ion_battery = self.__class__.potential_and_li_ion_battery(service, version, mode, path + ["potential_and_li_ion_battery"])
                super().__init__(service, version, mode, path)
            class addon_module(TUIMethod):
                """
                Loads addon module.
                """
            class axisymmetric(TUIMethod):
                """
                Specifies whether or not the domain is axisymmetric.
                """
            class solidification_melting(TUIMethod):
                """
                Enables/disables the solidification and melting model.
                """
            class crevice_model(TUIMethod):
                """
                Enables/disables the crevice model.
                """
            class crevice_model_controls(TUIMethod):
                """
                Enters the crevice model controls menu.
                """
            class energy(TUIMethod):
                """
                Enable/disable the energy model.
                """
            class noniterative_time_advance(TUIMethod):
                """
                Enables/disables noniterative time advancement scheme.
                """
            class nox(TUIMethod):
                """
                Enables/disables the NOx model.
                """
            class soot(TUIMethod):
                """
                Enables/disables the soot model.
                """
            class steady(TUIMethod):
                """
                Enables/disables the steady solution model.
                """
            class swirl(TUIMethod):
                """
                Enables/disables axisymmetric swirl velocity.
                """
            class unsteady_1st_order(TUIMethod):
                """
                Selects the first-order implicit formulation for transient simulations.
                """
            class frozen_flux(TUIMethod):
                """
                Enables/disables frozen flux formulation for transient flows.
                """
            class unsteady_2nd_order(TUIMethod):
                """
                Selects the second-order implicit formulation for transient simulations.
                """
            class unsteady_2nd_order_bounded(TUIMethod):
                """
                Selects the bounded second-order implicit formulation for transient simulations.
                """
            class unsteady_global_time(TUIMethod):
                """
                Selects the explicit transient formulation. This text command is only available for unsteady cases that use the density-based solver with the explicit formulation.
                """
            class unsteady_structure_newmark(TUIMethod):
                """
                Selects the Newmark method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """
            class unsteady_structure_euler(TUIMethod):
                """
                Selects the backward Euler method for the direct time integration of the finite element semi-discrete equation of motion. This text command is only available for transient simulations that use the structural model.
                """
            class battery_model(TUIMethod):
                """
                Enables the dual potential MSMD battery model. For text commands that become available when the battery model is enabled, refer to Battery Model Text Commands.
                """
            class ablation(TUIMethod):
                """
                Enables/disables the ablation model.
                """
            class potential_and_li_ion_battery(TUIMethod):
                """
                Enables/disables the electric-potential model.
                """

            class acoustics(TUIMenu):
                """
                Enters the acoustics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.far_field_parameters = self.__class__.far_field_parameters(service, version, mode, path + ["far_field_parameters"])
                    self.wave_equation_options = self.__class__.wave_equation_options(service, version, mode, path + ["wave_equation_options"])
                    self.sources_fft = self.__class__.sources_fft(service, version, mode, path + ["sources_fft"])
                    self.sponge_layers = self.__class__.sponge_layers(service, version, mode, path + ["sponge_layers"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.ffowcs_williams = self.__class__.ffowcs_williams(service, version, mode, path + ["ffowcs_williams"])
                    self.broad_band_noise = self.__class__.broad_band_noise(service, version, mode, path + ["broad_band_noise"])
                    self.modal_analysis = self.__class__.modal_analysis(service, version, mode, path + ["modal_analysis"])
                    self.wave_equation = self.__class__.wave_equation(service, version, mode, path + ["wave_equation"])
                    self.receivers = self.__class__.receivers(service, version, mode, path + ["receivers"])
                    self.export_source_data = self.__class__.export_source_data(service, version, mode, path + ["export_source_data"])
                    self.export_source_data_cgns = self.__class__.export_source_data_cgns(service, version, mode, path + ["export_source_data_cgns"])
                    self.sources = self.__class__.sources(service, version, mode, path + ["sources"])
                    self.read_compute_write = self.__class__.read_compute_write(service, version, mode, path + ["read_compute_write"])
                    self.write_acoustic_signals = self.__class__.write_acoustic_signals(service, version, mode, path + ["write_acoustic_signals"])
                    self.compute_write = self.__class__.compute_write(service, version, mode, path + ["compute_write"])
                    self.write_centroid_info = self.__class__.write_centroid_info(service, version, mode, path + ["write_centroid_info"])
                    self.acoustic_modal_analysis = self.__class__.acoustic_modal_analysis(service, version, mode, path + ["acoustic_modal_analysis"])
                    self.export_volumetric_sources = self.__class__.export_volumetric_sources(service, version, mode, path + ["export_volumetric_sources"])
                    self.export_volumetric_sources_cgns = self.__class__.export_volumetric_sources_cgns(service, version, mode, path + ["export_volumetric_sources_cgns"])
                    self.display_flow_time = self.__class__.display_flow_time(service, version, mode, path + ["display_flow_time"])
                    self.cylindrical_export = self.__class__.cylindrical_export(service, version, mode, path + ["cylindrical_export"])
                    self.auto_prune = self.__class__.auto_prune(service, version, mode, path + ["auto_prune"])
                    self.moving_receiver = self.__class__.moving_receiver(service, version, mode, path + ["moving_receiver"])
                    self.convective_effects = self.__class__.convective_effects(service, version, mode, path + ["convective_effects"])
                    self.display_frequencies = self.__class__.display_frequencies(service, version, mode, path + ["display_frequencies"])
                    super().__init__(service, version, mode, path)
                class off(TUIMethod):
                    """
                    Enables/disables the acoustics model.
                    """
                class ffowcs_williams(TUIMethod):
                    """
                    Enables/disables the Ffowcs-Williams-and-Hawkings model.
                    """
                class broad_band_noise(TUIMethod):
                    """
                    Enables/disables the broadband noise model.
                    """
                class modal_analysis(TUIMethod):
                    """
                    Enable/disable the modal analysis model.
                    """
                class wave_equation(TUIMethod):
                    """
                    Enables/disables the wave equation model.
                    """
                class receivers(TUIMethod):
                    """
                    Sets acoustic receivers.
                    """
                class export_source_data(TUIMethod):
                    """
                    Enables/disables the export of acoustic source data in 	ASD format during the wave equation model run.
                    """
                class export_source_data_cgns(TUIMethod):
                    """
                    Enables/disables the export of acoustic source data in CGNS format.
                    """
                class sources(TUIMethod):
                    """
                    Sets acoustic sources.
                    """
                class read_compute_write(TUIMethod):
                    """
                    Reads acoustic source data files and computes sound pressure.
                    """
                class write_acoustic_signals(TUIMethod):
                    """
                    Writes on-the-fly sound pressure.
                    """
                class compute_write(TUIMethod):
                    """
                    Computes sound pressure.
                    """
                class write_centroid_info(TUIMethod):
                    """
                    Writes centroid info.
                    """
                class acoustic_modal_analysis(TUIMethod):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                class export_volumetric_sources(TUIMethod):
                    """
                    Enables/disables the export of fluid zones.
                    """
                class export_volumetric_sources_cgns(TUIMethod):
                    """
                    Enables/disables the export of fluid zones.
                    """
                class display_flow_time(TUIMethod):
                    """
                    Enables/disables the display of flow time during read-and-compute.
                    """
                class cylindrical_export(TUIMethod):
                    """
                    Enables/disables the export of data in cylindrical coordinates.
                    """
                class auto_prune(TUIMethod):
                    """
                    Enables/disables auto prune of the receiver signal(s) during 	read-and-compute.
                    """
                class moving_receiver(TUIMethod):
                    """
                    Enables/disables the moving receiver option.
                    """
                class convective_effects(TUIMethod):
                    """
                    Enables/disables the convective effects option.
                    """
                class display_frequencies(TUIMethod):
                    """
                    Display resonance frequencies.
                    """

                class far_field_parameters(TUIMenu):
                    """
                    Enters the menu to specify the far-field density and 	speed of sound. Note that this menu is currently 	available only with the acoustics wave equation model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.far_field_density = self.__class__.far_field_density(service, version, mode, path + ["far_field_density"])
                        self.far_field_sound_speed = self.__class__.far_field_sound_speed(service, version, mode, path + ["far_field_sound_speed"])
                        super().__init__(service, version, mode, path)
                    class far_field_density(TUIMethod):
                        """
                        Specifies the far-field density value for the acoustics wave equation model.
                        """
                    class far_field_sound_speed(TUIMethod):
                        """
                        Specifies the far-field speed of sound value for the acoustics wave equation model.
                        """

                class wave_equation_options(TUIMenu):
                    """
                    Enters the menu to define the acoustics wave equation 	model options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.basic_shapes = self.__class__.basic_shapes(service, version, mode, path + ["basic_shapes"])
                        self.remote_receivers_options = self.__class__.remote_receivers_options(service, version, mode, path + ["remote_receivers_options"])
                        self.time_filter_source = self.__class__.time_filter_source(service, version, mode, path + ["time_filter_source"])
                        self.sponge_layer_factor = self.__class__.sponge_layer_factor(service, version, mode, path + ["sponge_layer_factor"])
                        self.sponge_layer_base_level = self.__class__.sponge_layer_base_level(service, version, mode, path + ["sponge_layer_base_level"])
                        self.source_mask_udf = self.__class__.source_mask_udf(service, version, mode, path + ["source_mask_udf"])
                        self.sponge_layer_udf = self.__class__.sponge_layer_udf(service, version, mode, path + ["sponge_layer_udf"])
                        self.remote_receivers = self.__class__.remote_receivers(service, version, mode, path + ["remote_receivers"])
                        super().__init__(service, version, mode, path)
                    class time_filter_source(TUIMethod):
                        """
                        Enables/disables a time filter for the sound source.
                        """
                    class sponge_layer_factor(TUIMethod):
                        """
                        Specifies the factor of the artificial viscosity coefficient.
                        """
                    class sponge_layer_base_level(TUIMethod):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                    class source_mask_udf(TUIMethod):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the source mask.
                        """
                    class sponge_layer_udf(TUIMethod):
                        """
                        Specifies the name of a user-defined function, which defines geometry of the sponge layer.
                        """
                    class remote_receivers(TUIMethod):
                        """
                        Enables/disables the Kirchhoff integral model.
                        """

                    class basic_shapes(TUIMenu):
                        """
                        Enters the menu to define the geometry of the source mask and sponge layer using the basic shapes, represented by the cell registers of the type "Region".
                        """
                        def __init__(self, service, version, mode, path):
                            self.list_region_registers = self.__class__.list_region_registers(service, version, mode, path + ["list_region_registers"])
                            self.list_source_mask_shapes = self.__class__.list_source_mask_shapes(service, version, mode, path + ["list_source_mask_shapes"])
                            self.list_sponge_layer_shapes = self.__class__.list_sponge_layer_shapes(service, version, mode, path + ["list_sponge_layer_shapes"])
                            self.add_source_mask_shape = self.__class__.add_source_mask_shape(service, version, mode, path + ["add_source_mask_shape"])
                            self.add_sponge_layer_shape = self.__class__.add_sponge_layer_shape(service, version, mode, path + ["add_sponge_layer_shape"])
                            self.remove_source_mask_shape = self.__class__.remove_source_mask_shape(service, version, mode, path + ["remove_source_mask_shape"])
                            self.remove_sponge_layer_shape = self.__class__.remove_sponge_layer_shape(service, version, mode, path + ["remove_sponge_layer_shape"])
                            super().__init__(service, version, mode, path)
                        class list_region_registers(TUIMethod):
                            """
                            List all available cell registers of the type "Region".
                            """
                        class list_source_mask_shapes(TUIMethod):
                            """
                            List basic shapes, which are currently used in the definition of the source mask geometry.
                            """
                        class list_sponge_layer_shapes(TUIMethod):
                            """
                            List basic shapes, which are currently used in the definition of the sponge layer geometry.
                            """
                        class add_source_mask_shape(TUIMethod):
                            """
                            Adds a basic shape to the definition of the source mask geometry.
                            """
                        class add_sponge_layer_shape(TUIMethod):
                            """
                            Adds a basic shape to the definition of the sponge layer geometry.
                            """
                        class remove_source_mask_shape(TUIMethod):
                            """
                            Remove a basic shape from the definition of the source mask geometry.
                            """
                        class remove_sponge_layer_shape(TUIMethod):
                            """
                            Remove a basic shape from the definition of the sponge layer geometry.
                            """

                    class remote_receivers_options(TUIMenu):
                        """
                        Enters the menu to define remote receivers for the Kirchhoff integral model.
                        """
                        def __init__(self, service, version, mode, path):
                            self.integration_surface = self.__class__.integration_surface(service, version, mode, path + ["integration_surface"])
                            self.write_signals = self.__class__.write_signals(service, version, mode, path + ["write_signals"])
                            super().__init__(service, version, mode, path)
                        class integration_surface(TUIMethod):
                            """
                            Selects the integration surface for the Kirchhoff model.
                            """
                        class write_signals(TUIMethod):
                            """
                            Writes the computed receiver signals to the ASCII files.
                            """

                class sources_fft(TUIMenu):
                    """
                    Enters the acoustic sources fast Fourier transform (FFT) menu, to compute Fourier 	spectra from acoustic source data (ASD) files, create 	postprocessing variables for the pressure signals, and 	write CGNS files of the spectrum data.
                    """
                    def __init__(self, service, version, mode, path):
                        self.fft_surface_variables = self.__class__.fft_surface_variables(service, version, mode, path + ["fft_surface_variables"])
                        self.read_asd_files = self.__class__.read_asd_files(service, version, mode, path + ["read_asd_files"])
                        self.compute_fft_fields = self.__class__.compute_fft_fields(service, version, mode, path + ["compute_fft_fields"])
                        self.write_cgns_files = self.__class__.write_cgns_files(service, version, mode, path + ["write_cgns_files"])
                        self.clean_up_storage_area = self.__class__.clean_up_storage_area(service, version, mode, path + ["clean_up_storage_area"])
                        super().__init__(service, version, mode, path)
                    class read_asd_files(TUIMethod):
                        """
                        Reads ASD files to perform FFT of the pressure history field.
                        """
                    class compute_fft_fields(TUIMethod):
                        """
                        Computes FFT of the read pressure histories. The computed spectra replace the pressure histories in memory.
                        """
                    class write_cgns_files(TUIMethod):
                        """
                        Writes surface pressure spectra in CGNS format, which can be used for one-way coupling with Ansys Mechanical in the frequency domain.
                        """
                    class clean_up_storage_area(TUIMethod):
                        """
                        De-allocates memory used to store the pressure histories and their Fourier spectra, as well as any created surface variables for the visualization.
                        """

                    class fft_surface_variables(TUIMenu):
                        """
                        Enters the menu to create surface variables from the computed Fourier spectra for visualization.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create_octave_bands = self.__class__.create_octave_bands(service, version, mode, path + ["create_octave_bands"])
                            self.create_third_bands = self.__class__.create_third_bands(service, version, mode, path + ["create_third_bands"])
                            self.create_constant_width_bands = self.__class__.create_constant_width_bands(service, version, mode, path + ["create_constant_width_bands"])
                            self.create_set_of_modes = self.__class__.create_set_of_modes(service, version, mode, path + ["create_set_of_modes"])
                            self.remove_variables = self.__class__.remove_variables(service, version, mode, path + ["remove_variables"])
                            super().__init__(service, version, mode, path)
                        class create_octave_bands(TUIMethod):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 17 technical octaves.
                            """
                        class create_third_bands(TUIMethod):
                            """
                            Creates either the surface pressure level (SPL) variables or the PSD of dp/dt variables for 54 technical thirds.
                            """
                        class create_constant_width_bands(TUIMethod):
                            """
                            Selects up to 20 constant width bands and creates either the surface pressures level (SPL) variables or the PSD of dp/dt variables for them.
                            """
                        class create_set_of_modes(TUIMethod):
                            """
                            Selects up to 20 individual Fourier modes and create variable pairs for them, containing the real and the imaginary parts of the complex Fourier amplitudes.
                            """
                        class remove_variables(TUIMethod):
                            """
                            Removes all variables created in this menu.
                            """

                class sponge_layers(TUIMenu):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, service, version, mode, path):
                        self.activate = self.__class__.activate(service, version, mode, path + ["activate"])
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.deactivate = self.__class__.deactivate(service, version, mode, path + ["deactivate"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_active = self.__class__.list_active(service, version, mode, path + ["list_active"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        super().__init__(service, version, mode, path)
                    class activate(TUIMethod):
                        """
                        Activate a sponge object.
                        """
                    class add(TUIMethod):
                        """
                        Add a new sponge layer definition.
                        """
                    class deactivate(TUIMethod):
                        """
                        Deactivate a sponge layer definition.
                        """
                    class edit(TUIMethod):
                        """
                        Edits an existing sponge layer. You can revise the fields listed previously for the define/models/acoustics/sponge-layers/add text command.
                        """
                    class delete(TUIMethod):
                        """
                        Deletes an existing sponge layer definition.
                        """
                    class list(TUIMethod):
                        """
                        Prints a list of the existing sponge layers in the console.
                        """
                    class list_active(TUIMethod):
                        """
                        List the names of the active sponge layer definitions.
                        """
                    class list_properties(TUIMethod):
                        """
                        Prints the properties of an existing sponge layer of your choice in the console.
                        """

            class optics(TUIMenu):
                """
                Enter the optics model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.add_beam = self.__class__.add_beam(service, version, mode, path + ["add_beam"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable/disable optics model.
                    """
                class add_beam(TUIMethod):
                    """
                    Add optical beam grid.
                    """

                class set(TUIMenu):
                    """
                    Enter the set menu for optics model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.sampling = self.__class__.sampling(service, version, mode, path + ["sampling"])
                        self.index_of_refraction = self.__class__.index_of_refraction(service, version, mode, path + ["index_of_refraction"])
                        self.running_average = self.__class__.running_average(service, version, mode, path + ["running_average"])
                        super().__init__(service, version, mode, path)
                    class sampling(TUIMethod):
                        """
                        Specify when the fluid density field is sampled.
                        """
                    class index_of_refraction(TUIMethod):
                        """
                        Specify the model parameters of index of refraction.
                        """
                    class running_average(TUIMethod):
                        """
                        Setup the running average of the collected density field.
                        """

            class eulerian_wallfilm(TUIMenu):
                """
                Enters the Eulerian wall film model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.coupled_solution = self.__class__.coupled_solution(service, version, mode, path + ["coupled_solution"])
                    self.implicit_options = self.__class__.implicit_options(service, version, mode, path + ["implicit_options"])
                    self.enable_wallfilm_model = self.__class__.enable_wallfilm_model(service, version, mode, path + ["enable_wallfilm_model"])
                    self.initialize_wallfilm_model = self.__class__.initialize_wallfilm_model(service, version, mode, path + ["initialize_wallfilm_model"])
                    self.solve_wallfilm_equation = self.__class__.solve_wallfilm_equation(service, version, mode, path + ["solve_wallfilm_equation"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.film_material = self.__class__.film_material(service, version, mode, path + ["film_material"])
                    self.solution_options = self.__class__.solution_options(service, version, mode, path + ["solution_options"])
                    super().__init__(service, version, mode, path)
                class enable_wallfilm_model(TUIMethod):
                    """
                    Enables/disables Eulerian Wall Film Model.
                    """
                class initialize_wallfilm_model(TUIMethod):
                    """
                    Initializes Eulerian Wall Film Model.
                    """
                class solve_wallfilm_equation(TUIMethod):
                    """
                    Activates Eulerian Wall Film Equations.
                    """
                class model_options(TUIMethod):
                    """
                    Set Eulerian wall film model options.
                    """
                class film_material(TUIMethod):
                    """
                    Sets Film Material and Properties.
                    """
                class solution_options(TUIMethod):
                    """
                    Sets Eulerian Wall Film Model Solution Options.
                    """

                class coupled_solution(TUIMenu):
                    """
                    Enters the Coupled-Solution menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_coupled_solution = self.__class__.enable_coupled_solution(service, version, mode, path + ["enable_coupled_solution"])
                        self.enable_curvature_smoothing = self.__class__.enable_curvature_smoothing(service, version, mode, path + ["enable_curvature_smoothing"])
                        super().__init__(service, version, mode, path)
                    class enable_coupled_solution(TUIMethod):
                        """
                        Enables/disables the coupled solution method.
                        """
                    class enable_curvature_smoothing(TUIMethod):
                        """
                        Enables/disables the film curvature smoothing option and sets the smoothing parameters.
                        """

                class implicit_options(TUIMenu):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, service, version, mode, path):
                        self.new_implicit_scheme = self.__class__.new_implicit_scheme(service, version, mode, path + ["new_implicit_scheme"])
                        self.relative_error_residual = self.__class__.relative_error_residual(service, version, mode, path + ["relative_error_residual"])
                        super().__init__(service, version, mode, path)
                    class new_implicit_scheme(TUIMethod):
                        """
                        Enable alternative implicit scheme.
                        """
                    class relative_error_residual(TUIMethod):
                        """
                        Enable relative error residual.
                        """

            class dpm(TUIMenu):
                """
                Enters the dispersed phase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.collisions = self.__class__.collisions(service, version, mode, path + ["collisions"])
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(service, version, mode, path + ["erosion_dynamic_mesh"])
                    self.interaction = self.__class__.interaction(service, version, mode, path + ["interaction"])
                    self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.splash_options = self.__class__.splash_options(service, version, mode, path + ["splash_options"])
                    self.stripping_options = self.__class__.stripping_options(service, version, mode, path + ["stripping_options"])
                    self.clear_particles_from_domain = self.__class__.clear_particles_from_domain(service, version, mode, path + ["clear_particles_from_domain"])
                    self.fill_injection_material_sources = self.__class__.fill_injection_material_sources(service, version, mode, path + ["fill_injection_material_sources"])
                    self.injections = self.__class__.injections(service, version, mode, path + ["injections"])
                    self.unsteady_tracking = self.__class__.unsteady_tracking(service, version, mode, path + ["unsteady_tracking"])
                    self.spray_model = self.__class__.spray_model(service, version, mode, path + ["spray_model"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    super().__init__(service, version, mode, path)
                class clear_particles_from_domain(TUIMethod):
                    """
                    Removes/keeps all particles currently in the domain.
                    """
                class fill_injection_material_sources(TUIMethod):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                class injections(TUIMethod):
                    """
                    Enters the injections menu.
                    """
                class unsteady_tracking(TUIMethod):
                    """
                    Enables/disables unsteady particle tracking.
                    """
                class spray_model(TUIMethod):
                    """
                    Enters the spray model menu. This command is available only if the breakup model 	enabled globally.
                    """
                class user_defined(TUIMethod):
                    """
                    Sets DPM user-defined functions.
                    """

                class collisions(TUIMenu):
                    """
                    Enters the DEM collisions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.collision_partners = self.__class__.collision_partners(service, version, mode, path + ["collision_partners"])
                        self.collision_pair_settings = self.__class__.collision_pair_settings(service, version, mode, path + ["collision_pair_settings"])
                        self.list_all_pair_settings = self.__class__.list_all_pair_settings(service, version, mode, path + ["list_all_pair_settings"])
                        self.dem_collisions = self.__class__.dem_collisions(service, version, mode, path + ["dem_collisions"])
                        self.collision_mesh = self.__class__.collision_mesh(service, version, mode, path + ["collision_mesh"])
                        self.max_particle_velocity = self.__class__.max_particle_velocity(service, version, mode, path + ["max_particle_velocity"])
                        super().__init__(service, version, mode, path)
                    class collision_pair_settings(TUIMethod):
                        """
                        Supplies settings for collisions to a pair of collision partners. You will be prompted to specify theImpact collision partner and the Target collision partner.
                        """
                    class list_all_pair_settings(TUIMethod):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                    class dem_collisions(TUIMethod):
                        """
                        Enables/disables the DEM collision model.
                        """
                    class collision_mesh(TUIMethod):
                        """
                        Input for the collision mesh.
                        """
                    class max_particle_velocity(TUIMethod):
                        """
                        Sets the maximum particle velocity that may arise from collisions.
                        """

                    class collision_partners(TUIMenu):
                        """
                        Manages collision partners.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Creates a collision partner.
                            """
                        class delete(TUIMethod):
                            """
                            Deletes a collision partner.
                            """
                        class copy(TUIMethod):
                            """
                            Copies a collision partner.
                            """
                        class rename(TUIMethod):
                            """
                            Renames a collision partner.
                            """
                        class list(TUIMethod):
                            """
                            Lists all known collision partners.
                            """

                class erosion_dynamic_mesh(TUIMenu):
                    """
                    Enters the menu to enable/configure/run the erosion-dynamic mesh interaction.
                    """
                    def __init__(self, service, version, mode, path):
                        self.general_parameters = self.__class__.general_parameters(service, version, mode, path + ["general_parameters"])
                        self.run_parameters = self.__class__.run_parameters(service, version, mode, path + ["run_parameters"])
                        self.enable_erosion_dynamic_mesh_coupling = self.__class__.enable_erosion_dynamic_mesh_coupling(service, version, mode, path + ["enable_erosion_dynamic_mesh_coupling"])
                        self.run_simulation = self.__class__.run_simulation(service, version, mode, path + ["run_simulation"])
                        super().__init__(service, version, mode, path)
                    class enable_erosion_dynamic_mesh_coupling(TUIMethod):
                        """
                        Enables mesh deformation due to wall erosion.
                        """
                    class run_simulation(TUIMethod):
                        """
                        Performs a coupled erosion-dynamic mesh simulation.
                        """

                    class general_parameters(TUIMenu):
                        """
                        Enters the menu for setting erosion coupling with dynamic mesh.
                        """
                        def __init__(self, service, version, mode, path):
                            self.erosion_settings = self.__class__.erosion_settings(service, version, mode, path + ["erosion_settings"])
                            self.dynamic_mesh_settings = self.__class__.dynamic_mesh_settings(service, version, mode, path + ["dynamic_mesh_settings"])
                            self.participating_walls = self.__class__.participating_walls(service, version, mode, path + ["participating_walls"])
                            super().__init__(service, version, mode, path)
                        class erosion_settings(TUIMethod):
                            """
                            Sets parameters for erosion calculations.
                            """
                        class dynamic_mesh_settings(TUIMethod):
                            """
                            Sets parameters for dynamic mesh calculations.
                            """
                        class participating_walls(TUIMethod):
                            """
                            Specifies all participating walls.
                            """

                    class run_parameters(TUIMenu):
                        """
                        Manages erosion-dynamic mesh run settings.
                        """
                        def __init__(self, service, version, mode, path):
                            self.mesh_motion_time_step = self.__class__.mesh_motion_time_step(service, version, mode, path + ["mesh_motion_time_step"])
                            self.simulation_termination = self.__class__.simulation_termination(service, version, mode, path + ["simulation_termination"])
                            self.flow_simulation_control = self.__class__.flow_simulation_control(service, version, mode, path + ["flow_simulation_control"])
                            self.autosave_files = self.__class__.autosave_files(service, version, mode, path + ["autosave_files"])
                            self.autosave_graphics = self.__class__.autosave_graphics(service, version, mode, path + ["autosave_graphics"])
                            super().__init__(service, version, mode, path)
                        class mesh_motion_time_step(TUIMethod):
                            """
                            Sets the mesh motion time stepping parameters and method.
                            """
                        class simulation_termination(TUIMethod):
                            """
                            Sets the total time of erosion.
                            """
                        class flow_simulation_control(TUIMethod):
                            """
                            Sets the number of iterations per flow simulation step.
                            """
                        class autosave_files(TUIMethod):
                            """
                            Sets the iteration increment and filename to save data files.
                            """
                        class autosave_graphics(TUIMethod):
                            """
                            Sets the iteration increment to save graphics files.
                            """

                class interaction(TUIMenu):
                    """
                    Sets parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self.choice_of_eulerian_phase_for_interaction = self.__class__.choice_of_eulerian_phase_for_interaction(service, version, mode, path + ["choice_of_eulerian_phase_for_interaction"])
                        self.coupled_calculations = self.__class__.coupled_calculations(service, version, mode, path + ["coupled_calculations"])
                        self.dpm_iteration_interval = self.__class__.dpm_iteration_interval(service, version, mode, path + ["dpm_iteration_interval"])
                        self.underrelaxation_factor = self.__class__.underrelaxation_factor(service, version, mode, path + ["underrelaxation_factor"])
                        self.implicit_momentum_coupling = self.__class__.implicit_momentum_coupling(service, version, mode, path + ["implicit_momentum_coupling"])
                        self.implicit_source_term_coupling = self.__class__.implicit_source_term_coupling(service, version, mode, path + ["implicit_source_term_coupling"])
                        self.linearized_dpm_source_terms = self.__class__.linearized_dpm_source_terms(service, version, mode, path + ["linearized_dpm_source_terms"])
                        self.replace_dpm_mass_source_by_mixture_fraction = self.__class__.replace_dpm_mass_source_by_mixture_fraction(service, version, mode, path + ["replace_dpm_mass_source_by_mixture_fraction"])
                        self.linearized_dpm_mixture_fraction_source_terms = self.__class__.linearized_dpm_mixture_fraction_source_terms(service, version, mode, path + ["linearized_dpm_mixture_fraction_source_terms"])
                        self.linearized_dpm_species_source_terms = self.__class__.linearized_dpm_species_source_terms(service, version, mode, path + ["linearized_dpm_species_source_terms"])
                        self.keep_linearized_dpm_source_terms_constant = self.__class__.keep_linearized_dpm_source_terms_constant(service, version, mode, path + ["keep_linearized_dpm_source_terms_constant"])
                        self.linearized_dpm_source_terms_limiter = self.__class__.linearized_dpm_source_terms_limiter(service, version, mode, path + ["linearized_dpm_source_terms_limiter"])
                        self.update_dpm_sources_every_flow_iteration = self.__class__.update_dpm_sources_every_flow_iteration(service, version, mode, path + ["update_dpm_sources_every_flow_iteration"])
                        self.linear_growth_of_dpm_source_term = self.__class__.linear_growth_of_dpm_source_term(service, version, mode, path + ["linear_growth_of_dpm_source_term"])
                        self.reset_sources_at_timestep = self.__class__.reset_sources_at_timestep(service, version, mode, path + ["reset_sources_at_timestep"])
                        self.enable_flow_blocking_by_particles = self.__class__.enable_flow_blocking_by_particles(service, version, mode, path + ["enable_flow_blocking_by_particles"])
                        self.enable_source_scaling_due_to_flow_blocking = self.__class__.enable_source_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_source_scaling_due_to_flow_blocking"])
                        self.enable_drag_scaling_due_to_flow_blocking = self.__class__.enable_drag_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_drag_scaling_due_to_flow_blocking"])
                        self.max_vf_allowed_for_blocking = self.__class__.max_vf_allowed_for_blocking(service, version, mode, path + ["max_vf_allowed_for_blocking"])
                        self.min_vf_threshold_for_dpm_src_scaling = self.__class__.min_vf_threshold_for_dpm_src_scaling(service, version, mode, path + ["min_vf_threshold_for_dpm_src_scaling"])
                        self.ddpm_iad_particle = self.__class__.ddpm_iad_particle(service, version, mode, path + ["ddpm_iad_particle"])
                        self.ddpm_energy_coupling_via_source_term = self.__class__.ddpm_energy_coupling_via_source_term(service, version, mode, path + ["ddpm_energy_coupling_via_source_term"])
                        self.ddpm_enhanced_inter_phase_exchange = self.__class__.ddpm_enhanced_inter_phase_exchange(service, version, mode, path + ["ddpm_enhanced_inter_phase_exchange"])
                        super().__init__(service, version, mode, path)
                    class choice_of_eulerian_phase_for_interaction(TUIMethod):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                    class coupled_calculations(TUIMethod):
                        """
                        Selects whether or not to couple continuous and discrete phase calculations.
                        """
                    class dpm_iteration_interval(TUIMethod):
                        """
                        Sets the frequency with which the particle trajectory calculations are introduced.
                        """
                    class underrelaxation_factor(TUIMethod):
                        """
                        Sets the under-relaxation factor for the discrete phase sources.
                        """
                    class implicit_momentum_coupling(TUIMethod):
                        """
                        Enables/disables implicit treatment for the DPM momentum source terms.
                        """
                    class implicit_source_term_coupling(TUIMethod):
                        """
                        Enables/disables implicit treatment for all DPM source terms.
                        """
                    class linearized_dpm_source_terms(TUIMethod):
                        """
                        Enables/disables linearization of source terms for the discrete phase.
                        """
                    class replace_dpm_mass_source_by_mixture_fraction(TUIMethod):
                        """
                        When enabled, recalculates the mixture fraction source terms as a function of the primary mixture fraction. This command is available for non- or partially-premixed combustion cases only.
                        """
                    class linearized_dpm_mixture_fraction_source_terms(TUIMethod):
                        """
                        Enables/disables linearization of mixture fraction source terms. This command is available only for non- or partially-premixed combustion cases.
                        """
                    class linearized_dpm_species_source_terms(TUIMethod):
                        """
                        Perform linearization of species source terms.
                        """
                    class keep_linearized_dpm_source_terms_constant(TUIMethod):
                        """
                        Keep linearized DPM source terms constant until the next DPM Update.
                        """
                    class linearized_dpm_source_terms_limiter(TUIMethod):
                        """
                        Relative limit for DPM source linear coefficient with respect to fluid linear Ap coefficient.
                        """
                    class update_dpm_sources_every_flow_iteration(TUIMethod):
                        """
                        Enables/disables the update of DPM source terms every flow iteration (if this option is not enabled, the terms will be updated every DPM iteration).
                        """
                    class linear_growth_of_dpm_source_term(TUIMethod):
                        """
                        Enables/disables the linear ramping up of the DPM source terms at every DPM iteration.
                        """
                    class reset_sources_at_timestep(TUIMethod):
                        """
                        Enables/disables flush of DPM source terms at beginning of every time step.
                        """
                    class enable_flow_blocking_by_particles(TUIMethod):
                        """
                        Enable/disable inclusion of DPM volume fraction in continuous flow.
                        """
                    class enable_source_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                    class enable_drag_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        Enable/disable scaling of DPM drag coefficient due to inclusion of DPM volume fraction in continuous flow.
                        """
                    class max_vf_allowed_for_blocking(TUIMethod):
                        """
                        Maximum DPM volume fraction used in continuous flow.
                        """
                    class min_vf_threshold_for_dpm_src_scaling(TUIMethod):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                    class ddpm_iad_particle(TUIMethod):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                    class ddpm_energy_coupling_via_source_term(TUIMethod):
                        """
                        Energy coupling in DDPM established via source term.
                        """
                    class ddpm_enhanced_inter_phase_exchange(TUIMethod):
                        """
                        Enhanced Eulerian inter-phase exchange.
                        """

                class numerics(TUIMenu):
                    """
                    Enters the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(service, version, mode, path + ["high_resolution_tracking"])
                        self.coupled_heat_mass_update = self.__class__.coupled_heat_mass_update(service, version, mode, path + ["coupled_heat_mass_update"])
                        self.minimum_liquid_fraction = self.__class__.minimum_liquid_fraction(service, version, mode, path + ["minimum_liquid_fraction"])
                        self.underrelax_film_height = self.__class__.underrelax_film_height(service, version, mode, path + ["underrelax_film_height"])
                        self.vaporization_limiting_factors = self.__class__.vaporization_limiting_factors(service, version, mode, path + ["vaporization_limiting_factors"])
                        self.tracking_parameters = self.__class__.tracking_parameters(service, version, mode, path + ["tracking_parameters"])
                        self.tracking_scheme = self.__class__.tracking_scheme(service, version, mode, path + ["tracking_scheme"])
                        self.tracking_statistics = self.__class__.tracking_statistics(service, version, mode, path + ["tracking_statistics"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                        self.automated_scheme_selection = self.__class__.automated_scheme_selection(service, version, mode, path + ["automated_scheme_selection"])
                        self.drag_law = self.__class__.drag_law(service, version, mode, path + ["drag_law"])
                        self.enable_node_based_averaging = self.__class__.enable_node_based_averaging(service, version, mode, path + ["enable_node_based_averaging"])
                        self.average_source_terms = self.__class__.average_source_terms(service, version, mode, path + ["average_source_terms"])
                        self.average_DDPM_variables = self.__class__.average_DDPM_variables(service, version, mode, path + ["average_DDPM_variables"])
                        self.average_each_step = self.__class__.average_each_step(service, version, mode, path + ["average_each_step"])
                        self.average_kernel = self.__class__.average_kernel(service, version, mode, path + ["average_kernel"])
                        self.gaussian_factor = self.__class__.gaussian_factor(service, version, mode, path + ["gaussian_factor"])
                        self.mppic_settings = self.__class__.mppic_settings(service, version, mode, path + ["mppic_settings"])
                        self.enhanced_packing_limit_numerics = self.__class__.enhanced_packing_limit_numerics(service, version, mode, path + ["enhanced_packing_limit_numerics"])
                        super().__init__(service, version, mode, path)
                    class coupled_heat_mass_update(TUIMethod):
                        """
                        Enables/disables coupled heat and mass update.
                        """
                    class minimum_liquid_fraction(TUIMethod):
                        """
                        A droplet evaporates completely when the remaining mass is below this fraction of the initial droplet mass.
                        """
                    class underrelax_film_height(TUIMethod):
                        """
                        Sets the under-relaxation factor for the film height calculation. The recommended values range between 0.5 (default) and 0.9.
                        """
                    class vaporization_limiting_factors(TUIMethod):
                        """
                        Sets the Vaporization Fractional Change Limits.
                        """
                    class tracking_parameters(TUIMethod):
                        """
                        Sets parameters for the (initial) tracking step length.
                        """
                    class tracking_scheme(TUIMethod):
                        """
                        Specifies a tracking scheme.
                        """
                    class tracking_statistics(TUIMethod):
                        """
                        Controls the format of the one-line tracking statistics to be printed after every DPM tracking pass. A value of 0 (the default) prints only fates with non-zero values. A value of 1 prints all fates, including fates with zero values.
                        """
                    class verbosity(TUIMethod):
                        """
                        Adjust the DPM tracker's verbosity level.
                        """
                    class error_control(TUIMethod):
                        """
                        Adapts integration step length based on a maximum error.
                        """
                    class automated_scheme_selection(TUIMethod):
                        """
                        Enables/disables the adaptation of integration step length based on a maximum error.
                        """
                    class drag_law(TUIMethod):
                        """
                        Sets the drag law.
                        """
                    class enable_node_based_averaging(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DPM quantities.
                        """
                    class average_source_terms(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DPM source terms.
                        """
                    class average_DDPM_variables(TUIMethod):
                        """
                        Enables/disables mesh node averaging of DDPM quantities.
                        """
                    class average_each_step(TUIMethod):
                        """
                        Enables/disables mesh node averaging during integration time step.
                        """
                    class average_kernel(TUIMethod):
                        """
                        Specifies the averaging kernel to use for mesh node averaging.
                        """
                    class gaussian_factor(TUIMethod):
                        """
                        Specifies the Gaussian constant when using thegaussian kernel for mesh node averaging.
                        """
                    class mppic_settings(TUIMethod):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                    class enhanced_packing_limit_numerics(TUIMethod):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """

                    class high_resolution_tracking(TUIMenu):
                        """
                        Enters the high resolution tracking menu. See  for more information about these options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(service, version, mode, path + ["barycentric_interpolation"])
                            self.particle_relocation = self.__class__.particle_relocation(service, version, mode, path + ["particle_relocation"])
                            self.enable_high_resolution_tracking = self.__class__.enable_high_resolution_tracking(service, version, mode, path + ["enable_high_resolution_tracking"])
                            self.enable_barycentric_intersections = self.__class__.enable_barycentric_intersections(service, version, mode, path + ["enable_barycentric_intersections"])
                            self.use_barycentric_sampling = self.__class__.use_barycentric_sampling(service, version, mode, path + ["use_barycentric_sampling"])
                            self.use_velocity_based_error_control = self.__class__.use_velocity_based_error_control(service, version, mode, path + ["use_velocity_based_error_control"])
                            self.use_quad_face_centroid = self.__class__.use_quad_face_centroid(service, version, mode, path + ["use_quad_face_centroid"])
                            self.check_subtet_validity = self.__class__.check_subtet_validity(service, version, mode, path + ["check_subtet_validity"])
                            self.always_use_face_centroid_with_periodics = self.__class__.always_use_face_centroid_with_periodics(service, version, mode, path + ["always_use_face_centroid_with_periodics"])
                            self.boundary_layer_tracking = self.__class__.boundary_layer_tracking(service, version, mode, path + ["boundary_layer_tracking"])
                            self.sliding_interface_crossover_fraction = self.__class__.sliding_interface_crossover_fraction(service, version, mode, path + ["sliding_interface_crossover_fraction"])
                            self.project_wall_film_particles_to_film = self.__class__.project_wall_film_particles_to_film(service, version, mode, path + ["project_wall_film_particles_to_film"])
                            self.use_particle_timestep_for_intersection_tolerance = self.__class__.use_particle_timestep_for_intersection_tolerance(service, version, mode, path + ["use_particle_timestep_for_intersection_tolerance"])
                            self.enable_automatic_intersection_tolerance = self.__class__.enable_automatic_intersection_tolerance(service, version, mode, path + ["enable_automatic_intersection_tolerance"])
                            self.set_film_spreading_parameter = self.__class__.set_film_spreading_parameter(service, version, mode, path + ["set_film_spreading_parameter"])
                            self.set_subtet_intersection_tolerance = self.__class__.set_subtet_intersection_tolerance(service, version, mode, path + ["set_subtet_intersection_tolerance"])
                            super().__init__(service, version, mode, path)
                        class enable_high_resolution_tracking(TUIMethod):
                            """
                            Enables/disables high resolution tracking.
                            """
                        class enable_barycentric_intersections(TUIMethod):
                            """
                            Enables/disables an alternative method of calculating intersections with cell boundaries. Barycentric intersections are linear calculations and are faster than the default intersection algorithm. The default intersection algorithm is second-order for stationary meshes; therefore, using the barycentric intersection may sacrifice accuracy. You must verify that the barycentric intersections provide comparable results to the default intersection method. This option is available only for 3D stationary meshes and the double precision solver.
                            """
                        class use_barycentric_sampling(TUIMethod):
                            """
                            When enabled, this option provides improved accuracy and parallel consistency when sampling particles at planes. This item is available only with the 3D solver. Using the double-precision solver and bounded planes is recommended.
                            """
                        class use_velocity_based_error_control(TUIMethod):
                            """
                            Enables/disables an alternative method of timestep adaption. By default, ANSYS Fluent uses the half-step method of timestep adaption with particle integration. This alternative method of controlling the integration timestep based upon velocity changes is faster; however, you need to ensure that the accuracy is comparable for your specific application.
                            """
                        class use_quad_face_centroid(TUIMethod):
                            """
                            Enables/disables using quad face centroids when creating subtets. This option changes the way hexahedral cells are decomposed to avoid creating degenerate subtets.
                            """
                        class check_subtet_validity(TUIMethod):
                            """
                            When enabled, checks the validity of a subtet when the particle first enters it. If the subtet is found to be degenerate, the tracking algorithm modifies to accommodate it.
                            """
                        class always_use_face_centroid_with_periodics(TUIMethod):
                            """
                            When enabled, ANSYS Fluent uses quad face centroids when creating subtets in cases with periodic boundaries.
                            """
                        class boundary_layer_tracking(TUIMethod):
                            """
                            Enables/disables the calculation of the particle time step that considers both the cell aspect ratio and the particle trajectory. This method improves the accuracy of the predictions in boundary layer cells, particularly in layers where flow gradients are large.
                            """
                        class sliding_interface_crossover_fraction(TUIMethod):
                            """
                            Specifies the fraction of the distance to the subtet center to move the particle.  At non-conformal interfaces, the nodes used for the barycentric interpolation are different on either side of the interface. This may result in incomplete particles due to discontinuities in the variable interpolation. The number of incomplete particles may be reduced by moving the particles slightly off of the sliding interface. Recommended values range between 0 and 0.5.
                            """
                        class project_wall_film_particles_to_film(TUIMethod):
                            """
                            Enables/disables projecting existing particles to Lagrangian wall film to track using high-resolution tracking.  When reading in a data file that contains wall film particles previously tracked with the existing ANSYS Fluent tracking method, you need to either clear the particles from the domain or project their positions to the wall film surface using the project-wall-film-particles-to-film? text command prior to using the high-resolution tracking method. After tracking the particles for one timestep, this option can be disabled to improve performance.
                            """
                        class use_particle_timestep_for_intersection_tolerance(TUIMethod):
                            """
                            Enables/disables the use of the particle timestep for the subtet intersection tolerance with axisymmetric grids (default: enabled). If disabled, the tolerance will be calculated in the same manner as non-axisymmetric meshes (a scaled value of the tolerance which is set using the define/models/dpm/numerics/high-resolution-tracking/set-subtet-intersection-tolerance text command).
                            """
                        class enable_automatic_intersection_tolerance(TUIMethod):
                            """
                            Enables/disables the automatic calculation of intersection tolerance. By default, the tolerance used in intersection calculations is scaled by the residence time of the particle in the cell to improve robustness. For most cases, the scaled tolerance is sufficient to identify all intersections of the particle trajectory and the subtet faces. You can set the intersection tolerance manually using the set-subtet-intersection-tolerance text command.
                            """
                        class set_film_spreading_parameter(TUIMethod):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                        class set_subtet_intersection_tolerance(TUIMethod):
                            """
                            Specifies the tolerance used in intersection calculations. This tolerance will be scaled by the characteristic cell crossing time of the particle if the enable-automatic-intersection-tolerance? text command is enabled. If that option is disabled, the specified tolerance will be used without scaling. The default intersection tolerance is 10-5.
                            """

                        class barycentric_interpolation(TUIMenu):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.interpolate_flow_solution_gradients = self.__class__.interpolate_flow_solution_gradients(service, version, mode, path + ["interpolate_flow_solution_gradients"])
                                self.interpolate_temperature = self.__class__.interpolate_temperature(service, version, mode, path + ["interpolate_temperature"])
                                self.interpolate_flow_density = self.__class__.interpolate_flow_density(service, version, mode, path + ["interpolate_flow_density"])
                                self.interpolate_flow_cp = self.__class__.interpolate_flow_cp(service, version, mode, path + ["interpolate_flow_cp"])
                                self.interpolate_flow_viscosity = self.__class__.interpolate_flow_viscosity(service, version, mode, path + ["interpolate_flow_viscosity"])
                                self.interpolate_wallfilm_properties = self.__class__.interpolate_wallfilm_properties(service, version, mode, path + ["interpolate_wallfilm_properties"])
                                self.precompute_pdf_species = self.__class__.precompute_pdf_species(service, version, mode, path + ["precompute_pdf_species"])
                                self.zero_nodal_velocity_on_walls = self.__class__.zero_nodal_velocity_on_walls(service, version, mode, path + ["zero_nodal_velocity_on_walls"])
                                self.enable_transient_variable_interpolation = self.__class__.enable_transient_variable_interpolation(service, version, mode, path + ["enable_transient_variable_interpolation"])
                                self.nodal_reconstruction_frequency = self.__class__.nodal_reconstruction_frequency(service, version, mode, path + ["nodal_reconstruction_frequency"])
                                self.user_interpolation_function = self.__class__.user_interpolation_function(service, version, mode, path + ["user_interpolation_function"])
                                super().__init__(service, version, mode, path)
                            class interpolate_flow_solution_gradients(TUIMethod):
                                """
                                When enabled, flow solution gradients are interpolated to the particle position. This can be useful when using physical models that depend on these gradients (for example, the thermophoretic force, pressure-gradient force, or virtual mass force). Interpolating the gradients also improves the accuracy and robustness of the trapezoidal numerics scheme, which is the default method for pathlines.
                                """
                            class interpolate_temperature(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of temperature to the particle position. The cell temperature is used by default in calculations of heat transfer to/from the particle.
                                """
                            class interpolate_flow_density(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of the flow density. This option is recommended when the density varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For constant density flows, this option is unnecessary.
                                """
                            class interpolate_flow_cp(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of specific heat to the particle position. This option is recommended when the specific heat varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant specific heat, this option is unnecessary.
                                """
                            class interpolate_flow_viscosity(TUIMethod):
                                """
                                Enables/disables the barycentric interpolation of flow viscosity to the particle position. This option is recommended when the flow viscosity varies with position to avoid discontinuities in the interpolated variable at cell boundaries. For flows with constant viscosity, this option is unnecessary.
                                """
                            class interpolate_wallfilm_properties(TUIMethod):
                                """
                                When enabled, the wall film properties (film height, film mass, and wall shear) are interpolated to the particle position.
                                """
                            class precompute_pdf_species(TUIMethod):
                                """
                                When this option is enabled for premixed or non-premixed combustion simulations, the species composition in each cell is precomputed prior to tracking particles. This approach may improve performance for cases with many particles and relatively few cells. By default, this option is set to no, and ANSYS Fluent calculates the species composition during particle tracking. The solution results will be identical for both methods.
                                """
                            class zero_nodal_velocity_on_walls(TUIMethod):
                                """
                                When enabled, sets the velocity at wall nodes to zero. (By default, the nodal velocities on walls are first reconstructed from cell and face values and then corrected to ensure that there are no velocity components directed towards the walls). This may be useful if you want to consider particle impingement on the walls. Note that enabling this option will more likely produce incomplete particles as some particles may settle on the walls.
                                """
                            class enable_transient_variable_interpolation(TUIMethod):
                                """
                                Enable transient variable interpolation.
                                """
                            class nodal_reconstruction_frequency(TUIMethod):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                            class user_interpolation_function(TUIMethod):
                                """
                                Enter user interpolation function.
                                """

                        class particle_relocation(TUIMenu):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.wallfilm_relocation_tolerance_scale_factor = self.__class__.wallfilm_relocation_tolerance_scale_factor(service, version, mode, path + ["wallfilm_relocation_tolerance_scale_factor"])
                                self.use_legacy_particle_location_method = self.__class__.use_legacy_particle_location_method(service, version, mode, path + ["use_legacy_particle_location_method"])
                                self.load_legacy_particles = self.__class__.load_legacy_particles(service, version, mode, path + ["load_legacy_particles"])
                                self.enhanced_cell_relocation_method = self.__class__.enhanced_cell_relocation_method(service, version, mode, path + ["enhanced_cell_relocation_method"])
                                self.overset_relocation_robustness_level = self.__class__.overset_relocation_robustness_level(service, version, mode, path + ["overset_relocation_robustness_level"])
                                self.enhanced_wallfilm_location_method = self.__class__.enhanced_wallfilm_location_method(service, version, mode, path + ["enhanced_wallfilm_location_method"])
                                super().__init__(service, version, mode, path)
                            class wallfilm_relocation_tolerance_scale_factor(TUIMethod):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """
                            class use_legacy_particle_location_method(TUIMethod):
                                """
                                Enable legacy method of locating particles in cells.
                                """
                            class load_legacy_particles(TUIMethod):
                                """
                                Load particles that were tracked without high-resolution tracking enabled.
                                """
                            class enhanced_cell_relocation_method(TUIMethod):
                                """
                                Enable enhanced method of locating particles in cells.
                                """
                            class overset_relocation_robustness_level(TUIMethod):
                                """
                                Set the robustness level for particle relocation in overset meshes.
                                """
                            class enhanced_wallfilm_location_method(TUIMethod):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """

                class options(TUIMenu):
                    """
                    Enters the options menu to set optional models.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_contour_plots = self.__class__.enable_contour_plots(service, version, mode, path + ["enable_contour_plots"])
                        self.ensemble_average = self.__class__.ensemble_average(service, version, mode, path + ["ensemble_average"])
                        self.particle_radiation = self.__class__.particle_radiation(service, version, mode, path + ["particle_radiation"])
                        self.track_in_absolute_frame = self.__class__.track_in_absolute_frame(service, version, mode, path + ["track_in_absolute_frame"])
                        self.thermophoretic_force = self.__class__.thermophoretic_force(service, version, mode, path + ["thermophoretic_force"])
                        self.convective_film_heat_transfer = self.__class__.convective_film_heat_transfer(service, version, mode, path + ["convective_film_heat_transfer"])
                        self.saffman_lift_force = self.__class__.saffman_lift_force(service, version, mode, path + ["saffman_lift_force"])
                        self.pressure_gradient_force = self.__class__.pressure_gradient_force(service, version, mode, path + ["pressure_gradient_force"])
                        self.virtual_mass_force = self.__class__.virtual_mass_force(service, version, mode, path + ["virtual_mass_force"])
                        self.two_way_coupling = self.__class__.two_way_coupling(service, version, mode, path + ["two_way_coupling"])
                        self.remove_wall_film_temperature_limiter = self.__class__.remove_wall_film_temperature_limiter(service, version, mode, path + ["remove_wall_film_temperature_limiter"])
                        self.maximum_udf_species = self.__class__.maximum_udf_species(service, version, mode, path + ["maximum_udf_species"])
                        self.brownian_motion = self.__class__.brownian_motion(service, version, mode, path + ["brownian_motion"])
                        self.stagger_spatially_standard_injections = self.__class__.stagger_spatially_standard_injections(service, version, mode, path + ["stagger_spatially_standard_injections"])
                        self.stagger_spatially_atomizer_injections = self.__class__.stagger_spatially_atomizer_injections(service, version, mode, path + ["stagger_spatially_atomizer_injections"])
                        self.stagger_temporally = self.__class__.stagger_temporally(service, version, mode, path + ["stagger_temporally"])
                        self.staggering_factor = self.__class__.staggering_factor(service, version, mode, path + ["staggering_factor"])
                        self.stagger_radius = self.__class__.stagger_radius(service, version, mode, path + ["stagger_radius"])
                        self.uniform_mass_distribution_for_injections = self.__class__.uniform_mass_distribution_for_injections(service, version, mode, path + ["uniform_mass_distribution_for_injections"])
                        self.use_absolute_pressure_for_vaporization = self.__class__.use_absolute_pressure_for_vaporization(service, version, mode, path + ["use_absolute_pressure_for_vaporization"])
                        self.vaporization_options = self.__class__.vaporization_options(service, version, mode, path + ["vaporization_options"])
                        self.vaporization_heat_transfer_averaging = self.__class__.vaporization_heat_transfer_averaging(service, version, mode, path + ["vaporization_heat_transfer_averaging"])
                        self.allow_supercritical_pressure_vaporization = self.__class__.allow_supercritical_pressure_vaporization(service, version, mode, path + ["allow_supercritical_pressure_vaporization"])
                        self.treat_multicomponent_saturation_temperature_failure = self.__class__.treat_multicomponent_saturation_temperature_failure(service, version, mode, path + ["treat_multicomponent_saturation_temperature_failure"])
                        self.set_thermolysis_limit = self.__class__.set_thermolysis_limit(service, version, mode, path + ["set_thermolysis_limit"])
                        self.lowest_volatiles_mass_fraction = self.__class__.lowest_volatiles_mass_fraction(service, version, mode, path + ["lowest_volatiles_mass_fraction"])
                        self.erosion_accretion = self.__class__.erosion_accretion(service, version, mode, path + ["erosion_accretion"])
                        self.init_erosion_accretion_rate = self.__class__.init_erosion_accretion_rate(service, version, mode, path + ["init_erosion_accretion_rate"])
                        self.step_report_sig_figures = self.__class__.step_report_sig_figures(service, version, mode, path + ["step_report_sig_figures"])
                        self.include_lwf_particles_in_dpm_concentration = self.__class__.include_lwf_particles_in_dpm_concentration(service, version, mode, path + ["include_lwf_particles_in_dpm_concentration"])
                        self.current_positions_in_sample_file_format = self.__class__.current_positions_in_sample_file_format(service, version, mode, path + ["current_positions_in_sample_file_format"])
                        self.scr_urea_deposition_risk_analysis = self.__class__.scr_urea_deposition_risk_analysis(service, version, mode, path + ["scr_urea_deposition_risk_analysis"])
                        super().__init__(service, version, mode, path)
                    class enable_contour_plots(TUIMethod):
                        """
                        Enables computation of mean and/or RMS values of additional discrete phase variables for postprocessing.
                        """
                    class ensemble_average(TUIMethod):
                        """
                        Ensembles average cloud properties.
                        """
                    class particle_radiation(TUIMethod):
                        """
                        Enables/disables particle radiation.
                        """
                    class track_in_absolute_frame(TUIMethod):
                        """
                        Enables/disables tracking in absolute frame.
                        """
                    class thermophoretic_force(TUIMethod):
                        """
                        Enables/disables thermophoretic force.
                        """
                    class convective_film_heat_transfer(TUIMethod):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                    class saffman_lift_force(TUIMethod):
                        """
                        Enables/disables Saffman lift force.
                        """
                    class pressure_gradient_force(TUIMethod):
                        """
                        Enables/disables inclusion of pressure gradient effects in the particle force balance.
                        """
                    class virtual_mass_force(TUIMethod):
                        """
                        Enables/disables inclusion of the virtual mass force in the particle force balance.
                        """
                    class two_way_coupling(TUIMethod):
                        """
                        Enables/disables calculation of DPM sources in TKE equation.
                        """
                    class remove_wall_film_temperature_limiter(TUIMethod):
                        """
                        Remove the wall film temperature limiter.
                        """
                    class maximum_udf_species(TUIMethod):
                        """
                        Specifies the maximum number of species that will be accessible from discrete phase model UDFs. Only species with indices up to this value are accessible in discrete phase model UDFs.
                        """
                    class brownian_motion(TUIMethod):
                        """
                        Enables/disables Brownian motion of particles.
                        """
                    class stagger_spatially_standard_injections(TUIMethod):
                        """
                        Enables/disables spatial staggering for standard (non-atomizer and non-solid-cone) injections.
                        """
                    class stagger_spatially_atomizer_injections(TUIMethod):
                        """
                        Enables/disables spatial staggering for atomizer and solid-cone injections.
                        """
                    class stagger_temporally(TUIMethod):
                        """
                        Enables/disables temporal staggering.
                        """
                    class staggering_factor(TUIMethod):
                        """
                        S.
                        """
                    class stagger_radius(TUIMethod):
                        """
                        Specifies the region over which to spatially stagger particles when particle-staggering is enabled for non-atomizer injections.
                        """
                    class uniform_mass_distribution_for_injections(TUIMethod):
                        """
                        Specifies a uniform distribution of mass over the cross-section of solid cone and atomizer injections. This can become important when the mesh is smaller than the diameter (or another characteristic size) of the injection.
                        """
                    class use_absolute_pressure_for_vaporization(TUIMethod):
                        """
                        Determines whether the absolute pressure or constant operating pressure (specified in define/operating-conditions/operating-pressure) will be used in vaporization rates calculations.
                        """
                    class vaporization_options(TUIMethod):
                        """
                        Sets Vaporization options.
                        """
                    class vaporization_heat_transfer_averaging(TUIMethod):
                        """
                        Enables averaging of the Spalding heat transfer term for the convection/diffusion-controlled model.
                        """
                    class allow_supercritical_pressure_vaporization(TUIMethod):
                        """
                        Enforces the switching from vaporization to boiling even if the boiling point is not calculated from the vapor pressure data. If the pressure in your model is above critical you must retain the default setting (yes). This options is available only if whenPressure Dependent Boiling is enabled in the Physical Models tab of the Discrete Phase Models dialog box. For more details, see .
                        """
                    class treat_multicomponent_saturation_temperature_failure(TUIMethod):
                        """
                        Enables/disables dumping multicomponent particle mass into the continuous phase if the saturation temperature calculation fails.
                        """
                    class set_thermolysis_limit(TUIMethod):
                        """
                        Sets the limit for the thermolysis model.
                        """
                    class lowest_volatiles_mass_fraction(TUIMethod):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                    class erosion_accretion(TUIMethod):
                        """
                        Enables/disables erosion/accretion.
                        """
                    class init_erosion_accretion_rate(TUIMethod):
                        """
                        Initializes the erosion/accretion rates with zero.
                        """
                    class step_report_sig_figures(TUIMethod):
                        """
                        Sets significant figures in the step-by-step report.
                        """
                    class include_lwf_particles_in_dpm_concentration(TUIMethod):
                        """
                        Include LWF particle mass in DPM Concentration.
                        """
                    class current_positions_in_sample_file_format(TUIMethod):
                        """
                        When enabled, generates a file containing particle current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                    class scr_urea_deposition_risk_analysis(TUIMethod):
                        """
                        Enters the menu for setting up the risk for solids deposit formation for the Selective Catalytic Reduction (SCR) process. For more information, see .
                        """

                class parallel(TUIMenu):
                    """
                    Enters the parallel menu to set parameters for parallel DPM calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.enable_workpile = self.__class__.enable_workpile(service, version, mode, path + ["enable_workpile"])
                        self.n_threads = self.__class__.n_threads(service, version, mode, path + ["n_threads"])
                        self.report = self.__class__.report(service, version, mode, path + ["report"])
                        self.use_shared_memory = self.__class__.use_shared_memory(service, version, mode, path + ["use_shared_memory"])
                        self.use_message_passing = self.__class__.use_message_passing(service, version, mode, path + ["use_message_passing"])
                        self.use_hybrid = self.__class__.use_hybrid(service, version, mode, path + ["use_hybrid"])
                        self.fix_source_term_accumulation_order = self.__class__.fix_source_term_accumulation_order(service, version, mode, path + ["fix_source_term_accumulation_order"])
                        self.hybrid_2domain = self.__class__.hybrid_2domain(service, version, mode, path + ["hybrid_2domain"])
                        self.hybrid_workpile = self.__class__.hybrid_workpile(service, version, mode, path + ["hybrid_workpile"])
                        self.hybrid_collision_model = self.__class__.hybrid_collision_model(service, version, mode, path + ["hybrid_collision_model"])
                        self.hybrid_collision_unidirectional = self.__class__.hybrid_collision_unidirectional(service, version, mode, path + ["hybrid_collision_unidirectional"])
                        self.hybrid_collision_variant = self.__class__.hybrid_collision_variant(service, version, mode, path + ["hybrid_collision_variant"])
                        super().__init__(service, version, mode, path)
                    class enable_workpile(TUIMethod):
                        """
                        Turns on/off particle workpile algorithm. This option is only available when the define/models/dpm/parallel/use-shared-memory option is selected.
                        """
                    class n_threads(TUIMethod):
                        """
                        Sets the number of processors to use for DPM. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                    class report(TUIMethod):
                        """
                        Prints particle workpile statistics. This option is only available when the define/models/dpm/parallel/enable-workpile? option is enabled.
                        """
                    class use_shared_memory(TUIMethod):
                        """
                        Specifies that the calculations are performed on shared-memory multiprocessor machines.
                        """
                    class use_message_passing(TUIMethod):
                        """
                        Specifies that the calculations are performed using cluster computing or shared-memory machines. With this option, the compute node processes themselves perform the particle work on their local partitions and particle migration to other compute nodes is implemented using message passing primitives.
                        """
                    class use_hybrid(TUIMethod):
                        """
                        Specifies that the calculations are performed using multicore cluster computing or shared-memory machines. This option works in conjunction withopenmpi for a dynamic load balancing without migration of cells.
                        """
                    class fix_source_term_accumulation_order(TUIMethod):
                        """
                        Enforce deterministic order of source term accumulation.
                        """
                    class hybrid_2domain(TUIMethod):
                        """
                        Enables/disables the use of a second domain for DPM particle tracking.
                        """
                    class hybrid_workpile(TUIMethod):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                    class hybrid_collision_model(TUIMethod):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_unidirectional(TUIMethod):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_variant(TUIMethod):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """

                    class expert(TUIMenu):
                        """
                        Enters the menu for expert DPM parallel text commands.
                        """
                        def __init__(self, service, version, mode, path):
                            self.partition_method_hybrid_2domain = self.__class__.partition_method_hybrid_2domain(service, version, mode, path + ["partition_method_hybrid_2domain"])
                            super().__init__(service, version, mode, path)
                        class partition_method_hybrid_2domain(TUIMethod):
                            """
                            Enables/disables a partitioning method that is more granular and can yield faster calculations (especially for cases that are running on a low to moderate number of processors). This partitioning method is only applied when you use the DPM domain for the hybrid parallel DPM tracking mode (that is, when you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                            """

                class splash_options(TUIMenu):
                    """
                    Enters the splash option menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.orourke_splash_fraction = self.__class__.orourke_splash_fraction(service, version, mode, path + ["orourke_splash_fraction"])
                        self.splash_pdf_limiting = self.__class__.splash_pdf_limiting(service, version, mode, path + ["splash_pdf_limiting"])
                        super().__init__(service, version, mode, path)
                    class orourke_splash_fraction(TUIMethod):
                        """
                        Enables/disables the O’Rourke formulation (default for the Lagrangian Wall Film (LWF) model). If the O’Rourke formulation is disabled, the Stanton formulation (default for the Eulerian Wall Film (EWF) model) is used in a simulation.
                        """
                    class splash_pdf_limiting(TUIMethod):
                        """
                        Sets the splash pdf limiting method. Available methods are: the splash pdf tail limiting (default for the LWF model) and the splash pdf peak limiting (default for the EWF model). For the splash pdf peak limiting, you will be prompted to specify the peak limiting value.
                        """

                class stripping_options(TUIMenu):
                    """
                    Enters the stripping options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mass_coefficient = self.__class__.mass_coefficient(service, version, mode, path + ["mass_coefficient"])
                        self.diameter_coefficient = self.__class__.diameter_coefficient(service, version, mode, path + ["diameter_coefficient"])
                        super().__init__(service, version, mode, path)
                    class mass_coefficient(TUIMethod):
                        """
                        Sets the mass coefficient (  in  in the Theory Guide).
                        """
                    class diameter_coefficient(TUIMethod):
                        """
                        Sets the diameter coefficient (  in  in the Theory Guide).
                        """

            class shell_conduction(TUIMenu):
                """
                Enters the shell conduction models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.multi_layer_shell = self.__class__.multi_layer_shell(service, version, mode, path + ["multi_layer_shell"])
                    self.enhanced_encapsulation = self.__class__.enhanced_encapsulation(service, version, mode, path + ["enhanced_encapsulation"])
                    self.read_csv = self.__class__.read_csv(service, version, mode, path + ["read_csv"])
                    self.write_csv = self.__class__.write_csv(service, version, mode, path + ["write_csv"])
                    self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                    self.save_shell_zones = self.__class__.save_shell_zones(service, version, mode, path + ["save_shell_zones"])
                    super().__init__(service, version, mode, path)
                class multi_layer_shell(TUIMethod):
                    """
                    Enables/disables the ability to define multi-layer 	shell conduction for walls. Note that the warped-face 	gradient correction (WFGC) is not supported when 	multi-layer shells are disabled.
                    """
                class enhanced_encapsulation(TUIMethod):
                    """
                    Enables/disables an enhanced routine for the encapsulation of coupled walls during 	mesh partitioning that is enabled by default when shell 	conduction and/or the surface to surface (S2S) radiation 	model is used.
                    """
                class read_csv(TUIMethod):
                    """
                    Defines the shell conduction settings by reading a CSV file.
                    """
                class write_csv(TUIMethod):
                    """
                    Writes your saved shell conduction settings to a CSV file.
                    """
                class settings(TUIMethod):
                    """
                    Enables shell conduction and defines the settings for any wall or group of walls by 	manually entering the number and properties of the 	layers.
                    """
                class save_shell_zones(TUIMethod):
                    """
                    Enables the saving of shell zones to case 	files.
                    """

            class system_coupling_settings(TUIMenu):
                """
                Enters the system coupling menu.
                """
                def __init__(self, service, version, mode, path):
                    self.htc = self.__class__.htc(service, version, mode, path + ["htc"])
                    self.use_face_or_element_based_data_transfer = self.__class__.use_face_or_element_based_data_transfer(service, version, mode, path + ["use_face_or_element_based_data_transfer"])
                    self.update_rigid_body_mesh_motion_before_mesh_transfer = self.__class__.update_rigid_body_mesh_motion_before_mesh_transfer(service, version, mode, path + ["update_rigid_body_mesh_motion_before_mesh_transfer"])
                    self.specify_system_coupling_volumetric_cell_zones = self.__class__.specify_system_coupling_volumetric_cell_zones(service, version, mode, path + ["specify_system_coupling_volumetric_cell_zones"])
                    super().__init__(service, version, mode, path)
                class use_face_or_element_based_data_transfer(TUIMethod):
                    """
                    Answering yes at the prompt 	enables Fluent to use element data for mapping surface 	conservative quantities such as surface forces and heat 	flows.
                    """
                class update_rigid_body_mesh_motion_before_mesh_transfer(TUIMethod):
                    """
                    SC Enable/disable mesh motion.
                    """
                class specify_system_coupling_volumetric_cell_zones(TUIMethod):
                    """
                    Enable/disable volumetric cell zones.
                    """

                class htc(TUIMenu):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.unsteady_statistics = self.__class__.unsteady_statistics(service, version, mode, path + ["unsteady_statistics"])
                        self.htc_calculation_method = self.__class__.htc_calculation_method(service, version, mode, path + ["htc_calculation_method"])
                        super().__init__(service, version, mode, path)

                    class unsteady_statistics(TUIMenu):
                        """
                        Enter the unsteady statistics menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.sc_enable_sub_stepping_option_per_coupling_step = self.__class__.sc_enable_sub_stepping_option_per_coupling_step(service, version, mode, path + ["sc_enable_sub_stepping_option_per_coupling_step"])
                            super().__init__(service, version, mode, path)
                        class sc_enable_sub_stepping_option_per_coupling_step(TUIMethod):
                            """
                            Enable/disable sub stepping option per coupling step.
                            """

                    class htc_calculation_method(TUIMenu):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.use_tref_in_htc_calculation = self.__class__.use_tref_in_htc_calculation(service, version, mode, path + ["use_tref_in_htc_calculation"])
                            self.use_yplus_based_htc_calculation = self.__class__.use_yplus_based_htc_calculation(service, version, mode, path + ["use_yplus_based_htc_calculation"])
                            self.use_wall_function_based_htc = self.__class__.use_wall_function_based_htc(service, version, mode, path + ["use_wall_function_based_htc"])
                            super().__init__(service, version, mode, path)
                        class use_tref_in_htc_calculation(TUIMethod):
                            """
                            Enable/disable tref in htc computation.
                            """
                        class use_yplus_based_htc_calculation(TUIMethod):
                            """
                            Enable/disable yplus in htc computation.
                            """
                        class use_wall_function_based_htc(TUIMethod):
                            """
                            Enable/disable wall function based htc computation.
                            """

            class cht(TUIMenu):
                """
                Enters the cht (conjugate heat transfer) menu.
                """
                def __init__(self, service, version, mode, path):
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(service, version, mode, path + ["explicit_time_averaged_coupling"])
                    self.read_mi_type_wall = self.__class__.read_mi_type_wall(service, version, mode, path + ["read_mi_type_wall"])
                    self.write_mi_type_wall = self.__class__.write_mi_type_wall(service, version, mode, path + ["write_mi_type_wall"])
                    self.implicit_coupling = self.__class__.implicit_coupling(service, version, mode, path + ["implicit_coupling"])
                    super().__init__(service, version, mode, path)
                class read_mi_type_wall(TUIMethod):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                class write_mi_type_wall(TUIMethod):
                    """
                    Write mapped interface settings to a scv file.
                    """
                class implicit_coupling(TUIMethod):
                    """
                    Enables the implicit mapping scheme for any 	fluid-solid pair with a mapped mesh interface (only 	required for cases set up in version 19.2 or 	earlier).
                    """

                class explicit_time_averaged_coupling(TUIMenu):
                    """
                    Enters the explicit time averaged thermal coupling 	menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.conformal_coupled_walls = self.__class__.conformal_coupled_walls(service, version, mode, path + ["conformal_coupled_walls"])
                        self.mapped_interfaces = self.__class__.mapped_interfaces(service, version, mode, path + ["mapped_interfaces"])
                        self.coupling_controls = self.__class__.coupling_controls(service, version, mode, path + ["coupling_controls"])
                        self.fuse_explicit_cht_zones = self.__class__.fuse_explicit_cht_zones(service, version, mode, path + ["fuse_explicit_cht_zones"])
                        super().__init__(service, version, mode, path)
                    class conformal_coupled_walls(TUIMethod):
                        """
                        Specify explicit coupling controls for coupled conformal walls. Note this operation will slit the coupled wall pair.
                        """
                    class mapped_interfaces(TUIMethod):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """
                    class coupling_controls(TUIMethod):
                        """
                        Specify explcit coupling controls.
                        """
                    class fuse_explicit_cht_zones(TUIMethod):
                        """
                        Fuses slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """

            class two_temperature(TUIMenu):
                """
                Enters the Two-Temperature model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.robustness_enhancement = self.__class__.robustness_enhancement(service, version, mode, path + ["robustness_enhancement"])
                    self.nasa9_enhancement = self.__class__.nasa9_enhancement(service, version, mode, path + ["nasa9_enhancement"])
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables the Two-Temperature model.
                    """
                class robustness_enhancement(TUIMethod):
                    """
                    Enables/disables the robustness enhancement, which is 	on by default.
                    """
                class nasa9_enhancement(TUIMethod):
                    """
                    Apply nasa9 robustness enhancements in the two-temperature model.
                    """
                class set_verbosity(TUIMethod):
                    """
                    Specifies the level of detail printed in the console 	about the Two-Temperature model. For a verbosity of one, 	Fluent will print the number of cells that reach the 	temperature limit, have an excessive temperature change, 	or get a negative temperature.
                    """

            class multiphase(TUIMenu):
                """
                Enters the multiphase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.phases = self.__class__.phases(service, version, mode, path + ["phases"])
                    self.wet_steam = self.__class__.wet_steam(service, version, mode, path + ["wet_steam"])
                    self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                    self.explicit_expert_options = self.__class__.explicit_expert_options(service, version, mode, path + ["explicit_expert_options"])
                    self.model = self.__class__.model(service, version, mode, path + ["model"])
                    self.number_of_phases = self.__class__.number_of_phases(service, version, mode, path + ["number_of_phases"])
                    self.regime_transition_modeling = self.__class__.regime_transition_modeling(service, version, mode, path + ["regime_transition_modeling"])
                    self.eulerian_parameters = self.__class__.eulerian_parameters(service, version, mode, path + ["eulerian_parameters"])
                    self.volume_fraction_parameters = self.__class__.volume_fraction_parameters(service, version, mode, path + ["volume_fraction_parameters"])
                    self.boiling_model_options = self.__class__.boiling_model_options(service, version, mode, path + ["boiling_model_options"])
                    self.mixture_parameters = self.__class__.mixture_parameters(service, version, mode, path + ["mixture_parameters"])
                    self.body_force_formulation = self.__class__.body_force_formulation(service, version, mode, path + ["body_force_formulation"])
                    self.coupled_level_set = self.__class__.coupled_level_set(service, version, mode, path + ["coupled_level_set"])
                    self.vof_sub_models = self.__class__.vof_sub_models(service, version, mode, path + ["vof_sub_models"])
                    self.interface_modeling_options = self.__class__.interface_modeling_options(service, version, mode, path + ["interface_modeling_options"])
                    self.expert_options = self.__class__.expert_options(service, version, mode, path + ["expert_options"])
                    super().__init__(service, version, mode, path)
                class model(TUIMethod):
                    """
                    Specifies multiphase model.
                    """
                class number_of_phases(TUIMethod):
                    """
                    Specifies the number of phases.
                    """
                class regime_transition_modeling(TUIMethod):
                    """
                    Enables the Algebraic Interfacial Area Density (AIAD) 	model and sets the AIAD secondary continuous phase and 	the secondary entrained phase. Entering 0 as a phase ID cancels any 	previous phase selection. Note that you must define the 	phases in your simulation using the define/phases/ text command 	prior to using the regime-transition-modeling 	text command. This option is available only with the 	Eulerian multiphase model.
                    """
                class eulerian_parameters(TUIMethod):
                    """
                    Specifies Eulerian parameters.
                    """
                class volume_fraction_parameters(TUIMethod):
                    """
                    Specifies volume fraction parameters.
                    """
                class boiling_model_options(TUIMethod):
                    """
                    Specifies the boiling model options. You can choose theRPI boiling model,Non-equilibrium boiling, orCritical heat flux.
                    """
                class mixture_parameters(TUIMethod):
                    """
                    Specifies mixture parameters.
                    """
                class body_force_formulation(TUIMethod):
                    """
                    Specifies body force formulation.
                    """
                class coupled_level_set(TUIMethod):
                    """
                    Enables coupled level set interface tracking method.
                    """
                class vof_sub_models(TUIMethod):
                    """
                    Enables the Open Channel sub-model and/or the Open Channel Wave Boundary Condition 	sub-model.
                    """
                class interface_modeling_options(TUIMethod):
                    """
                    Specifies interface modeling options.
                    """
                class expert_options(TUIMethod):
                    """
                    Expert Options.
                    """

                class phases(TUIMenu):
                    """
                    Enter the phases menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set_domain_properties = self.__class__.set_domain_properties(service, version, mode, path + ["set_domain_properties"])
                        self.iac_expert = self.__class__.iac_expert(service, version, mode, path + ["iac_expert"])
                        super().__init__(service, version, mode, path)

                    class set_domain_properties(TUIMenu):
                        """
                        Enter the menu to set domain properties.
                        """
                        def __init__(self, service, version, mode, path):
                            self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                            self.change_phases_names = self.__class__.change_phases_names(service, version, mode, path + ["change_phases_names"])
                            self.phase_domains = self.__class__.phase_domains(service, version, mode, path + ["phase_domains"])
                            super().__init__(service, version, mode, path)
                        class change_phases_names(TUIMethod):
                            """
                            Change names for all defined phases?.
                            """
                        class phase_domains(TUIMethod):
                            """
                            Enter the menu to select a specific phase domain.
                            """

                        class interaction_domain(TUIMenu):
                            """
                            Enter the menu to set the interaction domain properties.
                            """
                            def __init__(self, service, version, mode, path):
                                self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                                self.heat_mass_reactions = self.__class__.heat_mass_reactions(service, version, mode, path + ["heat_mass_reactions"])
                                self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                                super().__init__(service, version, mode, path)

                            class forces(TUIMenu):
                                """
                                Enter the menu to set interfacial forces related models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class heat_mass_reactions(TUIMenu):
                                """
                                Enter the menu to set heat, mass-transfer, or reaction related models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class interfacial_area(TUIMenu):
                                """
                                Enter the menu to set interfacial area models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class model_transition(TUIMenu):
                                """
                                Enter the menu to set model transition mechanisms.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class numerics(TUIMenu):
                                """
                                Enter the menu to set numerics models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                    class iac_expert(TUIMenu):
                        """
                        Enter the IAC expert setting menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.ishii_kim_model = self.__class__.ishii_kim_model(service, version, mode, path + ["ishii_kim_model"])
                            self.hibiki_ishii_model = self.__class__.hibiki_ishii_model(service, version, mode, path + ["hibiki_ishii_model"])
                            self.yao_morel_model = self.__class__.yao_morel_model(service, version, mode, path + ["yao_morel_model"])
                            self.iac_pseudo_time_step = self.__class__.iac_pseudo_time_step(service, version, mode, path + ["iac_pseudo_time_step"])
                            super().__init__(service, version, mode, path)
                        class ishii_kim_model(TUIMethod):
                            """
                            Set ik model coefficients.
                            """
                        class hibiki_ishii_model(TUIMethod):
                            """
                            Set hi model coefficients.
                            """
                        class yao_morel_model(TUIMethod):
                            """
                            Set ym model coefficients.
                            """
                        class iac_pseudo_time_step(TUIMethod):
                            """
                            Set iac pseudo-time.
                            """

                class wet_steam(TUIMenu):
                    """
                    Enters the wet steam model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.compile_user_defined_wetsteam_functions = self.__class__.compile_user_defined_wetsteam_functions(service, version, mode, path + ["compile_user_defined_wetsteam_functions"])
                        self.load_unload_user_defined_wetsteam_library = self.__class__.load_unload_user_defined_wetsteam_library(service, version, mode, path + ["load_unload_user_defined_wetsteam_library"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enables/disables the wet steam model.
                        """
                    class compile_user_defined_wetsteam_functions(TUIMethod):
                        """
                        Compiles user-defined wet steam library.
                        """
                    class load_unload_user_defined_wetsteam_library(TUIMethod):
                        """
                        Loads or unloads user-defined wet steam library.
                        """

                    class set(TUIMenu):
                        """
                        Enters the set menu for setting wet steam model options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.max_liquid_mass_fraction = self.__class__.max_liquid_mass_fraction(service, version, mode, path + ["max_liquid_mass_fraction"])
                            self.droplet_growth_rate = self.__class__.droplet_growth_rate(service, version, mode, path + ["droplet_growth_rate"])
                            self.virial_equation = self.__class__.virial_equation(service, version, mode, path + ["virial_equation"])
                            self.rgp_tables = self.__class__.rgp_tables(service, version, mode, path + ["rgp_tables"])
                            self.stagnation_conditions = self.__class__.stagnation_conditions(service, version, mode, path + ["stagnation_conditions"])
                            super().__init__(service, version, mode, path)
                        class max_liquid_mass_fraction(TUIMethod):
                            """
                            Sets the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                        class droplet_growth_rate(TUIMethod):
                            """
                            S formulation (default) or Hill.
                            """
                        class virial_equation(TUIMethod):
                            """
                            Sets the equation of state for steam to either Vukalovich formulation (default) or Young formulation.
                            """
                        class rgp_tables(TUIMethod):
                            """
                            Sets the RGP (real gas property) table to be used with the Wet Steam model.
                            """
                        class stagnation_conditions(TUIMethod):
                            """
                            Computes stagnation conditions using either gas phase only, or mixture. For details, see .
                            """

                class population_balance(TUIMenu):
                    """
                    Enters the population balance models menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.phenomena = self.__class__.phenomena(service, version, mode, path + ["phenomena"])
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.model = self.__class__.model(service, version, mode, path + ["model"])
                        self.include_expansion = self.__class__.include_expansion(service, version, mode, path + ["include_expansion"])
                        self.size_calculator = self.__class__.size_calculator(service, version, mode, path + ["size_calculator"])
                        super().__init__(service, version, mode, path)
                    class model(TUIMethod):
                        """
                        Allows you to select the population balance model and set its parameters.
                        """
                    class include_expansion(TUIMethod):
                        """
                        Set expansion.
                        """
                    class size_calculator(TUIMethod):
                        """
                        Gives you recommendations for appropriate bubble sizes and/or droplet size limits.
                        """

                    class phenomena(TUIMenu):
                        """
                        Enters the phenomena menu for population balance.
                        """
                        def __init__(self, service, version, mode, path):
                            self.nucleation = self.__class__.nucleation(service, version, mode, path + ["nucleation"])
                            self.growth = self.__class__.growth(service, version, mode, path + ["growth"])
                            self.aggregation = self.__class__.aggregation(service, version, mode, path + ["aggregation"])
                            self.breakage = self.__class__.breakage(service, version, mode, path + ["breakage"])
                            self.aggregation_factor = self.__class__.aggregation_factor(service, version, mode, path + ["aggregation_factor"])
                            self.breakage_factor = self.__class__.breakage_factor(service, version, mode, path + ["breakage_factor"])
                            self.breakage_aggregation_vof_cutoff = self.__class__.breakage_aggregation_vof_cutoff(service, version, mode, path + ["breakage_aggregation_vof_cutoff"])
                            super().__init__(service, version, mode, path)
                        class nucleation(TUIMethod):
                            """
                            Specifies the nucleation rate.
                            """
                        class growth(TUIMethod):
                            """
                            Specifies the growth rate.
                            """
                        class aggregation(TUIMethod):
                            """
                            Sets the aggregation kernel.
                            """
                        class breakage(TUIMethod):
                            """
                            Set the breakage kernel.
                            """
                        class aggregation_factor(TUIMethod):
                            """
                            Specifies a factor that controls the intensity of the selected aggregation kernel.
                            """
                        class breakage_factor(TUIMethod):
                            """
                            Specifies a factor that controls the intensity of the selected breakage kernel.
                            """
                        class breakage_aggregation_vof_cutoff(TUIMethod):
                            """
                            Specifies a cutoff limit for the volume fraction values for the breakage and aggregation kernels.
                            """

                    class expert(TUIMenu):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, service, version, mode, path):
                            self.qmom = self.__class__.qmom(service, version, mode, path + ["qmom"])
                            super().__init__(service, version, mode, path)

                        class qmom(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.retain_qmom_sources_for_low_vof = self.__class__.retain_qmom_sources_for_low_vof(service, version, mode, path + ["retain_qmom_sources_for_low_vof"])
                                self.realizable_moments = self.__class__.realizable_moments(service, version, mode, path + ["realizable_moments"])
                                self.print_realizable_moment_warning = self.__class__.print_realizable_moment_warning(service, version, mode, path + ["print_realizable_moment_warning"])
                                self.inversion_algorithm = self.__class__.inversion_algorithm(service, version, mode, path + ["inversion_algorithm"])
                                super().__init__(service, version, mode, path)
                            class retain_qmom_sources_for_low_vof(TUIMethod):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """
                            class realizable_moments(TUIMethod):
                                """
                                Set the population balance model.
                                """
                            class print_realizable_moment_warning(TUIMethod):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                            class inversion_algorithm(TUIMethod):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """

                class explicit_expert_options(TUIMenu):
                    """
                    Enters the menu to set explicit VOF expert 	options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(service, version, mode, path + ["volume_fraction_filtering"])
                        self.sub_time_step_method = self.__class__.sub_time_step_method(service, version, mode, path + ["sub_time_step_method"])
                        self.solve_vof_every_iter = self.__class__.solve_vof_every_iter(service, version, mode, path + ["solve_vof_every_iter"])
                        super().__init__(service, version, mode, path)
                    class sub_time_step_method(TUIMethod):
                        """
                        Selects the sub-time step method.
                        """
                    class solve_vof_every_iter(TUIMethod):
                        """
                        If you enter yes, the volume fraction equations will be solved every iteration. By default, the volume fraction equations will be solved only once per time step.
                        """

                    class volume_fraction_filtering(TUIMenu):
                        """
                        Enters the volume fraction filtering menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.filtering_options = self.__class__.filtering_options(service, version, mode, path + ["filtering_options"])
                            self.vol_frac_cutoff = self.__class__.vol_frac_cutoff(service, version, mode, path + ["vol_frac_cutoff"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            Enables/disables the volume fraction filtering treatment.
                            """
                        class filtering_options(TUIMethod):
                            """
                            Selects the volume fraction filtering method. This command becomes available once the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/enable? text option has been set to yes.
                            """
                        class vol_frac_cutoff(TUIMethod):
                            """
                            Specifies a cut-off value for the volume fraction filtering. This command becomes available after you select the node averaged cutoff method using the define/models/multiphase/explicit-expert-options/volume-fraction-filtering/filtering-options text command.
                            """

            class nox_parameters(TUIMenu):
                """
                Enters the NOx parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.nox_chemistry = self.__class__.nox_chemistry(service, version, mode, path + ["nox_chemistry"])
                    self.nox_turbulence_interaction = self.__class__.nox_turbulence_interaction(service, version, mode, path + ["nox_turbulence_interaction"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.nox_expert = self.__class__.nox_expert(service, version, mode, path + ["nox_expert"])
                    super().__init__(service, version, mode, path)
                class nox_chemistry(TUIMethod):
                    """
                    Selects NOx chemistry model.
                    """
                class nox_turbulence_interaction(TUIMethod):
                    """
                    Sets NOx turbulence interaction model.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class nox_expert(TUIMethod):
                    """
                    Selects additional NOx equations.
                    """

            class soot_parameters(TUIMenu):
                """
                Enters the soot parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.soot_model_parameters = self.__class__.soot_model_parameters(service, version, mode, path + ["soot_model_parameters"])
                    self.soot_process_parameters = self.__class__.soot_process_parameters(service, version, mode, path + ["soot_process_parameters"])
                    self.soot_radiation_interaction = self.__class__.soot_radiation_interaction(service, version, mode, path + ["soot_radiation_interaction"])
                    self.soot_turbulence_interaction = self.__class__.soot_turbulence_interaction(service, version, mode, path + ["soot_turbulence_interaction"])
                    self.modify_schmidt_number = self.__class__.modify_schmidt_number(service, version, mode, path + ["modify_schmidt_number"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.soot_model_udfs = self.__class__.soot_model_udfs(service, version, mode, path + ["soot_model_udfs"])
                    super().__init__(service, version, mode, path)
                class soot_model_parameters(TUIMethod):
                    """
                    Selects soot model parameters.
                    """
                class soot_process_parameters(TUIMethod):
                    """
                    Selects soot process parameters.
                    """
                class soot_radiation_interaction(TUIMethod):
                    """
                    Enables/disables the soot-radiation interaction model.
                    """
                class soot_turbulence_interaction(TUIMethod):
                    """
                    Sets soot-turbulence interaction model.
                    """
                class modify_schmidt_number(TUIMethod):
                    """
                    Changes the turbulent Schmidt number for soot/nuclei equations.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class soot_model_udfs(TUIMethod):
                    """
                    User defined functions for soot model.
                    """

            class radiation(TUIMenu):
                """
                Enters the radiation models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.s2s_parameters = self.__class__.s2s_parameters(service, version, mode, path + ["s2s_parameters"])
                    self.dtrm_parameters = self.__class__.dtrm_parameters(service, version, mode, path + ["dtrm_parameters"])
                    self.solar_parameters = self.__class__.solar_parameters(service, version, mode, path + ["solar_parameters"])
                    self.discrete_ordinates = self.__class__.discrete_ordinates(service, version, mode, path + ["discrete_ordinates"])
                    self.do_acceleration = self.__class__.do_acceleration(service, version, mode, path + ["do_acceleration"])
                    self.non_gray_model_parameters = self.__class__.non_gray_model_parameters(service, version, mode, path + ["non_gray_model_parameters"])
                    self.montecarlo = self.__class__.montecarlo(service, version, mode, path + ["montecarlo"])
                    self.target_cells_per_volume_cluster = self.__class__.target_cells_per_volume_cluster(service, version, mode, path + ["target_cells_per_volume_cluster"])
                    self.s2s = self.__class__.s2s(service, version, mode, path + ["s2s"])
                    self.discrete_transfer = self.__class__.discrete_transfer(service, version, mode, path + ["discrete_transfer"])
                    self.p1 = self.__class__.p1(service, version, mode, path + ["p1"])
                    self.radiation_model_parameters = self.__class__.radiation_model_parameters(service, version, mode, path + ["radiation_model_parameters"])
                    self.radiation_iteration_parameters = self.__class__.radiation_iteration_parameters(service, version, mode, path + ["radiation_iteration_parameters"])
                    self.mc_model_parameters = self.__class__.mc_model_parameters(service, version, mode, path + ["mc_model_parameters"])
                    self.mc_under_relaxation = self.__class__.mc_under_relaxation(service, version, mode, path + ["mc_under_relaxation"])
                    self.rosseland = self.__class__.rosseland(service, version, mode, path + ["rosseland"])
                    self.solar = self.__class__.solar(service, version, mode, path + ["solar"])
                    self.solar_irradiation = self.__class__.solar_irradiation(service, version, mode, path + ["solar_irradiation"])
                    self.solar_calculator = self.__class__.solar_calculator(service, version, mode, path + ["solar_calculator"])
                    self.apply_full_solar_irradiation = self.__class__.apply_full_solar_irradiation(service, version, mode, path + ["apply_full_solar_irradiation"])
                    self.wsggm_cell_based = self.__class__.wsggm_cell_based(service, version, mode, path + ["wsggm_cell_based"])
                    self.fast_second_order_discrete_ordinate = self.__class__.fast_second_order_discrete_ordinate(service, version, mode, path + ["fast_second_order_discrete_ordinate"])
                    self.do_coupling = self.__class__.do_coupling(service, version, mode, path + ["do_coupling"])
                    self.solution_method_for_do_coupling = self.__class__.solution_method_for_do_coupling(service, version, mode, path + ["solution_method_for_do_coupling"])
                    self.beta_radiation_features = self.__class__.beta_radiation_features(service, version, mode, path + ["beta_radiation_features"])
                    self.method_partially_specular_wall = self.__class__.method_partially_specular_wall(service, version, mode, path + ["method_partially_specular_wall"])
                    self.blending_factor = self.__class__.blending_factor(service, version, mode, path + ["blending_factor"])
                    super().__init__(service, version, mode, path)
                class discrete_ordinates(TUIMethod):
                    """
                    Enables/disables discrete ordinates radiation model.
                    """
                class do_acceleration(TUIMethod):
                    """
                    Enables/disables the acceleration of the discrete 	ordinates (DO) radiation model calculations. Note that 	this text command is only available when running on 	Linux in parallel.
                    """
                class non_gray_model_parameters(TUIMethod):
                    """
                    Sets parameters for non-gray model.
                    """
                class montecarlo(TUIMethod):
                    """
                    Enables/disables the Monte Carlo radiation model.
                    """
                class target_cells_per_volume_cluster(TUIMethod):
                    """
                    Sets the amount of coarsening of the radiation mesh 	for the Monte Carlo radiation model. A number greater 	than one implies coarsening, whereas equal to one 	implies no coarsening.
                    """
                class s2s(TUIMethod):
                    """
                    Enables/disables S2S radiation model.
                    """
                class discrete_transfer(TUIMethod):
                    """
                    Enables/disables discrete transfer radiation model.
                    """
                class p1(TUIMethod):
                    """
                    Enables/disables P1 radiation model.
                    """
                class radiation_model_parameters(TUIMethod):
                    """
                    Set parameters for radiation models.
                    """
                class radiation_iteration_parameters(TUIMethod):
                    """
                    Sets iteration parameters for radiation models.
                    """
                class mc_model_parameters(TUIMethod):
                    """
                    Specifies Monte Carlo model parameters. This text command is available only when the 	Monte Carlo model is enabled.
                    """
                class mc_under_relaxation(TUIMethod):
                    """
                    Sets the under-relaxation factor for Monte Carlo radiation sources used in the 	energy equation.
                    """
                class rosseland(TUIMethod):
                    """
                    Enables/disables Rosseland radiation model.
                    """
                class solar(TUIMethod):
                    """
                    Enables/disables solar model.
                    """
                class solar_irradiation(TUIMethod):
                    """
                    Enables/disables the solar irradiation model.
                    """
                class solar_calculator(TUIMethod):
                    """
                    Calculates sun direction and intensity.
                    """
                class apply_full_solar_irradiation(TUIMethod):
                    """
                    Enables/disables the application of the complete solar load to the first wavelength 	band only, reverting to the pre-2019 R1 behavior of the 	Solar Load and Discrete Ordinates models.
                    """
                class wsggm_cell_based(TUIMethod):
                    """
                    Enables/disables WSGGM cell based method. Note that when enabled, the wsggm-cell-based option will 	become available in theAbsorption Coefficient drop-down list in the Create/Edit Materials dialog 	box.
                    """
                class fast_second_order_discrete_ordinate(TUIMethod):
                    """
                    Enables/disables the fast-second-order option for Discrete Ordinate Model.
                    """
                class do_coupling(TUIMethod):
                    """
                    Enables/disables DO/energy coupling.
                    """
                class solution_method_for_do_coupling(TUIMethod):
                    """
                    Enables/disables the solution method for DO/energy coupling.
                    """
                class beta_radiation_features(TUIMethod):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                class method_partially_specular_wall(TUIMethod):
                    """
                    Sets the method for partially specular wall with discrete ordinate model.
                    """
                class blending_factor(TUIMethod):
                    """
                    Sets numeric option for Discrete Ordinate model. Make sure thatSecond Order Upwind is selected for the Discrete Ordinates spatial 	discretization for the blending-factor option to 	appear in the text command list.
                    """

                class s2s_parameters(TUIMenu):
                    """
                    Enters the S2S parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_vf_only = self.__class__.compute_vf_only(service, version, mode, path + ["compute_vf_only"])
                        self.compute_write_vf = self.__class__.compute_write_vf(service, version, mode, path + ["compute_write_vf"])
                        self.compute_vf_accelerated = self.__class__.compute_vf_accelerated(service, version, mode, path + ["compute_vf_accelerated"])
                        self.compute_clusters_and_vf_accelerated = self.__class__.compute_clusters_and_vf_accelerated(service, version, mode, path + ["compute_clusters_and_vf_accelerated"])
                        self.non_participating_boundary_zones_temperature = self.__class__.non_participating_boundary_zones_temperature(service, version, mode, path + ["non_participating_boundary_zones_temperature"])
                        self.read_vf_file = self.__class__.read_vf_file(service, version, mode, path + ["read_vf_file"])
                        self.set_vf_parameters = self.__class__.set_vf_parameters(service, version, mode, path + ["set_vf_parameters"])
                        self.split_angle = self.__class__.split_angle(service, version, mode, path + ["split_angle"])
                        self.set_global_faces_per_surface_cluster = self.__class__.set_global_faces_per_surface_cluster(service, version, mode, path + ["set_global_faces_per_surface_cluster"])
                        self.print_thread_clusters = self.__class__.print_thread_clusters(service, version, mode, path + ["print_thread_clusters"])
                        self.print_zonewise_radiation = self.__class__.print_zonewise_radiation(service, version, mode, path + ["print_zonewise_radiation"])
                        self.use_old_cluster_algorithm = self.__class__.use_old_cluster_algorithm(service, version, mode, path + ["use_old_cluster_algorithm"])
                        self.use_new_cluster_algorithm = self.__class__.use_new_cluster_algorithm(service, version, mode, path + ["use_new_cluster_algorithm"])
                        self.compute_fpsc_values = self.__class__.compute_fpsc_values(service, version, mode, path + ["compute_fpsc_values"])
                        self.enable_mesh_interface_clustering = self.__class__.enable_mesh_interface_clustering(service, version, mode, path + ["enable_mesh_interface_clustering"])
                        super().__init__(service, version, mode, path)
                    class compute_vf_only(TUIMethod):
                        """
                        Computes/writes view factors only.
                        """
                    class compute_write_vf(TUIMethod):
                        """
                        Computes/writes surface clusters and view factors for S2S radiation model.
                        """
                    class compute_vf_accelerated(TUIMethod):
                        """
                        Compute/Write view factors from existing surface clusters.
                        """
                    class compute_clusters_and_vf_accelerated(TUIMethod):
                        """
                        Compute/Write surface cluster first and then view factors.
                        """
                    class non_participating_boundary_zones_temperature(TUIMethod):
                        """
                        Sets temperature for the non-participating boundary zones.
                        """
                    class read_vf_file(TUIMethod):
                        """
                        Reads S2S file.
                        """
                    class set_vf_parameters(TUIMethod):
                        """
                        Sets the parameters needed for the viewfactor calculations.
                        """
                    class split_angle(TUIMethod):
                        """
                        Sets split angle for the clustering algorithm.
                        """
                    class set_global_faces_per_surface_cluster(TUIMethod):
                        """
                        Sets global value of faces per surface cluster for all boundary zones.
                        """
                    class print_thread_clusters(TUIMethod):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                    class print_zonewise_radiation(TUIMethod):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                    class use_old_cluster_algorithm(TUIMethod):
                        """
                        Uses the old surface clustering algorithm.
                        """
                    class use_new_cluster_algorithm(TUIMethod):
                        """
                        Uses the new surface clustering algorithm.
                        """
                    class compute_fpsc_values(TUIMethod):
                        """
                        Computes only fpsc values based on current settings.
                        """
                    class enable_mesh_interface_clustering(TUIMethod):
                        """
                        Enables surface clusters on mesh interfaces.
                        """

                class dtrm_parameters(TUIMenu):
                    """
                    Enters the dtrm parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                        self.make_globs = self.__class__.make_globs(service, version, mode, path + ["make_globs"])
                        self.ray_trace = self.__class__.ray_trace(service, version, mode, path + ["ray_trace"])
                        self.check_ray_file = self.__class__.check_ray_file(service, version, mode, path + ["check_ray_file"])
                        super().__init__(service, version, mode, path)
                    class controls(TUIMethod):
                        """
                        Sets dtrm solution controls.
                        """
                    class make_globs(TUIMethod):
                        """
                        Makes globs (coarser mesh) for radiation.
                        """
                    class ray_trace(TUIMethod):
                        """
                        Creates DTRM rays for radiation.
                        """
                    class check_ray_file(TUIMethod):
                        """
                        Reads DTRM rays file.
                        """

                class solar_parameters(TUIMenu):
                    """
                    Enters the solar parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.autosave_solar_data = self.__class__.autosave_solar_data(service, version, mode, path + ["autosave_solar_data"])
                        self.autoread_solar_data = self.__class__.autoread_solar_data(service, version, mode, path + ["autoread_solar_data"])
                        self.sun_direction_vector = self.__class__.sun_direction_vector(service, version, mode, path + ["sun_direction_vector"])
                        self.illumination_parameters = self.__class__.illumination_parameters(service, version, mode, path + ["illumination_parameters"])
                        self.iteration_parameters = self.__class__.iteration_parameters(service, version, mode, path + ["iteration_parameters"])
                        self.quad_tree_parameters = self.__class__.quad_tree_parameters(service, version, mode, path + ["quad_tree_parameters"])
                        self.ground_reflectivity = self.__class__.ground_reflectivity(service, version, mode, path + ["ground_reflectivity"])
                        self.scattering_fraction = self.__class__.scattering_fraction(service, version, mode, path + ["scattering_fraction"])
                        self.sol_on_demand = self.__class__.sol_on_demand(service, version, mode, path + ["sol_on_demand"])
                        self.sol_camera_pos = self.__class__.sol_camera_pos(service, version, mode, path + ["sol_camera_pos"])
                        self.sol_adjacent_fluidcells = self.__class__.sol_adjacent_fluidcells(service, version, mode, path + ["sol_adjacent_fluidcells"])
                        self.use_direction_from_sol_calc = self.__class__.use_direction_from_sol_calc(service, version, mode, path + ["use_direction_from_sol_calc"])
                        self.solar_thread_control = self.__class__.solar_thread_control(service, version, mode, path + ["solar_thread_control"])
                        super().__init__(service, version, mode, path)
                    class autosave_solar_data(TUIMethod):
                        """
                        Sets autosave solar data parameters.
                        """
                    class autoread_solar_data(TUIMethod):
                        """
                        Sets autoread solar data parameters.
                        """
                    class sun_direction_vector(TUIMethod):
                        """
                        Sets sun direction vector.
                        """
                    class illumination_parameters(TUIMethod):
                        """
                        Sets illumination parameters.
                        """
                    class iteration_parameters(TUIMethod):
                        """
                        Sets update parameters.
                        """
                    class quad_tree_parameters(TUIMethod):
                        """
                        Sets quad-tree refinement parameters.
                        """
                    class ground_reflectivity(TUIMethod):
                        """
                        Sets ground reflectivity parameters.
                        """
                    class scattering_fraction(TUIMethod):
                        """
                        Sets scattering fraction parameters.
                        """
                    class sol_on_demand(TUIMethod):
                        """
                        Sets solar load on demand.
                        """
                    class sol_camera_pos(TUIMethod):
                        """
                        Sets camera position based on sun direction vector.
                        """
                    class sol_adjacent_fluidcells(TUIMethod):
                        """
                        Sets solar load on for adjacent fluid cells.
                        """
                    class use_direction_from_sol_calc(TUIMethod):
                        """
                        Sets direction computed from solar calculator.
                        """
                    class solar_thread_control(TUIMethod):
                        """
                        Sets the number of threads to run the solar flux calculation. This item appears only when running in parallel with nodes located on a separate machine from the one running the host process andSolar Ray Tracing is enabled.
                        """

            class solver(TUIMenu):
                """
                Enters the menu to select the solver.
                """
                def __init__(self, service, version, mode, path):
                    self.pressure_based = self.__class__.pressure_based(service, version, mode, path + ["pressure_based"])
                    self.density_based_explicit = self.__class__.density_based_explicit(service, version, mode, path + ["density_based_explicit"])
                    self.density_based_implicit = self.__class__.density_based_implicit(service, version, mode, path + ["density_based_implicit"])
                    self.adjust_solver_defaults_based_on_setup = self.__class__.adjust_solver_defaults_based_on_setup(service, version, mode, path + ["adjust_solver_defaults_based_on_setup"])
                    super().__init__(service, version, mode, path)
                class pressure_based(TUIMethod):
                    """
                    Enables/disables the pressure-based solver.
                    """
                class density_based_explicit(TUIMethod):
                    """
                    Enables/disables the density-based-explicit solver.
                    """
                class density_based_implicit(TUIMethod):
                    """
                    Enables/disables the density-based-implicit solver.
                    """
                class adjust_solver_defaults_based_on_setup(TUIMethod):
                    """
                    Enable/disable adjustment of solver defaults based on setup.
                    """

            class species(TUIMenu):
                """
                Enters the species models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(service, version, mode, path + ["CHEMKIN_CFD_parameters"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.species_transport = self.__class__.species_transport(service, version, mode, path + ["species_transport"])
                    self.non_premixed_combustion = self.__class__.non_premixed_combustion(service, version, mode, path + ["non_premixed_combustion"])
                    self.premixed_combustion = self.__class__.premixed_combustion(service, version, mode, path + ["premixed_combustion"])
                    self.partially_premixed_combustion = self.__class__.partially_premixed_combustion(service, version, mode, path + ["partially_premixed_combustion"])
                    self.premixed_model = self.__class__.premixed_model(service, version, mode, path + ["premixed_model"])
                    self.pdf_transport = self.__class__.pdf_transport(service, version, mode, path + ["pdf_transport"])
                    self.save_gradients = self.__class__.save_gradients(service, version, mode, path + ["save_gradients"])
                    self.liquid_energy_diffusion = self.__class__.liquid_energy_diffusion(service, version, mode, path + ["liquid_energy_diffusion"])
                    self.volumetric_reactions = self.__class__.volumetric_reactions(service, version, mode, path + ["volumetric_reactions"])
                    self.species_transport_expert = self.__class__.species_transport_expert(service, version, mode, path + ["species_transport_expert"])
                    self.coal_calculator = self.__class__.coal_calculator(service, version, mode, path + ["coal_calculator"])
                    self.mixing_model = self.__class__.mixing_model(service, version, mode, path + ["mixing_model"])
                    self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                    self.liquid_micro_mixing = self.__class__.liquid_micro_mixing(service, version, mode, path + ["liquid_micro_mixing"])
                    self.epdf_energy = self.__class__.epdf_energy(service, version, mode, path + ["epdf_energy"])
                    self.integration_parameters = self.__class__.integration_parameters(service, version, mode, path + ["integration_parameters"])
                    self.clear_isat_table = self.__class__.clear_isat_table(service, version, mode, path + ["clear_isat_table"])
                    self.pdf_transport_expert = self.__class__.pdf_transport_expert(service, version, mode, path + ["pdf_transport_expert"])
                    self.set_turb_chem_interaction = self.__class__.set_turb_chem_interaction(service, version, mode, path + ["set_turb_chem_interaction"])
                    self.spark_model = self.__class__.spark_model(service, version, mode, path + ["spark_model"])
                    self.ignition_model = self.__class__.ignition_model(service, version, mode, path + ["ignition_model"])
                    self.ignition_model_controls = self.__class__.ignition_model_controls(service, version, mode, path + ["ignition_model_controls"])
                    self.inert_transport_model = self.__class__.inert_transport_model(service, version, mode, path + ["inert_transport_model"])
                    self.inert_transport_controls = self.__class__.inert_transport_controls(service, version, mode, path + ["inert_transport_controls"])
                    self.particle_surface_reactions = self.__class__.particle_surface_reactions(service, version, mode, path + ["particle_surface_reactions"])
                    self.wall_surface_reactions = self.__class__.wall_surface_reactions(service, version, mode, path + ["wall_surface_reactions"])
                    self.heat_of_surface_reactions = self.__class__.heat_of_surface_reactions(service, version, mode, path + ["heat_of_surface_reactions"])
                    self.mass_deposition_source = self.__class__.mass_deposition_source(service, version, mode, path + ["mass_deposition_source"])
                    self.electro_chemical_surface_reactions = self.__class__.electro_chemical_surface_reactions(service, version, mode, path + ["electro_chemical_surface_reactions"])
                    self.species_migration = self.__class__.species_migration(service, version, mode, path + ["species_migration"])
                    self.reaction_diffusion_balance = self.__class__.reaction_diffusion_balance(service, version, mode, path + ["reaction_diffusion_balance"])
                    self.surf_reaction_aggressiveness_factor = self.__class__.surf_reaction_aggressiveness_factor(service, version, mode, path + ["surf_reaction_aggressiveness_factor"])
                    self.surf_reaction_netm_params = self.__class__.surf_reaction_netm_params(service, version, mode, path + ["surf_reaction_netm_params"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.diffusion_energy_source = self.__class__.diffusion_energy_source(service, version, mode, path + ["diffusion_energy_source"])
                    self.multicomponent_diffusion = self.__class__.multicomponent_diffusion(service, version, mode, path + ["multicomponent_diffusion"])
                    self.thermal_diffusion = self.__class__.thermal_diffusion(service, version, mode, path + ["thermal_diffusion"])
                    self.CHEMKIN_CFD = self.__class__.CHEMKIN_CFD(service, version, mode, path + ["CHEMKIN_CFD"])
                    self.non_premixed_combustion_parameters = self.__class__.non_premixed_combustion_parameters(service, version, mode, path + ["non_premixed_combustion_parameters"])
                    self.partially_premixed_combustion_parameters = self.__class__.partially_premixed_combustion_parameters(service, version, mode, path + ["partially_premixed_combustion_parameters"])
                    self.partially_premixed_properties = self.__class__.partially_premixed_properties(service, version, mode, path + ["partially_premixed_properties"])
                    self.re_calc_par_premix_props = self.__class__.re_calc_par_premix_props(service, version, mode, path + ["re_calc_par_premix_props"])
                    self.full_tabulation = self.__class__.full_tabulation(service, version, mode, path + ["full_tabulation"])
                    self.init_unsteady_flamelet_prob = self.__class__.init_unsteady_flamelet_prob(service, version, mode, path + ["init_unsteady_flamelet_prob"])
                    self.import_flamelet_for_restart = self.__class__.import_flamelet_for_restart(service, version, mode, path + ["import_flamelet_for_restart"])
                    self.non_premixed_combustion_expert = self.__class__.non_premixed_combustion_expert(service, version, mode, path + ["non_premixed_combustion_expert"])
                    self.partially_premixed_combustion_expert = self.__class__.partially_premixed_combustion_expert(service, version, mode, path + ["partially_premixed_combustion_expert"])
                    self.partially_premixed_combustion_grids = self.__class__.partially_premixed_combustion_grids(service, version, mode, path + ["partially_premixed_combustion_grids"])
                    self.flamelet_expert = self.__class__.flamelet_expert(service, version, mode, path + ["flamelet_expert"])
                    self.combustion_expert = self.__class__.combustion_expert(service, version, mode, path + ["combustion_expert"])
                    self.set_premixed_combustion = self.__class__.set_premixed_combustion(service, version, mode, path + ["set_premixed_combustion"])
                    self.set_multi_regime_fgm = self.__class__.set_multi_regime_fgm(service, version, mode, path + ["set_multi_regime_fgm"])
                    self.relax_to_equil = self.__class__.relax_to_equil(service, version, mode, path + ["relax_to_equil"])
                    self.thickened_flame_model = self.__class__.thickened_flame_model(service, version, mode, path + ["thickened_flame_model"])
                    self.decoupled_detailed_chemistry = self.__class__.decoupled_detailed_chemistry(service, version, mode, path + ["decoupled_detailed_chemistry"])
                    self.reactor_network_model = self.__class__.reactor_network_model(service, version, mode, path + ["reactor_network_model"])
                    self.reacting_channel_model = self.__class__.reacting_channel_model(service, version, mode, path + ["reacting_channel_model"])
                    self.reacting_channel_model_options = self.__class__.reacting_channel_model_options(service, version, mode, path + ["reacting_channel_model_options"])
                    self.combustion_numerics = self.__class__.combustion_numerics(service, version, mode, path + ["combustion_numerics"])
                    super().__init__(service, version, mode, path)
                class off(TUIMethod):
                    """
                    Enables/disables solution of species models.
                    """
                class species_transport(TUIMethod):
                    """
                    Enables/disables the species transport model.
                    """
                class non_premixed_combustion(TUIMethod):
                    """
                    Enables/disables non-premixed combustion model.
                    """
                class premixed_combustion(TUIMethod):
                    """
                    Enables/disables premixed combustion model.
                    """
                class partially_premixed_combustion(TUIMethod):
                    """
                    Enables/disables partially premixed combustion model.
                    """
                class premixed_model(TUIMethod):
                    """
                    Sets premixed combustion model.
                    """
                class pdf_transport(TUIMethod):
                    """
                    Enables/disables the composition PDF transport combustion model.
                    """
                class save_gradients(TUIMethod):
                    """
                    Enables/disables storage of species mass fraction gradients.
                    """
                class liquid_energy_diffusion(TUIMethod):
                    """
                    Enable/disable energy diffusion for liquid regime.
                    """
                class volumetric_reactions(TUIMethod):
                    """
                    Enables/disables volumetric reactions.
                    """
                class species_transport_expert(TUIMethod):
                    """
                    Sets the convergence acceleration expert parameters. This command is only available 	when the species transport model is enabled.
                    """
                class coal_calculator(TUIMethod):
                    """
                    Sets up coal modeling inputs.
                    """
                class mixing_model(TUIMethod):
                    """
                    Sets PDF Transport mixing model.
                    """
                class stiff_chemistry(TUIMethod):
                    """
                    Enables/disables stiff chemistry option.
                    """
                class liquid_micro_mixing(TUIMethod):
                    """
                    Enables/disables liquid micro mixing.
                    """
                class epdf_energy(TUIMethod):
                    """
                    Enables/disables EPDF energy option.
                    """
                class integration_parameters(TUIMethod):
                    """
                    Sets chemistry ODE integrator parameters. Enables/disables stiff chemistry 	acceleration methods and set their parameters.
                    """
                class clear_isat_table(TUIMethod):
                    """
                    Clears ISAT table.
                    """
                class pdf_transport_expert(TUIMethod):
                    """
                    Enables/disables PDF Transport expert user.
                    """
                class set_turb_chem_interaction(TUIMethod):
                    """
                    Sets EDC model constants.
                    """
                class spark_model(TUIMethod):
                    """
                    Switches between the R15 and R14.5 spark models and sets spark model 	parameters.
                    """
                class ignition_model(TUIMethod):
                    """
                    Enables/disables the ignition model.
                    """
                class ignition_model_controls(TUIMethod):
                    """
                    Sets ignition model parameters.
                    """
                class inert_transport_model(TUIMethod):
                    """
                    Enables/disables the inert transport model.
                    """
                class inert_transport_controls(TUIMethod):
                    """
                    Sets inert transport model parameters.
                    """
                class particle_surface_reactions(TUIMethod):
                    """
                    Enables/disables particle surface reactions.
                    """
                class wall_surface_reactions(TUIMethod):
                    """
                    Enables/disables wall surface reactions.
                    """
                class heat_of_surface_reactions(TUIMethod):
                    """
                    Enables/disables heat of surface reactions.
                    """
                class mass_deposition_source(TUIMethod):
                    """
                    Enables/disables mass deposition source due to surface reactions.
                    """
                class electro_chemical_surface_reactions(TUIMethod):
                    """
                    Enables/disables electrochemical surface reactions.
                    """
                class species_migration(TUIMethod):
                    """
                    Includes species migration in electric field. This command is available only when 	the electrochemical surface reactions are 	enabled.
                    """
                class reaction_diffusion_balance(TUIMethod):
                    """
                    Enables/disables reaction diffusion balance at reacting surface for surface 	reactions.
                    """
                class surf_reaction_aggressiveness_factor(TUIMethod):
                    """
                    Sets the surface reaction aggressiveness factor.
                    """
                class surf_reaction_netm_params(TUIMethod):
                    """
                    Sets the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enables/disables inclusion of diffusion at inlets.
                    """
                class diffusion_energy_source(TUIMethod):
                    """
                    Enables/disables diffusion energy source.
                    """
                class multicomponent_diffusion(TUIMethod):
                    """
                    Enables/disables multicomponent diffusion.
                    """
                class thermal_diffusion(TUIMethod):
                    """
                    Enables/disables thermal diffusion.
                    """
                class CHEMKIN_CFD(TUIMethod):
                    """
                    Enables/disables the Ansys CHEMKIN-CFD solver.
                    """
                class non_premixed_combustion_parameters(TUIMethod):
                    """
                    Sets PDF parameters.
                    """
                class partially_premixed_combustion_parameters(TUIMethod):
                    """
                    Sets PDF parameters.
                    """
                class partially_premixed_properties(TUIMethod):
                    """
                    Sets/changes partially-premixed mixture properties. 	This command is only available when partially-premixed-combustion? 	is enabled.
                    """
                class re_calc_par_premix_props(TUIMethod):
                    """
                    Re-calculate partially-premixed properties.
                    """
                class full_tabulation(TUIMethod):
                    """
                    Enables/disables building of a full 2-mixture fraction table.
                    """
                class init_unsteady_flamelet_prob(TUIMethod):
                    """
                    Initializes Unsteady Flamelet Probability.
                    """
                class import_flamelet_for_restart(TUIMethod):
                    """
                    Imports Flamelet File for Restart.
                    """
                class non_premixed_combustion_expert(TUIMethod):
                    """
                    Sets PDF expert parameters.
                    """
                class partially_premixed_combustion_expert(TUIMethod):
                    """
                    Sets PDF expert parameters.
                    """
                class partially_premixed_combustion_grids(TUIMethod):
                    """
                    Sets values for the grid distribution for PDF table or 	flamelet parameter. This text command is available only 	for partially premixed combustion cases with FGM.
                    """
                class flamelet_expert(TUIMethod):
                    """
                    Sets flamelet expert parameters.
                    """
                class combustion_expert(TUIMethod):
                    """
                    Enables import of the CHEMKIN mechanism transport 	data. When this option is enabled, you will be prompted 	for importing CHEMKIN transport property database when 	setting your combustion case.
                    """
                class set_premixed_combustion(TUIMethod):
                    """
                    Sets premixed combustion parameters.
                    """
                class set_multi_regime_fgm(TUIMethod):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                class relax_to_equil(TUIMethod):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                class thickened_flame_model(TUIMethod):
                    """
                    Enables/disables the Relaxation to Chemical Equilibrium model.
                    """
                class decoupled_detailed_chemistry(TUIMethod):
                    """
                    Enables/disables the Decoupled Detailed Chemistry model.
                    """
                class reactor_network_model(TUIMethod):
                    """
                    Enables/disables the Reactor Network Model.
                    """
                class reacting_channel_model(TUIMethod):
                    """
                    Enables/disables the Reacting Channel Model.
                    """
                class reacting_channel_model_options(TUIMethod):
                    """
                    Sets Reacting Channel Model parameters.
                    """
                class combustion_numerics(TUIMethod):
                    """
                    Applies optimal solver settings automatically to provide a faster solution time. 	This command is available only for transient 	non-premixed and partially premixed combustion 	models.
                    """

                class CHEMKIN_CFD_parameters(TUIMenu):
                    """
                    Enters the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.basic_options = self.__class__.basic_options(service, version, mode, path + ["basic_options"])
                        self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                        self.add_cell_monitor = self.__class__.add_cell_monitor(service, version, mode, path + ["add_cell_monitor"])
                        self.list_cell_monitors = self.__class__.list_cell_monitors(service, version, mode, path + ["list_cell_monitors"])
                        self.delete_cell_monitors = self.__class__.delete_cell_monitors(service, version, mode, path + ["delete_cell_monitors"])
                        super().__init__(service, version, mode, path)
                    class basic_options(TUIMethod):
                        """
                        Sets basic parameter options.
                        """
                    class advanced_options(TUIMethod):
                        """
                        Sets advanced parameter options.
                        """
                    class add_cell_monitor(TUIMethod):
                        """
                        Monitors cell for debug output.
                        """
                    class list_cell_monitors(TUIMethod):
                        """
                        Lists cell monitors.
                        """
                    class delete_cell_monitors(TUIMethod):
                        """
                        Deletes cell monitors.
                        """

            class viscous(TUIMenu):
                """
                Enters the viscous model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.near_wall_treatment = self.__class__.near_wall_treatment(service, version, mode, path + ["near_wall_treatment"])
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(service, version, mode, path + ["multiphase_turbulence"])
                    self.turbulence_expert = self.__class__.turbulence_expert(service, version, mode, path + ["turbulence_expert"])
                    self.geko_options = self.__class__.geko_options(service, version, mode, path + ["geko_options"])
                    self.transition_model_options = self.__class__.transition_model_options(service, version, mode, path + ["transition_model_options"])
                    self.inviscid = self.__class__.inviscid(service, version, mode, path + ["inviscid"])
                    self.laminar = self.__class__.laminar(service, version, mode, path + ["laminar"])
                    self.low_pressure_boundary_slip = self.__class__.low_pressure_boundary_slip(service, version, mode, path + ["low_pressure_boundary_slip"])
                    self.mixing_length = self.__class__.mixing_length(service, version, mode, path + ["mixing_length"])
                    self.zero_equation_hvac = self.__class__.zero_equation_hvac(service, version, mode, path + ["zero_equation_hvac"])
                    self.spalart_allmaras = self.__class__.spalart_allmaras(service, version, mode, path + ["spalart_allmaras"])
                    self.ke1e = self.__class__.ke1e(service, version, mode, path + ["ke1e"])
                    self.sa_enhanced_wall_treatment = self.__class__.sa_enhanced_wall_treatment(service, version, mode, path + ["sa_enhanced_wall_treatment"])
                    self.sa_alternate_prod = self.__class__.sa_alternate_prod(service, version, mode, path + ["sa_alternate_prod"])
                    self.sa_damping = self.__class__.sa_damping(service, version, mode, path + ["sa_damping"])
                    self.ke_standard = self.__class__.ke_standard(service, version, mode, path + ["ke_standard"])
                    self.ke_easm = self.__class__.ke_easm(service, version, mode, path + ["ke_easm"])
                    self.ke_realizable = self.__class__.ke_realizable(service, version, mode, path + ["ke_realizable"])
                    self.ke_rng = self.__class__.ke_rng(service, version, mode, path + ["ke_rng"])
                    self.rng_differential_visc = self.__class__.rng_differential_visc(service, version, mode, path + ["rng_differential_visc"])
                    self.rng_swirl_model = self.__class__.rng_swirl_model(service, version, mode, path + ["rng_swirl_model"])
                    self.kw_standard = self.__class__.kw_standard(service, version, mode, path + ["kw_standard"])
                    self.kw_easm = self.__class__.kw_easm(service, version, mode, path + ["kw_easm"])
                    self.kw_bsl = self.__class__.kw_bsl(service, version, mode, path + ["kw_bsl"])
                    self.kw_geko = self.__class__.kw_geko(service, version, mode, path + ["kw_geko"])
                    self.kw_sst = self.__class__.kw_sst(service, version, mode, path + ["kw_sst"])
                    self.kw_wj_bsl_earsm = self.__class__.kw_wj_bsl_earsm(service, version, mode, path + ["kw_wj_bsl_earsm"])
                    self.kw_low_re_correction = self.__class__.kw_low_re_correction(service, version, mode, path + ["kw_low_re_correction"])
                    self.kw_shear_correction = self.__class__.kw_shear_correction(service, version, mode, path + ["kw_shear_correction"])
                    self.turb_compressibility = self.__class__.turb_compressibility(service, version, mode, path + ["turb_compressibility"])
                    self.k_kl_w = self.__class__.k_kl_w(service, version, mode, path + ["k_kl_w"])
                    self.transition_sst = self.__class__.transition_sst(service, version, mode, path + ["transition_sst"])
                    self.v2f = self.__class__.v2f(service, version, mode, path + ["v2f"])
                    self.reynolds_stress_model = self.__class__.reynolds_stress_model(service, version, mode, path + ["reynolds_stress_model"])
                    self.rsm_solve_tke = self.__class__.rsm_solve_tke(service, version, mode, path + ["rsm_solve_tke"])
                    self.rsm_wall_echo = self.__class__.rsm_wall_echo(service, version, mode, path + ["rsm_wall_echo"])
                    self.rsm_linear_pressure_strain = self.__class__.rsm_linear_pressure_strain(service, version, mode, path + ["rsm_linear_pressure_strain"])
                    self.rsm_ssg_pressure_strain = self.__class__.rsm_ssg_pressure_strain(service, version, mode, path + ["rsm_ssg_pressure_strain"])
                    self.rsm_omega_based = self.__class__.rsm_omega_based(service, version, mode, path + ["rsm_omega_based"])
                    self.rsm_bsl_based = self.__class__.rsm_bsl_based(service, version, mode, path + ["rsm_bsl_based"])
                    self.sas = self.__class__.sas(service, version, mode, path + ["sas"])
                    self.detached_eddy_simulation = self.__class__.detached_eddy_simulation(service, version, mode, path + ["detached_eddy_simulation"])
                    self.des_limiter_option = self.__class__.des_limiter_option(service, version, mode, path + ["des_limiter_option"])
                    self.large_eddy_simulation = self.__class__.large_eddy_simulation(service, version, mode, path + ["large_eddy_simulation"])
                    self.les_subgrid_smagorinsky = self.__class__.les_subgrid_smagorinsky(service, version, mode, path + ["les_subgrid_smagorinsky"])
                    self.les_dynamic_energy_flux = self.__class__.les_dynamic_energy_flux(service, version, mode, path + ["les_dynamic_energy_flux"])
                    self.les_dynamic_scalar_flux = self.__class__.les_dynamic_scalar_flux(service, version, mode, path + ["les_dynamic_scalar_flux"])
                    self.les_subgrid_dynamic_fvar = self.__class__.les_subgrid_dynamic_fvar(service, version, mode, path + ["les_subgrid_dynamic_fvar"])
                    self.les_subgrid_rng = self.__class__.les_subgrid_rng(service, version, mode, path + ["les_subgrid_rng"])
                    self.les_subgrid_wale = self.__class__.les_subgrid_wale(service, version, mode, path + ["les_subgrid_wale"])
                    self.les_subgrid_wmles = self.__class__.les_subgrid_wmles(service, version, mode, path + ["les_subgrid_wmles"])
                    self.les_subgrid_wmles_s_minus_omega = self.__class__.les_subgrid_wmles_s_minus_omega(service, version, mode, path + ["les_subgrid_wmles_s_minus_omega"])
                    self.les_subgrid_tke = self.__class__.les_subgrid_tke(service, version, mode, path + ["les_subgrid_tke"])
                    self.turb_buoyancy_effects = self.__class__.turb_buoyancy_effects(service, version, mode, path + ["turb_buoyancy_effects"])
                    self.curvature_correction = self.__class__.curvature_correction(service, version, mode, path + ["curvature_correction"])
                    self.curvature_correction_ccurv = self.__class__.curvature_correction_ccurv(service, version, mode, path + ["curvature_correction_ccurv"])
                    self.corner_flow_correction = self.__class__.corner_flow_correction(service, version, mode, path + ["corner_flow_correction"])
                    self.corner_flow_correction_ccorner = self.__class__.corner_flow_correction_ccorner(service, version, mode, path + ["corner_flow_correction_ccorner"])
                    self.rsm_or_earsm_geko_option = self.__class__.rsm_or_earsm_geko_option(service, version, mode, path + ["rsm_or_earsm_geko_option"])
                    self.add_transition_model = self.__class__.add_transition_model(service, version, mode, path + ["add_transition_model"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    self.user_defined_transition = self.__class__.user_defined_transition(service, version, mode, path + ["user_defined_transition"])
                    self.trans_sst_roughness_correlation = self.__class__.trans_sst_roughness_correlation(service, version, mode, path + ["trans_sst_roughness_correlation"])
                    super().__init__(service, version, mode, path)
                class inviscid(TUIMethod):
                    """
                    Enables/disables inviscid flow model.
                    """
                class laminar(TUIMethod):
                    """
                    Enables/disables laminar flow model.
                    """
                class low_pressure_boundary_slip(TUIMethod):
                    """
                    Enables/disables the slip boundary formulation for 	low-pressure gas systems.
                    """
                class mixing_length(TUIMethod):
                    """
                    Enables/disables mixing-length (algebraic) turbulence model.
                    """
                class zero_equation_hvac(TUIMethod):
                    """
                    Enables/disables zero-equation HVAC turbulence model.
                    """
                class spalart_allmaras(TUIMethod):
                    """
                    Enables/disables Spalart-Allmaras turbulence model.
                    """
                class ke1e(TUIMethod):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                class sa_enhanced_wall_treatment(TUIMethod):
                    """
                    Enables/disables the enhanced wall treatment for the Spalart-Allmaras model. If 	disabled, no smooth blending between the viscous 	sublayer and the log-law formulation is employed, as was 	done in versions previous to Fluent 14.
                    """
                class sa_alternate_prod(TUIMethod):
                    """
                    Enables/disables strain/vorticity production in Spalart-Allmaras model.
                    """
                class sa_damping(TUIMethod):
                    """
                    Enables/disables full low-Reynolds number form of Spalart-Allmaras model. This option is only available if your response wasno to sa-enhanced-wall-treatment?.
                    """
                class ke_standard(TUIMethod):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                class ke_easm(TUIMethod):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                class ke_realizable(TUIMethod):
                    """
                    Enables/disables the realizable -  turbulence model.
                    """
                class ke_rng(TUIMethod):
                    """
                    Enables/disables the RNG -  turbulence model.
                    """
                class rng_differential_visc(TUIMethod):
                    """
                    Enables/disables the differential-viscosity model.
                    """
                class rng_swirl_model(TUIMethod):
                    """
                    Enables/disables swirl corrections for rng-model.
                    """
                class kw_standard(TUIMethod):
                    """
                    Enables/disables the standard -  turbulence model.
                    """
                class kw_easm(TUIMethod):
                    """
                    Enables/disables the EASM -  turbulence model.
                    """
                class kw_bsl(TUIMethod):
                    """
                    Enables/disables the baseline (BSL) -  turbulence model.
                    """
                class kw_geko(TUIMethod):
                    """
                    Enables/disables the generalized -  (GEKO) turbulence model.
                    """
                class kw_sst(TUIMethod):
                    """
                    Enables/disables the SST -  turbulence model.
                    """
                class kw_wj_bsl_earsm(TUIMethod):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                class kw_low_re_correction(TUIMethod):
                    """
                    Enables/disables the -  low Re option.
                    """
                class kw_shear_correction(TUIMethod):
                    """
                    Enables/disables the -  shear-flow correction option. This 	text command is only available for the standard  -  model and the stress-omega RSM 	model.
                    """
                class turb_compressibility(TUIMethod):
                    """
                    Enables/disables the compressibility correction option.
                    """
                class k_kl_w(TUIMethod):
                    """
                    Enables/disables the k-kl-  turbulence model.
                    """
                class transition_sst(TUIMethod):
                    """
                    Enables/disables the transition SST turbulence model.
                    """
                class v2f(TUIMethod):
                    """
                    Enables/disables V2F turbulence model.
                    """
                class reynolds_stress_model(TUIMethod):
                    """
                    Enables/disables the Reynolds-stress turbulence model.
                    """
                class rsm_solve_tke(TUIMethod):
                    """
                    Enables/disables the solution of T.K.E. in RSM model.
                    """
                class rsm_wall_echo(TUIMethod):
                    """
                    Enables/disables wall-echo effects in RSM model.
                    """
                class rsm_linear_pressure_strain(TUIMethod):
                    """
                    Enables/disables the linear pressure-strain model in RSM.
                    """
                class rsm_ssg_pressure_strain(TUIMethod):
                    """
                    Enables/disables quadratic pressure-strain model in RSM.
                    """
                class rsm_omega_based(TUIMethod):
                    """
                    Enables/disables the stress-omega Reynolds stress model.
                    """
                class rsm_bsl_based(TUIMethod):
                    """
                    Enables/disables the stress-BSL Reynolds stress model.
                    """
                class sas(TUIMethod):
                    """
                    Enables/disables Scale-Adaptive Simulation (SAS) in combination with the SST  -  turbulence model.
                    """
                class detached_eddy_simulation(TUIMethod):
                    """
                    Enables/disables detached eddy simulation.
                    """
                class des_limiter_option(TUIMethod):
                    """
                    Selects the DES limiter option (none, F1, F2, Delayed DES, or Improved Delayed 	DES).
                    """
                class large_eddy_simulation(TUIMethod):
                    """
                    Enables/disables large eddy simulation.
                    """
                class les_subgrid_smagorinsky(TUIMethod):
                    """
                    Enables/disables the Smagorinsky-Lilly subgrid-scale model.
                    """
                class les_dynamic_energy_flux(TUIMethod):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                class les_dynamic_scalar_flux(TUIMethod):
                    """
                    Enables/disables the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                class les_subgrid_dynamic_fvar(TUIMethod):
                    """
                    Enables/disables the dynamic subgrid-scale mixture fraction variance model.
                    """
                class les_subgrid_rng(TUIMethod):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                class les_subgrid_wale(TUIMethod):
                    """
                    Enables/disables WALE subgrid-scale model.
                    """
                class les_subgrid_wmles(TUIMethod):
                    """
                    Enables/disables the WMLES subgrid-scale model.
                    """
                class les_subgrid_wmles_s_minus_omega(TUIMethod):
                    """
                    Enables/disables the WMLES -  subgrid-scale model.
                    """
                class les_subgrid_tke(TUIMethod):
                    """
                    Enables/disables kinetic energy transport subgrid-scale model.
                    """
                class turb_buoyancy_effects(TUIMethod):
                    """
                    Enables/disables effects of buoyancy on 	turbulence.
                    """
                class curvature_correction(TUIMethod):
                    """
                    Enables/disables the curvature correction.
                    """
                class curvature_correction_ccurv(TUIMethod):
                    """
                    Sets the strength of the curvature correction term. 	The default value is 1. This is available after the curvature-correction? 	option is enabled.
                    """
                class corner_flow_correction(TUIMethod):
                    """
                    Enables/disables the corner flow correction.
                    """
                class corner_flow_correction_ccorner(TUIMethod):
                    """
                    Sets the strength of the quadratic term of the corner flow correction. The default 	value is 1. This is available after the corner-flow-correction? 	option is enabled.
                    """
                class rsm_or_earsm_geko_option(TUIMethod):
                    """
                    Enables/disables the RSM version of the GEKO model.
                    """
                class add_transition_model(TUIMethod):
                    """
                    Sets Transition model to account for transitional effects. The default is none, however you can 	select gamma-algebraic or gamma-transport-eqn.  After a transition model has been enabled, you have additional options in the 	submenu transition-model-options.
                    """
                class user_defined(TUIMethod):
                    """
                    Selects user-defined functions to define the turbulent viscosity and the turbulent 	Prandtl and Schmidt numbers.
                    """
                class user_defined_transition(TUIMethod):
                    """
                    Sets user-defined transition correlations.
                    """
                class trans_sst_roughness_correlation(TUIMethod):
                    """
                    Enables/disables the Transition-SST roughness correlation option.
                    """

                class near_wall_treatment(TUIMenu):
                    """
                    Enters the near wall treatment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.non_equilibrium_wall_fn = self.__class__.non_equilibrium_wall_fn(service, version, mode, path + ["non_equilibrium_wall_fn"])
                        self.enhanced_wall_treatment = self.__class__.enhanced_wall_treatment(service, version, mode, path + ["enhanced_wall_treatment"])
                        self.menter_lechner = self.__class__.menter_lechner(service, version, mode, path + ["menter_lechner"])
                        self.scalable_wall_functions = self.__class__.scalable_wall_functions(service, version, mode, path + ["scalable_wall_functions"])
                        self.user_defined_wall_functions = self.__class__.user_defined_wall_functions(service, version, mode, path + ["user_defined_wall_functions"])
                        self.werner_wengle_wall_fn = self.__class__.werner_wengle_wall_fn(service, version, mode, path + ["werner_wengle_wall_fn"])
                        self.wf_pressure_gradient_effects = self.__class__.wf_pressure_gradient_effects(service, version, mode, path + ["wf_pressure_gradient_effects"])
                        self.wf_thermal_effects = self.__class__.wf_thermal_effects(service, version, mode, path + ["wf_thermal_effects"])
                        super().__init__(service, version, mode, path)
                    class non_equilibrium_wall_fn(TUIMethod):
                        """
                        Enables/disables non-equilibrium wall functions.
                        """
                    class enhanced_wall_treatment(TUIMethod):
                        """
                        Enables/disables enhanced wall functions.
                        """
                    class menter_lechner(TUIMethod):
                        """
                        Enables/disables the Menter-Lechner near-wall treatment.
                        """
                    class scalable_wall_functions(TUIMethod):
                        """
                        Enables/disables scalable wall functions.
                        """
                    class user_defined_wall_functions(TUIMethod):
                        """
                        Enables/disables user-defined wall functions.
                        """
                    class werner_wengle_wall_fn(TUIMethod):
                        """
                        Enables/disables Werner-Wengle wall functions.
                        """
                    class wf_pressure_gradient_effects(TUIMethod):
                        """
                        Enables/disables wall function pressure- gradient effects.
                        """
                    class wf_thermal_effects(TUIMethod):
                        """
                        Enables/disables wall function thermal effects.
                        """

                class multiphase_turbulence(TUIMenu):
                    """
                    Enters the multiphase turbulence menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.multiphase_options = self.__class__.multiphase_options(service, version, mode, path + ["multiphase_options"])
                        self.turbulence_multiphase_models = self.__class__.turbulence_multiphase_models(service, version, mode, path + ["turbulence_multiphase_models"])
                        self.rsm_multiphase_models = self.__class__.rsm_multiphase_models(service, version, mode, path + ["rsm_multiphase_models"])
                        self.subgrid_turbulence_contribution_aiad = self.__class__.subgrid_turbulence_contribution_aiad(service, version, mode, path + ["subgrid_turbulence_contribution_aiad"])
                        super().__init__(service, version, mode, path)
                    class multiphase_options(TUIMethod):
                        """
                        Enables/disables multiphase options.
                        """
                    class turbulence_multiphase_models(TUIMethod):
                        """
                        Selects -  multiphase model.
                        """
                    class rsm_multiphase_models(TUIMethod):
                        """
                        Selects Reynolds Stress multiphase model.
                        """
                    class subgrid_turbulence_contribution_aiad(TUIMethod):
                        """
                        Enable/disable the Subgrid Turbulence Contribution for the AIAD model.
                        """

                class turbulence_expert(TUIMenu):
                    """
                    Enters the turbulence expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.low_re_ke = self.__class__.low_re_ke(service, version, mode, path + ["low_re_ke"])
                        self.low_re_ke_index = self.__class__.low_re_ke_index(service, version, mode, path + ["low_re_ke_index"])
                        self.kato_launder_model = self.__class__.kato_launder_model(service, version, mode, path + ["kato_launder_model"])
                        self.production_limiter = self.__class__.production_limiter(service, version, mode, path + ["production_limiter"])
                        self.kw_vorticity_based_production = self.__class__.kw_vorticity_based_production(service, version, mode, path + ["kw_vorticity_based_production"])
                        self.kw_add_sas = self.__class__.kw_add_sas(service, version, mode, path + ["kw_add_sas"])
                        self.kw_add_des = self.__class__.kw_add_des(service, version, mode, path + ["kw_add_des"])
                        self.turb_add_sbes_sdes = self.__class__.turb_add_sbes_sdes(service, version, mode, path + ["turb_add_sbes_sdes"])
                        self.sbes_sdes_hybrid_model = self.__class__.sbes_sdes_hybrid_model(service, version, mode, path + ["sbes_sdes_hybrid_model"])
                        self.sbes_update_interval_k_omega = self.__class__.sbes_update_interval_k_omega(service, version, mode, path + ["sbes_update_interval_k_omega"])
                        self.sbes_sgs_option = self.__class__.sbes_sgs_option(service, version, mode, path + ["sbes_sgs_option"])
                        self.sbes_les_subgrid_dynamic_fvar = self.__class__.sbes_les_subgrid_dynamic_fvar(service, version, mode, path + ["sbes_les_subgrid_dynamic_fvar"])
                        self.turbulence_damping = self.__class__.turbulence_damping(service, version, mode, path + ["turbulence_damping"])
                        self.rke_cmu_rotation_term = self.__class__.rke_cmu_rotation_term(service, version, mode, path + ["rke_cmu_rotation_term"])
                        self.turb_non_newtonian = self.__class__.turb_non_newtonian(service, version, mode, path + ["turb_non_newtonian"])
                        self.non_newtonian_modification = self.__class__.non_newtonian_modification(service, version, mode, path + ["non_newtonian_modification"])
                        self.turb_pk_compressible = self.__class__.turb_pk_compressible(service, version, mode, path + ["turb_pk_compressible"])
                        self.thermal_p_function = self.__class__.thermal_p_function(service, version, mode, path + ["thermal_p_function"])
                        self.restore_sst_v61 = self.__class__.restore_sst_v61(service, version, mode, path + ["restore_sst_v61"])
                        self.stg_set_ti_and_tvr_limiters = self.__class__.stg_set_ti_and_tvr_limiters(service, version, mode, path + ["stg_set_ti_and_tvr_limiters"])
                        super().__init__(service, version, mode, path)
                    class low_re_ke(TUIMethod):
                        """
                        Enables/disables the low-Re -  turbulence model.
                        """
                    class low_re_ke_index(TUIMethod):
                        """
                        Specifies which low-Reynolds-number -  model is to be used. Six models are available:
                        Index
                        Model
                        0
                        Abid
                        1
                        Lam-Bremhorst
                        2
                        Launder-Sharma
                        3
                        Yang-Shih
                        4
                        Abe-Kondoh-Nagano
                        5
                        Chang-Hsieh-Chen
                        Contact your Ansys, Inc. technical support engineer for more details.
                        """
                    class kato_launder_model(TUIMethod):
                        """
                        Enables/disables Kato-Launder modification.
                        """
                    class production_limiter(TUIMethod):
                        """
                        Enables/disables Production Limiter modification.
                        """
                    class kw_vorticity_based_production(TUIMethod):
                        """
                        Enables/disables vorticity-based production.
                        """
                    class kw_add_sas(TUIMethod):
                        """
                        Enables/disables Scale-Adaptive Simulation (SAS) in combination with the currently selected -based URANS turbulence model. This text command is only available for transient cases.
                        """
                    class kw_add_des(TUIMethod):
                        """
                        Enables/disables Detached Eddy Simulation (DES) in combination with the currently selected BSL -  model or transition SST model. This text command is only available for transient cases.
                        """
                    class turb_add_sbes_sdes(TUIMethod):
                        """
                        Enables/disables the Stress-Blended Eddy Simulation (SBES) model or Shielded Detached Eddy Simulation (SDES) model.
                        """
                    class sbes_sdes_hybrid_model(TUIMethod):
                        """
                        Selects the hybrid model, to specify whether you want to apply the Shielded Detached Eddy Simulation (SDES) model, Stress-Blended Eddy Simulation (SBES), or SBES with a user-defined function.
                        """
                    class sbes_update_interval_k_omega(TUIMethod):
                        """
                        Sets the number of time steps between updates of the k-ω part of the SBES model.
                        """
                    class sbes_sgs_option(TUIMethod):
                        """
                        Selects the subgrid-scale model for the LES portion of your Stress-Blended Eddy Simulation (SBES).
                        """
                    class sbes_les_subgrid_dynamic_fvar(TUIMethod):
                        """
                        Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                        """
                    class turbulence_damping(TUIMethod):
                        """
                        Enables/disables turbulence damping and sets turbulence damping parameters.
                        """
                    class rke_cmu_rotation_term(TUIMethod):
                        """
                        Modifies the  definition for the realizable  -  model.
                        """
                    class turb_non_newtonian(TUIMethod):
                        """
                        Enables/disables turbulence for non-Newtonian fluids.
                        """
                    class non_newtonian_modification(TUIMethod):
                        """
                        Enables/disables non-Newtonian modification for Lam-Bremhorst model.
                        """
                    class turb_pk_compressible(TUIMethod):
                        """
                        Enables/disables turbulent production due to compressible divergence.
                        """
                    class thermal_p_function(TUIMethod):
                        """
                        Enables/disables Jayatilleke P function.
                        """
                    class restore_sst_v61(TUIMethod):
                        """
                        Enables/disables SST formulation of v6.1.
                        """
                    class stg_set_ti_and_tvr_limiters(TUIMethod):
                        """
                        Specify minimum Turbulence Intensity (TI) and Turbulent Viscosity Ratio (TVR)
                        to search STG scales only at inlet areas where TVR > TVR_min and TI > TI_min.
                        """

                class geko_options(TUIMenu):
                    """
                    Enters the GEKO model menu..
                    """
                    def __init__(self, service, version, mode, path):
                        self.wall_distance_free = self.__class__.wall_distance_free(service, version, mode, path + ["wall_distance_free"])
                        self.csep = self.__class__.csep(service, version, mode, path + ["csep"])
                        self.cnw = self.__class__.cnw(service, version, mode, path + ["cnw"])
                        self.cmix = self.__class__.cmix(service, version, mode, path + ["cmix"])
                        self.cjet = self.__class__.cjet(service, version, mode, path + ["cjet"])
                        self.blending_function = self.__class__.blending_function(service, version, mode, path + ["blending_function"])
                        self.creal = self.__class__.creal(service, version, mode, path + ["creal"])
                        self.cnw_sub = self.__class__.cnw_sub(service, version, mode, path + ["cnw_sub"])
                        self.cjet_aux = self.__class__.cjet_aux(service, version, mode, path + ["cjet_aux"])
                        self.cbf_lam = self.__class__.cbf_lam(service, version, mode, path + ["cbf_lam"])
                        self.cbf_tur = self.__class__.cbf_tur(service, version, mode, path + ["cbf_tur"])
                        self.geko_defaults = self.__class__.geko_defaults(service, version, mode, path + ["geko_defaults"])
                        super().__init__(service, version, mode, path)
                    class wall_distance_free(TUIMethod):
                        """
                        Enables/disables the wall distance free version of the GEKO model.
                        """
                    class csep(TUIMethod):
                        """
                        Setscsep, the parameter to optimize flow separation from smooth surfaces.
                        """
                    class cnw(TUIMethod):
                        """
                        Setscnw, the parameter to optimize flow in non-equilibrium near wall regions.
                        """
                    class cmix(TUIMethod):
                        """
                        Setscmix, the parameter to optimize strength of mixing in free shear flows.
                        """
                    class cjet(TUIMethod):
                        """
                        Setscjet, the parameter to optimize free shear layer mixing (optimize free jets independent of mixing layer).
                        """
                    class blending_function(TUIMethod):
                        """
                        Sets the blending function, which deactivatescmix and cjet inside boundary layers.
                        """
                    class creal(TUIMethod):
                        """
                        Setscreal, a realizability limiter that ensures positive normal stresses in the entire domain.
                        """
                    class cnw_sub(TUIMethod):
                        """
                        Setscnw_sub, which allows the adjustment of log-layer and cf.
                        """
                    class cjet_aux(TUIMethod):
                        """
                        Setscjet_aux, which allows fine-tuning of the parameter to optimize free jets.
                        """
                    class cbf_lam(TUIMethod):
                        """
                        Setscbf_lam, a part of the blending function and shields the laminar boundary layer.
                        """
                    class cbf_tur(TUIMethod):
                        """
                        Setscbf_tur, a factor for the main blending factor, controlling the thickness of the layer near walls.
                        """
                    class geko_defaults(TUIMethod):
                        """
                        Restores the defaults of all GEKO parameters.
                        """

                class transition_model_options(TUIMenu):
                    """
                    Enters the transition model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.crossflow_transition = self.__class__.crossflow_transition(service, version, mode, path + ["crossflow_transition"])
                        self.critical_reynolds_number_correlation = self.__class__.critical_reynolds_number_correlation(service, version, mode, path + ["critical_reynolds_number_correlation"])
                        self.clambda_scale = self.__class__.clambda_scale(service, version, mode, path + ["clambda_scale"])
                        self.capg_hightu = self.__class__.capg_hightu(service, version, mode, path + ["capg_hightu"])
                        self.cfpg_hightu = self.__class__.cfpg_hightu(service, version, mode, path + ["cfpg_hightu"])
                        self.capg_lowtu = self.__class__.capg_lowtu(service, version, mode, path + ["capg_lowtu"])
                        self.cfpg_lowtu = self.__class__.cfpg_lowtu(service, version, mode, path + ["cfpg_lowtu"])
                        self.ctu_hightu = self.__class__.ctu_hightu(service, version, mode, path + ["ctu_hightu"])
                        self.ctu_lowtu = self.__class__.ctu_lowtu(service, version, mode, path + ["ctu_lowtu"])
                        self.rec_max = self.__class__.rec_max(service, version, mode, path + ["rec_max"])
                        self.rec_c1 = self.__class__.rec_c1(service, version, mode, path + ["rec_c1"])
                        self.rec_c2 = self.__class__.rec_c2(service, version, mode, path + ["rec_c2"])
                        self.cbubble_c1 = self.__class__.cbubble_c1(service, version, mode, path + ["cbubble_c1"])
                        self.cbubble_c2 = self.__class__.cbubble_c2(service, version, mode, path + ["cbubble_c2"])
                        self.rv1_switch = self.__class__.rv1_switch(service, version, mode, path + ["rv1_switch"])
                        super().__init__(service, version, mode, path)
                    class crossflow_transition(TUIMethod):
                        """
                        Enables/disables the effects of crossflow instability.
                        """
                    class critical_reynolds_number_correlation(TUIMethod):
                        """
                        Sets the critical Reynolds number correlation.
                        """
                    class clambda_scale(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                    class capg_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                    class cfpg_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                    class capg_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CAPG_LOWTU.
                        """
                    class cfpg_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CFPG_LOWTU.
                        """
                    class ctu_hightu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CTU_HIGHTU.
                        """
                    class ctu_lowtu(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CTU_LOWTU.
                        """
                    class rec_max(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_MAX.
                        """
                    class rec_c1(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_C1.
                        """
                    class rec_c2(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient REC_C2.
                        """
                    class cbubble_c1(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C1.
                        """
                    class cbubble_c2(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient CBUBBLE_C2.
                        """
                    class rv1_switch(TUIMethod):
                        """
                        Sets the algebraic transition model coefficient RV1_SWITCH.
                        """

            class structure(TUIMenu):
                """
                Enters the structure model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.structure_off = self.__class__.structure_off(service, version, mode, path + ["structure_off"])
                    self.linear_elasticity = self.__class__.linear_elasticity(service, version, mode, path + ["linear_elasticity"])
                    self.nonlinear_elasticity = self.__class__.nonlinear_elasticity(service, version, mode, path + ["nonlinear_elasticity"])
                    self.thermal_effects = self.__class__.thermal_effects(service, version, mode, path + ["thermal_effects"])
                    super().__init__(service, version, mode, path)
                class structure_off(TUIMethod):
                    """
                    Disables the structural model.
                    """
                class linear_elasticity(TUIMethod):
                    """
                    Enables the linear elasticity model.
                    """
                class nonlinear_elasticity(TUIMethod):
                    """
                    Enable the nonlinear elasticity model.
                    """
                class thermal_effects(TUIMethod):
                    """
                    Enable structure thermal effects.
                    """

                class controls(TUIMenu):
                    """
                    Enters the structure controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.numerical_damping_factor = self.__class__.numerical_damping_factor(service, version, mode, path + ["numerical_damping_factor"])
                        self.enhanced_strain = self.__class__.enhanced_strain(service, version, mode, path + ["enhanced_strain"])
                        self.unsteady_damping_rayleigh = self.__class__.unsteady_damping_rayleigh(service, version, mode, path + ["unsteady_damping_rayleigh"])
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        super().__init__(service, version, mode, path)
                    class numerical_damping_factor(TUIMethod):
                        """
                        Sets the damping factor for the structural model (that is, the amplitude decay factor  in  in the Theory Guide).
                        """
                    class enhanced_strain(TUIMethod):
                        """
                        Enable enhanced strain element.
                        """
                    class unsteady_damping_rayleigh(TUIMethod):
                        """
                        Enable/disable Newmark unsteady solution model.
                        """
                    class amg_stabilization(TUIMethod):
                        """
                        Sets the algebraic multigrid (AMG) stabilization method for the structural model calculations.
                        """
                    class max_iter(TUIMethod):
                        """
                        Sets the maximum number of iterations for the structural model calculations.
                        """

                class expert(TUIMenu):
                    """
                    Enters the structure expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.include_pop_in_fsi_force = self.__class__.include_pop_in_fsi_force(service, version, mode, path + ["include_pop_in_fsi_force"])
                        self.steady_2way_fsi = self.__class__.steady_2way_fsi(service, version, mode, path + ["steady_2way_fsi"])
                        self.include_viscous_fsi_force = self.__class__.include_viscous_fsi_force(service, version, mode, path + ["include_viscous_fsi_force"])
                        self.explicit_fsi_force = self.__class__.explicit_fsi_force(service, version, mode, path + ["explicit_fsi_force"])
                        super().__init__(service, version, mode, path)
                    class include_pop_in_fsi_force(TUIMethod):
                        """
                        Enables/disables the inclusion of operating pressure into the fluid-structure interaction force.
                        """
                    class steady_2way_fsi(TUIMethod):
                        """
                        Enable steady 2-way fsi workflow.
                        """
                    class include_viscous_fsi_force(TUIMethod):
                        """
                        Enables/disables the inclusion of a viscous fluid-structure interaction force.
                        """
                    class explicit_fsi_force(TUIMethod):
                        """
                        Enables/disables an explicit fluid-structure interaction force.
                        """

            class heat_exchanger(TUIMenu):
                """
                Enters the heat exchanger menu.
                """
                def __init__(self, service, version, mode, path):
                    self.macro_model = self.__class__.macro_model(service, version, mode, path + ["macro_model"])
                    self.dual_cell_model = self.__class__.dual_cell_model(service, version, mode, path + ["dual_cell_model"])
                    super().__init__(service, version, mode, path)

                class macro_model(TUIMenu):
                    """
                    Enters the heat macro-model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.heat_exchanger_model = self.__class__.heat_exchanger_model(service, version, mode, path + ["heat_exchanger_model"])
                        self.heat_exchanger_zone = self.__class__.heat_exchanger_zone(service, version, mode, path + ["heat_exchanger_zone"])
                        self.heat_exchanger_group = self.__class__.heat_exchanger_group(service, version, mode, path + ["heat_exchanger_group"])
                        self.delete_heat_exchanger_group = self.__class__.delete_heat_exchanger_group(service, version, mode, path + ["delete_heat_exchanger_group"])
                        self.heat_exchanger_report = self.__class__.heat_exchanger_report(service, version, mode, path + ["heat_exchanger_report"])
                        self.heat_exchanger_macro_report = self.__class__.heat_exchanger_macro_report(service, version, mode, path + ["heat_exchanger_macro_report"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        super().__init__(service, version, mode, path)
                    class heat_exchanger(TUIMethod):
                        """
                        Enables/disables heat-exchanger model.
                        """
                    class heat_exchanger_model(TUIMethod):
                        """
                        Defines heat-exchanger core model.
                        """
                    class heat_exchanger_zone(TUIMethod):
                        """
                        Specifies the zone that represents the heat exchanger, the dimensions of the heat exchanger, the macro grid, and the coolant direction and properties.
                        """
                    class heat_exchanger_group(TUIMethod):
                        """
                        Defines heat-exchanger group.
                        """
                    class delete_heat_exchanger_group(TUIMethod):
                        """
                        Deletes heat-exchanger group.
                        """
                    class heat_exchanger_report(TUIMethod):
                        """
                        Reports the computed values of total heat rejection, outlet temperature, and inlet temperature for a specified heat-exchanger core.
                        """
                    class heat_exchanger_macro_report(TUIMethod):
                        """
                        Reports the computed values of heat rejection, outlet temperature, and inlet temperature for the macroscopic cells (macros) in a heat exchanger.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """

                class dual_cell_model(TUIMenu):
                    """
                    Enters the dual cell model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.add_heat_exchanger = self.__class__.add_heat_exchanger(service, version, mode, path + ["add_heat_exchanger"])
                        self.modify_heat_exchanger = self.__class__.modify_heat_exchanger(service, version, mode, path + ["modify_heat_exchanger"])
                        self.delete_heat_exchanger = self.__class__.delete_heat_exchanger(service, version, mode, path + ["delete_heat_exchanger"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        self.alternative_formulation = self.__class__.alternative_formulation(service, version, mode, path + ["alternative_formulation"])
                        super().__init__(service, version, mode, path)
                    class heat_exchanger(TUIMethod):
                        """
                        Enables/disables the dual cell heat-exchanger model.
                        """
                    class add_heat_exchanger(TUIMethod):
                        """
                        Adds heat-exchanger.
                        """
                    class modify_heat_exchanger(TUIMethod):
                        """
                        Modifies heat-exchanger.
                        """
                    class delete_heat_exchanger(TUIMethod):
                        """
                        Deletes heat-exchanger.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plots NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Writes NTU vs. primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class alternative_formulation(TUIMethod):
                        """
                        Enables/disables alternative formulation for heat transfer calculations.
                        """

            class electrolysis_setup(TUIMenu):
                """
                Enter the electrolysis model setup menu.
                """
                def __init__(self, service, version, mode, path):
                    self.anode_setup = self.__class__.anode_setup(service, version, mode, path + ["anode_setup"])
                    self.cathode_setup = self.__class__.cathode_setup(service, version, mode, path + ["cathode_setup"])
                    self.membrane_setup = self.__class__.membrane_setup(service, version, mode, path + ["membrane_setup"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.electrical_tabs_setup = self.__class__.electrical_tabs_setup(service, version, mode, path + ["electrical_tabs_setup"])
                    super().__init__(service, version, mode, path)
                class model_options(TUIMethod):
                    """
                    Model Options.
                    """
                class parameters(TUIMethod):
                    """
                    Model Parameters.
                    """
                class electrical_tabs_setup(TUIMethod):
                    """
                    Electrical Tabs Setup.
                    """

                class anode_setup(TUIMenu):
                    """
                    Anode Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

                class cathode_setup(TUIMenu):
                    """
                    Cathode Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

                class membrane_setup(TUIMenu):
                    """
                    Membrane Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

        class overset_interfaces(TUIMenu):
            """
            Enters the overset interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.cut_control = self.__class__.cut_control(service, version, mode, path + ["cut_control"])
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.intersect = self.__class__.intersect(service, version, mode, path + ["intersect"])
                self.intersect_all = self.__class__.intersect_all(service, version, mode, path + ["intersect_all"])
                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                self.clear_all = self.__class__.clear_all(service, version, mode, path + ["clear_all"])
                self.grid_priorities = self.__class__.grid_priorities(service, version, mode, path + ["grid_priorities"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.mark_cells = self.__class__.mark_cells(service, version, mode, path + ["mark_cells"])
                self.display_cells = self.__class__.display_cells(service, version, mode, path + ["display_cells"])
                self.mark_cell_change = self.__class__.mark_cell_change(service, version, mode, path + ["mark_cell_change"])
                self.set_mark_bounds = self.__class__.set_mark_bounds(service, version, mode, path + ["set_mark_bounds"])
                self.check = self.__class__.check(service, version, mode, path + ["check"])
                self.debug_hole_cut = self.__class__.debug_hole_cut(service, version, mode, path + ["debug_hole_cut"])
                self.fill_dci = self.__class__.fill_dci(service, version, mode, path + ["fill_dci"])
                self.free_dci = self.__class__.free_dci(service, version, mode, path + ["free_dci"])
                self.update_from_dci = self.__class__.update_from_dci(service, version, mode, path + ["update_from_dci"])
                self.write_dci_to_case = self.__class__.write_dci_to_case(service, version, mode, path + ["write_dci_to_case"])
                self.read_dci_from_case = self.__class__.read_dci_from_case(service, version, mode, path + ["read_dci_from_case"])
                self.write_dci = self.__class__.write_dci(service, version, mode, path + ["write_dci"])
                self.write_cell_types = self.__class__.write_cell_types(service, version, mode, path + ["write_cell_types"])
                self.find_bounding_cell = self.__class__.find_bounding_cell(service, version, mode, path + ["find_bounding_cell"])
                self.find_all_bounding_cells = self.__class__.find_all_bounding_cells(service, version, mode, path + ["find_all_bounding_cells"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Creates an overset interface.
                """
            class delete(TUIMethod):
                """
                Deletes an overset interface.
                """
            class delete_all(TUIMethod):
                """
                Deletes all overset interfaces in the domain.
                """
            class intersect(TUIMethod):
                """
                Executes the hole cutting of an overset interface and establishes the domain connectivity. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class intersect_all(TUIMethod):
                """
                Executes hole cutting for all overset interfaces in the domain. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class clear(TUIMethod):
                """
                Clears the domain connectivity of an overset interface. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class clear_all(TUIMethod):
                """
                Clears the domain connectivity of all overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class grid_priorities(TUIMethod):
                """
                Allows you to specify grid priorities on background and component meshes, used in the overlap minimization of an overset interface.
                """
            class list(TUIMethod):
                """
                Lists information about the overset interfaces. The output depends on the overset verbosity setting.
                """
            class mark_cells(TUIMethod):
                """
                Marks the specified overset cells (solve, receptor, donor, orphan, or dead) and fills registers based on the markings. Display the marked cells via the text command define/overset-interfaces/display-cells.
                """
            class display_cells(TUIMethod):
                """
                Displays the overset cells marked using the text command define/overset-interfaces/mark-cells.
                """
            class mark_cell_change(TUIMethod):
                """
                Marks cells that have undergone a specified overset cell type change (from solve,receptor, or dead to any other type) in the last time step. Adaption registers are automatically filled based on these markings. This text command is only available for unsteady simulations and if define/overset-interfaces/options/expert? is set to yes.
                """
            class set_mark_bounds(TUIMethod):
                """
                Allows you to set bounds so that any marking of cells is performed within a spherical region based on a specified origin and radius. This can be useful when diagnosing a local problem on a large mesh. This text command is only available if define/overset-interfaces/options/expert? is set to yes. After defining the bounds, you can then mark the cells using the define/overset-interfaces/mark-cell-change or define/overset-interfaces/mark-cells text command. To disable the bounds, enter a radius of 0.
                """
            class check(TUIMethod):
                """
                Checks the integrity of the overset interfaces. Reports orphan cells and errors in the domain connectivity.
                """
            class debug_hole_cut(TUIMethod):
                """
                Debugging tool to troubleshoot hole cutting of overset interfaces. This text command is only available when define/overset-interfaces/options/expert? is set to yes.
                """
            class fill_dci(TUIMethod):
                """
                Fill overset domain connectivity information (DCI).
                """
            class free_dci(TUIMethod):
                """
                Free overset domain connectivity information (DCI).
                """
            class update_from_dci(TUIMethod):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
            class write_dci_to_case(TUIMethod):
                """
                Save domain connectivity information (DCI) to case file.
                """
            class read_dci_from_case(TUIMethod):
                """
                Read domain connectivity information (DCI) from case file.
                """
            class write_dci(TUIMethod):
                """
                Save domain connectivity information (DCI) to a text file.
                """
            class write_cell_types(TUIMethod):
                """
                Write overset cell types into file.
                """
            class find_bounding_cell(TUIMethod):
                """
                Find bounding cell for given cell or search point.
                """
            class find_all_bounding_cells(TUIMethod):
                """
                Find bounding cells for all cell centroids.
                """

            class options(TUIMenu):
                """
                Enters the overset interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.render_receptor_cells = self.__class__.render_receptor_cells(service, version, mode, path + ["render_receptor_cells"])
                    self.partial_cut_faces = self.__class__.partial_cut_faces(service, version, mode, path + ["partial_cut_faces"])
                    self.auto_create = self.__class__.auto_create(service, version, mode, path + ["auto_create"])
                    self.minimize_overlap = self.__class__.minimize_overlap(service, version, mode, path + ["minimize_overlap"])
                    self.overlap_boundaries = self.__class__.overlap_boundaries(service, version, mode, path + ["overlap_boundaries"])
                    self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
                    self.node_connected_donors = self.__class__.node_connected_donors(service, version, mode, path + ["node_connected_donors"])
                    self.donor_priority_method = self.__class__.donor_priority_method(service, version, mode, path + ["donor_priority_method"])
                    self.solve_island_removal = self.__class__.solve_island_removal(service, version, mode, path + ["solve_island_removal"])
                    self.transient_caching = self.__class__.transient_caching(service, version, mode, path + ["transient_caching"])
                    self.modified_donor_search = self.__class__.modified_donor_search(service, version, mode, path + ["modified_donor_search"])
                    self.modified_hole_cutting = self.__class__.modified_hole_cutting(service, version, mode, path + ["modified_hole_cutting"])
                    self.dead_cell_update = self.__class__.dead_cell_update(service, version, mode, path + ["dead_cell_update"])
                    self.update_before_case_write = self.__class__.update_before_case_write(service, version, mode, path + ["update_before_case_write"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class expert(TUIMethod):
                    """
                    Enables / disables overset-related expert tools.
                    """
                class render_receptor_cells(TUIMethod):
                    """
                    Allows you to enable visualization of receptor cells in contour and mesh 	displays.
                    """
                class partial_cut_faces(TUIMethod):
                    """
                    Enables/disables enhanced hole cutting, where partially overlapping cut faces are 	decomposed into overlapping and non-overlapping 	fractions, and only the non-overlapping fractions 	participate in the hole cutting. This can help avoid the 	situation where a region or cell zone is erroneously 	identified as dead because of leakage during flood 	filling, even though it has overlapping boundaries that 	match well. When this text command is disabled, the 	partially overlapping faces are entirely protected from 	cutting.
                    """
                class auto_create(TUIMethod):
                    """
                    Enables the automatic creation of a default overset interface during 	initialization or mesh motion update.
                    """
                class minimize_overlap(TUIMethod):
                    """
                    Allows you to disable overlap minimization during hole cutting.
                    """
                class overlap_boundaries(TUIMethod):
                    """
                    Allows you to disable the detection of overlapping boundaries during hole cutting, 	in order to reduce the computational expense for cases 	that do not include such boundaries. When enabled, this 	text command also allows you to specify which boundary 	zones should be considered when detecting overlapping 	boundaries; this can be helpful when the default hole 	cutting process fails.
                    """
                class mesh_interfaces(TUIMethod):
                    """
                    Allows the inclusion of non-conformal mesh interfaces 	inside overset cell zones, as long as the mesh 	interfaces do not spatially overlap with the cells where 	the overset interfaces lie.
                    """
                class node_connected_donors(TUIMethod):
                    """
                    Allows you to switch between face or node connected donor cells. This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class donor_priority_method(TUIMethod):
                    """
                    Allows you to specify whether the cell donor priority used in the overlap 	minimization of an overset interface is inversely proportional to either the 	cell size or the distance to the nearest boundary.
                    """
                class solve_island_removal(TUIMethod):
                    """
                    Sets the method used to control the removal of isolated patches of solve cells. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class transient_caching(TUIMethod):
                    """
                    Sets the options to control caching of entities in transient overset simulations. This text 	command is only available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class modified_donor_search(TUIMethod):
                    """
                    Enables / disables modified donor search parameters. When enabled, these parameters result in 	a more extended donor search, which can be helpful for 	meshes with orphans. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class modified_hole_cutting(TUIMethod):
                    """
                    Enables / disables modified hole cutting parameters. When enabled, the parameters used can 	help avoid dead cell zones that result from a hole 	cutting failure. This text command is only available 	when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class dead_cell_update(TUIMethod):
                    """
                    Enables/disables the updating of dead cells during the solution process, which may 	be helpful for some moving and dynamic mesh simulations 	(though at the cost of solver performance). You can 	enter the number of layers of dead cells adjacent to the 	receptor cells that you want updated, or enter -1 to request that all dead 	cells are updated. This text command is only available 	for transient simulations when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class update_before_case_write(TUIMethod):
                    """
                    Enables/disables the updating of the overset interfaces before writing a case file in the 	Common Fluids Format (CFF). This text command is only 	available when define/overset-interfaces/options/expert? 	is set to yes.
                    """
                class parallel(TUIMethod):
                    """
                    Allows you to select the algorithm used for overset parallel processing. You can 	select from the default cell exchange model or the local 	cell zone replication model; the cell exchange model 	should require less memory and may result in faster 	calculations.
                    """
                class verbosity(TUIMethod):
                    """
                    Specifies the level of detail printed in the console about overset 	interfaces.
                    """

            class cut_control(TUIMenu):
                """
                Enters the overset hole cut control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cut_seeds = self.__class__.cut_seeds(service, version, mode, path + ["cut_seeds"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Adds a hole cut control, so that a boundary zone does 	not cut specified cell zones.
                    """
                class delete(TUIMethod):
                    """
                    Deletes the hole cut control for a boundary 	zone.
                    """
                class delete_all(TUIMethod):
                    """
                    Deletes the hole cut controls for all boundary 	zones.
                    """
                class list(TUIMethod):
                    """
                    Lists the defined hole cut controls.
                    """

                class cut_seeds(TUIMenu):
                    """
                    Enters the overset hole cut seeds menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.cut_seeds_for_all_component_zones = self.__class__.cut_seeds_for_all_component_zones(service, version, mode, path + ["cut_seeds_for_all_component_zones"])
                        super().__init__(service, version, mode, path)
                    class add(TUIMethod):
                        """
                        Add a hole cut seed.
                        """
                    class delete(TUIMethod):
                        """
                        Delete a hole cut seed.
                        """
                    class delete_all(TUIMethod):
                        """
                        Delete all hole cut seeds.
                        """
                    class list(TUIMethod):
                        """
                        List the defined hole cut seeds.
                        """
                    class cut_seeds_for_all_component_zones(TUIMethod):
                        """
                        Specifies whether all component zones get cut seeds, which cut pilot holes into the overlapping meshes that will then be enlarged during overlap minimization.
                        """

            class adapt(TUIMenu):
                """
                Enters the overset adaption menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.mark_adaption = self.__class__.mark_adaption(service, version, mode, path + ["mark_adaption"])
                    self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                    super().__init__(service, version, mode, path)
                class mark_adaption(TUIMethod):
                    """
                    Marks cells to identify those that can be adapted in 	order to improve your overset mesh.
                    """
                class adapt_mesh(TUIMethod):
                    """
                    Marks and adapts the mesh to improve your overset 	mesh.
                    """

                class set(TUIMenu):
                    """
                    Enters the overset adaption set menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mark_orphans = self.__class__.mark_orphans(service, version, mode, path + ["mark_orphans"])
                        self.mark_fixed_orphans = self.__class__.mark_fixed_orphans(service, version, mode, path + ["mark_fixed_orphans"])
                        self.mark_size = self.__class__.mark_size(service, version, mode, path + ["mark_size"])
                        self.mark_gaps = self.__class__.mark_gaps(service, version, mode, path + ["mark_gaps"])
                        self.mark_coarsening = self.__class__.mark_coarsening(service, version, mode, path + ["mark_coarsening"])
                        self.anisotropic = self.__class__.anisotropic(service, version, mode, path + ["anisotropic"])
                        self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                        self.length_ratio_max = self.__class__.length_ratio_max(service, version, mode, path + ["length_ratio_max"])
                        self.buffer_layers = self.__class__.buffer_layers(service, version, mode, path + ["buffer_layers"])
                        self.adaption_sweeps = self.__class__.adaption_sweeps(service, version, mode, path + ["adaption_sweeps"])
                        self.maximum_refinement_level = self.__class__.maximum_refinement_level(service, version, mode, path + ["maximum_refinement_level"])
                        super().__init__(service, version, mode, path)
                    class mark_orphans(TUIMethod):
                        """
                        Enables/disables the option to adapt for orphan reduction.
                        """
                    class mark_fixed_orphans(TUIMethod):
                        """
                        Enables/disables the option to also adapt based on cells that are not actual orphans because they were fixed by accepting neighbor donors. This option is only applied if define/overset-interfaces/adapt/set/mark-orphans? is enabled.
                        """
                    class mark_size(TUIMethod):
                        """
                        Enables/disables the option to adapt based on donor-receptor cell size differences.
                        """
                    class mark_gaps(TUIMethod):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                    class mark_coarsening(TUIMethod):
                        """
                        Enables/disables the option to coarsen the mesh if mesh refinement is no longer needed. This option is enabled by default.
                        """
                    class anisotropic(TUIMethod):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """
                    class automatic(TUIMethod):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                    class length_ratio_max(TUIMethod):
                        """
                        Sets the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                    class buffer_layers(TUIMethod):
                        """
                        Sets the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                    class adaption_sweeps(TUIMethod):
                        """
                        Sets the number of rounds of adaption applied during each adaption cycle.
                        """
                    class maximum_refinement_level(TUIMethod):
                        """
                        Sets the maximum level of refinement during overset adaption, in conjunction with the value set using the mesh/adapt/set/maximum-refinement-level text command (the larger of the two values is used).
                        """

        class operating_conditions(TUIMenu):
            """
            Enters the define operating conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.gravity = self.__class__.gravity(service, version, mode, path + ["gravity"])
                self.gravity_mrf_rotation = self.__class__.gravity_mrf_rotation(service, version, mode, path + ["gravity_mrf_rotation"])
                self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                self.operating_pressure = self.__class__.operating_pressure(service, version, mode, path + ["operating_pressure"])
                self.reference_pressure_location = self.__class__.reference_pressure_location(service, version, mode, path + ["reference_pressure_location"])
                self.reference_pressure_method = self.__class__.reference_pressure_method(service, version, mode, path + ["reference_pressure_method"])
                self.used_ref_pressure_location = self.__class__.used_ref_pressure_location(service, version, mode, path + ["used_ref_pressure_location"])
                self.operating_density = self.__class__.operating_density(service, version, mode, path + ["operating_density"])
                self.use_inlet_temperature_for_operating_density = self.__class__.use_inlet_temperature_for_operating_density(service, version, mode, path + ["use_inlet_temperature_for_operating_density"])
                self.operating_temperature = self.__class__.operating_temperature(service, version, mode, path + ["operating_temperature"])
                super().__init__(service, version, mode, path)
            class gravity(TUIMethod):
                """
                Sets gravitational acceleration.
                """
            class gravity_mrf_rotation(TUIMethod):
                """
                Enables/disables rotation of gravity vector in moving reference frame simulations. If enabled, the gravity vector will rotate with respect to the moving reference frame such that the direction of gravity in global coordinates remains fixed.
                """
            class set_state(TUIMethod):
                """
                Selects state for real gas EOS subcritical condition.
                """
            class operating_pressure(TUIMethod):
                """
                Sets the operating pressure.
                """
            class reference_pressure_location(TUIMethod):
                """
                Sets a location that determines the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """
            class reference_pressure_method(TUIMethod):
                """
                Specifies the method used for adjusting the gauge pressure field after each iteration to keep it from floating: the method can assume that all of the cell zones are connected by internal boundary zones (such as interior zones), or can account for connected and disconnected cell zones. Such adjustment is only allowed for incompressible flows, and will be limited partially or entirely by the presence of a pressure boundary.
                """
            class used_ref_pressure_location(TUIMethod):
                """
                Prints the coordinates of the reference pressure cell or cells (depending on the selected reference pressure method). The pressure value in such cells can be used to adjust the gauge pressure field after each iteration to keep it from floating.
                """
            class operating_density(TUIMethod):
                """
                Enters the operating density menu. This menu is available only for multiphase flows.
                """
            class use_inlet_temperature_for_operating_density(TUIMethod):
                """
                Uses inlet temperature to calculate operating density.
                """
            class operating_temperature(TUIMethod):
                """
                Sets the operating temperature for Boussinesq.
                """

        class parameters(TUIMenu):
            """
            Enters the parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                self.list_parameters = self.__class__.list_parameters(service, version, mode, path + ["list_parameters"])
                self.enable_in_TUI = self.__class__.enable_in_TUI(service, version, mode, path + ["enable_in_TUI"])
                super().__init__(service, version, mode, path)
            class enable_in_TUI(TUIMethod):
                """
                Enables/disables parameters in the text user interface.
                """

            class input_parameters(TUIMenu):
                """
                Enters the input-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.advance = self.__class__.advance(service, version, mode, path + ["advance"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    super().__init__(service, version, mode, path)
                class edit(TUIMethod):
                    """
                    Edits an input parameter.
                    """
                class delete(TUIMethod):
                    """
                    Deletes an input parameter.
                    """

                class advance(TUIMenu):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, service, version, mode, path):
                        self.use_in = self.__class__.use_in(service, version, mode, path + ["use_in"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        super().__init__(service, version, mode, path)
                    class use_in(TUIMethod):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """
                    class list(TUIMethod):
                        """
                        List of custom-input-parameters.
                        """
                    class delete(TUIMethod):
                        """
                        Delete selected custom-input-parameters.
                        """

            class output_parameters(TUIMenu):
                """
                Enters the output-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.print_all_to_console = self.__class__.print_all_to_console(service, version, mode, path + ["print_all_to_console"])
                    self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                    self.write_all_to_file = self.__class__.write_all_to_file(service, version, mode, path + ["write_all_to_file"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Creates an output parameter.
                    """
                class edit(TUIMethod):
                    """
                    Edits an output parameter.
                    """
                class rename(TUIMethod):
                    """
                    Renames an output parameter.
                    """
                class delete(TUIMethod):
                    """
                    Deletes an output parameter.
                    """
                class print_to_console(TUIMethod):
                    """
                    Displays parameter value in the console.
                    """
                class print_all_to_console(TUIMethod):
                    """
                    Displays all parameter values in the console.
                    """
                class write_to_file(TUIMethod):
                    """
                    Writes parameter value to file.
                    """
                class write_all_to_file(TUIMethod):
                    """
                    Writes all parameter values to file.
                    """

            class list_parameters(TUIMenu):
                """
                Enter list-param menu.
                """
                def __init__(self, service, version, mode, path):
                    self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                    self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                    super().__init__(service, version, mode, path)
                class input_parameters(TUIMethod):
                    """
                    List all input parameters.
                    """
                class output_parameters(TUIMethod):
                    """
                    List all output parameters.
                    """

        class periodic_conditions(TUIMenu):
            """
            Enters the periodic conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.massflow_rate_specification = self.__class__.massflow_rate_specification(service, version, mode, path + ["massflow_rate_specification"])
                self.pressure_gradient_specification = self.__class__.pressure_gradient_specification(service, version, mode, path + ["pressure_gradient_specification"])
                super().__init__(service, version, mode, path)
            class massflow_rate_specification(TUIMethod):
                """
                Enables/disables specification of mass flow rate at the periodic boundary.
                """
            class pressure_gradient_specification(TUIMethod):
                """
                Enables/disables specification of pressure gradient at the periodic boundary.
                """

        class turbo_model(TUIMenu):
            """
            Enters the turbo menu.
            """
            def __init__(self, service, version, mode, path):
                self.turbo_topology = self.__class__.turbo_topology(service, version, mode, path + ["turbo_topology"])
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(service, version, mode, path + ["general_turbo_interface_settings"])
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(service, version, mode, path + ["blade_flutter_harmonics"])
                self.enable_turbo_model = self.__class__.enable_turbo_model(service, version, mode, path + ["enable_turbo_model"])
                self.separate_nonoverlapping_interface_boundary = self.__class__.separate_nonoverlapping_interface_boundary(service, version, mode, path + ["separate_nonoverlapping_interface_boundary"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.number_of_blades_in_row = self.__class__.number_of_blades_in_row(service, version, mode, path + ["number_of_blades_in_row"])
                self.create_turbomachine_description = self.__class__.create_turbomachine_description(service, version, mode, path + ["create_turbomachine_description"])
                self.create_phaselag_spectral_content = self.__class__.create_phaselag_spectral_content(service, version, mode, path + ["create_phaselag_spectral_content"])
                self.phaselag_extra_settings = self.__class__.phaselag_extra_settings(service, version, mode, path + ["phaselag_extra_settings"])
                self.create_graphics_spectral_content = self.__class__.create_graphics_spectral_content(service, version, mode, path + ["create_graphics_spectral_content"])
                self.graphics_extra_settings = self.__class__.graphics_extra_settings(service, version, mode, path + ["graphics_extra_settings"])
                self.delete_turbomachine_description = self.__class__.delete_turbomachine_description(service, version, mode, path + ["delete_turbomachine_description"])
                self.delete_phaselag_spectral_content = self.__class__.delete_phaselag_spectral_content(service, version, mode, path + ["delete_phaselag_spectral_content"])
                self.delete_graphics_spectral_content = self.__class__.delete_graphics_spectral_content(service, version, mode, path + ["delete_graphics_spectral_content"])
                self.list_turbomachine_description = self.__class__.list_turbomachine_description(service, version, mode, path + ["list_turbomachine_description"])
                self.list_graphics_spectral_content = self.__class__.list_graphics_spectral_content(service, version, mode, path + ["list_graphics_spectral_content"])
                self.list_phaselag_state = self.__class__.list_phaselag_state(service, version, mode, path + ["list_phaselag_state"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                super().__init__(service, version, mode, path)
            class enable_turbo_model(TUIMethod):
                """
                Enables/disables turbo model menu.
                """
            class separate_nonoverlapping_interface_boundary(TUIMethod):
                """
                Split a general turbo interface non-overlapping zone.
                """
            class turbo_create(TUIMethod):
                """
                Creates a general turbo interface.
                """
            class number_of_blades_in_row(TUIMethod):
                """
                Defines the number of blades in the turbo machine, used for calculating interblade phase angle.
                """
            class create_turbomachine_description(TUIMethod):
                """
                Define turbomachine description.
                """
            class create_phaselag_spectral_content(TUIMethod):
                """
                Define phaselag related spectral content.
                """
            class phaselag_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class create_graphics_spectral_content(TUIMethod):
                """
                Define post-processing related spectral content.
                """
            class graphics_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class delete_turbomachine_description(TUIMethod):
                """
                Delete turbomachine description.
                """
            class delete_phaselag_spectral_content(TUIMethod):
                """
                Delete phaselag related spectral content.
                """
            class delete_graphics_spectral_content(TUIMethod):
                """
                Delete post-processing related spectral content.
                """
            class list_turbomachine_description(TUIMethod):
                """
                List turbomachine description.
                """
            class list_graphics_spectral_content(TUIMethod):
                """
                List post-processing related spectral content.
                """
            class list_phaselag_state(TUIMethod):
                """
                List all phaselag related case settings.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                Make interface zones phase lagged.
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                Convert periodic interface to phase lagged.
                """

            class turbo_topology(TUIMenu):
                """
                Enters the turbo topology menu.
                """
                def __init__(self, service, version, mode, path):
                    self.define_topology = self.__class__.define_topology(service, version, mode, path + ["define_topology"])
                    self.mesh_method = self.__class__.mesh_method(service, version, mode, path + ["mesh_method"])
                    self.search_method = self.__class__.search_method(service, version, mode, path + ["search_method"])
                    self.projection_method = self.__class__.projection_method(service, version, mode, path + ["projection_method"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    super().__init__(service, version, mode, path)
                class define_topology(TUIMethod):
                    """
                    Defines a turbo topology.
                    """
                class mesh_method(TUIMethod):
                    """
                    Sets turbo structured mesh generation method.
                    """
                class search_method(TUIMethod):
                    """
                    Sets search method for a topology.
                    """
                class projection_method(TUIMethod):
                    """
                    Sets 2D projection method.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a previously created turbo topology.
                    """

            class general_turbo_interface_settings(TUIMenu):
                """
                Enters the General Turbo Interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(service, version, mode, path + ["mixing_plane_model_settings"])
                    self.pitch_scale_model_settings = self.__class__.pitch_scale_model_settings(service, version, mode, path + ["pitch_scale_model_settings"])
                    self.no_pitch_scale_model_settings = self.__class__.no_pitch_scale_model_settings(service, version, mode, path + ["no_pitch_scale_model_settings"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)

                class mixing_plane_model_settings(TUIMenu):
                    """
                    Defines settings for the mixing plane model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.number_of_bands = self.__class__.number_of_bands(service, version, mode, path + ["number_of_bands"])
                        self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                        self.mixing_set_constraint = self.__class__.mixing_set_constraint(service, version, mode, path + ["mixing_set_constraint"])
                        self.bands_type = self.__class__.bands_type(service, version, mode, path + ["bands_type"])
                        self.number_of_inner_iterations = self.__class__.number_of_inner_iterations(service, version, mode, path + ["number_of_inner_iterations"])
                        self.list_mixing_planes = self.__class__.list_mixing_planes(service, version, mode, path + ["list_mixing_planes"])
                        super().__init__(service, version, mode, path)
                    class averaging_method(TUIMethod):
                        """
                        Set the averaging method for the mixing.
                        """
                    class mixing_set_constraint(TUIMethod):
                        """
                        To set the mixing of primitive or total variable approach.
                        """
                    class bands_type(TUIMethod):
                        """
                        Specifies the averaging bands for mixing as fixed or variable width.
                        """
                    class number_of_inner_iterations(TUIMethod):
                        """
                        Sets the number of iterations used in averaging.
                        """
                    class list_mixing_planes(TUIMethod):
                        """
                        List the settings of mixing planes in the case.
                        """

                    class number_of_bands(TUIMenu):
                        """
                        Sets the number of bands to be used for mixing.
                        """
                        def __init__(self, service, version, mode, path):
                            self.set_specific_interface = self.__class__.set_specific_interface(service, version, mode, path + ["set_specific_interface"])
                            self.set_all_interfaces = self.__class__.set_all_interfaces(service, version, mode, path + ["set_all_interfaces"])
                            super().__init__(service, version, mode, path)
                        class set_specific_interface(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """
                        class set_all_interfaces(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """

                class pitch_scale_model_settings(TUIMenu):
                    """
                    Defines settings for the pitch-scale model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.scale_mflux = self.__class__.scale_mflux(service, version, mode, path + ["scale_mflux"])
                        super().__init__(service, version, mode, path)
                    class scale_mflux(TUIMethod):
                        """
                        Scales mass flux to improve conservation.
                        """

                class no_pitch_scale_model_settings(TUIMenu):
                    """
                    Defines settings for the no pitch-scale model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.scale_mflux = self.__class__.scale_mflux(service, version, mode, path + ["scale_mflux"])
                        super().__init__(service, version, mode, path)
                    class scale_mflux(TUIMethod):
                        """
                        Scales mass flux to improve conservation.
                        """

                class expert(TUIMenu):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enforce_flux_scaling = self.__class__.enforce_flux_scaling(service, version, mode, path + ["enforce_flux_scaling"])
                        self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                        super().__init__(service, version, mode, path)
                    class enforce_flux_scaling(TUIMethod):
                        """
                        Enforce flux scaling ON/OFF at the turbo interfaces.
                        """
                    class list_settings(TUIMethod):
                        """
                        List the flux scale settings at the turbo interfaces.
                        """

            class blade_flutter_harmonics(TUIMenu):
                """
                Enters the blade flutter harmonics options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable_harmonic_postprocessing = self.__class__.enable_harmonic_postprocessing(service, version, mode, path + ["enable_harmonic_postprocessing"])
                    self.enable_harmonic_exports = self.__class__.enable_harmonic_exports(service, version, mode, path + ["enable_harmonic_exports"])
                    self.write_harmonic_exports = self.__class__.write_harmonic_exports(service, version, mode, path + ["write_harmonic_exports"])
                    self.write_aerodamping_vs_nodal_diameter = self.__class__.write_aerodamping_vs_nodal_diameter(service, version, mode, path + ["write_aerodamping_vs_nodal_diameter"])
                    super().__init__(service, version, mode, path)
                class enable_harmonic_postprocessing(TUIMethod):
                    """
                    Calculates/Deletes Postprocessing Fourier coefficients data.
                    """
                class enable_harmonic_exports(TUIMethod):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                class write_harmonic_exports(TUIMethod):
                    """
                    Writes harmonic export data.
                    """
                class write_aerodamping_vs_nodal_diameter(TUIMethod):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """

        class phases(TUIMenu):
            """
            Enters the phases menu.
            """
            def __init__(self, service, version, mode, path):
                self.set_domain_properties = self.__class__.set_domain_properties(service, version, mode, path + ["set_domain_properties"])
                self.iac_expert = self.__class__.iac_expert(service, version, mode, path + ["iac_expert"])
                super().__init__(service, version, mode, path)

            class set_domain_properties(TUIMenu):
                """
                Enters the menu to set phase domain properties.
                """
                def __init__(self, service, version, mode, path):
                    self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                    self.change_phases_names = self.__class__.change_phases_names(service, version, mode, path + ["change_phases_names"])
                    self.phase_domains = self.__class__.phase_domains(service, version, mode, path + ["phase_domains"])
                    super().__init__(service, version, mode, path)
                class change_phases_names(TUIMethod):
                    """
                    Allows you to change the names of all the phases in your simulation.
                    """
                class phase_domains(TUIMethod):
                    """
                    Enters the menu to select a specific phase.
                    """

                class interaction_domain(TUIMenu):
                    """
                    Enters the menu to set the interaction domain 	properties.
                    """
                    def __init__(self, service, version, mode, path):
                        self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                        self.heat_mass_reactions = self.__class__.heat_mass_reactions(service, version, mode, path + ["heat_mass_reactions"])
                        self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                        self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                        self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                        super().__init__(service, version, mode, path)

                    class forces(TUIMenu):
                        """
                        Enters the menu to set interfacial forces models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specifies the drag function, drag modification, and drag factor for each pair of phases. This command is available only with the Eulerian and Mixture multiphase models.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specifies the restitution coefficient for collisions between each pair of granular phases, and for collisions between particles of the same granular phase. This command is available only for multiphase flows with two or more granular phases.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specifies the slip velocity function for each secondary phase with respect to the primary phase. This command is available only for the Mixture multiphase model.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specifies the turbulence interaction model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specifies the turbulent dispersion model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specifies the wall lubrication model for each primary-secondary phase pair. This command is available only with the Eulerian multiphase model.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enters the menu to set the lift force. This item is available only with the Eulerian multiphase model.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                Specifies the lift function for each pair of phases.
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Enables/disables the Shaver-Podowski lift correction.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enters the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enables/disables the treatment of the contact angle specification at the porous jump boundary. This command is available only for the VOF multiphase model with the continuum surface stress model option and when sfc-modeling? is enabled.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Selects the surface tension model. You can choose between the continuum surface force and continuum surface stress methods. This item is available only when sfc-modeling? is enabled.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Allows you to include the effects of surface tension along the fluid-fluid interface. This option is only available for the VOF and Eulerian multiphase models.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specifies the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enables/disables the specification for a wall adhesion angle. This item is available only whensfc-modeling? is enabled.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enters the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Allows you to include the virtual mass force effect that occurs when a secondary phase accelerates relative to the primary phase. This command is available only with the Eulerian multiphase model.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specifies the virtual mass coefficient for each pair of phases. This option is available only ifvirtual-mass? is enabled.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Specifies what form of the implicit method to use (default, option-2, or option-3). default models the entire virtual mass force while option-2 and option-3 model truncated expressions which may further improve convergence. This option is available only if vmass-implicit? is enabled.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enables/disables the implicit method for the virtual mass force. This option can improve convergence in some cases. This option is available only if virtual-mass? is enabled.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class heat_mass_reactions(TUIMenu):
                        """
                        Enters the menu to set heat, mass-transfer, and reaction models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Species the heat transfer coefficient function between each pair of phases (constant-htc, nusselt-number, ranz-marshall, hughmark, tomiyama, fixed-to-sat-temp, two-resistance, or user-defined). This command is enable only with the Eulerian multiphase model.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Allows you to define multiple heterogeneous reactions and stoichiometry. This option is available only with the species model.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enters the menu to set cavitation models. This option is available only for the Mixture multiphase model with the Singhal-et-al cavitation model enabled via solve/set/advanced/singhal-et-al-cavitation-model.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Sets the vaporization pressure, surface tension coefficient, and non-condensable gas mass fraction. This command is available only when cavitation? is enabled.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class interfacial_area(TUIMenu):
                        """
                        Enters the menu to set interfacial area models. This menu is available only for the Mixture and Eulerian multiphase models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Specifies the interfacial area model for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class model_transition(TUIMenu):
                        """
                        Enters the menu to set model transition mechanisms.
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Sets the VOF-to-DPM model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                    class numerics(TUIMenu):
                        """
                        Enters the menu to set numerics models. This menu is available for multiphase models with the sharp-dispersed and phase localized discretization interface modeling options (set in define/models/multiphase/interface-modeling-options).
                        """
                        def __init__(self, service, version, mode, path):
                            self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                            self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                            self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                            self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                            self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                            self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                            self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                            self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                            self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                            self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                            self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                            self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                            self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                            self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                            self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                            self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                            super().__init__(service, version, mode, path)
                        class drag(TUIMethod):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                        class heat_coeff(TUIMethod):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                        class interfacial_area(TUIMethod):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                        class mass_transfer(TUIMethod):
                            """
                            Specify the mass transfer mechanisms.
                            """
                        class model_transition(TUIMethod):
                            """
                            Set the model transition mechanism.
                            """
                        class reactions(TUIMethod):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                        class restitution(TUIMethod):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                        class slip_velocity(TUIMethod):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                        class turbulence_interaction(TUIMethod):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                        class turbulent_dispersion(TUIMethod):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                        class wall_lubrication(TUIMethod):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """

                        class cavitation(TUIMenu):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_discretization(TUIMenu):
                            """
                            Enters the menu to set interphase discretization models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enables/disables phase localized compressive scheme.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specifies the slope limiter to set a specific discretization scheme for each phase pair. A value of 0 corresponds to first order upwind, a value of 1 corresponds to second order upwind, a value of 2 applies the compressive scheme, and a value between 0 and 2 corresponds to a blended scheme. This option is available only wheninterphase-discr? is enabled.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class interphase_viscous_dissipation(TUIMenu):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class lift(TUIMenu):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class surface_tension(TUIMenu):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

                        class virtual_mass(TUIMenu):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, service, version, mode, path):
                                self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                super().__init__(service, version, mode, path)
                            class cavitation(TUIMethod):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                            class interphase_discr(TUIMethod):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                            class interphase_visc_disp(TUIMethod):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                            class jump_adhesion(TUIMethod):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                            class lift(TUIMethod):
                                """
                                .
                                """
                            class lift_montoya(TUIMethod):
                                """
                                Include the Montoya correction for Lift.
                                """
                            class lift_shaver_podowski(TUIMethod):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                            class sfc_model_type(TUIMethod):
                                """
                                Select the surface tension model.
                                """
                            class sfc_modeling(TUIMethod):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                            class sfc_tension_coeff(TUIMethod):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                            class slope_limiter(TUIMethod):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                            class virtual_mass(TUIMethod):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                            class visc_disp_factor(TUIMethod):
                                """
                                Set the dissipation intensity.
                                """
                            class vmass_coeff(TUIMethod):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                            class vmass_implicit_options(TUIMethod):
                                """
                                Select the virtual mass implicit option.
                                """
                            class vmass_implicit(TUIMethod):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                            class wall_adhesion(TUIMethod):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """

            class iac_expert(TUIMenu):
                """
                Enters the IAC expert setting menu.
                """
                def __init__(self, service, version, mode, path):
                    self.ishii_kim_model = self.__class__.ishii_kim_model(service, version, mode, path + ["ishii_kim_model"])
                    self.hibiki_ishii_model = self.__class__.hibiki_ishii_model(service, version, mode, path + ["hibiki_ishii_model"])
                    self.yao_morel_model = self.__class__.yao_morel_model(service, version, mode, path + ["yao_morel_model"])
                    self.iac_pseudo_time_step = self.__class__.iac_pseudo_time_step(service, version, mode, path + ["iac_pseudo_time_step"])
                    super().__init__(service, version, mode, path)
                class ishii_kim_model(TUIMethod):
                    """
                    Sets Ishii-Kim model coefficients.
                    """
                class hibiki_ishii_model(TUIMethod):
                    """
                    Sets Hibiki-Ishii model coefficients.
                    """
                class yao_morel_model(TUIMethod):
                    """
                    Sets Yao-Morel model coefficients.
                    """
                class iac_pseudo_time_step(TUIMethod):
                    """
                    Set iac pseudo-time.
                    """

        class profiles(TUIMenu):
            """
            Enters the boundary profiles menu.
            """
            def __init__(self, service, version, mode, path):
                self.display_profile_surface = self.__class__.display_profile_surface(service, version, mode, path + ["display_profile_surface"])
                self.display_profile_point_cloud_data = self.__class__.display_profile_point_cloud_data(service, version, mode, path + ["display_profile_point_cloud_data"])
                self.overlay_profile_surface = self.__class__.overlay_profile_surface(service, version, mode, path + ["overlay_profile_surface"])
                self.overlay_profile_point_cloud_data = self.__class__.overlay_profile_point_cloud_data(service, version, mode, path + ["overlay_profile_point_cloud_data"])
                self.set_preference_profile_point_cloud_data = self.__class__.set_preference_profile_point_cloud_data(service, version, mode, path + ["set_preference_profile_point_cloud_data"])
                self.list_profile_parameters = self.__class__.list_profile_parameters(service, version, mode, path + ["list_profile_parameters"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.list_profiles = self.__class__.list_profiles(service, version, mode, path + ["list_profiles"])
                self.list_profile_fields = self.__class__.list_profile_fields(service, version, mode, path + ["list_profile_fields"])
                self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                self.morphing = self.__class__.morphing(service, version, mode, path + ["morphing"])
                self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                self.link_profile_to_reference_frame = self.__class__.link_profile_to_reference_frame(service, version, mode, path + ["link_profile_to_reference_frame"])
                self.replicate_profile = self.__class__.replicate_profile(service, version, mode, path + ["replicate_profile"])
                self.orient_profile = self.__class__.orient_profile(service, version, mode, path + ["orient_profile"])
                super().__init__(service, version, mode, path)
            class display_profile_surface(TUIMethod):
                """
                Display the profile as a surface (this option is only available if the specified profile contains node-connectivity data).
                """
            class display_profile_point_cloud_data(TUIMethod):
                """
                Display Profile Point Cloud Data.
                """
            class overlay_profile_surface(TUIMethod):
                """
                Overlay Profile Surface.
                """
            class overlay_profile_point_cloud_data(TUIMethod):
                """
                Overlay Profile Point Cloud Data.
                """
            class set_preference_profile_point_cloud_data(TUIMethod):
                """
                Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                """
            class list_profile_parameters(TUIMethod):
                """
                List the parameters of a particular profile.
                """
            class delete(TUIMethod):
                """
                Deletes a profile.
                """
            class delete_all(TUIMethod):
                """
                Deletes all boundary-profiles.
                """
            class list_profiles(TUIMethod):
                """
                Lists all profiles.
                """
            class list_profile_fields(TUIMethod):
                """
                Lists the fields of a particular profile.
                """
            class interpolation_method(TUIMethod):
                """
                Chooses the method for interpolation of profiles.
                """
            class morphing(TUIMethod):
                """
                Enables/disables profile morphing options in Orient Profile panel.
                """
            class update_interval(TUIMethod):
                """
                Sets interval between updates of dynamic profiles.
                """
            class link_profile_to_reference_frame(TUIMethod):
                """
                Attaches a profile to a reference frame so that the profile will rotate according to the reference frame.
                """
            class replicate_profile(TUIMethod):
                """
                Replicate Profile.
                """
            class orient_profile(TUIMethod):
                """
                Re-orient an existing profile.
                """

        class solution_strategy(TUIMenu):
            """
            Enters the automatic initialization and case modification strategy menu.
            """
            def __init__(self, service, version, mode, path):
                self.automatic_case_modification = self.__class__.automatic_case_modification(service, version, mode, path + ["automatic_case_modification"])
                self.enable_strategy = self.__class__.enable_strategy(service, version, mode, path + ["enable_strategy"])
                self.execute_strategy = self.__class__.execute_strategy(service, version, mode, path + ["execute_strategy"])
                self.add_edit_modification = self.__class__.add_edit_modification(service, version, mode, path + ["add_edit_modification"])
                self.copy_modification = self.__class__.copy_modification(service, version, mode, path + ["copy_modification"])
                self.delete_modification = self.__class__.delete_modification(service, version, mode, path + ["delete_modification"])
                self.enable_modification = self.__class__.enable_modification(service, version, mode, path + ["enable_modification"])
                self.disable_modification = self.__class__.disable_modification(service, version, mode, path + ["disable_modification"])
                self.import_modifications = self.__class__.import_modifications(service, version, mode, path + ["import_modifications"])
                self.export_modifications = self.__class__.export_modifications(service, version, mode, path + ["export_modifications"])
                self.continue_strategy_execution = self.__class__.continue_strategy_execution(service, version, mode, path + ["continue_strategy_execution"])
                self.automatic_initialization = self.__class__.automatic_initialization(service, version, mode, path + ["automatic_initialization"])
                super().__init__(service, version, mode, path)
            class enable_strategy(TUIMethod):
                """
                Enables/disables automatic initialization and case modification.
                """
            class execute_strategy(TUIMethod):
                """
                Executes the currently defined automatic initialization and case modification strategy.
                """
            class add_edit_modification(TUIMethod):
                """
                Define a single case modification.
                """
            class copy_modification(TUIMethod):
                """
                Copy a single case modification.
                """
            class delete_modification(TUIMethod):
                """
                Delete a single case modification.
                """
            class enable_modification(TUIMethod):
                """
                Enable a single defined case modification.
                """
            class disable_modification(TUIMethod):
                """
                Disable a single defined case modification.
                """
            class import_modifications(TUIMethod):
                """
                Import a list of case modifications from a tsv file.
                """
            class export_modifications(TUIMethod):
                """
                Export all case modifications to a tsv file.
                """
            class continue_strategy_execution(TUIMethod):
                """
                Continues execution of the currently defined automatic initialization and case modification strategy.
                """
            class automatic_initialization(TUIMethod):
                """
                Defines how the case is to be automatically initialized.
                """

            class automatic_case_modification(TUIMenu):
                """
                Enters the automatic case modification menu.
                """
                def __init__(self, service, version, mode, path):
                    self.before_init_modification = self.__class__.before_init_modification(service, version, mode, path + ["before_init_modification"])
                    self.original_settings = self.__class__.original_settings(service, version, mode, path + ["original_settings"])
                    self.modifications = self.__class__.modifications(service, version, mode, path + ["modifications"])
                    super().__init__(service, version, mode, path)
                class before_init_modification(TUIMethod):
                    """
                    Specifies modification to be performed before initialization.
                    """
                class original_settings(TUIMethod):
                    """
                    Specifies modification to be performed after initialization to restore to original 	settings.
                    """
                class modifications(TUIMethod):
                    """
                    Specifies modifications to be performed during solution.
                    """

        class reference_frames(TUIMenu):
            """
            Enters the reference frames menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.display_edit = self.__class__.display_edit(service, version, mode, path + ["display_edit"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.hide = self.__class__.hide(service, version, mode, path + ["hide"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new reference frame.
                """
            class display(TUIMethod):
                """
                Displays the reference frame you specify.
                """
            class display_edit(TUIMethod):
                """
                Display and edit reference frame from graphics.
                """
            class edit(TUIMethod):
                """
                Allows you to edit a reference frame.
                """
            class delete(TUIMethod):
                """
                Deletes the reference frame you specify.
                """
            class hide(TUIMethod):
                """
                Removes the specified reference frame from the graphics window.
                """
            class list(TUIMethod):
                """
                Lists all of the reference frames.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of the reference frame you specify.
                """

        class user_defined(TUIMenu):
            """
            Enters the user-defined functions and scalars menu.
            """
            def __init__(self, service, version, mode, path):
                self.real_gas_models = self.__class__.real_gas_models(service, version, mode, path + ["real_gas_models"])
                self.auto_compile_compiled_udfs = self.__class__.auto_compile_compiled_udfs(service, version, mode, path + ["auto_compile_compiled_udfs"])
                self.compiled_functions = self.__class__.compiled_functions(service, version, mode, path + ["compiled_functions"])
                self.use_built_in_compiler = self.__class__.use_built_in_compiler(service, version, mode, path + ["use_built_in_compiler"])
                self.interpreted_functions = self.__class__.interpreted_functions(service, version, mode, path + ["interpreted_functions"])
                self.function_hooks = self.__class__.function_hooks(service, version, mode, path + ["function_hooks"])
                self.execute_on_demand = self.__class__.execute_on_demand(service, version, mode, path + ["execute_on_demand"])
                self.user_defined_memory = self.__class__.user_defined_memory(service, version, mode, path + ["user_defined_memory"])
                self.user_defined_node_memory = self.__class__.user_defined_node_memory(service, version, mode, path + ["user_defined_node_memory"])
                self.use_contributed_cpp = self.__class__.use_contributed_cpp(service, version, mode, path + ["use_contributed_cpp"])
                self.fan_model = self.__class__.fan_model(service, version, mode, path + ["fan_model"])
                self.one_D_coupling = self.__class__.one_D_coupling(service, version, mode, path + ["one_D_coupling"])
                self.user_defined_scalars = self.__class__.user_defined_scalars(service, version, mode, path + ["user_defined_scalars"])
                self.enable_udf_on_gpu = self.__class__.enable_udf_on_gpu(service, version, mode, path + ["enable_udf_on_gpu"])
                self.compile_customized_addon_module = self.__class__.compile_customized_addon_module(service, version, mode, path + ["compile_customized_addon_module"])
                super().__init__(service, version, mode, path)
            class auto_compile_compiled_udfs(TUIMethod):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
            class compiled_functions(TUIMethod):
                """
                Opens user-defined function library.
                """
            class use_built_in_compiler(TUIMethod):
                """
                Enables/disables the use of a built-in compiler (Clang) when the define/user-defined/compiled-functions text command is used. This text command / compiler is available for Windows only, and is provided as part of the ANSYS Fluent installation. It is recommended that you enable this text command when the compiler you installed on your machine is an older version that is no longer supported. Note that the built-in compiler is used automatically if Fluent determines that you have not installed Microsoft Visual Studio or Clang on your computer, whether this text command is enabled or not.
                """
            class interpreted_functions(TUIMethod):
                """
                Loads interpreted user-defined functions.
                """
            class function_hooks(TUIMethod):
                """
                Hooks up user-defined functions.
                """
            class execute_on_demand(TUIMethod):
                """
                Executes UDFs on demand.
                """
            class user_defined_memory(TUIMethod):
                """
                Allocates user-defined memory.
                """
            class user_defined_node_memory(TUIMethod):
                """
                Allocate user-defined node memory.
                """
            class use_contributed_cpp(TUIMethod):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
            class fan_model(TUIMethod):
                """
                Configures user-defined fan model.
                """
            class one_D_coupling(TUIMethod):
                """
                Load 1D library.
                """
            class user_defined_scalars(TUIMethod):
                """
                Defines user-defined scalars.
                """
            class enable_udf_on_gpu(TUIMethod):
                """
                Compile UDFs with OpenCL support.
                """
            class compile_customized_addon_module(TUIMethod):
                """
                Compile customized addon module?.
                """

            class real_gas_models(TUIMenu):
                """
                Enters the real-gas menu to enable/configure real gas model.
                """
                def __init__(self, service, version, mode, path):
                    self.nist_real_gas_model = self.__class__.nist_real_gas_model(service, version, mode, path + ["nist_real_gas_model"])
                    self.nist_multispecies_real_gas_model = self.__class__.nist_multispecies_real_gas_model(service, version, mode, path + ["nist_multispecies_real_gas_model"])
                    self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                    self.nist_settings = self.__class__.nist_settings(service, version, mode, path + ["nist_settings"])
                    self.user_defined_real_gas_model = self.__class__.user_defined_real_gas_model(service, version, mode, path + ["user_defined_real_gas_model"])
                    self.user_defined_multispecies_real_gas_model = self.__class__.user_defined_multispecies_real_gas_model(service, version, mode, path + ["user_defined_multispecies_real_gas_model"])
                    super().__init__(service, version, mode, path)
                class nist_real_gas_model(TUIMethod):
                    """
                    Loads the NIST real-gas library.
                    """
                class nist_multispecies_real_gas_model(TUIMethod):
                    """
                    Loads the NIST real-gas library.
                    """
                class set_state(TUIMethod):
                    """
                    Selects the state for NIST real gas model.
                    """
                class nist_settings(TUIMethod):
                    """
                    Specifies the name and the location for the REFPROP library and fluid files.
                    """
                class user_defined_real_gas_model(TUIMethod):
                    """
                    Loads the user-defined real-gas library.
                    """
                class user_defined_multispecies_real_gas_model(TUIMethod):
                    """
                    Loads a user-defined multispecies real-gas library.
                    """

        class named_expressions(TUIMenu):
            """
            Enters the named expressions menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.export_to_tsv = self.__class__.export_to_tsv(service, version, mode, path + ["export_to_tsv"])
                self.import_from_tsv = self.__class__.import_from_tsv(service, version, mode, path + ["import_from_tsv"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new named expression.
                """
            class compute(TUIMethod):
                """
                Computes and prints the value of an expression. This is only available for expressions that evaluate to a single value.
                """
            class copy(TUIMethod):
                """
                Allows you to copy an existing named expression.
                """
            class edit(TUIMethod):
                """
                Allows you to edit the definition of a named expression.
                """
            class delete(TUIMethod):
                """
                Allows you to delete a named expression, as long as it is not in use.
                """
            class export_to_tsv(TUIMethod):
                """
                Export one or more named expressions to a file in TSV format.
                """
            class import_from_tsv(TUIMethod):
                """
                Import one or more named expressions saved in TSV format.
                """
            class list(TUIMethod):
                """
                Lists all of the currently defined named expressions.
                """
            class list_properties(TUIMethod):
                """
                Lists the definition of a named expression.
                """

        class virtual_boundary(TUIMenu):
            """
            Manage Virtual Boundaries.
            """
            def __init__(self, service, version, mode, path):
                self.boundary_interface = self.__class__.boundary_interface(service, version, mode, path + ["boundary_interface"])
                self.hole_geometry = self.__class__.hole_geometry(service, version, mode, path + ["hole_geometry"])
                super().__init__(service, version, mode, path)
            class boundary_interface(TUIMethod):
                """
                Create a Boundary Interface.
                """
            class hole_geometry(TUIMethod):
                """
                Create a Hole Geometry template.
                """

        class curvilinear_coordinate_system(TUIMenu):
            """
            Curvilinear Coordinate System.
            """
            def __init__(self, service, version, mode, path):
                self.calculation_settings = self.__class__.calculation_settings(service, version, mode, path + ["calculation_settings"])
                self.new = self.__class__.new(service, version, mode, path + ["new"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display_settings = self.__class__.display_settings(service, version, mode, path + ["display_settings"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                super().__init__(service, version, mode, path)
            class calculation_settings(TUIMethod):
                """
                Define Settings for curvilinear coordinate system.
                """
            class new(TUIMethod):
                """
                Define a new curvilinear coordinate system.
                """
            class edit(TUIMethod):
                """
                Edit an existing curvilinear coordinate system.
                """
            class delete(TUIMethod):
                """
                Delete Curvilinear Coordinate System.
                """
            class display_settings(TUIMethod):
                """
                Display settings for Curvilinear Coordinate System.
                """
            class display(TUIMethod):
                """
                Display Curvilinear Coordinate System.
                """

    class file(TUIMenu):
        """
        Enter the file menu.
        """
        def __init__(self, service, version, mode, path):
            self.auto_save = self.__class__.auto_save(service, version, mode, path + ["auto_save"])
            self.cffio_options = self.__class__.cffio_options(service, version, mode, path + ["cffio_options"])
            self.export = self.__class__.export(service, version, mode, path + ["export"])
            self.transient_export = self.__class__.transient_export(service, version, mode, path + ["transient_export"])
            self.em_mapping = self.__class__.em_mapping(service, version, mode, path + ["em_mapping"])
            self.import_ = self.__class__.import_(service, version, mode, path + ["import"])
            self.interpolate = self.__class__.interpolate(service, version, mode, path + ["interpolate"])
            self.fsi = self.__class__.fsi(service, version, mode, path + ["fsi"])
            self.parametric_project = self.__class__.parametric_project(service, version, mode, path + ["parametric_project"])
            self.project = self.__class__.project(service, version, mode, path + ["project[beta]"])
            self.table_manager = self.__class__.table_manager(service, version, mode, path + ["table_manager"])
            self.solution_files = self.__class__.solution_files(service, version, mode, path + ["solution_files"])
            self.single_precision_coordinates = self.__class__.single_precision_coordinates(service, version, mode, path + ["single_precision_coordinates"])
            self.binary_legacy_files = self.__class__.binary_legacy_files(service, version, mode, path + ["binary_legacy_files"])
            self.cff_files = self.__class__.cff_files(service, version, mode, path + ["cff_files"])
            self.async_optimize = self.__class__.async_optimize(service, version, mode, path + ["async_optimize"])
            self.write_pdat = self.__class__.write_pdat(service, version, mode, path + ["write_pdat"])
            self.confirm_overwrite = self.__class__.confirm_overwrite(service, version, mode, path + ["confirm_overwrite"])
            self.define_macro = self.__class__.define_macro(service, version, mode, path + ["define_macro"])
            self.export_to_cfd_post = self.__class__.export_to_cfd_post(service, version, mode, path + ["export_to_cfd_post"])
            self.execute_macro = self.__class__.execute_macro(service, version, mode, path + ["execute_macro"])
            self.read_settings = self.__class__.read_settings(service, version, mode, path + ["read_settings"])
            self.read_case = self.__class__.read_case(service, version, mode, path + ["read_case"])
            self.read_case_light = self.__class__.read_case_light(service, version, mode, path + ["read_case_light"])
            self.read_case_data = self.__class__.read_case_data(service, version, mode, path + ["read_case_data"])
            self.read_data = self.__class__.read_data(service, version, mode, path + ["read_data"])
            self.read_case_info = self.__class__.read_case_info(service, version, mode, path + ["read_case_info"])
            self.read_field_functions = self.__class__.read_field_functions(service, version, mode, path + ["read_field_functions"])
            self.read_injections = self.__class__.read_injections(service, version, mode, path + ["read_injections"])
            self.read_journal = self.__class__.read_journal(service, version, mode, path + ["read_journal"])
            self.read_macros = self.__class__.read_macros(service, version, mode, path + ["read_macros"])
            self.read_profile = self.__class__.read_profile(service, version, mode, path + ["read_profile"])
            self.read_transient_table = self.__class__.read_transient_table(service, version, mode, path + ["read_transient_table"])
            self.read_pdf = self.__class__.read_pdf(service, version, mode, path + ["read_pdf"])
            self.read_rays = self.__class__.read_rays(service, version, mode, path + ["read_rays"])
            self.read_surface_clusters = self.__class__.read_surface_clusters(service, version, mode, path + ["read_surface_clusters"])
            self.read_viewfactors = self.__class__.read_viewfactors(service, version, mode, path + ["read_viewfactors"])
            self.read_isat_table = self.__class__.read_isat_table(service, version, mode, path + ["read_isat_table"])
            self.replace_mesh = self.__class__.replace_mesh(service, version, mode, path + ["replace_mesh"])
            self.reload_setup = self.__class__.reload_setup(service, version, mode, path + ["reload_setup"])
            self.close_without_save = self.__class__.close_without_save(service, version, mode, path + ["close_without_save"])
            self.sync_workbench = self.__class__.sync_workbench(service, version, mode, path + ["sync_workbench"])
            self.set_batch_options = self.__class__.set_batch_options(service, version, mode, path + ["set_batch_options"])
            self.set_idle_timeout = self.__class__.set_idle_timeout(service, version, mode, path + ["set_idle_timeout"])
            self.show_configuration = self.__class__.show_configuration(service, version, mode, path + ["show_configuration"])
            self.start_journal = self.__class__.start_journal(service, version, mode, path + ["start_journal"])
            self.stop_journal = self.__class__.stop_journal(service, version, mode, path + ["stop_journal"])
            self.stop_macro = self.__class__.stop_macro(service, version, mode, path + ["stop_macro"])
            self.start_transcript = self.__class__.start_transcript(service, version, mode, path + ["start_transcript"])
            self.stop_transcript = self.__class__.stop_transcript(service, version, mode, path + ["stop_transcript"])
            self.write_settings = self.__class__.write_settings(service, version, mode, path + ["write_settings"])
            self.write_boundary_mesh = self.__class__.write_boundary_mesh(service, version, mode, path + ["write_boundary_mesh"])
            self.write_case = self.__class__.write_case(service, version, mode, path + ["write_case"])
            self.write_case_light = self.__class__.write_case_light(service, version, mode, path + ["write_case_light"])
            self.data_file_options = self.__class__.data_file_options(service, version, mode, path + ["data_file_options"])
            self.write_case_data = self.__class__.write_case_data(service, version, mode, path + ["write_case_data"])
            self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
            self.write_fan_profile = self.__class__.write_fan_profile(service, version, mode, path + ["write_fan_profile"])
            self.write_field_functions = self.__class__.write_field_functions(service, version, mode, path + ["write_field_functions"])
            self.write_profile = self.__class__.write_profile(service, version, mode, path + ["write_profile"])
            self.write_currently_defined_profiles = self.__class__.write_currently_defined_profiles(service, version, mode, path + ["write_currently_defined_profiles"])
            self.set_target_reference_frame_for_write_profiles = self.__class__.set_target_reference_frame_for_write_profiles(service, version, mode, path + ["set_target_reference_frame_for_write_profiles"])
            self.write_circumferential_averaged_profile = self.__class__.write_circumferential_averaged_profile(service, version, mode, path + ["write_circumferential_averaged_profile"])
            self.write_merge_profiles = self.__class__.write_merge_profiles(service, version, mode, path + ["write_merge_profiles"])
            self.write_pdf = self.__class__.write_pdf(service, version, mode, path + ["write_pdf"])
            self.write_flamelet = self.__class__.write_flamelet(service, version, mode, path + ["write_flamelet"])
            self.write_injections = self.__class__.write_injections(service, version, mode, path + ["write_injections"])
            self.write_macros = self.__class__.write_macros(service, version, mode, path + ["write_macros"])
            self.write_isat_table = self.__class__.write_isat_table(service, version, mode, path + ["write_isat_table"])
            self.write_cleanup_script = self.__class__.write_cleanup_script(service, version, mode, path + ["write_cleanup_script"])
            self.load_act_tool = self.__class__.load_act_tool(service, version, mode, path + ["load_act_tool"])
            self.set_tui_version = self.__class__.set_tui_version(service, version, mode, path + ["set_tui_version"])
            super().__init__(service, version, mode, path)
        class single_precision_coordinates(TUIMethod):
            """
            Specifies whether the nodal coordinates should be written in single precision (rather than the default double precision). This text command is only available in the single-precision version of ANSYS Fluent.
            """
        class binary_legacy_files(TUIMethod):
            """
            Indicate whether to write binary or text format case and data files.
            """
        class cff_files(TUIMethod):
            """
            Indicate whether to write ANSYS common fluids format (CFF) files or legacy case and data files.
            """
        class async_optimize(TUIMethod):
            """
            Chooses whether to optimize file I/O using scratch disks and asynchronous operations.
            """
        class write_pdat(TUIMethod):
            """
            Enables / disables the attempt to save .pdat files. Note that this text command is no longer supported.
            """
        class confirm_overwrite(TUIMethod):
            """
            Indicate whether or not to confirm attempts to overwrite existing files.
            """
        class define_macro(TUIMethod):
            """
            Saves input to a named macro.
            """
        class export_to_cfd_post(TUIMethod):
            """
            Exports data files that are compatible with CFD-Post and EnSight (that is, .cdat and .cst files) and opens CFD-Post, if desired.
            """
        class execute_macro(TUIMethod):
            """
            Runs a previously defined macro.
            """
        class read_settings(TUIMethod):
            """
            Reads and sets boundary conditions from a specified file.
            """
        class read_case(TUIMethod):
            """
            Read a case file.
            Parameters
            ----------
            case_file_name : str.
            """
        class read_case_light(TUIMethod):
            """
            Read a case file while skipping mesh elements.
            """
        class read_case_data(TUIMethod):
            """
            Reads a case and a data file.
            """
        class read_data(TUIMethod):
            """
            Reads a data file.
            """
        class read_case_info(TUIMethod):
            """
            Read basic case info.
            """
        class read_field_functions(TUIMethod):
            """
            Reads custom field function definitions from a file.
            """
        class read_injections(TUIMethod):
            """
            Reads all DPM injections from a file.
            """
        class read_journal(TUIMethod):
            """
            Read a journal file.
            """
        class read_macros(TUIMethod):
            """
            Reads macro definitions from a file.
            """
        class read_profile(TUIMethod):
            """
            Reads boundary profile data.
            """
        class read_transient_table(TUIMethod):
            """
            Reads table of transient boundary profile data.
            """
        class read_pdf(TUIMethod):
            """
            Reads a PDF file.
            """
        class read_rays(TUIMethod):
            """
            Reads a ray file.
            """
        class read_surface_clusters(TUIMethod):
            """
            Reads surface clusters from a file.
            """
        class read_viewfactors(TUIMethod):
            """
            Reads view factors from a file.
            """
        class read_isat_table(TUIMethod):
            """
            Reads ISAT Table.
            """
        class replace_mesh(TUIMethod):
            """
            Replaces the mesh with a new one while preserving settings.
            """
        class reload_setup(TUIMethod):
            """
            Discards any changes in the current ANSYS Fluent in Workbench session and removes any corresponding data from the Solution cell. This command is only available when running ANSYS Fluent in Workbench.
            """
        class close_without_save(TUIMethod):
            """
            Exits ANSYS Fluent without saving data in Workbench. This command is only available when running ANSYS Fluent in Workbench.
            """
        class sync_workbench(TUIMethod):
            """
            Directly updates Workbench with the most recent Fluent changes. This command is only available when running ANSYS Fluent in Workbench.
            """
        class set_batch_options(TUIMethod):
            """
            Sets the batch options.
            """
        class set_idle_timeout(TUIMethod):
            """
            Set the idle timeout.
            """
        class show_configuration(TUIMethod):
            """
            Display current release and version information.
            """
        class start_journal(TUIMethod):
            """
            Start recording all input in a file.
            """
        class stop_journal(TUIMethod):
            """
            Stop recording input and close the journal file.
            """
        class stop_macro(TUIMethod):
            """
            Stops recording input to a macro.
            """
        class start_transcript(TUIMethod):
            """
            Start recording input and output in a file.
            """
        class stop_transcript(TUIMethod):
            """
            Stop recording input and output and close the transcript file.
            """
        class write_settings(TUIMethod):
            """
            Writes out current boundary conditions in use.
            """
        class write_boundary_mesh(TUIMethod):
            """
            Writes the boundary mesh to a file.
            """
        class write_case(TUIMethod):
            """
            Write a case file.
            """
        class write_case_light(TUIMethod):
            """
            Save the case file in light-weight mode,i.e. mesh not touched.
            """
        class data_file_options(TUIMethod):
            """
            Sets derived quantities to be written in data file.
            """
        class write_case_data(TUIMethod):
            """
            Writes a case and a data file.
            """
        class write_data(TUIMethod):
            """
            Writes a data file.
            """
        class write_fan_profile(TUIMethod):
            """
            Computes radial profiles for a fan zone and writes them to a profile file.
            """
        class write_field_functions(TUIMethod):
            """
            Writes the currently defined custom field functions to a file.
            """
        class write_profile(TUIMethod):
            """
            Writes surface data as a boundary profile file.
            """
        class write_currently_defined_profiles(TUIMethod):
            """
            Write currently defined profiles. To use \*.csv format specify filename with .csv suffix.
            """
        class set_target_reference_frame_for_write_profiles(TUIMethod):
            """
            Set reference frame options, which will be used for position transformation during writing of profiles.
            """
        class write_circumferential_averaged_profile(TUIMethod):
            """
            Write surface data as a boundary profile file. To use \*.csv format specify filename with .csv suffix.
            """
        class write_merge_profiles(TUIMethod):
            """
            Writes a .csv file with the selected surfaces consolidated into one set of data points.
            """
        class write_pdf(TUIMethod):
            """
            Writes a pdf file.
            """
        class write_flamelet(TUIMethod):
            """
            Writes a flamelet file.
            """
        class write_injections(TUIMethod):
            """
            Writes out selected DPM injections to a file.
            """
        class write_macros(TUIMethod):
            """
            Writes the currently defined macros to a file.
            """
        class write_isat_table(TUIMethod):
            """
            Writes ISAT Table.
            """
        class write_cleanup_script(TUIMethod):
            """
            Writes the cleanup-script-file for ANSYS Fluent.
            """
        class load_act_tool(TUIMethod):
            """
            Load ACT Start Page.
            """
        class set_tui_version(TUIMethod):
            """
            Set the version of the TUI commands.
            """

        class auto_save(TUIMenu):
            """
            Enters the auto save menu.
            """
            def __init__(self, service, version, mode, path):
                self.case_frequency = self.__class__.case_frequency(service, version, mode, path + ["case_frequency"])
                self.data_frequency = self.__class__.data_frequency(service, version, mode, path + ["data_frequency"])
                self.root_name = self.__class__.root_name(service, version, mode, path + ["root_name"])
                self.retain_most_recent_files = self.__class__.retain_most_recent_files(service, version, mode, path + ["retain_most_recent_files"])
                self.max_files = self.__class__.max_files(service, version, mode, path + ["max_files"])
                self.append_file_name_with = self.__class__.append_file_name_with(service, version, mode, path + ["append_file_name_with"])
                self.save_data_file_every = self.__class__.save_data_file_every(service, version, mode, path + ["save_data_file_every"])
                super().__init__(service, version, mode, path)
            class case_frequency(TUIMethod):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which case files are saved.
                """
            class data_frequency(TUIMethod):
                """
                Specifies the frequency (in iterations, time steps, or flow time) with which data files are saved.
                """
            class root_name(TUIMethod):
                """
                Specifies the root name for the files that are saved.
                """
            class retain_most_recent_files(TUIMethod):
                """
                Sets autosave to retain the 5 most recent files.
                """
            class max_files(TUIMethod):
                """
                Sets the maximum number of files. Once the maximum is reached, files will be erased as new files are written.
                """
            class append_file_name_with(TUIMethod):
                """
                Sets the suffix for auto-saved files. The file name can be appended by flow-time, time-step value, or by user-specified flags in file name.
                """
            class save_data_file_every(TUIMethod):
                """
                Specifies the type and frequency of the data file to be saved.
                """

        class cffio_options(TUIMenu):
            """
            Enters the cffio options menu, which provides options for the I/O of case and data files in the Common Fluids Format (CFF).
            """
            def __init__(self, service, version, mode, path):
                self.io_mode = self.__class__.io_mode(service, version, mode, path + ["io_mode"])
                self.compression_level = self.__class__.compression_level(service, version, mode, path + ["compression_level"])
                self.single_precision_data = self.__class__.single_precision_data(service, version, mode, path + ["single_precision_data"])
                super().__init__(service, version, mode, path)
            class io_mode(TUIMethod):
                """
                Sets the I/O mode for writing CFF files.
                1. HOST: I/O is done serially by the host process.
                2. NODE0: I/O is done serially by the node 0 process.
                3. PARALLEL INDEPENDENT: I/O is done in parallel using the independent mode of MPI I/O.
                4. PARALLEL COLLECTIVE: I/O is done in parallel using the collective mode of MPI I/O.
                """
            class compression_level(TUIMethod):
                """
                Sets the compression level for CFF files. The compression level can be set between 0 and 9 with 0 being least compression (fastest) and 9 being highest compression (slowest).
                """
            class single_precision_data(TUIMethod):
                """
                Specifies whether the double-precision solver saves single-precision data when writing CFF data files, in order to reduce the size of the files.
                """

        class export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self.system_coupling_definition_file_settings = self.__class__.system_coupling_definition_file_settings(service, version, mode, path + ["system_coupling_definition_file_settings"])
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.mechanical_apdl = self.__class__.mechanical_apdl(service, version, mode, path + ["mechanical_apdl"])
                self.mechanical_apdl_input = self.__class__.mechanical_apdl_input(service, version, mode, path + ["mechanical_apdl_input"])
                self.ascii = self.__class__.ascii(service, version, mode, path + ["ascii"])
                self.common_fluids_format_post = self.__class__.common_fluids_format_post(service, version, mode, path + ["common_fluids_format_post"])
                self.avs = self.__class__.avs(service, version, mode, path + ["avs"])
                self.cdat_for_cfd_post__and__ensight = self.__class__.cdat_for_cfd_post__and__ensight(service, version, mode, path + ["cdat_for_cfd_post__and__ensight"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.custom_heat_flux = self.__class__.custom_heat_flux(service, version, mode, path + ["custom_heat_flux"])
                self.dx = self.__class__.dx(service, version, mode, path + ["dx"])
                self.ensight = self.__class__.ensight(service, version, mode, path + ["ensight"])
                self.ensight_gold = self.__class__.ensight_gold(service, version, mode, path + ["ensight_gold"])
                self.ensight_gold_parallel_surfaces = self.__class__.ensight_gold_parallel_surfaces(service, version, mode, path + ["ensight_gold_parallel_surfaces"])
                self.ensight_gold_parallel_volume = self.__class__.ensight_gold_parallel_volume(service, version, mode, path + ["ensight_gold_parallel_volume"])
                self.ensight_dvs_surfaces = self.__class__.ensight_dvs_surfaces(service, version, mode, path + ["ensight_dvs_surfaces"])
                self.ensight_dvs_volume = self.__class__.ensight_dvs_volume(service, version, mode, path + ["ensight_dvs_volume"])
                self.icemcfd_for_icepak = self.__class__.icemcfd_for_icepak(service, version, mode, path + ["icemcfd_for_icepak"])
                self.fast_mesh = self.__class__.fast_mesh(service, version, mode, path + ["fast_mesh"])
                self.fast_scalar = self.__class__.fast_scalar(service, version, mode, path + ["fast_scalar"])
                self.fast_solution = self.__class__.fast_solution(service, version, mode, path + ["fast_solution"])
                self.fast_velocity = self.__class__.fast_velocity(service, version, mode, path + ["fast_velocity"])
                self.fieldview = self.__class__.fieldview(service, version, mode, path + ["fieldview"])
                self.fieldview_data = self.__class__.fieldview_data(service, version, mode, path + ["fieldview_data"])
                self.fieldview_unstruct = self.__class__.fieldview_unstruct(service, version, mode, path + ["fieldview_unstruct"])
                self.fieldview_unstruct_mesh = self.__class__.fieldview_unstruct_mesh(service, version, mode, path + ["fieldview_unstruct_mesh"])
                self.fieldview_unstruct_data = self.__class__.fieldview_unstruct_data(service, version, mode, path + ["fieldview_unstruct_data"])
                self.fieldview_unstruct_surfaces = self.__class__.fieldview_unstruct_surfaces(service, version, mode, path + ["fieldview_unstruct_surfaces"])
                self.fieldview_xdb = self.__class__.fieldview_xdb(service, version, mode, path + ["fieldview_xdb"])
                self.gambit = self.__class__.gambit(service, version, mode, path + ["gambit"])
                self.ideas = self.__class__.ideas(service, version, mode, path + ["ideas"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.patran_neutral = self.__class__.patran_neutral(service, version, mode, path + ["patran_neutral"])
                self.patran_nodal = self.__class__.patran_nodal(service, version, mode, path + ["patran_nodal"])
                self.taitherm = self.__class__.taitherm(service, version, mode, path + ["taitherm"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                self.particle_history_data = self.__class__.particle_history_data(service, version, mode, path + ["particle_history_data"])
                super().__init__(service, version, mode, path)
            class abaqus(TUIMethod):
                """
                Writes an ABAQUS file.
                """
            class mechanical_apdl(TUIMethod):
                """
                Write an Mechanical APDL file.
                """
            class mechanical_apdl_input(TUIMethod):
                """
                Writes a Mechanical APDL Input file.
                """
            class ascii(TUIMethod):
                """
                Writes an ASCII file.
                """
            class common_fluids_format_post(TUIMethod):
                """
                Writes common fluids format files (.cas.post and .dat.post) for mesh and data, respectively. These files are saved in the hierarchical data format.
                """
            class avs(TUIMethod):
                """
                Writes an AVS UCD file.
                """
            class cdat_for_cfd_post__and__ensight(TUIMethod):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
            class cgns(TUIMethod):
                """
                Write a CGNS file.
                """
            class custom_heat_flux(TUIMethod):
                """
                Writes a generic file for heat transfer.
                """
            class dx(TUIMethod):
                """
                Writes an IBM Data Explorer format file.
                """
            class ensight(TUIMethod):
                """
                Writes EnSight geometry, velocity, and scalar files.
                """
            class ensight_gold(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
            class ensight_gold_parallel_surfaces(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_gold_parallel_volume(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_dvs_surfaces(TUIMethod):
                """
                Write post-processing data(geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_volume(TUIMethod):
                """
                Write post-processing data(geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
            class icemcfd_for_icepak(TUIMethod):
                """
                Writes a binary ICEM CFD domain file.
                """
            class fast_mesh(TUIMethod):
                """
                Writes FAST/Plot3D unstructured mesh file.
                """
            class fast_scalar(TUIMethod):
                """
                Writes FAST/Plot3D unstructured scalar function file.
                """
            class fast_solution(TUIMethod):
                """
                Writes FAST/Plot3D unstructured solution file.
                """
            class fast_velocity(TUIMethod):
                """
                Writes FAST/Plot3D unstructured vector function file.
                """
            class fieldview(TUIMethod):
                """
                Writes FIELDVIEW case and data files.
                """
            class fieldview_data(TUIMethod):
                """
                Writes FIELDVIEW case and data files.
                """
            class fieldview_unstruct(TUIMethod):
                """
                Writes FIELDVIEW unstructured combined file.
                """
            class fieldview_unstruct_mesh(TUIMethod):
                """
                Writes FIELDVIEW unstructured mesh-only file.
                """
            class fieldview_unstruct_data(TUIMethod):
                """
                Writes FIELDVIEW unstructured results-only file.
                """
            class fieldview_unstruct_surfaces(TUIMethod):
                """
                Writes FIELDVIEW unstructured file for surfaces. You are prompted to select either [1], [2] or [3] to write either mesh-only, results-only, or combined for surfaces (respectively).
                """
            class fieldview_xdb(TUIMethod):
                """
                Write a FieldView XDB format file.
                """
            class gambit(TUIMethod):
                """
                Writes GAMBIT neutral file.
                """
            class ideas(TUIMethod):
                """
                Writes an I-deas universal file.
                """
            class nastran(TUIMethod):
                """
                Write a NASTRAN file.
                """
            class patran_neutral(TUIMethod):
                """
                Writes a PATRAN neutral file.
                """
            class patran_nodal(TUIMethod):
                """
                Writes a PATRAN nodal results file.
                """
            class taitherm(TUIMethod):
                """
                Exports TAITherm file.
                """
            class tecplot(TUIMethod):
                """
                Writes a Tecplot+3DV format file.
                """
            class particle_history_data(TUIMethod):
                """
                Exports particle-history data.
                """

            class system_coupling_definition_file_settings(TUIMenu):
                """
                Enters the system coupling file (.scp) menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable_automatic_creation_of_scp_file = self.__class__.enable_automatic_creation_of_scp_file(service, version, mode, path + ["enable_automatic_creation_of_scp_file"])
                    self.write_system_coupling_file = self.__class__.write_system_coupling_file(service, version, mode, path + ["write_system_coupling_file"])
                    super().__init__(service, version, mode, path)
                class enable_automatic_creation_of_scp_file(TUIMethod):
                    """
                    Enables/disables automatically writing a .scp every time a case file is written.
                    """
                class write_system_coupling_file(TUIMethod):
                    """
                    Writes a system coupling (.scp) file.
                    """

            class settings(TUIMenu):
                """
                Enter the export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_cgns_export_filetype = self.__class__.set_cgns_export_filetype(service, version, mode, path + ["set_cgns_export_filetype"])
                    super().__init__(service, version, mode, path)
                class set_cgns_export_filetype(TUIMethod):
                    """
                    Select HDF5 or ADF as file format for CGNS.
                    """

        class transient_export(TUIMenu):
            """
            Enter the export menu.
            """
            def __init__(self, service, version, mode, path):
                self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.mechanical_apdl_input = self.__class__.mechanical_apdl_input(service, version, mode, path + ["mechanical_apdl_input"])
                self.ascii = self.__class__.ascii(service, version, mode, path + ["ascii"])
                self.avs = self.__class__.avs(service, version, mode, path + ["avs"])
                self.cdat_for_cfd_post__and__ensight = self.__class__.cdat_for_cfd_post__and__ensight(service, version, mode, path + ["cdat_for_cfd_post__and__ensight"])
                self.common_fluids_format_post = self.__class__.common_fluids_format_post(service, version, mode, path + ["common_fluids_format_post"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.dx = self.__class__.dx(service, version, mode, path + ["dx"])
                self.ensight_gold_transient = self.__class__.ensight_gold_transient(service, version, mode, path + ["ensight_gold_transient"])
                self.ensight_gold_parallel_surfaces = self.__class__.ensight_gold_parallel_surfaces(service, version, mode, path + ["ensight_gold_parallel_surfaces"])
                self.ensight_gold_parallel_volume = self.__class__.ensight_gold_parallel_volume(service, version, mode, path + ["ensight_gold_parallel_volume"])
                self.ensight_dvs_surfaces = self.__class__.ensight_dvs_surfaces(service, version, mode, path + ["ensight_dvs_surfaces"])
                self.ensight_dvs_volume = self.__class__.ensight_dvs_volume(service, version, mode, path + ["ensight_dvs_volume"])
                self.ensight_gold_from_existing_files = self.__class__.ensight_gold_from_existing_files(service, version, mode, path + ["ensight_gold_from_existing_files"])
                self.fast = self.__class__.fast(service, version, mode, path + ["fast"])
                self.fast_solution = self.__class__.fast_solution(service, version, mode, path + ["fast_solution"])
                self.fieldview_unstruct = self.__class__.fieldview_unstruct(service, version, mode, path + ["fieldview_unstruct"])
                self.fieldview_unstruct_mesh = self.__class__.fieldview_unstruct_mesh(service, version, mode, path + ["fieldview_unstruct_mesh"])
                self.fieldview_unstruct_data = self.__class__.fieldview_unstruct_data(service, version, mode, path + ["fieldview_unstruct_data"])
                self.fieldview_unstruct_surfaces = self.__class__.fieldview_unstruct_surfaces(service, version, mode, path + ["fieldview_unstruct_surfaces"])
                self.fieldview_xdb = self.__class__.fieldview_xdb(service, version, mode, path + ["fieldview_xdb"])
                self.ideas = self.__class__.ideas(service, version, mode, path + ["ideas"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.patran_neutral = self.__class__.patran_neutral(service, version, mode, path + ["patran_neutral"])
                self.taitherm = self.__class__.taitherm(service, version, mode, path + ["taitherm"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                self.particle_history_data = self.__class__.particle_history_data(service, version, mode, path + ["particle_history_data"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                super().__init__(service, version, mode, path)
            class abaqus(TUIMethod):
                """
                Writes an ABAQUS file.
                """
            class mechanical_apdl_input(TUIMethod):
                """
                Writes a Mechanical APDL input file.
                """
            class ascii(TUIMethod):
                """
                Writes an ASCII file.
                """
            class avs(TUIMethod):
                """
                Writes an AVS UCD file.
                """
            class cdat_for_cfd_post__and__ensight(TUIMethod):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
            class common_fluids_format_post(TUIMethod):
                """
                Write an CFF Post-Only file.
                """
            class cgns(TUIMethod):
                """
                Writes a CGNS file.
                """
            class dx(TUIMethod):
                """
                Writes an IBM Data Explorer format file.
                """
            class ensight_gold_transient(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files.
                """
            class ensight_gold_parallel_surfaces(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for surfaces in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_gold_parallel_volume(TUIMethod):
                """
                Writes EnSight Gold geometry, velocity, and scalar files for cell zones in a parallel format suitable for ANSYS Ensight Enterprise.
                """
            class ensight_dvs_surfaces(TUIMethod):
                """
                Write post-processing data(geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_dvs_volume(TUIMethod):
                """
                Write post-processing data(geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
            class ensight_gold_from_existing_files(TUIMethod):
                """
                Writes EnSight Gold files using ANSYS Fluent case files.
                """
            class fast(TUIMethod):
                """
                Writes a FAST/Plot3D unstructured mesh velocity scalar file.
                """
            class fast_solution(TUIMethod):
                """
                Writes a FAST/Plot3D unstructured solution file.
                """
            class fieldview_unstruct(TUIMethod):
                """
                Writes a FIELDVIEW unstructured combined file.
                """
            class fieldview_unstruct_mesh(TUIMethod):
                """
                Writes a FIELDVIEW unstructured mesh only file.
                """
            class fieldview_unstruct_data(TUIMethod):
                """
                Writes a FIELDVIEW unstructured results only file.
                """
            class fieldview_unstruct_surfaces(TUIMethod):
                """
                Writes FIELDVIEW unstructured combined file for surfaces.
                """
            class fieldview_xdb(TUIMethod):
                """
                Write a FieldView XDB format file.
                """
            class ideas(TUIMethod):
                """
                Writes an I-deas universal file.
                """
            class nastran(TUIMethod):
                """
                Writes a NASTRAN file.
                """
            class patran_neutral(TUIMethod):
                """
                Writes a PATRAN neutral file.
                """
            class taitherm(TUIMethod):
                """
                Writes a TAITherm file.
                """
            class tecplot(TUIMethod):
                """
                Write a Tecplot+3DV format file.
                """
            class particle_history_data(TUIMethod):
                """
                Sets up an automatic particle-history data export.
                """
            class edit(TUIMethod):
                """
                Edits transient exports.
                """
            class delete(TUIMethod):
                """
                Deletes transient exports.
                """

            class settings(TUIMenu):
                """
                Enters the automatic export settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cfd_post_compatible = self.__class__.cfd_post_compatible(service, version, mode, path + ["cfd_post_compatible"])
                    super().__init__(service, version, mode, path)
                class cfd_post_compatible(TUIMethod):
                    """
                    Specifies when case files are written with the .cdat and .cst files exported for Ansys CFD-Post. Note that this setting is ignored if the Write Case File Every Time option is enabled in the Automatic Export dialog box, which is always the case starting in Release 2021 R1.
                    """

        class em_mapping(TUIMenu):
            """
            Enters the electromagnetic loss mapping menu.
            """
            def __init__(self, service, version, mode, path):
                self.volumetric_energy_source = self.__class__.volumetric_energy_source(service, version, mode, path + ["volumetric_energy_source"])
                self.surface_energy_source = self.__class__.surface_energy_source(service, version, mode, path + ["surface_energy_source"])
                self.remove_loss_only = self.__class__.remove_loss_only(service, version, mode, path + ["remove_loss_only"])
                self.maintain_loss_on_initialization = self.__class__.maintain_loss_on_initialization(service, version, mode, path + ["maintain_loss_on_initialization"])
                super().__init__(service, version, mode, path)
            class volumetric_energy_source(TUIMethod):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected cell zones.
                """
            class surface_energy_source(TUIMethod):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected wall zones.
                """
            class remove_loss_only(TUIMethod):
                """
                Removes the loss data provided by Maxwell and keeps all other solution data.
                """
            class maintain_loss_on_initialization(TUIMethod):
                """
                Maintains the loss data provided by Maxwell even if solution is initialized.
                """

        class import_(TUIMenu):
            """
            Enter the import menu.
            """
            def __init__(self, service, version, mode, path):
                self.mechanical_apdl = self.__class__.mechanical_apdl(service, version, mode, path + ["mechanical_apdl"])
                self.abaqus = self.__class__.abaqus(service, version, mode, path + ["abaqus"])
                self.cfx = self.__class__.cfx(service, version, mode, path + ["cfx"])
                self.cgns = self.__class__.cgns(service, version, mode, path + ["cgns"])
                self.fmu_file = self.__class__.fmu_file(service, version, mode, path + ["fmu_file"])
                self.flamelet = self.__class__.flamelet(service, version, mode, path + ["flamelet"])
                self.lstc = self.__class__.lstc(service, version, mode, path + ["lstc"])
                self.nastran = self.__class__.nastran(service, version, mode, path + ["nastran"])
                self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
                self.patran = self.__class__.patran(service, version, mode, path + ["patran"])
                self.plot3d = self.__class__.plot3d(service, version, mode, path + ["plot3d"])
                self.tecplot = self.__class__.tecplot(service, version, mode, path + ["tecplot"])
                self.chemkin_mechanism = self.__class__.chemkin_mechanism(service, version, mode, path + ["chemkin_mechanism"])
                self.chemkin_report_each_line = self.__class__.chemkin_report_each_line(service, version, mode, path + ["chemkin_report_each_line"])
                self.fidap = self.__class__.fidap(service, version, mode, path + ["fidap"])
                self.fluent4_case = self.__class__.fluent4_case(service, version, mode, path + ["fluent4_case"])
                self.gambit = self.__class__.gambit(service, version, mode, path + ["gambit"])
                self.hypermesh = self.__class__.hypermesh(service, version, mode, path + ["hypermesh"])
                self.ensight = self.__class__.ensight(service, version, mode, path + ["ensight"])
                self.ideas_universal = self.__class__.ideas_universal(service, version, mode, path + ["ideas_universal"])
                self.marc_post = self.__class__.marc_post(service, version, mode, path + ["marc_post"])
                self.ptc_mechanica = self.__class__.ptc_mechanica(service, version, mode, path + ["ptc_mechanica"])
                self.prebfc_structured = self.__class__.prebfc_structured(service, version, mode, path + ["prebfc_structured"])
                super().__init__(service, version, mode, path)
            class chemkin_mechanism(TUIMethod):
                """
                Reads a CHEMKIN mechanism file.
                """
            class chemkin_report_each_line(TUIMethod):
                """
                Enables/disables reporting after reading each line.
                """
            class fidap(TUIMethod):
                """
                Imports a FIDAP neutral file.
                """
            class fluent4_case(TUIMethod):
                """
                Imports a formatted ANSYS Fluent 4 case file.
                """
            class gambit(TUIMethod):
                """
                Imports a GAMBIT neutral file.
                """
            class hypermesh(TUIMethod):
                """
                Reads a HYPERMESH file as a case file.
                """
            class ensight(TUIMethod):
                """
                Reads an EnSight file as a case file.
                """
            class ideas_universal(TUIMethod):
                """
                Imports an I-deas Universal file.
                """
            class marc_post(TUIMethod):
                """
                Reads a MARC POST file as a case file.
                """
            class ptc_mechanica(TUIMethod):
                """
                Reads a PTC Mechanica Design file as a case file.
                """
            class prebfc_structured(TUIMethod):
                """
                Imports a formatted PreBFC structured mesh file.
                """

            class mechanical_apdl(TUIMenu):
                """
                Imports a Mechanical APDL file.
                """
                def __init__(self, service, version, mode, path):
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.result = self.__class__.result(service, version, mode, path + ["result"])
                    super().__init__(service, version, mode, path)
                class input(TUIMethod):
                    """
                    Reads a Mechanical APDL file as a case file.
                    """
                class result(TUIMethod):
                    """
                    Reads a Mechanical APDL result file as a case file.
                    """

            class abaqus(TUIMenu):
                """
                Imports an ABAQUS file.
                """
                def __init__(self, service, version, mode, path):
                    self.fil = self.__class__.fil(service, version, mode, path + ["fil"])
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.odb = self.__class__.odb(service, version, mode, path + ["odb"])
                    super().__init__(service, version, mode, path)
                class fil(TUIMethod):
                    """
                    Reads an ABAQUS .fil result file as a case file.
                    """
                class input(TUIMethod):
                    """
                    Reads an ABAQUS input file as a case file.
                    """
                class odb(TUIMethod):
                    """
                    Reads an ABAQUS odb file as a case file.
                    """

            class cfx(TUIMenu):
                """
                Imports a CFX file.
                """
                def __init__(self, service, version, mode, path):
                    self.definition = self.__class__.definition(service, version, mode, path + ["definition"])
                    self.result = self.__class__.result(service, version, mode, path + ["result"])
                    super().__init__(service, version, mode, path)
                class definition(TUIMethod):
                    """
                    Reads a CFX definition file as a case file.
                    """
                class result(TUIMethod):
                    """
                    Reads a CFX definition file as a case file.
                    """

            class cgns(TUIMenu):
                """
                Imports a CGNS file.
                """
                def __init__(self, service, version, mode, path):
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    self.data = self.__class__.data(service, version, mode, path + ["data"])
                    self.mesh_data = self.__class__.mesh_data(service, version, mode, path + ["mesh_data"])
                    super().__init__(service, version, mode, path)
                class mesh(TUIMethod):
                    """
                    Imports a CGNS mesh file.
                    """
                class data(TUIMethod):
                    """
                    Reads data from CGNS file.
                    """
                class mesh_data(TUIMethod):
                    """
                    Imports a CGNS mesh file and data file.
                    """

            class fmu_file(TUIMenu):
                """
                Enters the import FMU file menu.
                """
                def __init__(self, service, version, mode, path):
                    self.import_fmu = self.__class__.import_fmu(service, version, mode, path + ["import_fmu"])
                    self.define_fmu = self.__class__.define_fmu(service, version, mode, path + ["define_fmu"])
                    self.select_fmu_local = self.__class__.select_fmu_local(service, version, mode, path + ["select_fmu_local"])
                    self.set_fmu_parameter = self.__class__.set_fmu_parameter(service, version, mode, path + ["set_fmu_parameter"])
                    super().__init__(service, version, mode, path)
                class import_fmu(TUIMethod):
                    """
                    Imports an FMU file.
                    """
                class define_fmu(TUIMethod):
                    """
                    Links the FMU variables with the Fluent output parameters.
                    """
                class select_fmu_local(TUIMethod):
                    """
                    Allows you to select FMU local variables to be monitored during the calculation.
                    """
                class set_fmu_parameter(TUIMethod):
                    """
                    Allows you to select FMU parameter variables and change their values.
                    """

            class flamelet(TUIMenu):
                """
                Imports a flamelet file.
                """
                def __init__(self, service, version, mode, path):
                    self.standard = self.__class__.standard(service, version, mode, path + ["standard"])
                    self.cfx_rif = self.__class__.cfx_rif(service, version, mode, path + ["cfx_rif"])
                    super().__init__(service, version, mode, path)
                class standard(TUIMethod):
                    """
                    Reads a standard format flamelet file.
                    """
                class cfx_rif(TUIMethod):
                    """
                    Reads a CFX-RIF format flamelet file.
                    """

            class lstc(TUIMenu):
                """
                Imports an LSTC file.
                """
                def __init__(self, service, version, mode, path):
                    self.input = self.__class__.input(service, version, mode, path + ["input"])
                    self.state = self.__class__.state(service, version, mode, path + ["state"])
                    super().__init__(service, version, mode, path)
                class input(TUIMethod):
                    """
                    Reads an LSTC input file as a case file.
                    """
                class state(TUIMethod):
                    """
                    Reads an LSTC result file as a case file.
                    """

            class nastran(TUIMenu):
                """
                Imports a NASTRAN file.
                """
                def __init__(self, service, version, mode, path):
                    self.bulkdata = self.__class__.bulkdata(service, version, mode, path + ["bulkdata"])
                    self.output2 = self.__class__.output2(service, version, mode, path + ["output2"])
                    super().__init__(service, version, mode, path)
                class bulkdata(TUIMethod):
                    """
                    Reads a NASTRAN file as a case file.
                    """
                class output2(TUIMethod):
                    """
                    Reads a NASTRAN op2 file as a case file.
                    """

            class partition(TUIMenu):
                """
                Enters the partition menu to set conditions for partitioning an ANSYS Fluent case file during read.
                """
                def __init__(self, service, version, mode, path):
                    self.metis = self.__class__.metis(service, version, mode, path + ["metis"])
                    self.metis_zone = self.__class__.metis_zone(service, version, mode, path + ["metis_zone"])
                    super().__init__(service, version, mode, path)
                class metis(TUIMethod):
                    """
                    Reads and partitions an ANSYS Fluent case file.
                    """
                class metis_zone(TUIMethod):
                    """
                    Reads and partitions an ANSYS Fluent case file.
                    """

            class patran(TUIMenu):
                """
                Imports a PATRAN neutral file (zones defined by named components).
                """
                def __init__(self, service, version, mode, path):
                    self.neutral = self.__class__.neutral(service, version, mode, path + ["neutral"])
                    super().__init__(service, version, mode, path)
                class neutral(TUIMethod):
                    """
                    Reads a PATRAN Neutral file (zones defined by named components) as a case file.
                    """

            class plot3d(TUIMenu):
                """
                Imports a PLOT3D file.
                """
                def __init__(self, service, version, mode, path):
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    super().__init__(service, version, mode, path)
                class mesh(TUIMethod):
                    """
                    Reads a PLOT3D file as a case file.
                    """

            class tecplot(TUIMenu):
                """
                Enters the Tecplot menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    super().__init__(service, version, mode, path)
                class mesh(TUIMethod):
                    """
                    Reads a Tecplot binary file as a case file.
                    """

        class interpolate(TUIMenu):
            """
            Interpolates data to/from another grid.
            """
            def __init__(self, service, version, mode, path):
                self.write_data = self.__class__.write_data(service, version, mode, path + ["write_data"])
                self.read_data = self.__class__.read_data(service, version, mode, path + ["read_data"])
                self.zone_selection = self.__class__.zone_selection(service, version, mode, path + ["zone_selection"])
                super().__init__(service, version, mode, path)
            class write_data(TUIMethod):
                """
                Writes data for interpolation.
                """
            class read_data(TUIMethod):
                """
                Reads and interpolates data.
                """
            class zone_selection(TUIMethod):
                """
                Defines a list of cell zone IDs. If specified, interpolation data will be read/written for these cell zones only.
                """

        class fsi(TUIMenu):
            """
            Enters the fluid-structure interaction menu.
            """
            def __init__(self, service, version, mode, path):
                self.read_fsi_mesh = self.__class__.read_fsi_mesh(service, version, mode, path + ["read_fsi_mesh"])
                self.display_fsi_mesh = self.__class__.display_fsi_mesh(service, version, mode, path + ["display_fsi_mesh"])
                self.write_fsi_mesh = self.__class__.write_fsi_mesh(service, version, mode, path + ["write_fsi_mesh"])
                self.conserve_force = self.__class__.conserve_force(service, version, mode, path + ["conserve_force"])
                super().__init__(service, version, mode, path)
            class read_fsi_mesh(TUIMethod):
                """
                Reads an FEM mesh for one-way data mapping from ANSYS Fluent.
                """
            class display_fsi_mesh(TUIMethod):
                """
                Displays the mesh for a fluid-structure interaction.
                """
            class write_fsi_mesh(TUIMethod):
                """
                Writes a fluid-structure interaction mesh file.
                """
            class conserve_force(TUIMethod):
                """
                Conserve the forces for linear line, tri and tet elements.
                """

        class parametric_project(TUIMenu):
            """
            Enter to open, save, archive parametric project.
            """
            def __init__(self, service, version, mode, path):
                self.open = self.__class__.open(service, version, mode, path + ["open"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                self.save_as = self.__class__.save_as(service, version, mode, path + ["save_as"])
                self.save_a_copy = self.__class__.save_a_copy(service, version, mode, path + ["save_a_copy"])
                self.archive = self.__class__.archive(service, version, mode, path + ["archive"])
                super().__init__(service, version, mode, path)
            class open(TUIMethod):
                """
                Open project.
                """
            class save(TUIMethod):
                """
                Save Project.
                """
            class save_as(TUIMethod):
                """
                Save As Project.
                """
            class save_a_copy(TUIMethod):
                """
                Save a Copy.
                """
            class archive(TUIMethod):
                """
                Archive Project.
                """

        class project(TUIMenu):
            """
            Enter to create new project, open project, save and archive project.
            """
            def __init__(self, service, version, mode, path):
                self.new = self.__class__.new(service, version, mode, path + ["new"])
                self.open = self.__class__.open(service, version, mode, path + ["open"])
                self.save = self.__class__.save(service, version, mode, path + ["save"])
                self.save_as = self.__class__.save_as(service, version, mode, path + ["save_as"])
                self.save_as_copy = self.__class__.save_as_copy(service, version, mode, path + ["save_as_copy"])
                self.archive = self.__class__.archive(service, version, mode, path + ["archive"])
                super().__init__(service, version, mode, path)
            class new(TUIMethod):
                """
                Create New Project.
                """
            class open(TUIMethod):
                """
                Open project.
                """
            class save(TUIMethod):
                """
                Save Project.
                """
            class save_as(TUIMethod):
                """
                Save As Project.
                """
            class save_as_copy(TUIMethod):
                """
                Save As Copy.
                """
            class archive(TUIMethod):
                """
                Archive Project.
                """

        class table_manager(TUIMenu):
            """
            Enters the table file manager menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list_matrix_data = self.__class__.list_matrix_data(service, version, mode, path + ["list_matrix_data"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.list_tables = self.__class__.list_tables(service, version, mode, path + ["list_tables"])
                self.read_matrix_data_file = self.__class__.read_matrix_data_file(service, version, mode, path + ["read_matrix_data_file"])
                self.read_rgp_file = self.__class__.read_rgp_file(service, version, mode, path + ["read_rgp_file"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                self.store_in_case_file = self.__class__.store_in_case_file(service, version, mode, path + ["store_in_case_file"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Deletes a table from local storage.
                """
            class list_matrix_data(TUIMethod):
                """
                Lists the data of a “matrix” type locally-stored table.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a locally-stored table.
                """
            class list_tables(TUIMethod):
                """
                Lists all locally-stored tables.
                """
            class read_matrix_data_file(TUIMethod):
                """
                Imports a “matrix” type table from a file into local storage.
                """
            class read_rgp_file(TUIMethod):
                """
                Imports a set of Real Gas Property (RGP) tables from a file into local storage.
                """
            class rename(TUIMethod):
                """
                Renames a locally-stored table.
                """
            class store_in_case_file(TUIMethod):
                """
                Sets the persistence mode for RGP tables (embedded in case file or rely on external file).
                """

        class solution_files(TUIMenu):
            """
            Enters the solution files menu.
            """
            def __init__(self, service, version, mode, path):
                self.print_solution_files = self.__class__.print_solution_files(service, version, mode, path + ["print_solution_files"])
                self.load_solution = self.__class__.load_solution(service, version, mode, path + ["load_solution"])
                self.delete_solution = self.__class__.delete_solution(service, version, mode, path + ["delete_solution"])
                super().__init__(service, version, mode, path)
            class print_solution_files(TUIMethod):
                """
                Prints a list of available solution files.
                """
            class load_solution(TUIMethod):
                """
                Loads a solution file.
                """
            class delete_solution(TUIMethod):
                """
                Deletes solution files.
                """

    class icing(TUIMenu):
        """
        FENSAP-ICE options.
        """
        def __init__(self, service, version, mode, path):
            self.file = self.__class__.file(service, version, mode, path + ["file"])
            self.flow = self.__class__.flow(service, version, mode, path + ["flow"])
            self.drop = self.__class__.drop(service, version, mode, path + ["drop"])
            self.ice = self.__class__.ice(service, version, mode, path + ["ice"])
            self.multishot = self.__class__.multishot(service, version, mode, path + ["multishot"])
            self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
            super().__init__(service, version, mode, path)
        class file(TUIMethod):
            """
            File menu.
            """
        class flow(TUIMethod):
            """
            Flow solver menu.
            """
        class drop(TUIMethod):
            """
            Droplet impingement menu.
            """
        class ice(TUIMethod):
            """
            Ice accretion menu.
            """
        class multishot(TUIMethod):
            """
            Multi-shot accretion menu.
            """
        class settings(TUIMethod):
            """
            Global settings menu.
            """

    class mesh(TUIMenu):
        """
        Enter the mesh menu.
        """
        def __init__(self, service, version, mode, path):
            self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
            self.modify_zones = self.__class__.modify_zones(service, version, mode, path + ["modify_zones"])
            self.polyhedra = self.__class__.polyhedra(service, version, mode, path + ["polyhedra"])
            self.reorder = self.__class__.reorder(service, version, mode, path + ["reorder"])
            self.repair_improve = self.__class__.repair_improve(service, version, mode, path + ["repair_improve"])
            self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
            self.adjacency = self.__class__.adjacency(service, version, mode, path + ["adjacency"])
            self.check = self.__class__.check(service, version, mode, path + ["check"])
            self.check_before_solve = self.__class__.check_before_solve(service, version, mode, path + ["check_before_solve"])
            self.check_verbosity = self.__class__.check_verbosity(service, version, mode, path + ["check_verbosity"])
            self.enhanced_orthogonal_quality = self.__class__.enhanced_orthogonal_quality(service, version, mode, path + ["enhanced_orthogonal_quality"])
            self.mesh_info = self.__class__.mesh_info(service, version, mode, path + ["mesh_info"])
            self.memory_usage = self.__class__.memory_usage(service, version, mode, path + ["memory_usage"])
            self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
            self.redistribute_boundary_layer = self.__class__.redistribute_boundary_layer(service, version, mode, path + ["redistribute_boundary_layer"])
            self.replace = self.__class__.replace(service, version, mode, path + ["replace"])
            self.rotate = self.__class__.rotate(service, version, mode, path + ["rotate"])
            self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
            self.size_info = self.__class__.size_info(service, version, mode, path + ["size_info"])
            self.smooth_mesh = self.__class__.smooth_mesh(service, version, mode, path + ["smooth_mesh"])
            self.swap_mesh_faces = self.__class__.swap_mesh_faces(service, version, mode, path + ["swap_mesh_faces"])
            self.show_periodic_shadow_zones = self.__class__.show_periodic_shadow_zones(service, version, mode, path + ["show_periodic_shadow_zones"])
            self.translate = self.__class__.translate(service, version, mode, path + ["translate"])
            self.set_unit_system = self.__class__.set_unit_system(service, version, mode, path + ["set_unit_system"])
            self.units = self.__class__.units(service, version, mode, path + ["units"])
            super().__init__(service, version, mode, path)
        class adjacency(TUIMethod):
            """
            Views and renames face zones adjacent to selected cell  zones.
            """
        class check(TUIMethod):
            """
            Performs various mesh consistency checks and displays a report in the console that lists the domain extents, the volume statistics, the face area statistics, and any warnings, as well as details about the various checks and mesh failures (depending on the setting specified for mesh/check-verbosity).
            """
        class check_before_solve(TUIMethod):
            """
            The default value for mesh/check-before-solve is “no”. If mesh/check-before-solve is set to “yes”, a mesh check operation will be invoked prior to starting solver. If grid check fails, solver will be interrupted, and relevant information will be printed in the Fluent console.
            """
        class check_verbosity(TUIMethod):
            """
            Sets the level of details that will be added to the mesh check report generated by mesh/check. A value of 0 (the default) notes when checks are being performed, but does not list them individually. A value of 1 lists the individual checks as they are performed. A value of 2 enables the availability of additional mesh field variables, lists the individual checks as they are performed, and provides additional details (for example, the location of the problem, the affected cells).  The check-verbosity text command can also be used to set the level of detail displayed in the mesh quality report generated by mesh/quality. A value of 0 (the default) or 1 lists the minimum orthogonal quality and the maximum aspect ratio. A value of 2 adds information about the zones that contain the cells with the lowest quality, and additional metrics such as the maximum cell squish index and the minimum expansion ratio.
            """
        class enhanced_orthogonal_quality(TUIMethod):
            """
            Enables / disables an enhanced definition when calculating the orthogonal quality. When enabled, the orthogonal quality is defined using a variety quality measures, including: the orthogonality of a face relative to a vector between the face and cell centroids; a metric that detects poor cell shape at a local edge (such as twisting and/or concavity); and the variation of normals between the faces that can be constructed from the cell face. This enhanced definition is optimal for evaluating thin prism cells.
            """
        class mesh_info(TUIMethod):
            """
            Prints zone information size.
            """
        class memory_usage(TUIMethod):
            """
            Reports solver memory use.
            """
        class quality(TUIMethod):
            """
            Displays information about the quality of the mesh in the console, including the minimum orthogonal quality and the maximum aspect ratio. The level of detail displayed depends on the setting specified for mesh/check-verbosity.
            """
        class redistribute_boundary_layer(TUIMethod):
            """
            Redistributes the nodes in a boundary layer zone to achieve a desired growth rate after anisotropic adaption.
            """
        class replace(TUIMethod):
            """
            Replace mesh and interpolate data.
            """
        class rotate(TUIMethod):
            """
            Rotates the mesh.
            """
        class scale(TUIMethod):
            """
            Prompts for the scaling factors in each of the active Cartesian coordinate directions.
            """
        class size_info(TUIMethod):
            """
            Prints mesh size.
            """
        class smooth_mesh(TUIMethod):
            """
            Smooths the mesh using quality-based, Laplacian, or skewness methods.
            """
        class swap_mesh_faces(TUIMethod):
            """
            Swaps mesh faces.
            """
        class show_periodic_shadow_zones(TUIMethod):
            """
            Option to show periodic shadow zones in user interface.
            """
        class translate(TUIMethod):
            """
            Prompts for the translation offset in each of the active Cartesian coordinate directions.
            """
        class set_unit_system(TUIMethod):
            """
            To apply standard set of units to all quantities.
            """
        class units(TUIMethod):
            """
            Set unit conversion factors.
            """

        class adapt(TUIMenu):
            """
            Enters the mesh adaption menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
                self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
                self.manage_criteria = self.__class__.manage_criteria(service, version, mode, path + ["manage_criteria"])
                self.multi_layer_refinement = self.__class__.multi_layer_refinement(service, version, mode, path + ["multi_layer_refinement"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.refinement_criteria = self.__class__.refinement_criteria(service, version, mode, path + ["refinement_criteria"])
                self.coarsening_criteria = self.__class__.coarsening_criteria(service, version, mode, path + ["coarsening_criteria"])
                self.manual_refinement_criteria = self.__class__.manual_refinement_criteria(service, version, mode, path + ["manual_refinement_criteria"])
                self.manual_coarsening_criteria = self.__class__.manual_coarsening_criteria(service, version, mode, path + ["manual_coarsening_criteria"])
                self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                self.display_adaption_cells = self.__class__.display_adaption_cells(service, version, mode, path + ["display_adaption_cells"])
                self.list_adaption_cells = self.__class__.list_adaption_cells(service, version, mode, path + ["list_adaption_cells"])
                self.free_hierarchy = self.__class__.free_hierarchy(service, version, mode, path + ["free_hierarchy"])
                self.anisotropic_adaption = self.__class__.anisotropic_adaption(service, version, mode, path + ["anisotropic_adaption"])
                super().__init__(service, version, mode, path)
            class refinement_criteria(TUIMethod):
                """
                Set expression for refinement criterion.
                """
            class coarsening_criteria(TUIMethod):
                """
                Set expression for coarsening criterion.
                """
            class manual_refinement_criteria(TUIMethod):
                """
                Set expression for manual refinement criterion.
                """
            class manual_coarsening_criteria(TUIMethod):
                """
                Set expression for manual coarsening criterion.
                """
            class adapt_mesh(TUIMethod):
                """
                Performs manual adaption on the mesh according to the methods and settings that you specified.
                """
            class display_adaption_cells(TUIMethod):
                """
                Displays the cells that are marked for adaption in the graphics window.
                """
            class list_adaption_cells(TUIMethod):
                """
                Prints the number of cells marked for refinement, coarsening, and both to the console.
                """
            class free_hierarchy(TUIMethod):
                """
                Deletes the defined adaption hierarchy.
                """
            class anisotropic_adaption(TUIMethod):
                """
                Applies legacy anisotropic adaption to refine the boundary layers or registers. Cells will be split in the normal direction to the boundary face. Note that this text command is only available for 3D cases that have the adaption method set to hanging node.
                """

            class set(TUIMenu):
                """
                Enters the set menu.
                """
                def __init__(self, service, version, mode, path):
                    self.method = self.__class__.method(service, version, mode, path + ["method"])
                    self.cell_zones = self.__class__.cell_zones(service, version, mode, path + ["cell_zones"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.encapsulate_children = self.__class__.encapsulate_children(service, version, mode, path + ["encapsulate_children"])
                    self.maximum_refinement_level = self.__class__.maximum_refinement_level(service, version, mode, path + ["maximum_refinement_level"])
                    self.minimum_edge_length = self.__class__.minimum_edge_length(service, version, mode, path + ["minimum_edge_length"])
                    self.minimum_cell_quality = self.__class__.minimum_cell_quality(service, version, mode, path + ["minimum_cell_quality"])
                    self.maximum_cell_count = self.__class__.maximum_cell_count(service, version, mode, path + ["maximum_cell_count"])
                    self.additional_refinement_layers = self.__class__.additional_refinement_layers(service, version, mode, path + ["additional_refinement_layers"])
                    self.anisotropic_adaption = self.__class__.anisotropic_adaption(service, version, mode, path + ["anisotropic_adaption"])
                    self.anisotropic_boundary_zones = self.__class__.anisotropic_boundary_zones(service, version, mode, path + ["anisotropic_boundary_zones"])
                    self.anisotropic_split_ratio = self.__class__.anisotropic_split_ratio(service, version, mode, path + ["anisotropic_split_ratio"])
                    self.display_settings = self.__class__.display_settings(service, version, mode, path + ["display_settings"])
                    self.dynamic_adaption = self.__class__.dynamic_adaption(service, version, mode, path + ["dynamic_adaption"])
                    self.dynamic_adaption_frequency = self.__class__.dynamic_adaption_frequency(service, version, mode, path + ["dynamic_adaption_frequency"])
                    self.overset_adapt_dead_cells = self.__class__.overset_adapt_dead_cells(service, version, mode, path + ["overset_adapt_dead_cells"])
                    super().__init__(service, version, mode, path)
                class method(TUIMethod):
                    """
                    Sets the adaption method.
                    """
                class cell_zones(TUIMethod):
                    """
                    Sets cell zones to be used for marking adaption. An empty list specifies that all zones are considered for adaption.
                    """
                class verbosity(TUIMethod):
                    """
                    Allows you set how much information about the adaption is printed to the console.
                    """
                class encapsulate_children(TUIMethod):
                    """
                    Encapsulate all children of parent cells on the same partition.
                    """
                class maximum_refinement_level(TUIMethod):
                    """
                    Controls the number of levels of refinement used to split cells during the adaption.
                    """
                class minimum_edge_length(TUIMethod):
                    """
                    Sets an approximate limit to the edge length for cells that are considered for refinement. Even if a cell is marked for refinement, it will not be refined if (for 3D) its volume is less than the cube of this field or (for 2D) its area is less than the square of this field. The default value of zero places no limits on the size of cells that are refined.
                    """
                class minimum_cell_quality(TUIMethod):
                    """
                    Sets the minimum value allowed for the orthogonal quality of cells during adaption. If your solution diverges, you may find that using a higher minimum quality value resolves the issue. This text command is only available with the PUMA 3D adaption method.
                    """
                class maximum_cell_count(TUIMethod):
                    """
                    Sets an approximate limit to the total cell count of the mesh during adaption. Fluent uses this value to determine when to stop marking cells for refinement. A value of zero places no limits on the number of cells.
                    """
                class additional_refinement_layers(TUIMethod):
                    """
                    Allows you to specify additional refinement layers (this is an advanced control).
                    """
                class anisotropic_adaption(TUIMethod):
                    """
                    Enables / disables anisotropic adaption for prismatic cells as part of manual adaption. Note that this text command requires that the adaption method is set to PUMA.
                    """
                class anisotropic_boundary_zones(TUIMethod):
                    """
                    Allows you to select the boundary zones that specify directions for anisotropic refinement with the PUMA method.
                    """
                class anisotropic_split_ratio(TUIMethod):
                    """
                    Sets the split ratio for the cells as part of anisotropic refinement with the PUMA method.
                    """
                class display_settings(TUIMethod):
                    """
                    Sets the graphics display options for the refinement, coarsening, and common cells.
                    """
                class dynamic_adaption(TUIMethod):
                    """
                    Adapt the mesh during solution.
                    """
                class dynamic_adaption_frequency(TUIMethod):
                    """
                    Set frequency for dynamic adaption.
                    """
                class overset_adapt_dead_cells(TUIMethod):
                    """
                    Enables/disables the adaption of dead cells in overset meshes.
                    """

            class profile(TUIMenu):
                """
                Enters the profile menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables adaption profiling.
                    """
                class disable(TUIMethod):
                    """
                    Disables adaption profiling.
                    """
                class print(TUIMethod):
                    """
                    Prints adaption profiling results.
                    """
                class clear(TUIMethod):
                    """
                    Clears the adaption profiling counters.
                    """

            class cell_registers(TUIMenu):
                """
                Enters the cell registers menu.
                """
                def __init__(self, service, version, mode, path):
                    self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.apply_poor_mesh_numerics = self.__class__.apply_poor_mesh_numerics(service, version, mode, path + ["apply_poor_mesh_numerics"])
                    self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                    super().__init__(service, version, mode, path)
                class adapt(TUIMethod):
                    """
                    Adapt cell register objects.
                    """
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class apply_poor_mesh_numerics(TUIMethod):
                    """
                    Applies poor mesh numerics to the mesh of a cell register.
                    """
                class coarsen(TUIMethod):
                    """
                    Coarsen cell register objects.
                    """
                class display(TUIMethod):
                    """
                    Displays a cell register.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Deletes a cell register.
                    """
                class list(TUIMethod):
                    """
                    Lists all of the currently defined cell registers.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of a cell register.
                    """
                class refine(TUIMethod):
                    """
                    Refine cell register objects.
                    """

            class manage_criteria(TUIMenu):
                """
                Enters the manage criteria menu, which provides text commands for managing automatic adaption criteria.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Adds a new automatic adaption criterion.
                    """
                class edit(TUIMethod):
                    """
                    Edits an existing automatic adaption criterion.
                    """
                class delete(TUIMethod):
                    """
                    Deletes an existing automatic adaption criterion.
                    """
                class list(TUIMethod):
                    """
                    Lists all the existing automatic adaption criteria.
                    """
                class list_properties(TUIMethod):
                    """
                    Lists the properties of an existing automatic adaption criterion.
                    """

            class multi_layer_refinement(TUIMenu):
                """
                Enter the multiple boundary layer refinement menu.
                """
                def __init__(self, service, version, mode, path):
                    self.refine_mesh = self.__class__.refine_mesh(service, version, mode, path + ["refine_mesh"])
                    self.boundary_zones = self.__class__.boundary_zones(service, version, mode, path + ["boundary_zones"])
                    self.layer_count = self.__class__.layer_count(service, version, mode, path + ["layer_count"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    super().__init__(service, version, mode, path)
                class refine_mesh(TUIMethod):
                    """
                    Refine the mesh for multiple boundary layers.
                    """
                class boundary_zones(TUIMethod):
                    """
                    Specify boundary zones for refinement.
                    """
                class layer_count(TUIMethod):
                    """
                    Specify the layer count for refinement.
                    """
                class parameters(TUIMethod):
                    """
                    Specify parameters for multiple boundary layer refinement.
                    """

            class geometry(TUIMenu):
                """
                Enters the geometry menu. Note that this text command menu is not available unless the adaption method is set to hanging node.
                """
                def __init__(self, service, version, mode, path):
                    self.reconstruct_geometry = self.__class__.reconstruct_geometry(service, version, mode, path + ["reconstruct_geometry"])
                    self.set_geometry_controls = self.__class__.set_geometry_controls(service, version, mode, path + ["set_geometry_controls"])
                    super().__init__(service, version, mode, path)
                class reconstruct_geometry(TUIMethod):
                    """
                    Enables/disables geometry-based adaption.
                    """
                class set_geometry_controls(TUIMethod):
                    """
                    Sets geometry controls for wall zones.
                    """

        class modify_zones(TUIMenu):
            """
            Enters the zone modification menu. For a description of the items in this menu, see define/boundary-conditions/modify-zones.
            """
            def __init__(self, service, version, mode, path):
                self.activate_cell_zone = self.__class__.activate_cell_zone(service, version, mode, path + ["activate_cell_zone"])
                self.append_mesh = self.__class__.append_mesh(service, version, mode, path + ["append_mesh"])
                self.append_mesh_data = self.__class__.append_mesh_data(service, version, mode, path + ["append_mesh_data"])
                self.copy_move_cell_zone = self.__class__.copy_move_cell_zone(service, version, mode, path + ["copy_move_cell_zone"])
                self.create_all_shell_threads = self.__class__.create_all_shell_threads(service, version, mode, path + ["create_all_shell_threads"])
                self.deactivate_cell_zone = self.__class__.deactivate_cell_zone(service, version, mode, path + ["deactivate_cell_zone"])
                self.recreate_all_shells = self.__class__.recreate_all_shells(service, version, mode, path + ["recreate_all_shells"])
                self.delete_all_shells = self.__class__.delete_all_shells(service, version, mode, path + ["delete_all_shells"])
                self.delete_cell_zone = self.__class__.delete_cell_zone(service, version, mode, path + ["delete_cell_zone"])
                self.extrude_face_zone_delta = self.__class__.extrude_face_zone_delta(service, version, mode, path + ["extrude_face_zone_delta"])
                self.extrude_face_zone_para = self.__class__.extrude_face_zone_para(service, version, mode, path + ["extrude_face_zone_para"])
                self.fuse_face_zones = self.__class__.fuse_face_zones(service, version, mode, path + ["fuse_face_zones"])
                self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                self.create_periodic_interface = self.__class__.create_periodic_interface(service, version, mode, path + ["create_periodic_interface"])
                self.scale_zone = self.__class__.scale_zone(service, version, mode, path + ["scale_zone"])
                self.rotate_zone = self.__class__.rotate_zone(service, version, mode, path + ["rotate_zone"])
                self.translate_zone = self.__class__.translate_zone(service, version, mode, path + ["translate_zone"])
                self.matching_tolerance = self.__class__.matching_tolerance(service, version, mode, path + ["matching_tolerance"])
                self.merge_zones = self.__class__.merge_zones(service, version, mode, path + ["merge_zones"])
                self.mrf_to_sliding_mesh = self.__class__.mrf_to_sliding_mesh(service, version, mode, path + ["mrf_to_sliding_mesh"])
                self.convert_all_solid_mrf_to_solid_motion = self.__class__.convert_all_solid_mrf_to_solid_motion(service, version, mode, path + ["convert_all_solid_mrf_to_solid_motion"])
                self.orient_face_zone = self.__class__.orient_face_zone(service, version, mode, path + ["orient_face_zone"])
                self.replace_zone = self.__class__.replace_zone(service, version, mode, path + ["replace_zone"])
                self.sep_cell_zone_mark = self.__class__.sep_cell_zone_mark(service, version, mode, path + ["sep_cell_zone_mark"])
                self.sep_cell_zone_region = self.__class__.sep_cell_zone_region(service, version, mode, path + ["sep_cell_zone_region"])
                self.sep_face_zone_angle = self.__class__.sep_face_zone_angle(service, version, mode, path + ["sep_face_zone_angle"])
                self.sep_face_zone_face = self.__class__.sep_face_zone_face(service, version, mode, path + ["sep_face_zone_face"])
                self.sep_face_zone_mark = self.__class__.sep_face_zone_mark(service, version, mode, path + ["sep_face_zone_mark"])
                self.sep_face_zone_region = self.__class__.sep_face_zone_region(service, version, mode, path + ["sep_face_zone_region"])
                self.slit_periodic = self.__class__.slit_periodic(service, version, mode, path + ["slit_periodic"])
                self.slit_face_zone = self.__class__.slit_face_zone(service, version, mode, path + ["slit_face_zone"])
                self.slit_interior_between_diff_solids = self.__class__.slit_interior_between_diff_solids(service, version, mode, path + ["slit_interior_between_diff_solids"])
                self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                self.copy_mrf_to_mesh_motion = self.__class__.copy_mrf_to_mesh_motion(service, version, mode, path + ["copy_mrf_to_mesh_motion"])
                self.copy_mesh_to_mrf_motion = self.__class__.copy_mesh_to_mrf_motion(service, version, mode, path + ["copy_mesh_to_mrf_motion"])
                self.change_zone_state = self.__class__.change_zone_state(service, version, mode, path + ["change_zone_state"])
                self.change_zone_phase = self.__class__.change_zone_phase(service, version, mode, path + ["change_zone_phase"])
                super().__init__(service, version, mode, path)
            class activate_cell_zone(TUIMethod):
                """
                Activate a cell thread.
                """
            class append_mesh(TUIMethod):
                """
                Append new mesh.
                """
            class append_mesh_data(TUIMethod):
                """
                Append new mesh with data.
                """
            class copy_move_cell_zone(TUIMethod):
                """
                Copy and translate or rotate a cell zone.
                """
            class create_all_shell_threads(TUIMethod):
                """
                Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                """
            class deactivate_cell_zone(TUIMethod):
                """
                Deactivate cell thread.
                """
            class recreate_all_shells(TUIMethod):
                """
                Create shell on all the walls where which were deleted using the command delete-all-shells.
                """
            class delete_all_shells(TUIMethod):
                """
                Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                """
            class delete_cell_zone(TUIMethod):
                """
                Delete a cell thread.
                """
            class extrude_face_zone_delta(TUIMethod):
                """
                Extrude a face thread a specified distance based on a list of deltas.
                """
            class extrude_face_zone_para(TUIMethod):
                """
                Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                """
            class fuse_face_zones(TUIMethod):
                """
                Attempt to fuse zones by removing duplicate faces and nodes.
                """
            class list_zones(TUIMethod):
                """
                List zone IDs, types, kinds, and names.
                """
            class make_periodic(TUIMethod):
                """
                Attempt to establish periodic/shadow face zone connectivity.
                """
            class create_periodic_interface(TUIMethod):
                """
                Create a conformal or non-conformal periodic interface.
                """
            class scale_zone(TUIMethod):
                """
                Scale nodal coordinates of input cell zones.
                """
            class rotate_zone(TUIMethod):
                """
                Rotate nodal coordinates of input cell zones.
                """
            class translate_zone(TUIMethod):
                """
                Translate nodal coordinates of input cell zones.
                """
            class matching_tolerance(TUIMethod):
                """
                Set the normalized tolerance used for finding coincident nodes.
                """
            class merge_zones(TUIMethod):
                """
                Merge zones of the same type and condition into one.
                """
            class mrf_to_sliding_mesh(TUIMethod):
                """
                Change motion specification from MRF to moving mesh.
                """
            class convert_all_solid_mrf_to_solid_motion(TUIMethod):
                """
                Change all solid zones motion specification from MRF to solid motion.
                """
            class orient_face_zone(TUIMethod):
                """
                Orient the face zone.
                """
            class replace_zone(TUIMethod):
                """
                Replace a cell zone.
                """
            class sep_cell_zone_mark(TUIMethod):
                """
                Separate a cell zone based on cell marking.
                """
            class sep_cell_zone_region(TUIMethod):
                """
                Separate a cell zone based on contiguous regions.
                """
            class sep_face_zone_angle(TUIMethod):
                """
                Separate a face zone based on significant angle.
                """
            class sep_face_zone_face(TUIMethod):
                """
                Separate each face in a zone into unique zone.
                """
            class sep_face_zone_mark(TUIMethod):
                """
                Separate a face zone based on cell marking.
                """
            class sep_face_zone_region(TUIMethod):
                """
                Separate a face zone based on contiguous regions.
                """
            class slit_periodic(TUIMethod):
                """
                Slit a periodic zone into two symmetry zones.
                """
            class slit_face_zone(TUIMethod):
                """
                Slit a two-sided wall into two connected wall zones.
                """
            class slit_interior_between_diff_solids(TUIMethod):
                """
                Slit interior created between different solids into coupled walls.
                """
            class zone_name(TUIMethod):
                """
                Give a zone a new name.
                """
            class zone_type(TUIMethod):
                """
                Set a zone's type.
                """
            class copy_mrf_to_mesh_motion(TUIMethod):
                """
                Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                """
            class copy_mesh_to_mrf_motion(TUIMethod):
                """
                Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                """
            class change_zone_state(TUIMethod):
                """
                Change the realgas material state for a zone.
                """
            class change_zone_phase(TUIMethod):
                """
                Change the realgas phase for a zone.
                """

        class polyhedra(TUIMenu):
            """
            Enters the polyhedra menu.
            """
            def __init__(self, service, version, mode, path):
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.convert_domain = self.__class__.convert_domain(service, version, mode, path + ["convert_domain"])
                self.convert_hanging_nodes = self.__class__.convert_hanging_nodes(service, version, mode, path + ["convert_hanging_nodes"])
                self.convert_hanging_nodes_zones = self.__class__.convert_hanging_nodes_zones(service, version, mode, path + ["convert_hanging_nodes_zones"])
                self.convert_skewed_cells = self.__class__.convert_skewed_cells(service, version, mode, path + ["convert_skewed_cells"])
                super().__init__(service, version, mode, path)
            class convert_domain(TUIMethod):
                """
                Converts the entire domain to polyhedra cells.
                """
            class convert_hanging_nodes(TUIMethod):
                """
                Converts cells with hanging nodes/edges to polyhedra.
                """
            class convert_hanging_nodes_zones(TUIMethod):
                """
                Convert selected cell zones with hanging nodes and faces to polyhedra.
                The selected cell zones cannot be connected to other zones.
                """
            class convert_skewed_cells(TUIMethod):
                """
                Converts skewed cells to polyhedra.
                """

            class options(TUIMenu):
                """
                Enters the polyhedra options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.migrate_and_reorder = self.__class__.migrate_and_reorder(service, version, mode, path + ["migrate_and_reorder"])
                    self.preserve_boundary_layer = self.__class__.preserve_boundary_layer(service, version, mode, path + ["preserve_boundary_layer"])
                    self.preserve_interior_zones = self.__class__.preserve_interior_zones(service, version, mode, path + ["preserve_interior_zones"])
                    super().__init__(service, version, mode, path)
                class migrate_and_reorder(TUIMethod):
                    """
                    Enables / disables the migration of newly created partitions to the compute-nodes and the reordering of the domain as part of polyhedra conversion. This is disabled by default, because it requires significant additional memory; when disabled, it is recommended that you save the case file after conversion, read it in a new Fluent session (so that the new / stored partitions become active), and then manually reorder using the mesh/reorder/reorder-domain text command. If you want to run the calculation in the current Fluent session you can enable the migrate-and-reorder? text command prior to conversion, but you must ensure that no more than half of the available memory of your system is currently used.
                    """
                class preserve_boundary_layer(TUIMethod):
                    """
                    Specifies whether boundary layer cells will be preserved when the domain is converted to polyhedra. When the value is set to 0 (default) ANSYS Fluent checks for high aspect ratio cells at the boundary layer and if any are found, Fluent asks if you want to preserve the boundary layer. When the value is set to 1, the boundary layer cells are never preserved; when it is set to 2, the boundary layer cells are always preserved (regardless of the aspect ratio of the boundary layer cells).
                    """
                class preserve_interior_zones(TUIMethod):
                    """
                    Enables the preservation of surfaces (that is, manifold zones of type interior) during the conversion of the domain to polyhedra. Note that only those zones with a name that includes the string you specify will be preserved.
                    """

        class reorder(TUIMenu):
            """
            Reorders domain menu.
            """
            def __init__(self, service, version, mode, path):
                self.band_width = self.__class__.band_width(service, version, mode, path + ["band_width"])
                self.reorder_domain = self.__class__.reorder_domain(service, version, mode, path + ["reorder_domain"])
                self.reorder_zones = self.__class__.reorder_zones(service, version, mode, path + ["reorder_zones"])
                super().__init__(service, version, mode, path)
            class band_width(TUIMethod):
                """
                Prints cell bandwidth.
                """
            class reorder_domain(TUIMethod):
                """
                Reorders cells and faces using the reverse Cuthill-McKee algorithm. Note that you must save a new case file (and a data file, if data exists) after reordering with this text command, as well as recreate any ray files and/or surface cluster information.
                """
            class reorder_zones(TUIMethod):
                """
                Reorders zones by partition, type, and ID.
                """

        class repair_improve(TUIMenu):
            """
            Enter the repair and improve quality menu.
            """
            def __init__(self, service, version, mode, path):
                self.report_poor_elements = self.__class__.report_poor_elements(service, version, mode, path + ["report_poor_elements"])
                self.improve_quality = self.__class__.improve_quality(service, version, mode, path + ["improve_quality"])
                self.repair = self.__class__.repair(service, version, mode, path + ["repair"])
                self.repair_face_handedness = self.__class__.repair_face_handedness(service, version, mode, path + ["repair_face_handedness"])
                self.repair_face_node_order = self.__class__.repair_face_node_order(service, version, mode, path + ["repair_face_node_order"])
                self.repair_periodic = self.__class__.repair_periodic(service, version, mode, path + ["repair_periodic"])
                self.repair_wall_distance = self.__class__.repair_wall_distance(service, version, mode, path + ["repair_wall_distance"])
                self.allow_repair_at_boundaries = self.__class__.allow_repair_at_boundaries(service, version, mode, path + ["allow_repair_at_boundaries"])
                self.include_local_polyhedra_conversion_in_repair = self.__class__.include_local_polyhedra_conversion_in_repair(service, version, mode, path + ["include_local_polyhedra_conversion_in_repair"])
                super().__init__(service, version, mode, path)
            class report_poor_elements(TUIMethod):
                """
                Reports invalid and poor quality elements.
                """
            class improve_quality(TUIMethod):
                """
                Improves poor quality cells in the mesh, if possible.
                """
            class repair(TUIMethod):
                """
                Repairs mesh problems identified by the mesh check, if possible. The repairs include fixing cells that have the wrong node order, the wrong face handedness, faces that are small or nonexistent, or very poor quality. Only interior nodes are repositioned by default; boundary nodes may be repositioned if the  mesh/repair-improve/allow-repair-at-boundaries text command is enabled. Note that highly skewed cells may be converted into polyhedra, depending on whether the  mesh/repair-improve/include-local-polyhedra-conversion-in-repair text command is enabled.
                """
            class repair_face_handedness(TUIMethod):
                """
                Modifies cell centroids to repair meshes that contain left-handed faces without face node order problems.
                """
            class repair_face_node_order(TUIMethod):
                """
                Modifies face nodes to repair faces with improper face node order and, therefore, eliminates any resulting left-handed faces.
                """
            class repair_periodic(TUIMethod):
                """
                Modifies the mesh to enforce a rotational angle or translational distance for periodic boundaries. For translationally periodic boundaries, the command computes an average translation distance and adjusts the node coordinates on the shadow face zone to match this distance. For rotationally periodic boundaries, the command prompts for an angle and adjusts the node coordinates on the shadow face zone using this angle and the defined rotational axis for the cell zone.
                """
            class repair_wall_distance(TUIMethod):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
            class allow_repair_at_boundaries(TUIMethod):
                """
                Allows the adjustment of the positions of nodes on boundaries as part of the mesh repairs performed by the mesh/repair-improve/repair text command.
                """
            class include_local_polyhedra_conversion_in_repair(TUIMethod):
                """
                Enables/disables the local conversion of degenerate cells into polyhedra based on skewness criteria as part of the mesh repairs performed by the  mesh/repair-improve/repair text command.
                """

        class surface_mesh(TUIMenu):
            """
            Enters the Surface Mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.read = self.__class__.read(service, version, mode, path + ["read"])
                super().__init__(service, version, mode, path)
            class delete(TUIMethod):
                """
                Deletes surface mesh.
                """
            class display(TUIMethod):
                """
                Displays surface meshes.
                """
            class read(TUIMethod):
                """
                Reads surface meshes.
                """

    class parameters__and__customization(TUIMenu):
        """
        Enter Parameters and custom menu.
        """
        def __init__(self, service, version, mode, path):
            self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
            self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
            super().__init__(service, version, mode, path)

        class parameters(TUIMenu):
            """
            Enter the parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                self.list_parameters = self.__class__.list_parameters(service, version, mode, path + ["list_parameters"])
                self.enable_in_TUI = self.__class__.enable_in_TUI(service, version, mode, path + ["enable_in_TUI"])
                super().__init__(service, version, mode, path)
            class enable_in_TUI(TUIMethod):
                """
                Enable/disable parameters in the text user interface.
                """

            class input_parameters(TUIMenu):
                """
                Enter the input-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.advance = self.__class__.advance(service, version, mode, path + ["advance"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    super().__init__(service, version, mode, path)
                class edit(TUIMethod):
                    """
                    Edit an input parameter.
                    """
                class delete(TUIMethod):
                    """
                    Delete an input parameter.
                    """

                class advance(TUIMenu):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, service, version, mode, path):
                        self.use_in = self.__class__.use_in(service, version, mode, path + ["use_in"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        super().__init__(service, version, mode, path)
                    class use_in(TUIMethod):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """
                    class list(TUIMethod):
                        """
                        List of custom-input-parameters.
                        """
                    class delete(TUIMethod):
                        """
                        Delete selected custom-input-parameters.
                        """

            class output_parameters(TUIMenu):
                """
                Enter the output-parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.print_to_console = self.__class__.print_to_console(service, version, mode, path + ["print_to_console"])
                    self.print_all_to_console = self.__class__.print_all_to_console(service, version, mode, path + ["print_all_to_console"])
                    self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                    self.write_all_to_file = self.__class__.write_all_to_file(service, version, mode, path + ["write_all_to_file"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create an output parameter.
                    """
                class edit(TUIMethod):
                    """
                    Edit an output parameter.
                    """
                class rename(TUIMethod):
                    """
                    Rename an output parameter.
                    """
                class delete(TUIMethod):
                    """
                    Delete an output parameter.
                    """
                class print_to_console(TUIMethod):
                    """
                    Print parameter value to console.
                    """
                class print_all_to_console(TUIMethod):
                    """
                    Print all parameter values to console.
                    """
                class write_to_file(TUIMethod):
                    """
                    Write parameter value to file.
                    """
                class write_all_to_file(TUIMethod):
                    """
                    Write all parameter values to file.
                    """

            class list_parameters(TUIMenu):
                """
                Enter list-param menu.
                """
                def __init__(self, service, version, mode, path):
                    self.input_parameters = self.__class__.input_parameters(service, version, mode, path + ["input_parameters"])
                    self.output_parameters = self.__class__.output_parameters(service, version, mode, path + ["output_parameters"])
                    super().__init__(service, version, mode, path)
                class input_parameters(TUIMethod):
                    """
                    List all input parameters.
                    """
                class output_parameters(TUIMethod):
                    """
                    List all output parameters.
                    """

        class user_defined(TUIMenu):
            """
            Enter the user-defined functions and scalars menu.
            """
            def __init__(self, service, version, mode, path):
                self.real_gas_models = self.__class__.real_gas_models(service, version, mode, path + ["real_gas_models"])
                self.auto_compile_compiled_udfs = self.__class__.auto_compile_compiled_udfs(service, version, mode, path + ["auto_compile_compiled_udfs"])
                self.compiled_functions = self.__class__.compiled_functions(service, version, mode, path + ["compiled_functions"])
                self.use_built_in_compiler = self.__class__.use_built_in_compiler(service, version, mode, path + ["use_built_in_compiler"])
                self.interpreted_functions = self.__class__.interpreted_functions(service, version, mode, path + ["interpreted_functions"])
                self.function_hooks = self.__class__.function_hooks(service, version, mode, path + ["function_hooks"])
                self.execute_on_demand = self.__class__.execute_on_demand(service, version, mode, path + ["execute_on_demand"])
                self.user_defined_memory = self.__class__.user_defined_memory(service, version, mode, path + ["user_defined_memory"])
                self.user_defined_node_memory = self.__class__.user_defined_node_memory(service, version, mode, path + ["user_defined_node_memory"])
                self.use_contributed_cpp = self.__class__.use_contributed_cpp(service, version, mode, path + ["use_contributed_cpp"])
                self.fan_model = self.__class__.fan_model(service, version, mode, path + ["fan_model"])
                self.one_D_coupling = self.__class__.one_D_coupling(service, version, mode, path + ["one_D_coupling"])
                self.user_defined_scalars = self.__class__.user_defined_scalars(service, version, mode, path + ["user_defined_scalars"])
                self.enable_udf_on_gpu = self.__class__.enable_udf_on_gpu(service, version, mode, path + ["enable_udf_on_gpu"])
                self.compile_customized_addon_module = self.__class__.compile_customized_addon_module(service, version, mode, path + ["compile_customized_addon_module"])
                super().__init__(service, version, mode, path)
            class auto_compile_compiled_udfs(TUIMethod):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
            class compiled_functions(TUIMethod):
                """
                Open user-defined function library.
                """
            class use_built_in_compiler(TUIMethod):
                """
                Enable/disable the use of the built-in compiler.
                """
            class interpreted_functions(TUIMethod):
                """
                Load interpreted user-defined functions.
                """
            class function_hooks(TUIMethod):
                """
                Hook up user-defined functions.
                """
            class execute_on_demand(TUIMethod):
                """
                Execute UDFs on demand.
                """
            class user_defined_memory(TUIMethod):
                """
                Allocate user-defined memory.
                """
            class user_defined_node_memory(TUIMethod):
                """
                Allocate user-defined node memory.
                """
            class use_contributed_cpp(TUIMethod):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
            class fan_model(TUIMethod):
                """
                Configure user-defined fan model.
                """
            class one_D_coupling(TUIMethod):
                """
                Load 1D library.
                """
            class user_defined_scalars(TUIMethod):
                """
                Define user-defined scalars.
                """
            class enable_udf_on_gpu(TUIMethod):
                """
                Compile UDFs with OpenCL support.
                """
            class compile_customized_addon_module(TUIMethod):
                """
                Compile customized addon module?.
                """

            class real_gas_models(TUIMenu):
                """
                Enable/configure real gas model.
                """
                def __init__(self, service, version, mode, path):
                    self.nist_real_gas_model = self.__class__.nist_real_gas_model(service, version, mode, path + ["nist_real_gas_model"])
                    self.nist_multispecies_real_gas_model = self.__class__.nist_multispecies_real_gas_model(service, version, mode, path + ["nist_multispecies_real_gas_model"])
                    self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                    self.nist_settings = self.__class__.nist_settings(service, version, mode, path + ["nist_settings"])
                    self.user_defined_real_gas_model = self.__class__.user_defined_real_gas_model(service, version, mode, path + ["user_defined_real_gas_model"])
                    self.user_defined_multispecies_real_gas_model = self.__class__.user_defined_multispecies_real_gas_model(service, version, mode, path + ["user_defined_multispecies_real_gas_model"])
                    super().__init__(service, version, mode, path)
                class nist_real_gas_model(TUIMethod):
                    """
                    Load NIST real gas library.
                    """
                class nist_multispecies_real_gas_model(TUIMethod):
                    """
                    Load NIST real gas library.
                    """
                class set_state(TUIMethod):
                    """
                    Select state for NIST real gas model.
                    """
                class nist_settings(TUIMethod):
                    """
                    Select refprop library.
                    """
                class user_defined_real_gas_model(TUIMethod):
                    """
                    Load user-defined real gas library.
                    """
                class user_defined_multispecies_real_gas_model(TUIMethod):
                    """
                    Load user-defined multispecies real gas library.
                    """

    class parallel(TUIMenu):
        """
        Enter the parallel processing menu.
        """
        def __init__(self, service, version, mode, path):
            self.network = self.__class__.network(service, version, mode, path + ["network"])
            self.partition = self.__class__.partition(service, version, mode, path + ["partition"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.load_balance = self.__class__.load_balance(service, version, mode, path + ["load_balance"])
            self.gpgpu = self.__class__.gpgpu(service, version, mode, path + ["gpgpu"])
            self.timer = self.__class__.timer(service, version, mode, path + ["timer"])
            self.multidomain = self.__class__.multidomain(service, version, mode, path + ["multidomain"])
            self.check = self.__class__.check(service, version, mode, path + ["check"])
            self.check_verbosity = self.__class__.check_verbosity(service, version, mode, path + ["check_verbosity"])
            self.show_connectivity = self.__class__.show_connectivity(service, version, mode, path + ["show_connectivity"])
            self.latency = self.__class__.latency(service, version, mode, path + ["latency"])
            self.bandwidth = self.__class__.bandwidth(service, version, mode, path + ["bandwidth"])
            self.thread_number_control = self.__class__.thread_number_control(service, version, mode, path + ["thread_number_control"])
            super().__init__(service, version, mode, path)
        class check(TUIMethod):
            """
            Performs checks of various factors that affect parallel performance.
            """
        class check_verbosity(TUIMethod):
            """
            Sets verbosity output of the parallel check. Higher verbosity corresponds to more detailed information.
            """
        class show_connectivity(TUIMethod):
            """
            Prints the network connectivity for the selected compute node.
            """
        class latency(TUIMethod):
            """
            Shows network latency.
            """
        class bandwidth(TUIMethod):
            """
            Shows network bandwidth.
            """
        class thread_number_control(TUIMethod):
            """
            Thread number control.
            """

        class network(TUIMenu):
            """
            Enter the network configuration menu.
            """
            def __init__(self, service, version, mode, path):
                self.kill_all_nodes = self.__class__.kill_all_nodes(service, version, mode, path + ["kill_all_nodes"])
                self.kill_node = self.__class__.kill_node(service, version, mode, path + ["kill_node"])
                self.load_hosts = self.__class__.load_hosts(service, version, mode, path + ["load_hosts"])
                self.path = self.__class__.path(service, version, mode, path + ["path"])
                self.save_hosts = self.__class__.save_hosts(service, version, mode, path + ["save_hosts"])
                self.spawn_node = self.__class__.spawn_node(service, version, mode, path + ["spawn_node"])
                super().__init__(service, version, mode, path)
            class kill_all_nodes(TUIMethod):
                """
                Delete all compute nodes from virtual machine.
                """
            class kill_node(TUIMethod):
                """
                Kill a compute node process specified by ID.
                """
            class load_hosts(TUIMethod):
                """
                Read a hosts file.
                """
            class path(TUIMethod):
                """
                Set the Fluent shell script path.
                """
            class save_hosts(TUIMethod):
                """
                Write a hosts file.
                """
            class spawn_node(TUIMethod):
                """
                Spawn a compute node process on a specified machine.
                """

        class partition(TUIMenu):
            """
            Enters the partition domain menu.
            """
            def __init__(self, service, version, mode, path):
                self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.combine_partition = self.__class__.combine_partition(service, version, mode, path + ["combine_partition"])
                self.merge_clusters = self.__class__.merge_clusters(service, version, mode, path + ["merge_clusters"])
                self.method = self.__class__.method(service, version, mode, path + ["method"])
                self.print_partitions = self.__class__.print_partitions(service, version, mode, path + ["print_partitions"])
                self.print_active_partitions = self.__class__.print_active_partitions(service, version, mode, path + ["print_active_partitions"])
                self.print_stored_partitions = self.__class__.print_stored_partitions(service, version, mode, path + ["print_stored_partitions"])
                self.reorder_partitions = self.__class__.reorder_partitions(service, version, mode, path + ["reorder_partitions"])
                self.reorder_partitions_to_architecture = self.__class__.reorder_partitions_to_architecture(service, version, mode, path + ["reorder_partitions_to_architecture"])
                self.smooth_partition = self.__class__.smooth_partition(service, version, mode, path + ["smooth_partition"])
                self.use_stored_partitions = self.__class__.use_stored_partitions(service, version, mode, path + ["use_stored_partitions"])
                super().__init__(service, version, mode, path)
            class combine_partition(TUIMethod):
                """
                Merges every N partitions.
                """
            class merge_clusters(TUIMethod):
                """
                Calls the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters. (An orphan cluster is a group of connected cells such that each member has at least one face that is part of an interface boundary.).
                """
            class method(TUIMethod):
                """
                Sets the partition method.
                """
            class print_partitions(TUIMethod):
                """
                Print partition information.
                """
            class print_active_partitions(TUIMethod):
                """
                Prints active partition information (parallel solver).
                """
            class print_stored_partitions(TUIMethod):
                """
                Prints stored partition information (parallel solver).
                """
            class reorder_partitions(TUIMethod):
                """
                Reorders partitions.
                """
            class reorder_partitions_to_architecture(TUIMethod):
                """
                Reorders partitions to architecture.
                """
            class smooth_partition(TUIMethod):
                """
                Calls the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                """
            class use_stored_partitions(TUIMethod):
                """
                Uses this partitioning.
                """

            class automatic(TUIMenu):
                """
                Enter the menu to set auto partition parameters.
                """
                def __init__(self, service, version, mode, path):
                    self.across_zones = self.__class__.across_zones(service, version, mode, path + ["across_zones"])
                    self.method = self.__class__.method(service, version, mode, path + ["method"])
                    self.load_vector = self.__class__.load_vector(service, version, mode, path + ["load_vector"])
                    self.pre_test = self.__class__.pre_test(service, version, mode, path + ["pre_test"])
                    self.use_case_file_method = self.__class__.use_case_file_method(service, version, mode, path + ["use_case_file_method"])
                    super().__init__(service, version, mode, path)
                class across_zones(TUIMethod):
                    """
                    Enable auto partitioning by zone or by domain.
                    """
                class method(TUIMethod):
                    """
                    Set the method for auto partitioning the domain.
                    """
                class load_vector(TUIMethod):
                    """
                    Set auto the partition load vector.
                    """
                class pre_test(TUIMethod):
                    """
                    Set auto partition pre-testing optimization.
                    """
                class use_case_file_method(TUIMethod):
                    """
                    Enable the use-case-file method for auto partitioning.
                    """

            class set(TUIMenu):
                """
                Enters the set partition parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.across_zones = self.__class__.across_zones(service, version, mode, path + ["across_zones"])
                    self.all_off = self.__class__.all_off(service, version, mode, path + ["all_off"])
                    self.all_on = self.__class__.all_on(service, version, mode, path + ["all_on"])
                    self.cell_function = self.__class__.cell_function(service, version, mode, path + ["cell_function"])
                    self.load_distribution = self.__class__.load_distribution(service, version, mode, path + ["load_distribution"])
                    self.merge = self.__class__.merge(service, version, mode, path + ["merge"])
                    self.origin = self.__class__.origin(service, version, mode, path + ["origin"])
                    self.pre_test = self.__class__.pre_test(service, version, mode, path + ["pre_test"])
                    self.smooth = self.__class__.smooth(service, version, mode, path + ["smooth"])
                    self.laplace_smoothing = self.__class__.laplace_smoothing(service, version, mode, path + ["laplace_smoothing"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.nfaces_as_weights = self.__class__.nfaces_as_weights(service, version, mode, path + ["nfaces_as_weights"])
                    self.face_area_as_weights = self.__class__.face_area_as_weights(service, version, mode, path + ["face_area_as_weights"])
                    self.stretched_mesh_enhancement = self.__class__.stretched_mesh_enhancement(service, version, mode, path + ["stretched_mesh_enhancement"])
                    self.layering = self.__class__.layering(service, version, mode, path + ["layering"])
                    self.solid_thread_weight = self.__class__.solid_thread_weight(service, version, mode, path + ["solid_thread_weight"])
                    self.particle_weight = self.__class__.particle_weight(service, version, mode, path + ["particle_weight"])
                    self.vof_free_surface_weight = self.__class__.vof_free_surface_weight(service, version, mode, path + ["vof_free_surface_weight"])
                    self.isat_weight = self.__class__.isat_weight(service, version, mode, path + ["isat_weight"])
                    self.model_weighted_partition = self.__class__.model_weighted_partition(service, version, mode, path + ["model_weighted_partition"])
                    self.fluid_solid_rebalance_after_read_case = self.__class__.fluid_solid_rebalance_after_read_case(service, version, mode, path + ["fluid_solid_rebalance_after_read_case"])
                    self.dpm_load_balancing = self.__class__.dpm_load_balancing(service, version, mode, path + ["dpm_load_balancing"])
                    super().__init__(service, version, mode, path)
                class across_zones(TUIMethod):
                    """
                    Allows partitions to cross zone boundaries (the default). If turned off, it will restrict partitioning to within each cell zone. This is recommended only when cells in different zones require significantly different amounts of computation during the solution phase; for example, if the domain contains both solid and fluid zones.
                    """
                class all_off(TUIMethod):
                    """
                    Disables all optimizations.
                    """
                class all_on(TUIMethod):
                    """
                    Enables all optimizations.
                    """
                class cell_function(TUIMethod):
                    """
                    Sets cell function.
                    """
                class load_distribution(TUIMethod):
                    """
                    Sets the number of cells desired for each partition. This is useful, for example, when computing on multiple machines with significantly different performance characteristics. If left unset, each partition will contain an approximately equal number of cells. Normalized relative values may be used for the entries.
                    """
                class merge(TUIMethod):
                    """
                    Toggles the optimizer that attempts to decrease the number of interfaces by eliminating orphan cell clusters.
                    """
                class origin(TUIMethod):
                    """
                    Sets the , , and  coordinate of the origin used by those partitioning functions that require a radial distance. By default, the origin is set to (0, 0, 0).
                    """
                class pre_test(TUIMethod):
                    """
                    Enables the operation that determines the best coordinate-splitting direction.
                    """
                class smooth(TUIMethod):
                    """
                    Toggles the optimizer that attempts to minimize the number of interfaces by modifying the partition boundaries to reduce surface area.
                    """
                class laplace_smoothing(TUIMethod):
                    """
                    Laplace smoothing for mesh with stretched cells.
                    """
                class verbosity(TUIMethod):
                    """
                    Controls the amount of information that is printed out during partitioning. If set to 1 (the default), a text character. is displayed during each bisection, and partition statistics are displayed once the partitioning completes. If set to 2, additional information about the bisection operation is displayed during each bisection. If set to 0, partition statistics and information during each bisection are not displayed.
                    """
                class nfaces_as_weights(TUIMethod):
                    """
                    Uses number of faces as weights.
                    """
                class face_area_as_weights(TUIMethod):
                    """
                    Uses face area as connection weights.
                    """
                class stretched_mesh_enhancement(TUIMethod):
                    """
                    Enhancement for mesh with stretched cells.
                    """
                class layering(TUIMethod):
                    """
                    Use layering for partitioning.
                    """
                class solid_thread_weight(TUIMethod):
                    """
                    Uses solid thread weights.
                    """
                class particle_weight(TUIMethod):
                    """
                    Sets DPM particle weight.
                    """
                class vof_free_surface_weight(TUIMethod):
                    """
                    Sets VOF free surface weight.
                    """
                class isat_weight(TUIMethod):
                    """
                    Sets ISAT weight.
                    """
                class model_weighted_partition(TUIMethod):
                    """
                    Enables / disables model-weighted partitioning. This option works with the METIS partitioning method, and specifies that Fluent automatically calculates the weighting based on the cell count and the models and attributes specified as weights (using the parallel/partition/set/isat-weight text command, for example).
                    """
                class fluid_solid_rebalance_after_read_case(TUIMethod):
                    """
                    Use optimal repartitioning after reading case file with significant solid and fluid zones.
                    """
                class dpm_load_balancing(TUIMethod):
                    """
                    Enables / disables dynamic load balancing for discrete phase model cases that use a second domain for DPM particle tracking (that is, cases for which you have enabled the define/models/dpm/parallel/hybrid-2domain? text command).
                    """

        class set(TUIMenu):
            """
            Enters the set parallel parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.partition_mask = self.__class__.partition_mask(service, version, mode, path + ["partition_mask"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                self.time_out = self.__class__.time_out(service, version, mode, path + ["time_out"])
                self.fast_i = self.__class__.fast_i(service, version, mode, path + ["fast_i"])
                super().__init__(service, version, mode, path)
            class partition_mask(TUIMethod):
                """
                Sets partition mask.
                """
            class verbosity(TUIMethod):
                """
                Sets the parallel verbosity.
                """
            class time_out(TUIMethod):
                """
                Sets spawn time-out in seconds.
                """
            class fast_i(TUIMethod):
                """
                Use fast I/O option.
                """

        class load_balance(TUIMenu):
            """
            Enters the load balancing parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.physical_models = self.__class__.physical_models(service, version, mode, path + ["physical_models"])
                self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
                self.mesh_adaption = self.__class__.mesh_adaption(service, version, mode, path + ["mesh_adaption"])
                super().__init__(service, version, mode, path)
            class physical_models(TUIMethod):
                """
                Uses physical-models load balancing?.
                """
            class dynamic_mesh(TUIMethod):
                """
                Uses load balancing for dynamic mesh?.
                """
            class mesh_adaption(TUIMethod):
                """
                Uses load balancing for mesh adaption?.
                """

        class gpgpu(TUIMenu):
            """
            Enters the GPGPU menu.
            """
            def __init__(self, service, version, mode, path):
                self.show = self.__class__.show(service, version, mode, path + ["show"])
                self.select = self.__class__.select(service, version, mode, path + ["select"])
                super().__init__(service, version, mode, path)
            class show(TUIMethod):
                """
                Lists the available GPGPUs. GPGPUs selected for use are indicated by the presence of an asterisk (\*).
                """
            class select(TUIMethod):
                """
                Selects which GPGPUs to use for AMG acceleration.
                """

        class timer(TUIMenu):
            """
            Enters the timer menu.
            """
            def __init__(self, service, version, mode, path):
                self.usage = self.__class__.usage(service, version, mode, path + ["usage"])
                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                super().__init__(service, version, mode, path)
            class usage(TUIMethod):
                """
                Prints performance statistics in the console window.
                """
            class reset(TUIMethod):
                """
                Adjusts domain timers.
                """

        class multidomain(TUIMenu):
            """
            Enters the multidomain architecture menu.
            """
            def __init__(self, service, version, mode, path):
                self.conjugate_heat_transfer = self.__class__.conjugate_heat_transfer(service, version, mode, path + ["conjugate_heat_transfer"])
                self.solve = self.__class__.solve(service, version, mode, path + ["solve"])
                super().__init__(service, version, mode, path)

            class conjugate_heat_transfer(TUIMenu):
                """
                Enters the conjugate heat transfer menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables loosely coupled conjugate heat transfer. This works in conjunction with the solve/set/transient-controls/solid-time-step-size text command (and thereby enables the use of a user-specified time step size for solid zones that can be larger than that used for the fluid zones) to increase the robustness of the energy equation calculation, and specifies that multidomain architecture is used within a single Fluent session to enhance the performance of the simulation.
                    """

                class set(TUIMenu):
                    """
                    Enters the set menu for loosely coupled conjugate heat transfer.
                    """
                    def __init__(self, service, version, mode, path):
                        self.session_mode = self.__class__.session_mode(service, version, mode, path + ["session_mode"])
                        self.coupling = self.__class__.coupling(service, version, mode, path + ["coupling"])
                        self.helper_session = self.__class__.helper_session(service, version, mode, path + ["helper_session"])
                        super().__init__(service, version, mode, path)
                    class session_mode(TUIMethod):
                        """
                        Setup session mode (single/multiple) for multidomain conjugate heat transfer.
                        """
                    class coupling(TUIMethod):
                        """
                        Specifies when the fluid and solid zone calculations are coupled,  either at a defined time period or number of fluid time steps.
                        """
                    class helper_session(TUIMethod):
                        """
                        Setup helper session for multidomain conjugate heat transfer.
                        """

            class solve(TUIMenu):
                """
                Enter the multi-domain simulation solver menu.
                """
                def __init__(self, service, version, mode, path):
                    self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
                    self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
                    super().__init__(service, version, mode, path)
                class iterate(TUIMethod):
                    """
                    Iteration the multidomain conjugate heat transfer.
                    """
                class dual_time_iterate(TUIMethod):
                    """
                    Dual-time iterate the multidomain conjugate heat transfer.
                    """

    class plot(TUIMenu):
        """
        Enter the XY plot menu.
        """
        def __init__(self, service, version, mode, path):
            self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(service, version, mode, path + ["ansys_sound_analysis"])
            self.cumulative_plot = self.__class__.cumulative_plot(service, version, mode, path + ["cumulative_plot"])
            self.flamelet_curves = self.__class__.flamelet_curves(service, version, mode, path + ["flamelet_curves"])
            self.circum_avg_axial = self.__class__.circum_avg_axial(service, version, mode, path + ["circum_avg_axial"])
            self.circum_avg_radial = self.__class__.circum_avg_radial(service, version, mode, path + ["circum_avg_radial"])
            self.change_fft_ref_pressure = self.__class__.change_fft_ref_pressure(service, version, mode, path + ["change_fft_ref_pressure"])
            self.fft = self.__class__.fft(service, version, mode, path + ["fft"])
            self.fft_set = self.__class__.fft_set(service, version, mode, path + ["fft_set"])
            self.file = self.__class__.file(service, version, mode, path + ["file"])
            self.datasources = self.__class__.datasources(service, version, mode, path + ["datasources"])
            self.display_profile_data = self.__class__.display_profile_data(service, version, mode, path + ["display_profile_data"])
            self.file_list = self.__class__.file_list(service, version, mode, path + ["file_list"])
            self.file_set = self.__class__.file_set(service, version, mode, path + ["file_set"])
            self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
            self.histogram_set = self.__class__.histogram_set(service, version, mode, path + ["histogram_set"])
            self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
            self.plot_direction = self.__class__.plot_direction(service, version, mode, path + ["plot_direction"])
            self.residuals = self.__class__.residuals(service, version, mode, path + ["residuals"])
            self.residuals_set = self.__class__.residuals_set(service, version, mode, path + ["residuals_set"])
            self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
            self.solution_set = self.__class__.solution_set(service, version, mode, path + ["solution_set"])
            self.set_boundary_val_off = self.__class__.set_boundary_val_off(service, version, mode, path + ["set_boundary_val_off"])
            self.label_alignment = self.__class__.label_alignment(service, version, mode, path + ["label_alignment"])
            super().__init__(service, version, mode, path)
        class circum_avg_axial(TUIMethod):
            """
            Computes iso-axial band surfaces and plots data vs. axial coordinate on them.
            """
        class circum_avg_radial(TUIMethod):
            """
            Computes iso-radial band surfaces and plots data vs. radius on them.
            """
        class change_fft_ref_pressure(TUIMethod):
            """
            Changes reference acoustic pressure.
            """
        class fft(TUIMethod):
            """
            Plots fast Fourier transform (FFT) of file data. If you respond yes to Acoustic Analysis?, then additional Y axis functions are made available.
            """
        class fft_set(TUIMethod):
            """
            Enter the menu to set histogram plot parameters.
            """
        class file(TUIMethod):
            """
            Plots data from an external file.
            """
        class datasources(TUIMethod):
            """
            Enters the menu for creating and modifying plots containing multiple data sources.
            """
        class display_profile_data(TUIMethod):
            """
            Plots profile data.
            """
        class file_list(TUIMethod):
            """
            Plots data from multiple external files.
            """
        class file_set(TUIMethod):
            """
            Sets file plot parameters.
            """
        class histogram(TUIMethod):
            """
            Plots a histogram of the specified solution variable using the defined range and number of intervals.
            """
        class histogram_set(TUIMethod):
            """
            Sets histogram plot parameters. Sub-menu items are the same as file-set/ above.
            """
        class plot(TUIMethod):
            """
            Plots solution on surfaces.
            """
        class plot_direction(TUIMethod):
            """
            Sets plot direction for XY plot.
            """
        class residuals(TUIMethod):
            """
            Contains commands that allow you to select the variables for which you want to display XY plots of residual histories in the active graphics window.
            """
        class residuals_set(TUIMethod):
            """
            Sets residual plot parameters. Sub-menu items are the same as file-set/ above.
            """
        class solution(TUIMethod):
            """
            Plots solution on surfaces and/or zones. Zone and surface names can be indicated using a  wildcard (\*).
            """
        class solution_set(TUIMethod):
            """
            Sets solution plot parameters. Sub-menu items are the same as file-set/ above.
            """
        class set_boundary_val_off(TUIMethod):
            """
            Disables the use of boundary face values when node values are disabled in solution XY plots. This option is disabled by default, that is, boundary face values are used when node values are disabled.
            """
        class label_alignment(TUIMethod):
            """
            Set the orientation of XY plot axis labels as either horizontal or axis-aligned.
            """

        class ansys_sound_analysis(TUIMenu):
            """
            Enter the Ansys sound analysis menu.
            """
            def __init__(self, service, version, mode, path):
                self.write_files = self.__class__.write_files(service, version, mode, path + ["write_files"])
                self.print_indicators = self.__class__.print_indicators(service, version, mode, path + ["print_indicators"])
                super().__init__(service, version, mode, path)
            class write_files(TUIMethod):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before writing a WAV, output pressure, and/or acoustic indicators file.
                """
            class print_indicators(TUIMethod):
                """
                Read in a pressure signal or spectrum file, then optionally read in a frequency response function (FRF) or transfer function file, before printing the acoustics indicators.
                """

        class cumulative_plot(TUIMenu):
            """
            Plot the development of force, force coefficient, moment, or moment coefficient across the specified wall zones.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                self.print = self.__class__.print(service, version, mode, path + ["print"])
                self.write = self.__class__.write(service, version, mode, path + ["write"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Create a new cumulative plot.
                """
            class axes(TUIMethod):
                """
                Set axes options of an object.
                """
            class curves(TUIMethod):
                """
                Set curves options of an object.
                """
            class edit(TUIMethod):
                """
                Edit an existing cumulative plot object.
                """
            class delete(TUIMethod):
                """
                Delete an existing cumulative plot object.
                """
            class list(TUIMethod):
                """
                Print the names of the existing cumulative plot objects to the console.
                """
            class list_properties(TUIMethod):
                """
                Print the properties of the specified cumulative plot object to the console.
                """
            class plot(TUIMethod):
                """
                Plot a cumulative plot in the graphics window.
                """
            class print(TUIMethod):
                """
                Print the value of a cumulative plot to the console.
                """
            class write(TUIMethod):
                """
                Write a cumulative plot to a file.
                """

        class flamelet_curves(TUIMenu):
            """
            Enters the flamelet curves menu.
            """
            def __init__(self, service, version, mode, path):
                self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                self.plot_curves = self.__class__.plot_curves(service, version, mode, path + ["plot_curves"])
                super().__init__(service, version, mode, path)
            class write_to_file(TUIMethod):
                """
                Writes curve to a file instead of plot.
                """
            class plot_curves(TUIMethod):
                """
                Plots of a curve property.
                """

    class preferences(TUIMenu):
        """
        Set preferences.
        """
        def __init__(self, service, version, mode, path):
            self.appearance = self.__class__.appearance(service, version, mode, path + ["appearance"])
            self.general = self.__class__.general(service, version, mode, path + ["general"])
            self.gpuapp = self.__class__.gpuapp(service, version, mode, path + ["gpuapp"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.mat_pro_app = self.__class__.mat_pro_app(service, version, mode, path + ["mat_pro_app"])
            self.meshing_workflow = self.__class__.meshing_workflow(service, version, mode, path + ["meshing_workflow"])
            self.navigation = self.__class__.navigation(service, version, mode, path + ["navigation"])
            self.prj_app = self.__class__.prj_app(service, version, mode, path + ["prj_app"])
            self.simulation = self.__class__.simulation(service, version, mode, path + ["simulation"])
            self.turbo_workflow = self.__class__.turbo_workflow(service, version, mode, path + ["turbo_workflow"])
            super().__init__(service, version, mode, path)

        class appearance(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.ansys_logo = self.__class__.ansys_logo(service, version, mode, path + ["ansys_logo"])
                self.charts = self.__class__.charts(service, version, mode, path + ["charts"])
                self.selections = self.__class__.selections(service, version, mode, path + ["selections"])
                self.application_font_size = self.__class__.application_font_size(service, version, mode, path + ["application_font_size"])
                self.axis_triad = self.__class__.axis_triad(service, version, mode, path + ["axis_triad"])
                self.color_theme = self.__class__.color_theme(service, version, mode, path + ["color_theme"])
                self.completer = self.__class__.completer(service, version, mode, path + ["completer"])
                self.custom_title_bar = self.__class__.custom_title_bar(service, version, mode, path + ["custom_title_bar"])
                self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
                self.graphics_background_color1 = self.__class__.graphics_background_color1(service, version, mode, path + ["graphics_background_color1"])
                self.graphics_background_color2 = self.__class__.graphics_background_color2(service, version, mode, path + ["graphics_background_color2"])
                self.graphics_background_style = self.__class__.graphics_background_style(service, version, mode, path + ["graphics_background_style"])
                self.graphics_color_theme = self.__class__.graphics_color_theme(service, version, mode, path + ["graphics_color_theme"])
                self.graphics_default_manual_face_color = self.__class__.graphics_default_manual_face_color(service, version, mode, path + ["graphics_default_manual_face_color"])
                self.graphics_default_manual_node_color = self.__class__.graphics_default_manual_node_color(service, version, mode, path + ["graphics_default_manual_node_color"])
                self.graphics_edge_color = self.__class__.graphics_edge_color(service, version, mode, path + ["graphics_edge_color"])
                self.graphics_foreground_color = self.__class__.graphics_foreground_color(service, version, mode, path + ["graphics_foreground_color"])
                self.graphics_partition_boundary_color = self.__class__.graphics_partition_boundary_color(service, version, mode, path + ["graphics_partition_boundary_color"])
                self.graphics_surface_color = self.__class__.graphics_surface_color(service, version, mode, path + ["graphics_surface_color"])
                self.graphics_title_window_framecolor = self.__class__.graphics_title_window_framecolor(service, version, mode, path + ["graphics_title_window_framecolor"])
                self.graphics_view = self.__class__.graphics_view(service, version, mode, path + ["graphics_view"])
                self.graphics_wall_face_color = self.__class__.graphics_wall_face_color(service, version, mode, path + ["graphics_wall_face_color"])
                self.group_by_tree_view = self.__class__.group_by_tree_view(service, version, mode, path + ["group_by_tree_view"])
                self.model_color_scheme = self.__class__.model_color_scheme(service, version, mode, path + ["model_color_scheme"])
                self.number_of_files_recently_used = self.__class__.number_of_files_recently_used(service, version, mode, path + ["number_of_files_recently_used"])
                self.number_of_pastel_colors = self.__class__.number_of_pastel_colors(service, version, mode, path + ["number_of_pastel_colors"])
                self.pastel_color_saturation = self.__class__.pastel_color_saturation(service, version, mode, path + ["pastel_color_saturation"])
                self.pastel_color_value = self.__class__.pastel_color_value(service, version, mode, path + ["pastel_color_value"])
                self.quick_property_view = self.__class__.quick_property_view(service, version, mode, path + ["quick_property_view"])
                self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                self.show_enabled_models = self.__class__.show_enabled_models(service, version, mode, path + ["show_enabled_models"])
                self.show_interface_children_zone = self.__class__.show_interface_children_zone(service, version, mode, path + ["show_interface_children_zone"])
                self.show_model_edges = self.__class__.show_model_edges(service, version, mode, path + ["show_model_edges"])
                self.solution_mode_edge_color_in_meshing_mode = self.__class__.solution_mode_edge_color_in_meshing_mode(service, version, mode, path + ["solution_mode_edge_color_in_meshing_mode"])
                self.startup_page = self.__class__.startup_page(service, version, mode, path + ["startup_page"])
                self.surface_emissivity = self.__class__.surface_emissivity(service, version, mode, path + ["surface_emissivity"])
                self.surface_specularity = self.__class__.surface_specularity(service, version, mode, path + ["surface_specularity"])
                self.surface_specularity_for_contours = self.__class__.surface_specularity_for_contours(service, version, mode, path + ["surface_specularity_for_contours"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                self.titles_border_offset = self.__class__.titles_border_offset(service, version, mode, path + ["titles_border_offset"])
                super().__init__(service, version, mode, path)
            class application_font_size(TUIMethod):
                """
                .
                """
            class axis_triad(TUIMethod):
                """
                .
                """
            class color_theme(TUIMethod):
                """
                .
                """
            class completer(TUIMethod):
                """
                .
                """
            class custom_title_bar(TUIMethod):
                """
                .
                """
            class default_view(TUIMethod):
                """
                .
                """
            class graphics_background_color1(TUIMethod):
                """
                .
                """
            class graphics_background_color2(TUIMethod):
                """
                .
                """
            class graphics_background_style(TUIMethod):
                """
                .
                """
            class graphics_color_theme(TUIMethod):
                """
                .
                """
            class graphics_default_manual_face_color(TUIMethod):
                """
                .
                """
            class graphics_default_manual_node_color(TUIMethod):
                """
                .
                """
            class graphics_edge_color(TUIMethod):
                """
                .
                """
            class graphics_foreground_color(TUIMethod):
                """
                .
                """
            class graphics_partition_boundary_color(TUIMethod):
                """
                .
                """
            class graphics_surface_color(TUIMethod):
                """
                .
                """
            class graphics_title_window_framecolor(TUIMethod):
                """
                .
                """
            class graphics_view(TUIMethod):
                """
                .
                """
            class graphics_wall_face_color(TUIMethod):
                """
                .
                """
            class group_by_tree_view(TUIMethod):
                """
                .
                """
            class model_color_scheme(TUIMethod):
                """
                .
                """
            class number_of_files_recently_used(TUIMethod):
                """
                .
                """
            class number_of_pastel_colors(TUIMethod):
                """
                .
                """
            class pastel_color_saturation(TUIMethod):
                """
                .
                """
            class pastel_color_value(TUIMethod):
                """
                .
                """
            class quick_property_view(TUIMethod):
                """
                .
                """
            class ruler(TUIMethod):
                """
                .
                """
            class show_enabled_models(TUIMethod):
                """
                .
                """
            class show_interface_children_zone(TUIMethod):
                """
                .
                """
            class show_model_edges(TUIMethod):
                """
                .
                """
            class solution_mode_edge_color_in_meshing_mode(TUIMethod):
                """
                .
                """
            class startup_page(TUIMethod):
                """
                .
                """
            class surface_emissivity(TUIMethod):
                """
                .
                """
            class surface_specularity(TUIMethod):
                """
                .
                """
            class surface_specularity_for_contours(TUIMethod):
                """
                .
                """
            class titles(TUIMethod):
                """
                .
                """
            class titles_border_offset(TUIMethod):
                """
                .
                """

            class ansys_logo(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.color = self.__class__.color(service, version, mode, path + ["color"])
                    self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                    super().__init__(service, version, mode, path)
                class color(TUIMethod):
                    """
                    .
                    """
                class visible(TUIMethod):
                    """
                    .
                    """

            class charts(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.font = self.__class__.font(service, version, mode, path + ["font"])
                    self.text_color = self.__class__.text_color(service, version, mode, path + ["text_color"])
                    self.curve_colors = self.__class__.curve_colors(service, version, mode, path + ["curve_colors"])
                    self.enable_open_glfor_modern_plots = self.__class__.enable_open_glfor_modern_plots(service, version, mode, path + ["enable_open_glfor_modern_plots"])
                    self.legend_alignment = self.__class__.legend_alignment(service, version, mode, path + ["legend_alignment"])
                    self.legend_visibility = self.__class__.legend_visibility(service, version, mode, path + ["legend_visibility"])
                    self.modern_plots_enabled = self.__class__.modern_plots_enabled(service, version, mode, path + ["modern_plots_enabled"])
                    self.modern_plots_points_threshold = self.__class__.modern_plots_points_threshold(service, version, mode, path + ["modern_plots_points_threshold"])
                    self.plots_behavior = self.__class__.plots_behavior(service, version, mode, path + ["plots_behavior"])
                    self.print_plot_data = self.__class__.print_plot_data(service, version, mode, path + ["print_plot_data"])
                    self.print_residuals_data = self.__class__.print_residuals_data(service, version, mode, path + ["print_residuals_data"])
                    self.threshold = self.__class__.threshold(service, version, mode, path + ["threshold"])
                    super().__init__(service, version, mode, path)
                class curve_colors(TUIMethod):
                    """
                    .
                    """
                class enable_open_glfor_modern_plots(TUIMethod):
                    """
                    .
                    """
                class legend_alignment(TUIMethod):
                    """
                    .
                    """
                class legend_visibility(TUIMethod):
                    """
                    .
                    """
                class modern_plots_enabled(TUIMethod):
                    """
                    .
                    """
                class modern_plots_points_threshold(TUIMethod):
                    """
                    .
                    """
                class plots_behavior(TUIMethod):
                    """
                    .
                    """
                class print_plot_data(TUIMethod):
                    """
                    .
                    """
                class print_residuals_data(TUIMethod):
                    """
                    .
                    """
                class threshold(TUIMethod):
                    """
                    .
                    """

                class font(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                        self.axes_titles = self.__class__.axes_titles(service, version, mode, path + ["axes_titles"])
                        self.legend = self.__class__.legend(service, version, mode, path + ["legend"])
                        self.title = self.__class__.title(service, version, mode, path + ["title"])
                        super().__init__(service, version, mode, path)
                    class axes(TUIMethod):
                        """
                        .
                        """
                    class axes_titles(TUIMethod):
                        """
                        .
                        """
                    class legend(TUIMethod):
                        """
                        .
                        """
                    class title(TUIMethod):
                        """
                        .
                        """

                class text_color(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                        self.axes_titles = self.__class__.axes_titles(service, version, mode, path + ["axes_titles"])
                        self.legend = self.__class__.legend(service, version, mode, path + ["legend"])
                        self.title = self.__class__.title(service, version, mode, path + ["title"])
                        super().__init__(service, version, mode, path)
                    class axes(TUIMethod):
                        """
                        .
                        """
                    class axes_titles(TUIMethod):
                        """
                        .
                        """
                    class legend(TUIMethod):
                        """
                        .
                        """
                    class title(TUIMethod):
                        """
                        .
                        """

            class selections(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.general_displacement = self.__class__.general_displacement(service, version, mode, path + ["general_displacement"])
                    self.highlight_edge_color = self.__class__.highlight_edge_color(service, version, mode, path + ["highlight_edge_color"])
                    self.highlight_edge_weight = self.__class__.highlight_edge_weight(service, version, mode, path + ["highlight_edge_weight"])
                    self.highlight_face_color = self.__class__.highlight_face_color(service, version, mode, path + ["highlight_face_color"])
                    self.highlight_gloss = self.__class__.highlight_gloss(service, version, mode, path + ["highlight_gloss"])
                    self.highlight_specular_component = self.__class__.highlight_specular_component(service, version, mode, path + ["highlight_specular_component"])
                    self.highlight_transparency = self.__class__.highlight_transparency(service, version, mode, path + ["highlight_transparency"])
                    self.mouse_hover_probe_values_enabled = self.__class__.mouse_hover_probe_values_enabled(service, version, mode, path + ["mouse_hover_probe_values_enabled"])
                    self.mouse_over_highlight_enabled = self.__class__.mouse_over_highlight_enabled(service, version, mode, path + ["mouse_over_highlight_enabled"])
                    self.probe_tooltip_hide_delay_timer = self.__class__.probe_tooltip_hide_delay_timer(service, version, mode, path + ["probe_tooltip_hide_delay_timer"])
                    self.probe_tooltip_show_delay_timer = self.__class__.probe_tooltip_show_delay_timer(service, version, mode, path + ["probe_tooltip_show_delay_timer"])
                    super().__init__(service, version, mode, path)
                class general_displacement(TUIMethod):
                    """
                    .
                    """
                class highlight_edge_color(TUIMethod):
                    """
                    .
                    """
                class highlight_edge_weight(TUIMethod):
                    """
                    .
                    """
                class highlight_face_color(TUIMethod):
                    """
                    .
                    """
                class highlight_gloss(TUIMethod):
                    """
                    .
                    """
                class highlight_specular_component(TUIMethod):
                    """
                    .
                    """
                class highlight_transparency(TUIMethod):
                    """
                    .
                    """
                class mouse_hover_probe_values_enabled(TUIMethod):
                    """
                    .
                    """
                class mouse_over_highlight_enabled(TUIMethod):
                    """
                    .
                    """
                class probe_tooltip_hide_delay_timer(TUIMethod):
                    """
                    .
                    """
                class probe_tooltip_show_delay_timer(TUIMethod):
                    """
                    .
                    """

        class general(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.advanced_partition = self.__class__.advanced_partition(service, version, mode, path + ["advanced_partition"])
                self.automatic_transcript = self.__class__.automatic_transcript(service, version, mode, path + ["automatic_transcript"])
                self.default_ioformat = self.__class__.default_ioformat(service, version, mode, path + ["default_ioformat"])
                self.dock_editor = self.__class__.dock_editor(service, version, mode, path + ["dock_editor"])
                self.enable_parametric_study = self.__class__.enable_parametric_study(service, version, mode, path + ["enable_parametric_study"])
                self.flow_model = self.__class__.flow_model(service, version, mode, path + ["flow_model"])
                self.idle_timeout = self.__class__.idle_timeout(service, version, mode, path + ["idle_timeout"])
                self.key_behavioral_changes_message = self.__class__.key_behavioral_changes_message(service, version, mode, path + ["key_behavioral_changes_message"])
                self.qaservice_message = self.__class__.qaservice_message(service, version, mode, path + ["qaservice_message"])
                self.utlcreate_physics_on_mode_change = self.__class__.utlcreate_physics_on_mode_change(service, version, mode, path + ["utlcreate_physics_on_mode_change"])
                self.utlmode = self.__class__.utlmode(service, version, mode, path + ["utlmode"])
                super().__init__(service, version, mode, path)
            class advanced_partition(TUIMethod):
                """
                .
                """
            class automatic_transcript(TUIMethod):
                """
                .
                """
            class default_ioformat(TUIMethod):
                """
                .
                """
            class dock_editor(TUIMethod):
                """
                .
                """
            class enable_parametric_study(TUIMethod):
                """
                .
                """
            class flow_model(TUIMethod):
                """
                .
                """
            class idle_timeout(TUIMethod):
                """
                .
                """
            class key_behavioral_changes_message(TUIMethod):
                """
                .
                """
            class qaservice_message(TUIMethod):
                """
                .
                """
            class utlcreate_physics_on_mode_change(TUIMethod):
                """
                .
                """
            class utlmode(TUIMethod):
                """
                .
                """

        class gpuapp(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.alpha_features = self.__class__.alpha_features(service, version, mode, path + ["alpha_features"])
                super().__init__(service, version, mode, path)
            class alpha_features(TUIMethod):
                """
                .
                """

        class graphics(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.boundary_markers = self.__class__.boundary_markers(service, version, mode, path + ["boundary_markers"])
                self.colormap_settings = self.__class__.colormap_settings(service, version, mode, path + ["colormap_settings"])
                self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
                self.export_video_settings = self.__class__.export_video_settings(service, version, mode, path + ["export_video_settings"])
                self.graphics_effects = self.__class__.graphics_effects(service, version, mode, path + ["graphics_effects"])
                self.hardcopy_settings = self.__class__.hardcopy_settings(service, version, mode, path + ["hardcopy_settings"])
                self.lighting = self.__class__.lighting(service, version, mode, path + ["lighting"])
                self.manage_hoops_memory = self.__class__.manage_hoops_memory(service, version, mode, path + ["manage_hoops_memory"])
                self.material_effects = self.__class__.material_effects(service, version, mode, path + ["material_effects"])
                self.meshing_mode = self.__class__.meshing_mode(service, version, mode, path + ["meshing_mode"])
                self.performance = self.__class__.performance(service, version, mode, path + ["performance"])
                self.transparency = self.__class__.transparency(service, version, mode, path + ["transparency"])
                self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                self.enable_non_object_based_workflow = self.__class__.enable_non_object_based_workflow(service, version, mode, path + ["enable_non_object_based_workflow"])
                self.event_poll_interval = self.__class__.event_poll_interval(service, version, mode, path + ["event_poll_interval"])
                self.event_poll_timeout = self.__class__.event_poll_timeout(service, version, mode, path + ["event_poll_timeout"])
                self.force_key_frame_animation_markers_to_off = self.__class__.force_key_frame_animation_markers_to_off(service, version, mode, path + ["force_key_frame_animation_markers_to_off"])
                self.graphics_window_line_width = self.__class__.graphics_window_line_width(service, version, mode, path + ["graphics_window_line_width"])
                self.graphics_window_point_symbol = self.__class__.graphics_window_point_symbol(service, version, mode, path + ["graphics_window_point_symbol"])
                self.hidden_surface_removal_method = self.__class__.hidden_surface_removal_method(service, version, mode, path + ["hidden_surface_removal_method"])
                self.higher_resolution_graphics_window_line_width = self.__class__.higher_resolution_graphics_window_line_width(service, version, mode, path + ["higher_resolution_graphics_window_line_width"])
                self.lower_resolution_graphics_window_line_width = self.__class__.lower_resolution_graphics_window_line_width(service, version, mode, path + ["lower_resolution_graphics_window_line_width"])
                self.marker_drawing_mode = self.__class__.marker_drawing_mode(service, version, mode, path + ["marker_drawing_mode"])
                self.max_graphics_text_size = self.__class__.max_graphics_text_size(service, version, mode, path + ["max_graphics_text_size"])
                self.min_graphics_text_size = self.__class__.min_graphics_text_size(service, version, mode, path + ["min_graphics_text_size"])
                self.new_material_infra = self.__class__.new_material_infra(service, version, mode, path + ["new_material_infra"])
                self.plot_legend_margin = self.__class__.plot_legend_margin(service, version, mode, path + ["plot_legend_margin"])
                self.point_tool_size = self.__class__.point_tool_size(service, version, mode, path + ["point_tool_size"])
                self.remove_partition_lines = self.__class__.remove_partition_lines(service, version, mode, path + ["remove_partition_lines"])
                self.remove_partition_lines_tolerance = self.__class__.remove_partition_lines_tolerance(service, version, mode, path + ["remove_partition_lines_tolerance"])
                self.rotation_centerpoint_visible = self.__class__.rotation_centerpoint_visible(service, version, mode, path + ["rotation_centerpoint_visible"])
                self.scroll_wheel_event_end_timer = self.__class__.scroll_wheel_event_end_timer(service, version, mode, path + ["scroll_wheel_event_end_timer"])
                self.set_camera_normal_to_surface_increments = self.__class__.set_camera_normal_to_surface_increments(service, version, mode, path + ["set_camera_normal_to_surface_increments"])
                self.show_hidden_lines = self.__class__.show_hidden_lines(service, version, mode, path + ["show_hidden_lines"])
                self.show_hidden_surfaces = self.__class__.show_hidden_surfaces(service, version, mode, path + ["show_hidden_surfaces"])
                self.switch_to_open_glfor_remote_visualization = self.__class__.switch_to_open_glfor_remote_visualization(service, version, mode, path + ["switch_to_open_glfor_remote_visualization"])
                self.test_use_external_function = self.__class__.test_use_external_function(service, version, mode, path + ["test_use_external_function"])
                self.text_window_line_width = self.__class__.text_window_line_width(service, version, mode, path + ["text_window_line_width"])
                super().__init__(service, version, mode, path)
            class animation_option(TUIMethod):
                """
                .
                """
            class double_buffering(TUIMethod):
                """
                .
                """
            class enable_non_object_based_workflow(TUIMethod):
                """
                .
                """
            class event_poll_interval(TUIMethod):
                """
                .
                """
            class event_poll_timeout(TUIMethod):
                """
                .
                """
            class force_key_frame_animation_markers_to_off(TUIMethod):
                """
                .
                """
            class graphics_window_line_width(TUIMethod):
                """
                .
                """
            class graphics_window_point_symbol(TUIMethod):
                """
                .
                """
            class hidden_surface_removal_method(TUIMethod):
                """
                .
                """
            class higher_resolution_graphics_window_line_width(TUIMethod):
                """
                .
                """
            class lower_resolution_graphics_window_line_width(TUIMethod):
                """
                .
                """
            class marker_drawing_mode(TUIMethod):
                """
                .
                """
            class max_graphics_text_size(TUIMethod):
                """
                .
                """
            class min_graphics_text_size(TUIMethod):
                """
                .
                """
            class new_material_infra(TUIMethod):
                """
                .
                """
            class plot_legend_margin(TUIMethod):
                """
                .
                """
            class point_tool_size(TUIMethod):
                """
                .
                """
            class remove_partition_lines(TUIMethod):
                """
                .
                """
            class remove_partition_lines_tolerance(TUIMethod):
                """
                .
                """
            class rotation_centerpoint_visible(TUIMethod):
                """
                .
                """
            class scroll_wheel_event_end_timer(TUIMethod):
                """
                .
                """
            class set_camera_normal_to_surface_increments(TUIMethod):
                """
                .
                """
            class show_hidden_lines(TUIMethod):
                """
                .
                """
            class show_hidden_surfaces(TUIMethod):
                """
                .
                """
            class switch_to_open_glfor_remote_visualization(TUIMethod):
                """
                .
                """
            class test_use_external_function(TUIMethod):
                """
                .
                """
            class text_window_line_width(TUIMethod):
                """
                .
                """

            class boundary_markers(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.color_option = self.__class__.color_option(service, version, mode, path + ["color_option"])
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.exclude_from_bounding = self.__class__.exclude_from_bounding(service, version, mode, path + ["exclude_from_bounding"])
                    self.inlet_color = self.__class__.inlet_color(service, version, mode, path + ["inlet_color"])
                    self.marker_fraction = self.__class__.marker_fraction(service, version, mode, path + ["marker_fraction"])
                    self.marker_size_limiting_scale_multiplier = self.__class__.marker_size_limiting_scale_multiplier(service, version, mode, path + ["marker_size_limiting_scale_multiplier"])
                    self.markers_limit = self.__class__.markers_limit(service, version, mode, path + ["markers_limit"])
                    self.outlet_color = self.__class__.outlet_color(service, version, mode, path + ["outlet_color"])
                    self.scale_marker = self.__class__.scale_marker(service, version, mode, path + ["scale_marker"])
                    self.show_inlet_markers = self.__class__.show_inlet_markers(service, version, mode, path + ["show_inlet_markers"])
                    self.show_outlet_markers = self.__class__.show_outlet_markers(service, version, mode, path + ["show_outlet_markers"])
                    super().__init__(service, version, mode, path)
                class color_option(TUIMethod):
                    """
                    .
                    """
                class enabled(TUIMethod):
                    """
                    .
                    """
                class exclude_from_bounding(TUIMethod):
                    """
                    .
                    """
                class inlet_color(TUIMethod):
                    """
                    .
                    """
                class marker_fraction(TUIMethod):
                    """
                    .
                    """
                class marker_size_limiting_scale_multiplier(TUIMethod):
                    """
                    .
                    """
                class markers_limit(TUIMethod):
                    """
                    .
                    """
                class outlet_color(TUIMethod):
                    """
                    .
                    """
                class scale_marker(TUIMethod):
                    """
                    .
                    """
                class show_inlet_markers(TUIMethod):
                    """
                    .
                    """
                class show_outlet_markers(TUIMethod):
                    """
                    .
                    """

            class colormap_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                    self.aspect_ratio_when_horizontal = self.__class__.aspect_ratio_when_horizontal(service, version, mode, path + ["aspect_ratio_when_horizontal"])
                    self.aspect_ratio_when_vertical = self.__class__.aspect_ratio_when_vertical(service, version, mode, path + ["aspect_ratio_when_vertical"])
                    self.auto_refit_on_resize = self.__class__.auto_refit_on_resize(service, version, mode, path + ["auto_refit_on_resize"])
                    self.automatic_resize = self.__class__.automatic_resize(service, version, mode, path + ["automatic_resize"])
                    self.border_style = self.__class__.border_style(service, version, mode, path + ["border_style"])
                    self.colormap = self.__class__.colormap(service, version, mode, path + ["colormap"])
                    self.isolines_position_offset = self.__class__.isolines_position_offset(service, version, mode, path + ["isolines_position_offset"])
                    self.labels = self.__class__.labels(service, version, mode, path + ["labels"])
                    self.levels = self.__class__.levels(service, version, mode, path + ["levels"])
                    self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                    self.major_length_to_screen_ratio_when_horizontal = self.__class__.major_length_to_screen_ratio_when_horizontal(service, version, mode, path + ["major_length_to_screen_ratio_when_horizontal"])
                    self.major_length_to_screen_ratio_when_vertical = self.__class__.major_length_to_screen_ratio_when_vertical(service, version, mode, path + ["major_length_to_screen_ratio_when_vertical"])
                    self.margin_from_edge_to_screen_ratio = self.__class__.margin_from_edge_to_screen_ratio(service, version, mode, path + ["margin_from_edge_to_screen_ratio"])
                    self.max_size_scale_factor = self.__class__.max_size_scale_factor(service, version, mode, path + ["max_size_scale_factor"])
                    self.min_size_scale_factor = self.__class__.min_size_scale_factor(service, version, mode, path + ["min_size_scale_factor"])
                    self.number_format_precision = self.__class__.number_format_precision(service, version, mode, path + ["number_format_precision"])
                    self.number_format_type = self.__class__.number_format_type(service, version, mode, path + ["number_format_type"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    self.skip_value = self.__class__.skip_value(service, version, mode, path + ["skip_value"])
                    self.text_behavior = self.__class__.text_behavior(service, version, mode, path + ["text_behavior"])
                    self.text_font_automatic_horizontal_size = self.__class__.text_font_automatic_horizontal_size(service, version, mode, path + ["text_font_automatic_horizontal_size"])
                    self.text_font_automatic_size = self.__class__.text_font_automatic_size(service, version, mode, path + ["text_font_automatic_size"])
                    self.text_font_automatic_units = self.__class__.text_font_automatic_units(service, version, mode, path + ["text_font_automatic_units"])
                    self.text_font_automatic_vertical_size = self.__class__.text_font_automatic_vertical_size(service, version, mode, path + ["text_font_automatic_vertical_size"])
                    self.text_font_fixed_horizontal_size = self.__class__.text_font_fixed_horizontal_size(service, version, mode, path + ["text_font_fixed_horizontal_size"])
                    self.text_font_fixed_size = self.__class__.text_font_fixed_size(service, version, mode, path + ["text_font_fixed_size"])
                    self.text_font_fixed_units = self.__class__.text_font_fixed_units(service, version, mode, path + ["text_font_fixed_units"])
                    self.text_font_fixed_vertical_size = self.__class__.text_font_fixed_vertical_size(service, version, mode, path + ["text_font_fixed_vertical_size"])
                    self.text_font_name = self.__class__.text_font_name(service, version, mode, path + ["text_font_name"])
                    self.text_truncation_limit_for_horizontal_colormaps = self.__class__.text_truncation_limit_for_horizontal_colormaps(service, version, mode, path + ["text_truncation_limit_for_horizontal_colormaps"])
                    self.text_truncation_limit_for_vertical_colormaps = self.__class__.text_truncation_limit_for_vertical_colormaps(service, version, mode, path + ["text_truncation_limit_for_vertical_colormaps"])
                    self.type = self.__class__.type(service, version, mode, path + ["type"])
                    self.use_no_sub_windows = self.__class__.use_no_sub_windows(service, version, mode, path + ["use_no_sub_windows"])
                    super().__init__(service, version, mode, path)
                class alignment(TUIMethod):
                    """
                    .
                    """
                class aspect_ratio_when_horizontal(TUIMethod):
                    """
                    .
                    """
                class aspect_ratio_when_vertical(TUIMethod):
                    """
                    .
                    """
                class auto_refit_on_resize(TUIMethod):
                    """
                    .
                    """
                class automatic_resize(TUIMethod):
                    """
                    .
                    """
                class border_style(TUIMethod):
                    """
                    .
                    """
                class colormap(TUIMethod):
                    """
                    .
                    """
                class isolines_position_offset(TUIMethod):
                    """
                    .
                    """
                class labels(TUIMethod):
                    """
                    .
                    """
                class levels(TUIMethod):
                    """
                    .
                    """
                class log_scale(TUIMethod):
                    """
                    .
                    """
                class major_length_to_screen_ratio_when_horizontal(TUIMethod):
                    """
                    .
                    """
                class major_length_to_screen_ratio_when_vertical(TUIMethod):
                    """
                    .
                    """
                class margin_from_edge_to_screen_ratio(TUIMethod):
                    """
                    .
                    """
                class max_size_scale_factor(TUIMethod):
                    """
                    .
                    """
                class min_size_scale_factor(TUIMethod):
                    """
                    .
                    """
                class number_format_precision(TUIMethod):
                    """
                    .
                    """
                class number_format_type(TUIMethod):
                    """
                    .
                    """
                class show_colormap(TUIMethod):
                    """
                    .
                    """
                class skip_value(TUIMethod):
                    """
                    .
                    """
                class text_behavior(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_horizontal_size(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_size(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_units(TUIMethod):
                    """
                    .
                    """
                class text_font_automatic_vertical_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_horizontal_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_size(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_units(TUIMethod):
                    """
                    .
                    """
                class text_font_fixed_vertical_size(TUIMethod):
                    """
                    .
                    """
                class text_font_name(TUIMethod):
                    """
                    .
                    """
                class text_truncation_limit_for_horizontal_colormaps(TUIMethod):
                    """
                    .
                    """
                class text_truncation_limit_for_vertical_colormaps(TUIMethod):
                    """
                    .
                    """
                class type(TUIMethod):
                    """
                    .
                    """
                class use_no_sub_windows(TUIMethod):
                    """
                    .
                    """

            class embedded_windows(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.default_embedded_mesh_windows_view = self.__class__.default_embedded_mesh_windows_view(service, version, mode, path + ["default_embedded_mesh_windows_view"])
                    self.default_embedded_windows_view = self.__class__.default_embedded_windows_view(service, version, mode, path + ["default_embedded_windows_view"])
                    self.save_embedded_window_layout = self.__class__.save_embedded_window_layout(service, version, mode, path + ["save_embedded_window_layout"])
                    self.show_border_for_embedded_window = self.__class__.show_border_for_embedded_window(service, version, mode, path + ["show_border_for_embedded_window"])
                    super().__init__(service, version, mode, path)
                class default_embedded_mesh_windows_view(TUIMethod):
                    """
                    .
                    """
                class default_embedded_windows_view(TUIMethod):
                    """
                    .
                    """
                class save_embedded_window_layout(TUIMethod):
                    """
                    .
                    """
                class show_border_for_embedded_window(TUIMethod):
                    """
                    .
                    """

            class export_video_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.advanced_video_quality_options = self.__class__.advanced_video_quality_options(service, version, mode, path + ["advanced_video_quality_options"])
                    self.video_format = self.__class__.video_format(service, version, mode, path + ["video_format"])
                    self.video_fps = self.__class__.video_fps(service, version, mode, path + ["video_fps"])
                    self.video_quality = self.__class__.video_quality(service, version, mode, path + ["video_quality"])
                    self.video_resoution_x = self.__class__.video_resoution_x(service, version, mode, path + ["video_resoution_x"])
                    self.video_resoution_y = self.__class__.video_resoution_y(service, version, mode, path + ["video_resoution_y"])
                    self.video_scale = self.__class__.video_scale(service, version, mode, path + ["video_scale"])
                    self.video_smooth_scaling = self.__class__.video_smooth_scaling(service, version, mode, path + ["video_smooth_scaling"])
                    self.video_use_frame_resolution = self.__class__.video_use_frame_resolution(service, version, mode, path + ["video_use_frame_resolution"])
                    super().__init__(service, version, mode, path)
                class video_format(TUIMethod):
                    """
                    .
                    """
                class video_fps(TUIMethod):
                    """
                    .
                    """
                class video_quality(TUIMethod):
                    """
                    .
                    """
                class video_resoution_x(TUIMethod):
                    """
                    .
                    """
                class video_resoution_y(TUIMethod):
                    """
                    .
                    """
                class video_scale(TUIMethod):
                    """
                    .
                    """
                class video_smooth_scaling(TUIMethod):
                    """
                    .
                    """
                class video_use_frame_resolution(TUIMethod):
                    """
                    .
                    """

                class advanced_video_quality_options(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.bit_rate_quality = self.__class__.bit_rate_quality(service, version, mode, path + ["bit_rate_quality"])
                        self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                        self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                        self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                        self.key_frames = self.__class__.key_frames(service, version, mode, path + ["key_frames"])
                        super().__init__(service, version, mode, path)
                    class bit_rate_quality(TUIMethod):
                        """
                        .
                        """
                    class bitrate(TUIMethod):
                        """
                        .
                        """
                    class compression_method(TUIMethod):
                        """
                        .
                        """
                    class enable_h264(TUIMethod):
                        """
                        .
                        """
                    class key_frames(TUIMethod):
                        """
                        .
                        """

            class graphics_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.ambient_occlusion_enabled = self.__class__.ambient_occlusion_enabled(service, version, mode, path + ["ambient_occlusion_enabled"])
                    self.ambient_occlusion_quality = self.__class__.ambient_occlusion_quality(service, version, mode, path + ["ambient_occlusion_quality"])
                    self.ambient_occlusion_strength = self.__class__.ambient_occlusion_strength(service, version, mode, path + ["ambient_occlusion_strength"])
                    self.anti_aliasing = self.__class__.anti_aliasing(service, version, mode, path + ["anti_aliasing"])
                    self.bloom_blur = self.__class__.bloom_blur(service, version, mode, path + ["bloom_blur"])
                    self.bloom_enabled = self.__class__.bloom_enabled(service, version, mode, path + ["bloom_enabled"])
                    self.bloom_strength = self.__class__.bloom_strength(service, version, mode, path + ["bloom_strength"])
                    self.grid_color = self.__class__.grid_color(service, version, mode, path + ["grid_color"])
                    self.grid_plane_count = self.__class__.grid_plane_count(service, version, mode, path + ["grid_plane_count"])
                    self.grid_plane_enabled = self.__class__.grid_plane_enabled(service, version, mode, path + ["grid_plane_enabled"])
                    self.grid_plane_offset = self.__class__.grid_plane_offset(service, version, mode, path + ["grid_plane_offset"])
                    self.grid_plane_size_factor = self.__class__.grid_plane_size_factor(service, version, mode, path + ["grid_plane_size_factor"])
                    self.plane_direction = self.__class__.plane_direction(service, version, mode, path + ["plane_direction"])
                    self.reflections_enabled = self.__class__.reflections_enabled(service, version, mode, path + ["reflections_enabled"])
                    self.shadow_map_enabled = self.__class__.shadow_map_enabled(service, version, mode, path + ["shadow_map_enabled"])
                    self.show_edge_reflections = self.__class__.show_edge_reflections(service, version, mode, path + ["show_edge_reflections"])
                    self.show_marker_reflections = self.__class__.show_marker_reflections(service, version, mode, path + ["show_marker_reflections"])
                    self.simple_shadows_enabled = self.__class__.simple_shadows_enabled(service, version, mode, path + ["simple_shadows_enabled"])
                    self.update_after_mouse_release = self.__class__.update_after_mouse_release(service, version, mode, path + ["update_after_mouse_release"])
                    super().__init__(service, version, mode, path)
                class ambient_occlusion_enabled(TUIMethod):
                    """
                    .
                    """
                class ambient_occlusion_quality(TUIMethod):
                    """
                    .
                    """
                class ambient_occlusion_strength(TUIMethod):
                    """
                    .
                    """
                class anti_aliasing(TUIMethod):
                    """
                    .
                    """
                class bloom_blur(TUIMethod):
                    """
                    .
                    """
                class bloom_enabled(TUIMethod):
                    """
                    .
                    """
                class bloom_strength(TUIMethod):
                    """
                    .
                    """
                class grid_color(TUIMethod):
                    """
                    .
                    """
                class grid_plane_count(TUIMethod):
                    """
                    .
                    """
                class grid_plane_enabled(TUIMethod):
                    """
                    .
                    """
                class grid_plane_offset(TUIMethod):
                    """
                    .
                    """
                class grid_plane_size_factor(TUIMethod):
                    """
                    .
                    """
                class plane_direction(TUIMethod):
                    """
                    .
                    """
                class reflections_enabled(TUIMethod):
                    """
                    .
                    """
                class shadow_map_enabled(TUIMethod):
                    """
                    .
                    """
                class show_edge_reflections(TUIMethod):
                    """
                    .
                    """
                class show_marker_reflections(TUIMethod):
                    """
                    .
                    """
                class simple_shadows_enabled(TUIMethod):
                    """
                    .
                    """
                class update_after_mouse_release(TUIMethod):
                    """
                    .
                    """

            class hardcopy_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.export_edges_for_avz = self.__class__.export_edges_for_avz(service, version, mode, path + ["export_edges_for_avz"])
                    self.hardcopy_driver = self.__class__.hardcopy_driver(service, version, mode, path + ["hardcopy_driver"])
                    self.hardcopy_line_width = self.__class__.hardcopy_line_width(service, version, mode, path + ["hardcopy_line_width"])
                    self.hardware_image_accel = self.__class__.hardware_image_accel(service, version, mode, path + ["hardware_image_accel"])
                    self.post_script_permission_override = self.__class__.post_script_permission_override(service, version, mode, path + ["post_script_permission_override"])
                    self.save_embedded_hardcopies_separately = self.__class__.save_embedded_hardcopies_separately(service, version, mode, path + ["save_embedded_hardcopies_separately"])
                    self.save_embedded_windows_in_hardcopy = self.__class__.save_embedded_windows_in_hardcopy(service, version, mode, path + ["save_embedded_windows_in_hardcopy"])
                    self.transparent_embedded_windows = self.__class__.transparent_embedded_windows(service, version, mode, path + ["transparent_embedded_windows"])
                    super().__init__(service, version, mode, path)
                class export_edges_for_avz(TUIMethod):
                    """
                    .
                    """
                class hardcopy_driver(TUIMethod):
                    """
                    .
                    """
                class hardcopy_line_width(TUIMethod):
                    """
                    .
                    """
                class hardware_image_accel(TUIMethod):
                    """
                    .
                    """
                class post_script_permission_override(TUIMethod):
                    """
                    .
                    """
                class save_embedded_hardcopies_separately(TUIMethod):
                    """
                    .
                    """
                class save_embedded_windows_in_hardcopy(TUIMethod):
                    """
                    .
                    """
                class transparent_embedded_windows(TUIMethod):
                    """
                    .
                    """

            class lighting(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.ambient_light_intensity = self.__class__.ambient_light_intensity(service, version, mode, path + ["ambient_light_intensity"])
                    self.headlight = self.__class__.headlight(service, version, mode, path + ["headlight"])
                    self.headlight_intensity = self.__class__.headlight_intensity(service, version, mode, path + ["headlight_intensity"])
                    self.lighting_method = self.__class__.lighting_method(service, version, mode, path + ["lighting_method"])
                    super().__init__(service, version, mode, path)
                class ambient_light_intensity(TUIMethod):
                    """
                    .
                    """
                class headlight(TUIMethod):
                    """
                    .
                    """
                class headlight_intensity(TUIMethod):
                    """
                    .
                    """
                class lighting_method(TUIMethod):
                    """
                    .
                    """

            class manage_hoops_memory(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                    self.hsfimport_limit = self.__class__.hsfimport_limit(service, version, mode, path + ["hsfimport_limit"])
                    super().__init__(service, version, mode, path)
                class enabled(TUIMethod):
                    """
                    .
                    """
                class hsfimport_limit(TUIMethod):
                    """
                    .
                    """

            class material_effects(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.decimation_filter = self.__class__.decimation_filter(service, version, mode, path + ["decimation_filter"])
                    self.parameterization_source = self.__class__.parameterization_source(service, version, mode, path + ["parameterization_source"])
                    self.tiling_style = self.__class__.tiling_style(service, version, mode, path + ["tiling_style"])
                    super().__init__(service, version, mode, path)
                class decimation_filter(TUIMethod):
                    """
                    .
                    """
                class parameterization_source(TUIMethod):
                    """
                    .
                    """
                class tiling_style(TUIMethod):
                    """
                    .
                    """

            class meshing_mode(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.graphics_window_display_timeout = self.__class__.graphics_window_display_timeout(service, version, mode, path + ["graphics_window_display_timeout"])
                    self.graphics_window_display_timeout_value = self.__class__.graphics_window_display_timeout_value(service, version, mode, path + ["graphics_window_display_timeout_value"])
                    super().__init__(service, version, mode, path)
                class graphics_window_display_timeout(TUIMethod):
                    """
                    .
                    """
                class graphics_window_display_timeout_value(TUIMethod):
                    """
                    .
                    """

            class performance(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.fast_display_mode = self.__class__.fast_display_mode(service, version, mode, path + ["fast_display_mode"])
                    self.minimum_frame_rate = self.__class__.minimum_frame_rate(service, version, mode, path + ["minimum_frame_rate"])
                    self.optimize_for = self.__class__.optimize_for(service, version, mode, path + ["optimize_for"])
                    self.ratio_of_target_frame_rate_to_classify_heavy_geometry = self.__class__.ratio_of_target_frame_rate_to_classify_heavy_geometry(service, version, mode, path + ["ratio_of_target_frame_rate_to_classify_heavy_geometry"])
                    self.ratio_of_target_frame_rate_to_declassify_heavy_geometry = self.__class__.ratio_of_target_frame_rate_to_declassify_heavy_geometry(service, version, mode, path + ["ratio_of_target_frame_rate_to_declassify_heavy_geometry"])
                    super().__init__(service, version, mode, path)
                class optimize_for(TUIMethod):
                    """
                    .
                    """
                class ratio_of_target_frame_rate_to_classify_heavy_geometry(TUIMethod):
                    """
                    .
                    """
                class ratio_of_target_frame_rate_to_declassify_heavy_geometry(TUIMethod):
                    """
                    .
                    """

                class fast_display_mode(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.culling = self.__class__.culling(service, version, mode, path + ["culling"])
                        self.faces_shown = self.__class__.faces_shown(service, version, mode, path + ["faces_shown"])
                        self.markers_decimation = self.__class__.markers_decimation(service, version, mode, path + ["markers_decimation"])
                        self.nodes_shown = self.__class__.nodes_shown(service, version, mode, path + ["nodes_shown"])
                        self.perimeter_edges_shown = self.__class__.perimeter_edges_shown(service, version, mode, path + ["perimeter_edges_shown"])
                        self.silhouette_shown = self.__class__.silhouette_shown(service, version, mode, path + ["silhouette_shown"])
                        self.status = self.__class__.status(service, version, mode, path + ["status"])
                        self.transparency = self.__class__.transparency(service, version, mode, path + ["transparency"])
                        super().__init__(service, version, mode, path)
                    class culling(TUIMethod):
                        """
                        .
                        """
                    class faces_shown(TUIMethod):
                        """
                        .
                        """
                    class markers_decimation(TUIMethod):
                        """
                        .
                        """
                    class nodes_shown(TUIMethod):
                        """
                        .
                        """
                    class perimeter_edges_shown(TUIMethod):
                        """
                        .
                        """
                    class silhouette_shown(TUIMethod):
                        """
                        .
                        """
                    class status(TUIMethod):
                        """
                        .
                        """
                    class transparency(TUIMethod):
                        """
                        .
                        """

                class minimum_frame_rate(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.dynamic_adjustment = self.__class__.dynamic_adjustment(service, version, mode, path + ["dynamic_adjustment"])
                        self.enabled = self.__class__.enabled(service, version, mode, path + ["enabled"])
                        self.fixed_culling_value = self.__class__.fixed_culling_value(service, version, mode, path + ["fixed_culling_value"])
                        self.maximum_culling_threshold = self.__class__.maximum_culling_threshold(service, version, mode, path + ["maximum_culling_threshold"])
                        self.minimum_culling_threshold = self.__class__.minimum_culling_threshold(service, version, mode, path + ["minimum_culling_threshold"])
                        self.target_fps = self.__class__.target_fps(service, version, mode, path + ["target_fps"])
                        super().__init__(service, version, mode, path)
                    class dynamic_adjustment(TUIMethod):
                        """
                        .
                        """
                    class enabled(TUIMethod):
                        """
                        .
                        """
                    class fixed_culling_value(TUIMethod):
                        """
                        .
                        """
                    class maximum_culling_threshold(TUIMethod):
                        """
                        .
                        """
                    class minimum_culling_threshold(TUIMethod):
                        """
                        .
                        """
                    class target_fps(TUIMethod):
                        """
                        .
                        """

            class transparency(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.algorithm_for_modern_drivers = self.__class__.algorithm_for_modern_drivers(service, version, mode, path + ["algorithm_for_modern_drivers"])
                    self.depth_peeling_layers = self.__class__.depth_peeling_layers(service, version, mode, path + ["depth_peeling_layers"])
                    self.depth_peeling_preference = self.__class__.depth_peeling_preference(service, version, mode, path + ["depth_peeling_preference"])
                    self.quick_moves = self.__class__.quick_moves(service, version, mode, path + ["quick_moves"])
                    self.zsort_options = self.__class__.zsort_options(service, version, mode, path + ["zsort_options"])
                    super().__init__(service, version, mode, path)
                class algorithm_for_modern_drivers(TUIMethod):
                    """
                    .
                    """
                class depth_peeling_layers(TUIMethod):
                    """
                    .
                    """
                class depth_peeling_preference(TUIMethod):
                    """
                    .
                    """
                class quick_moves(TUIMethod):
                    """
                    .
                    """
                class zsort_options(TUIMethod):
                    """
                    .
                    """

            class vector_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.arrow3_dradius1_factor = self.__class__.arrow3_dradius1_factor(service, version, mode, path + ["arrow3_dradius1_factor"])
                    self.arrow3_dradius2_factor = self.__class__.arrow3_dradius2_factor(service, version, mode, path + ["arrow3_dradius2_factor"])
                    self.arrowhead3_dradius1_factor = self.__class__.arrowhead3_dradius1_factor(service, version, mode, path + ["arrowhead3_dradius1_factor"])
                    self.line_arrow3_dperpendicular_radius = self.__class__.line_arrow3_dperpendicular_radius(service, version, mode, path + ["line_arrow3_dperpendicular_radius"])
                    super().__init__(service, version, mode, path)
                class arrow3_dradius1_factor(TUIMethod):
                    """
                    .
                    """
                class arrow3_dradius2_factor(TUIMethod):
                    """
                    .
                    """
                class arrowhead3_dradius1_factor(TUIMethod):
                    """
                    .
                    """
                class line_arrow3_dperpendicular_radius(TUIMethod):
                    """
                    .
                    """

        class mat_pro_app(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.beta_features = self.__class__.beta_features(service, version, mode, path + ["beta_features"])
                self.focus = self.__class__.focus(service, version, mode, path + ["focus"])
                self.warning = self.__class__.warning(service, version, mode, path + ["warning"])
                super().__init__(service, version, mode, path)
            class beta_features(TUIMethod):
                """
                .
                """
            class focus(TUIMethod):
                """
                .
                """
            class warning(TUIMethod):
                """
                .
                """

        class meshing_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.draw_settings = self.__class__.draw_settings(service, version, mode, path + ["draw_settings"])
                self.checkpointing_option = self.__class__.checkpointing_option(service, version, mode, path + ["checkpointing_option"])
                self.save_checkpoint_files = self.__class__.save_checkpoint_files(service, version, mode, path + ["save_checkpoint_files"])
                self.temp_folder = self.__class__.temp_folder(service, version, mode, path + ["temp_folder"])
                self.templates_folder = self.__class__.templates_folder(service, version, mode, path + ["templates_folder"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                super().__init__(service, version, mode, path)
            class checkpointing_option(TUIMethod):
                """
                .
                """
            class save_checkpoint_files(TUIMethod):
                """
                .
                """
            class temp_folder(TUIMethod):
                """
                .
                """
            class templates_folder(TUIMethod):
                """
                .
                """
            class verbosity(TUIMethod):
                """
                .
                """

            class draw_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.auto_draw = self.__class__.auto_draw(service, version, mode, path + ["auto_draw"])
                    self.face_zone_limit = self.__class__.face_zone_limit(service, version, mode, path + ["face_zone_limit"])
                    self.facet_limit = self.__class__.facet_limit(service, version, mode, path + ["facet_limit"])
                    super().__init__(service, version, mode, path)
                class auto_draw(TUIMethod):
                    """
                    .
                    """
                class face_zone_limit(TUIMethod):
                    """
                    .
                    """
                class facet_limit(TUIMethod):
                    """
                    .
                    """

        class navigation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.mouse_mapping = self.__class__.mouse_mapping(service, version, mode, path + ["mouse_mapping"])
                super().__init__(service, version, mode, path)

            class mouse_mapping(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.additional = self.__class__.additional(service, version, mode, path + ["additional"])
                    self.basic = self.__class__.basic(service, version, mode, path + ["basic"])
                    self.mousemaptheme = self.__class__.mousemaptheme(service, version, mode, path + ["mousemaptheme"])
                    super().__init__(service, version, mode, path)
                class mousemaptheme(TUIMethod):
                    """
                    .
                    """

                class additional(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.ctrllmbclick = self.__class__.ctrllmbclick(service, version, mode, path + ["ctrllmbclick"])
                        self.ctrllmbdrag = self.__class__.ctrllmbdrag(service, version, mode, path + ["ctrllmbdrag"])
                        self.ctrlmmbclick = self.__class__.ctrlmmbclick(service, version, mode, path + ["ctrlmmbclick"])
                        self.ctrlmmbdrag = self.__class__.ctrlmmbdrag(service, version, mode, path + ["ctrlmmbdrag"])
                        self.ctrlrmbclick = self.__class__.ctrlrmbclick(service, version, mode, path + ["ctrlrmbclick"])
                        self.ctrlrmbdrag = self.__class__.ctrlrmbdrag(service, version, mode, path + ["ctrlrmbdrag"])
                        self.mouseprobe = self.__class__.mouseprobe(service, version, mode, path + ["mouseprobe"])
                        self.mousewheel = self.__class__.mousewheel(service, version, mode, path + ["mousewheel"])
                        self.mousewheelsensitivity = self.__class__.mousewheelsensitivity(service, version, mode, path + ["mousewheelsensitivity"])
                        self.reversewheeldirection = self.__class__.reversewheeldirection(service, version, mode, path + ["reversewheeldirection"])
                        self.shiftlmbclick = self.__class__.shiftlmbclick(service, version, mode, path + ["shiftlmbclick"])
                        self.shiftlmbdrag = self.__class__.shiftlmbdrag(service, version, mode, path + ["shiftlmbdrag"])
                        self.shiftmmbclick = self.__class__.shiftmmbclick(service, version, mode, path + ["shiftmmbclick"])
                        self.shiftmmbdrag = self.__class__.shiftmmbdrag(service, version, mode, path + ["shiftmmbdrag"])
                        self.shiftrmbclick = self.__class__.shiftrmbclick(service, version, mode, path + ["shiftrmbclick"])
                        self.shiftrmbdrag = self.__class__.shiftrmbdrag(service, version, mode, path + ["shiftrmbdrag"])
                        super().__init__(service, version, mode, path)
                    class ctrllmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrllmbdrag(TUIMethod):
                        """
                        .
                        """
                    class ctrlmmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrlmmbdrag(TUIMethod):
                        """
                        .
                        """
                    class ctrlrmbclick(TUIMethod):
                        """
                        .
                        """
                    class ctrlrmbdrag(TUIMethod):
                        """
                        .
                        """
                    class mouseprobe(TUIMethod):
                        """
                        .
                        """
                    class mousewheel(TUIMethod):
                        """
                        .
                        """
                    class mousewheelsensitivity(TUIMethod):
                        """
                        .
                        """
                    class reversewheeldirection(TUIMethod):
                        """
                        .
                        """
                    class shiftlmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftlmbdrag(TUIMethod):
                        """
                        .
                        """
                    class shiftmmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftmmbdrag(TUIMethod):
                        """
                        .
                        """
                    class shiftrmbclick(TUIMethod):
                        """
                        .
                        """
                    class shiftrmbdrag(TUIMethod):
                        """
                        .
                        """

                class basic(TUIMenu):
                    """
                    .
                    """
                    def __init__(self, service, version, mode, path):
                        self.lmb = self.__class__.lmb(service, version, mode, path + ["lmb"])
                        self.lmbclick = self.__class__.lmbclick(service, version, mode, path + ["lmbclick"])
                        self.mmb = self.__class__.mmb(service, version, mode, path + ["mmb"])
                        self.mmbclick = self.__class__.mmbclick(service, version, mode, path + ["mmbclick"])
                        self.rmb = self.__class__.rmb(service, version, mode, path + ["rmb"])
                        self.rmbclick = self.__class__.rmbclick(service, version, mode, path + ["rmbclick"])
                        super().__init__(service, version, mode, path)
                    class lmb(TUIMethod):
                        """
                        .
                        """
                    class lmbclick(TUIMethod):
                        """
                        .
                        """
                    class mmb(TUIMethod):
                        """
                        .
                        """
                    class mmbclick(TUIMethod):
                        """
                        .
                        """
                    class rmb(TUIMethod):
                        """
                        .
                        """
                    class rmbclick(TUIMethod):
                        """
                        .
                        """

        class prj_app(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.advanced_flag = self.__class__.advanced_flag(service, version, mode, path + ["advanced_flag"])
                self.beta_flag = self.__class__.beta_flag(service, version, mode, path + ["beta_flag"])
                self.cffoutput = self.__class__.cffoutput(service, version, mode, path + ["cffoutput"])
                self.default_folder = self.__class__.default_folder(service, version, mode, path + ["default_folder"])
                self.display_mesh_after_case_load = self.__class__.display_mesh_after_case_load(service, version, mode, path + ["display_mesh_after_case_load"])
                self.multi_console = self.__class__.multi_console(service, version, mode, path + ["multi_console"])
                self.ncpu = self.__class__.ncpu(service, version, mode, path + ["ncpu"])
                self.session_color = self.__class__.session_color(service, version, mode, path + ["session_color"])
                self.show_fluent_window = self.__class__.show_fluent_window(service, version, mode, path + ["show_fluent_window"])
                self.use_default_folder = self.__class__.use_default_folder(service, version, mode, path + ["use_default_folder"])
                self.use_fluent_graphics = self.__class__.use_fluent_graphics(service, version, mode, path + ["use_fluent_graphics"])
                self.use_launcher = self.__class__.use_launcher(service, version, mode, path + ["use_launcher"])
                super().__init__(service, version, mode, path)
            class advanced_flag(TUIMethod):
                """
                .
                """
            class beta_flag(TUIMethod):
                """
                .
                """
            class cffoutput(TUIMethod):
                """
                .
                """
            class default_folder(TUIMethod):
                """
                .
                """
            class display_mesh_after_case_load(TUIMethod):
                """
                .
                """
            class multi_console(TUIMethod):
                """
                .
                """
            class ncpu(TUIMethod):
                """
                .
                """
            class session_color(TUIMethod):
                """
                .
                """
            class show_fluent_window(TUIMethod):
                """
                .
                """
            class use_default_folder(TUIMethod):
                """
                .
                """
            class use_fluent_graphics(TUIMethod):
                """
                .
                """
            class use_launcher(TUIMethod):
                """
                .
                """

        class simulation(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
                self.flow_model = self.__class__.flow_model(service, version, mode, path + ["flow_model"])
                self.local_residual_scaling = self.__class__.local_residual_scaling(service, version, mode, path + ["local_residual_scaling"])
                super().__init__(service, version, mode, path)
            class flow_model(TUIMethod):
                """
                .
                """
            class local_residual_scaling(TUIMethod):
                """
                .
                """

            class report_definitions(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.automatic_plot_file = self.__class__.automatic_plot_file(service, version, mode, path + ["automatic_plot_file"])
                    self.report_plot_history_data_size = self.__class__.report_plot_history_data_size(service, version, mode, path + ["report_plot_history_data_size"])
                    super().__init__(service, version, mode, path)
                class automatic_plot_file(TUIMethod):
                    """
                    .
                    """
                class report_plot_history_data_size(TUIMethod):
                    """
                    .
                    """

        class turbo_workflow(TUIMenu):
            """
            .
            """
            def __init__(self, service, version, mode, path):
                self.cell_zone_settings = self.__class__.cell_zone_settings(service, version, mode, path + ["cell_zone_settings"])
                self.face_zone_settings = self.__class__.face_zone_settings(service, version, mode, path + ["face_zone_settings"])
                self.graphics_settings = self.__class__.graphics_settings(service, version, mode, path + ["graphics_settings"])
                self.checkpointing_option = self.__class__.checkpointing_option(service, version, mode, path + ["checkpointing_option"])
                self.save_checkpoint_files = self.__class__.save_checkpoint_files(service, version, mode, path + ["save_checkpoint_files"])
                super().__init__(service, version, mode, path)
            class checkpointing_option(TUIMethod):
                """
                .
                """
            class save_checkpoint_files(TUIMethod):
                """
                .
                """

            class cell_zone_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.czsearch_order = self.__class__.czsearch_order(service, version, mode, path + ["czsearch_order"])
                    self.rotating = self.__class__.rotating(service, version, mode, path + ["rotating"])
                    self.stationary = self.__class__.stationary(service, version, mode, path + ["stationary"])
                    super().__init__(service, version, mode, path)
                class czsearch_order(TUIMethod):
                    """
                    .
                    """
                class rotating(TUIMethod):
                    """
                    .
                    """
                class stationary(TUIMethod):
                    """
                    .
                    """

            class face_zone_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.blade_region = self.__class__.blade_region(service, version, mode, path + ["blade_region"])
                    self.fzsearch_order = self.__class__.fzsearch_order(service, version, mode, path + ["fzsearch_order"])
                    self.hub_region = self.__class__.hub_region(service, version, mode, path + ["hub_region"])
                    self.inlet_region = self.__class__.inlet_region(service, version, mode, path + ["inlet_region"])
                    self.interior_region = self.__class__.interior_region(service, version, mode, path + ["interior_region"])
                    self.outlet_region = self.__class__.outlet_region(service, version, mode, path + ["outlet_region"])
                    self.periodic1_region = self.__class__.periodic1_region(service, version, mode, path + ["periodic1_region"])
                    self.periodic2_region = self.__class__.periodic2_region(service, version, mode, path + ["periodic2_region"])
                    self.shroud_region = self.__class__.shroud_region(service, version, mode, path + ["shroud_region"])
                    self.symmetry_region = self.__class__.symmetry_region(service, version, mode, path + ["symmetry_region"])
                    self.tip1_region = self.__class__.tip1_region(service, version, mode, path + ["tip1_region"])
                    self.tip2_region = self.__class__.tip2_region(service, version, mode, path + ["tip2_region"])
                    super().__init__(service, version, mode, path)
                class blade_region(TUIMethod):
                    """
                    .
                    """
                class fzsearch_order(TUIMethod):
                    """
                    .
                    """
                class hub_region(TUIMethod):
                    """
                    .
                    """
                class inlet_region(TUIMethod):
                    """
                    .
                    """
                class interior_region(TUIMethod):
                    """
                    .
                    """
                class outlet_region(TUIMethod):
                    """
                    .
                    """
                class periodic1_region(TUIMethod):
                    """
                    .
                    """
                class periodic2_region(TUIMethod):
                    """
                    .
                    """
                class shroud_region(TUIMethod):
                    """
                    .
                    """
                class symmetry_region(TUIMethod):
                    """
                    .
                    """
                class tip1_region(TUIMethod):
                    """
                    .
                    """
                class tip2_region(TUIMethod):
                    """
                    .
                    """

            class graphics_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.auto_draw = self.__class__.auto_draw(service, version, mode, path + ["auto_draw"])
                    super().__init__(service, version, mode, path)
                class auto_draw(TUIMethod):
                    """
                    .
                    """

    class report(TUIMenu):
        """
        Enter the report menu.
        """
        def __init__(self, service, version, mode, path):
            self.dpm_histogram = self.__class__.dpm_histogram(service, version, mode, path + ["dpm_histogram"])
            self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
            self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
            self.reference_values = self.__class__.reference_values(service, version, mode, path + ["reference_values"])
            self.surface_integrals = self.__class__.surface_integrals(service, version, mode, path + ["surface_integrals"])
            self.volume_integrals = self.__class__.volume_integrals(service, version, mode, path + ["volume_integrals"])
            self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
            self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
            self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
            self.system = self.__class__.system(service, version, mode, path + ["system"])
            self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
            self.aero_optical_distortions = self.__class__.aero_optical_distortions(service, version, mode, path + ["aero_optical_distortions"])
            self.dpm_summary = self.__class__.dpm_summary(service, version, mode, path + ["dpm_summary"])
            self.dpm_extended_summary = self.__class__.dpm_extended_summary(service, version, mode, path + ["dpm_extended_summary"])
            self.dpm_zone_summaries_per_injection = self.__class__.dpm_zone_summaries_per_injection(service, version, mode, path + ["dpm_zone_summaries_per_injection"])
            self.dpm_sample = self.__class__.dpm_sample(service, version, mode, path + ["dpm_sample"])
            self.dpm_sample_output_udf = self.__class__.dpm_sample_output_udf(service, version, mode, path + ["dpm_sample_output_udf"])
            self.dpm_sample_sort_file = self.__class__.dpm_sample_sort_file(service, version, mode, path + ["dpm_sample_sort_file"])
            self.particle_summary = self.__class__.particle_summary(service, version, mode, path + ["particle_summary"])
            self.path_line_summary = self.__class__.path_line_summary(service, version, mode, path + ["path_line_summary"])
            self.print_histogram = self.__class__.print_histogram(service, version, mode, path + ["print_histogram"])
            self.write_histogram = self.__class__.write_histogram(service, version, mode, path + ["write_histogram"])
            self.projected_surface_area = self.__class__.projected_surface_area(service, version, mode, path + ["projected_surface_area"])
            self.species_mass_flow = self.__class__.species_mass_flow(service, version, mode, path + ["species_mass_flow"])
            self.element_mass_flow = self.__class__.element_mass_flow(service, version, mode, path + ["element_mass_flow"])
            self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
            self.uds_flow = self.__class__.uds_flow(service, version, mode, path + ["uds_flow"])
            self.mphase_summary = self.__class__.mphase_summary(service, version, mode, path + ["mphase_summary"])
            super().__init__(service, version, mode, path)
        class aero_optical_distortions(TUIMethod):
            """
            Optics report menu.
            """
        class dpm_summary(TUIMethod):
            """
            Prints discrete phase summary report.
            """
        class dpm_extended_summary(TUIMethod):
            """
            Create an extended discrete phase summary report of the discrete phase injection(s). You can choose whether you want to save the extended report to a file or print it in the console window. For unsteady tracking, you will be asked whether you want to include in-domain particle/tracks in the report. You will be also prompted whether you want to select a single injection for the summary report. By default, all injections are included. The output depends on whether you have enabled the report/dpm-zone-summaries-per-injection? text command, in which case additional information is printed for escaped particles, such as per-injection data. Note that, for unsteady particle tracking, it is necessary to enable the report/dpm-zone-summaries-per-injection? text command before any particle parcels are injected into the domain.
            """
        class dpm_zone_summaries_per_injection(TUIMethod):
            """
            Enables/disables calculation of the escaped mass per injection. Note that for unsteady particle tracking, if you want to report the mass of escaped particles per injection, this text command must be enabled before any particles are injected into the domain.
            """
        class dpm_sample(TUIMethod):
            """
            Samples trajectories at boundaries and lines/planes.
            """
        class dpm_sample_output_udf(TUIMethod):
            """
            Allows you to hook a previously loaded DEFINE_DPM_OUTPUT UDF for file format specification for sampling of trajectories and VOF-to-DPM lump conversion transcripts.
            """
        class dpm_sample_sort_file(TUIMethod):
            """
            Enables/disables writing of sorted DPM sample files.
            """
        class particle_summary(TUIMethod):
            """
            Prints summary report for all current particles.
            """
        class path_line_summary(TUIMethod):
            """
            Prints pathline summary report.
            """
        class print_histogram(TUIMethod):
            """
            Prints a histogram of a scalar quantity.
            """
        class write_histogram(TUIMethod):
            """
            Write a histogram of a scalar quantity to a file.
            """
        class projected_surface_area(TUIMethod):
            """
            Computes the area of the projection of selected surfaces along the  ,  , or   axis.
            """
        class species_mass_flow(TUIMethod):
            """
            Prints list of species mass flow rate at inlets and outlets. This reports the mass flow rates of all species (in kg/s) flowing through the simulation boundaries.
            """
        class element_mass_flow(TUIMethod):
            """
            Prints list of element flow rate at inlets and outlets. This reports the mass flow rates of all chemical elements (in kg/s) flowing through the simulation boundaries.
            """
        class summary(TUIMethod):
            """
            Prints the current settings for physical models, boundary conditions, material properties, and solution parameters.
            """
        class uds_flow(TUIMethod):
            """
            Prints list of user-defined scalar flow rate at boundaries.
            """
        class mphase_summary(TUIMethod):
            """
            Prints summary report for a multiphase case setup.
            """

        class dpm_histogram(TUIMenu):
            """
            Enters the DPM histogram menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                self.compute_sample = self.__class__.compute_sample(service, version, mode, path + ["compute_sample"])
                self.delete_sample = self.__class__.delete_sample(service, version, mode, path + ["delete_sample"])
                self.list_samples = self.__class__.list_samples(service, version, mode, path + ["list_samples"])
                self.plot_sample = self.__class__.plot_sample(service, version, mode, path + ["plot_sample"])
                self.read_sample = self.__class__.read_sample(service, version, mode, path + ["read_sample"])
                self.write_sample = self.__class__.write_sample(service, version, mode, path + ["write_sample"])
                self.pick_sample_to_reduce = self.__class__.pick_sample_to_reduce(service, version, mode, path + ["pick_sample_to_reduce"])
                self.reduce_picked_sample = self.__class__.reduce_picked_sample(service, version, mode, path + ["reduce_picked_sample"])
                super().__init__(service, version, mode, path)
            class compute_sample(TUIMethod):
                """
                Computes the minimum/maximum of a sample variable.
                """
            class delete_sample(TUIMethod):
                """
                Deletes a sample from the loaded sample list.
                """
            class list_samples(TUIMethod):
                """
                Shows all samples in a loaded sample list.
                """
            class plot_sample(TUIMethod):
                """
                Plots a histogram of a loaded sample.
                """
            class read_sample(TUIMethod):
                """
                Reads a sample file and adds it to the sample list.
                """
            class write_sample(TUIMethod):
                """
                Write a histogram of a loaded sample into a file.
                """
            class pick_sample_to_reduce(TUIMethod):
                """
                Select a sample to be reduced.
                """
            class reduce_picked_sample(TUIMethod):
                """
                Reduce a sample as specified by the data reduction parameters. This command is available only after you selected the sample using the pick-sample-to-reduce text command.
                """

            class set(TUIMenu):
                """
                Enters the settings menu for the histogram.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                    self.correlation = self.__class__.correlation(service, version, mode, path + ["correlation"])
                    self.cumulation_curve = self.__class__.cumulation_curve(service, version, mode, path + ["cumulation_curve"])
                    self.diameter_statistics = self.__class__.diameter_statistics(service, version, mode, path + ["diameter_statistics"])
                    self.histogram_mode = self.__class__.histogram_mode(service, version, mode, path + ["histogram_mode"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                    self.percentage = self.__class__.percentage(service, version, mode, path + ["percentage"])
                    self.variable_power_3 = self.__class__.variable_power_3(service, version, mode, path + ["variable_power_3"])
                    self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                    self.weighting = self.__class__.weighting(service, version, mode, path + ["weighting"])
                    super().__init__(service, version, mode, path)
                class auto_range(TUIMethod):
                    """
                    Automatically computes the range of the sampling variable for histogram plots.
                    """
                class correlation(TUIMethod):
                    """
                    Computes the correlation of the sampling variable with another variable.
                    """
                class cumulation_curve(TUIMethod):
                    """
                    Computes a cumulative curve for the sampling variable or correlation variable when correlation? is specified.
                    """
                class diameter_statistics(TUIMethod):
                    """
                    Computes the Rosin Rammler parameters, Sauter, and other mean diameters.
                    """
                class histogram_mode(TUIMethod):
                    """
                    Uses bars for the histogram plot or xy-style.
                    """
                class minimum(TUIMethod):
                    """
                    Specifies the minimum value of the x-axis variable for histogram plots.
                    """
                class maximum(TUIMethod):
                    """
                    Specifies the maximum value of the x-axis variable for histogram plots.
                    """
                class number_of_bins(TUIMethod):
                    """
                    Specifies the number of bins.
                    """
                class percentage(TUIMethod):
                    """
                    Uses percentages of bins to be computed.
                    """
                class variable_power_3(TUIMethod):
                    """
                    Use the cubic of the cumulation variable during computation of the cumulative curve.
                    When the particle mass was not sampled, the diameter can be used instead.
                    """
                class logarithmic(TUIMethod):
                    """
                    Enables/disables the use of logarithmic scaling on the abscissa of the histogram.
                    """
                class weighting(TUIMethod):
                    """
                    Uses weighting with additional variables when sorting data into samples.
                    """

            class setup_reduction(TUIMenu):
                """
                Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                """
                def __init__(self, service, version, mode, path):
                    self.use_weighting = self.__class__.use_weighting(service, version, mode, path + ["use_weighting"])
                    self.weighting_variable = self.__class__.weighting_variable(service, version, mode, path + ["weighting_variable"])
                    self.make_steady_from_unsteady_file = self.__class__.make_steady_from_unsteady_file(service, version, mode, path + ["make_steady_from_unsteady_file"])
                    self.reset_min_and_max = self.__class__.reset_min_and_max(service, version, mode, path + ["reset_min_and_max"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                    self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                    self.all_variables_number_of_bins = self.__class__.all_variables_number_of_bins(service, version, mode, path + ["all_variables_number_of_bins"])
                    self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                    super().__init__(service, version, mode, path)
                class use_weighting(TUIMethod):
                    """
                    Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                    """
                class weighting_variable(TUIMethod):
                    """
                    Choose the weighting variable for the averaging in each bin in the data reduction.
                    """
                class make_steady_from_unsteady_file(TUIMethod):
                    """
                    Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                    """
                class reset_min_and_max(TUIMethod):
                    """
                    Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                    """
                class minimum(TUIMethod):
                    """
                    Set the minimum value of the range to be considered for a specific variable in the data reduction.
                    """
                class maximum(TUIMethod):
                    """
                    Set the maximum value of the range to be considered for a specific variable in the data reduction.
                    """
                class logarithmic(TUIMethod):
                    """
                    Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                    """
                class number_of_bins(TUIMethod):
                    """
                    Set the number of bins to be used for a specific variable in the data reduction.
                    """
                class all_variables_number_of_bins(TUIMethod):
                    """
                    Set the number of bins to be used for ALL variables in the data reduction.
                    """
                class list_settings(TUIMethod):
                    """
                    List all user inputs for the sample picked for data reduction.
                    """

        class fluxes(TUIMenu):
            """
            Enters the fluxes menu.
            """
            def __init__(self, service, version, mode, path):
                self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                self.heat_transfer = self.__class__.heat_transfer(service, version, mode, path + ["heat_transfer"])
                self.heat_transfer_sensible = self.__class__.heat_transfer_sensible(service, version, mode, path + ["heat_transfer_sensible"])
                self.rad_heat_trans = self.__class__.rad_heat_trans(service, version, mode, path + ["rad_heat_trans"])
                self.film_mass_flow = self.__class__.film_mass_flow(service, version, mode, path + ["film_mass_flow"])
                self.film_heat_transfer = self.__class__.film_heat_transfer(service, version, mode, path + ["film_heat_transfer"])
                self.pressure_work = self.__class__.pressure_work(service, version, mode, path + ["pressure_work"])
                self.viscous_work = self.__class__.viscous_work(service, version, mode, path + ["viscous_work"])
                super().__init__(service, version, mode, path)
            class mass_flow(TUIMethod):
                """
                Prints mass flow rate at inlets and outlets.
                """
            class heat_transfer(TUIMethod):
                """
                Prints heat transfer rate at boundaries.
                """
            class heat_transfer_sensible(TUIMethod):
                """
                Prints the sensible heat transfer rate at the boundaries.
                """
            class rad_heat_trans(TUIMethod):
                """
                Prints radiation heat transfer rate at boundaries.
                """
            class film_mass_flow(TUIMethod):
                """
                Prints wall film mass flow rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
            class film_heat_transfer(TUIMethod):
                """
                Prints wall film heat transfer rate at boundaries. This text command is only available when you enable the Eulerian wall film model.
                """
            class pressure_work(TUIMethod):
                """
                Prints the pressure work rate at the boundaries. This text command is only available when the energy equation is enabled, the absolute velocity formulation is selected, and zone motion is enabled for a fluid cell zone.
                """
            class viscous_work(TUIMethod):
                """
                Prints the viscous work rate at the boundaries. This text command is only available when the energy equation is enabled and the pressure-based solver is selected.
                """

        class forces(TUIMenu):
            """
            Enters the forces menu.
            """
            def __init__(self, service, version, mode, path):
                self.wall_forces = self.__class__.wall_forces(service, version, mode, path + ["wall_forces"])
                self.wall_moments = self.__class__.wall_moments(service, version, mode, path + ["wall_moments"])
                self.pressure_center = self.__class__.pressure_center(service, version, mode, path + ["pressure_center"])
                super().__init__(service, version, mode, path)
            class wall_forces(TUIMethod):
                """
                Computes the forces along the specified force vector for all wall zones.
                """
            class wall_moments(TUIMethod):
                """
                Computes the moments about the specified moment center for all wall zones.
                """
            class pressure_center(TUIMethod):
                """
                Prints the center of pressure on wall zones.
                """

        class reference_values(TUIMenu):
            """
            Enters the reference value menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.area = self.__class__.area(service, version, mode, path + ["area"])
                self.depth = self.__class__.depth(service, version, mode, path + ["depth"])
                self.density = self.__class__.density(service, version, mode, path + ["density"])
                self.enthalpy = self.__class__.enthalpy(service, version, mode, path + ["enthalpy"])
                self.length = self.__class__.length(service, version, mode, path + ["length"])
                self.pressure = self.__class__.pressure(service, version, mode, path + ["pressure"])
                self.temperature = self.__class__.temperature(service, version, mode, path + ["temperature"])
                self.yplus = self.__class__.yplus(service, version, mode, path + ["yplus"])
                self.velocity = self.__class__.velocity(service, version, mode, path + ["velocity"])
                self.viscosity = self.__class__.viscosity(service, version, mode, path + ["viscosity"])
                self.zone = self.__class__.zone(service, version, mode, path + ["zone"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class area(TUIMethod):
                """
                Sets reference area for normalization.
                """
            class depth(TUIMethod):
                """
                Sets reference depth for volume calculation.
                """
            class density(TUIMethod):
                """
                Sets reference density for normalization.
                """
            class enthalpy(TUIMethod):
                """
                Sets reference enthalpy for enthalpy damping and normalization.
                """
            class length(TUIMethod):
                """
                Sets reference length for normalization.
                """
            class pressure(TUIMethod):
                """
                Sets reference pressure for normalization.
                """
            class temperature(TUIMethod):
                """
                Sets reference temperature for normalization.
                """
            class yplus(TUIMethod):
                """
                Sets reference yplus for calculation of Yplus Based Heat Transfer Coefficient.
                """
            class velocity(TUIMethod):
                """
                Sets reference velocity for normalization.
                """
            class viscosity(TUIMethod):
                """
                Sets reference viscosity for normalization.
                """
            class zone(TUIMethod):
                """
                Sets reference zone.
                """
            class list(TUIMethod):
                """
                Lists current reference values.
                """

            class compute(TUIMenu):
                """
                Computes reference values from zone boundary conditions.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """

        class surface_integrals(TUIMenu):
            """
            Enters the surface integral menu.
            """
            def __init__(self, service, version, mode, path):
                self.area = self.__class__.area(service, version, mode, path + ["area"])
                self.area_weighted_avg = self.__class__.area_weighted_avg(service, version, mode, path + ["area_weighted_avg"])
                self.facet_avg = self.__class__.facet_avg(service, version, mode, path + ["facet_avg"])
                self.facet_max = self.__class__.facet_max(service, version, mode, path + ["facet_max"])
                self.facet_min = self.__class__.facet_min(service, version, mode, path + ["facet_min"])
                self.flow_rate = self.__class__.flow_rate(service, version, mode, path + ["flow_rate"])
                self.integral = self.__class__.integral(service, version, mode, path + ["integral"])
                self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                self.mass_weighted_avg = self.__class__.mass_weighted_avg(service, version, mode, path + ["mass_weighted_avg"])
                self.standard_deviation = self.__class__.standard_deviation(service, version, mode, path + ["standard_deviation"])
                self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                self.uniformity_index_area_weighted = self.__class__.uniformity_index_area_weighted(service, version, mode, path + ["uniformity_index_area_weighted"])
                self.uniformity_index_mass_weighted = self.__class__.uniformity_index_mass_weighted(service, version, mode, path + ["uniformity_index_mass_weighted"])
                self.vector_based_flux = self.__class__.vector_based_flux(service, version, mode, path + ["vector_based_flux"])
                self.vector_flux = self.__class__.vector_flux(service, version, mode, path + ["vector_flux"])
                self.vector_weighted_average = self.__class__.vector_weighted_average(service, version, mode, path + ["vector_weighted_average"])
                self.vertex_avg = self.__class__.vertex_avg(service, version, mode, path + ["vertex_avg"])
                self.vertex_max = self.__class__.vertex_max(service, version, mode, path + ["vertex_max"])
                self.vertex_min = self.__class__.vertex_min(service, version, mode, path + ["vertex_min"])
                self.volume_flow_rate = self.__class__.volume_flow_rate(service, version, mode, path + ["volume_flow_rate"])
                super().__init__(service, version, mode, path)
            class area(TUIMethod):
                """
                Prints the area of the selected surfaces.
                """
            class area_weighted_avg(TUIMethod):
                """
                Print area-weighted average of scalar on surfaces.
                """
            class facet_avg(TUIMethod):
                """
                Prints the facet average of the specified quantity over the selected surfaces.
                """
            class facet_max(TUIMethod):
                """
                Prints the maximum of the specified quantity over facet centroids of the selected surfaces.
                """
            class facet_min(TUIMethod):
                """
                Prints the minimum of the specified quantity over facet centroids of the selected surfaces.
                """
            class flow_rate(TUIMethod):
                """
                Prints the flow rate of the specified quantity over the selected surfaces.
                """
            class integral(TUIMethod):
                """
                Prints the integral of the specified quantity over the selected surfaces. You can include a wildcard (\*) within the surface names.
                """
            class mass_flow_rate(TUIMethod):
                """
                Prints the mass flow rate through the selected surfaces.
                """
            class mass_weighted_avg(TUIMethod):
                """
                Prints the mass-averaged quantity over the selected surfaces.
                """
            class standard_deviation(TUIMethod):
                """
                Prints the standard deviation of the scalar at the facet centroids of the surface.
                """
            class sum(TUIMethod):
                """
                Prints sum of scalar at facet centroids of the surfaces.
                """
            class uniformity_index_area_weighted(TUIMethod):
                """
                Prints the area-weighted uniformity index of the specified quantity over the selected surfaces.
                """
            class uniformity_index_mass_weighted(TUIMethod):
                """
                Prints the mass-weighted uniformity index of the specified quantity over the selected surfaces.
                """
            class vector_based_flux(TUIMethod):
                """
                Prints the vector-based flux of the specified quantity over the selected surfaces.
                """
            class vector_flux(TUIMethod):
                """
                Prints the vector flux over the selected surfaces.
                """
            class vector_weighted_average(TUIMethod):
                """
                Prints the vector-averaged quantity over the selected surfaces.
                """
            class vertex_avg(TUIMethod):
                """
                Prints the vertex average of the specified quantity over the selected surfaces.
                """
            class vertex_max(TUIMethod):
                """
                Prints the maximum of the specified quantity over vertices of the selected surfaces.
                """
            class vertex_min(TUIMethod):
                """
                Prints the minimum of the specified quantity over vertices of the selected surfaces.
                """
            class volume_flow_rate(TUIMethod):
                """
                Prints the volume flow rate through the selected surfaces.
                """

        class volume_integrals(TUIMenu):
            """
            Enters the volume integral menu.
            """
            def __init__(self, service, version, mode, path):
                self.mass = self.__class__.mass(service, version, mode, path + ["mass"])
                self.mass_avg = self.__class__.mass_avg(service, version, mode, path + ["mass_avg"])
                self.mass_integral = self.__class__.mass_integral(service, version, mode, path + ["mass_integral"])
                self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                self.twopisum = self.__class__.twopisum(service, version, mode, path + ["twopisum"])
                self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                self.volume_avg = self.__class__.volume_avg(service, version, mode, path + ["volume_avg"])
                self.volume_integral = self.__class__.volume_integral(service, version, mode, path + ["volume_integral"])
                super().__init__(service, version, mode, path)
            class mass(TUIMethod):
                """
                Print total mass of specified cell zones.
                """
            class mass_avg(TUIMethod):
                """
                Prints mass-average of scalar over cell zones.
                """
            class mass_integral(TUIMethod):
                """
                Prints mass-weighted integral of scalar over cell zones.
                """
            class maximum(TUIMethod):
                """
                Prints maximum of scalar over all cell zones.
                """
            class minimum(TUIMethod):
                """
                Prints minimum of scalar over all cell zones.
                """
            class sum(TUIMethod):
                """
                Prints sum of scalar over all cell zones.
                """
            class twopisum(TUIMethod):
                """
                Prints sum of scalar over all cell zones multiplied by 2π.
                """
            class volume(TUIMethod):
                """
                Prints total volume of specified cell zones.
                """
            class volume_avg(TUIMethod):
                """
                Prints volume-weighted average of scalar over cell zones.
                """
            class volume_integral(TUIMethod):
                """
                Prints integral of scalar over cell zones.
                """

        class modified_setting(TUIMenu):
            """
            Enter the modified settings menu.
            """
            def __init__(self, service, version, mode, path):
                self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
                self.write_user_setting = self.__class__.write_user_setting(service, version, mode, path + ["write_user_setting"])
                super().__init__(service, version, mode, path)
            class modified_setting(TUIMethod):
                """
                Specify which areas of setup will be checked for non-default settings for generating the Modified Settings Summary table. The table is displayed tabbed with the graphics window.
                """
            class write_user_setting(TUIMethod):
                """
                Write the contents of the Modified Settings Summary table to a file.
                """

        class population_balance(TUIMenu):
            """
            Population Balance menu.
            """
            def __init__(self, service, version, mode, path):
                self.moments = self.__class__.moments(service, version, mode, path + ["moments"])
                self.number_density = self.__class__.number_density(service, version, mode, path + ["number_density"])
                super().__init__(service, version, mode, path)
            class moments(TUIMethod):
                """
                Set moments for population balance.
                """
            class number_density(TUIMethod):
                """
                Set number density functions.
                """

        class heat_exchanger(TUIMenu):
            """
            Enters the heat exchanger menu.
            """
            def __init__(self, service, version, mode, path):
                self.computed_heat_rejection = self.__class__.computed_heat_rejection(service, version, mode, path + ["computed_heat_rejection"])
                self.inlet_temperature = self.__class__.inlet_temperature(service, version, mode, path + ["inlet_temperature"])
                self.outlet_temperature = self.__class__.outlet_temperature(service, version, mode, path + ["outlet_temperature"])
                self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                self.specific_heat = self.__class__.specific_heat(service, version, mode, path + ["specific_heat"])
                super().__init__(service, version, mode, path)
            class computed_heat_rejection(TUIMethod):
                """
                Prints total heat rejection.
                """
            class inlet_temperature(TUIMethod):
                """
                Prints inlet temperature.
                """
            class outlet_temperature(TUIMethod):
                """
                Prints outlet temperature.
                """
            class mass_flow_rate(TUIMethod):
                """
                Prints mass flow rate.
                """
            class specific_heat(TUIMethod):
                """
                Prints fluid’s specific heat.
                """

        class system(TUIMenu):
            """
            Enters the system menu.
            """
            def __init__(self, service, version, mode, path):
                self.proc_stats = self.__class__.proc_stats(service, version, mode, path + ["proc_stats"])
                self.sys_stats = self.__class__.sys_stats(service, version, mode, path + ["sys_stats"])
                self.gpgpu_stats = self.__class__.gpgpu_stats(service, version, mode, path + ["gpgpu_stats"])
                self.time_stats = self.__class__.time_stats(service, version, mode, path + ["time_stats"])
                super().__init__(service, version, mode, path)
            class proc_stats(TUIMethod):
                """
                Prints ANSYS Fluent process information. This is used to report the memory usage of each of the ANSYS Fluent processes.
                """
            class sys_stats(TUIMethod):
                """
                System information. This is used to report the CPU configuration of the machines where ANSYS Fluent processes have been spawned.
                """
            class gpgpu_stats(TUIMethod):
                """
                Prints information about installed general purpose graphical processing units.
                """
            class time_stats(TUIMethod):
                """
                Timer information. This is used to report CPU timings for user and kernel processes and detailed solver timings.
                """

        class simulation_reports(TUIMenu):
            """
            Enter the simulation reports menu.
            """
            def __init__(self, service, version, mode, path):
                self.list_simulation_reports = self.__class__.list_simulation_reports(service, version, mode, path + ["list_simulation_reports"])
                self.generate_simulation_report = self.__class__.generate_simulation_report(service, version, mode, path + ["generate_simulation_report"])
                self.view_simulation_report = self.__class__.view_simulation_report(service, version, mode, path + ["view_simulation_report"])
                self.export_simulation_report_as_pdf = self.__class__.export_simulation_report_as_pdf(service, version, mode, path + ["export_simulation_report_as_pdf"])
                self.export_simulation_report_as_html = self.__class__.export_simulation_report_as_html(service, version, mode, path + ["export_simulation_report_as_html"])
                self.write_report_names_to_file = self.__class__.write_report_names_to_file(service, version, mode, path + ["write_report_names_to_file"])
                self.rename_simulation_report = self.__class__.rename_simulation_report(service, version, mode, path + ["rename_simulation_report"])
                self.duplicate_simulation_report = self.__class__.duplicate_simulation_report(service, version, mode, path + ["duplicate_simulation_report"])
                self.reset_report_to_defaults = self.__class__.reset_report_to_defaults(service, version, mode, path + ["reset_report_to_defaults"])
                self.delete_simulation_report = self.__class__.delete_simulation_report(service, version, mode, path + ["delete_simulation_report"])
                self.write_simulation_report_template_file = self.__class__.write_simulation_report_template_file(service, version, mode, path + ["write_simulation_report_template_file"])
                self.read_simulation_report_template_file = self.__class__.read_simulation_report_template_file(service, version, mode, path + ["read_simulation_report_template_file"])
                super().__init__(service, version, mode, path)
            class list_simulation_reports(TUIMethod):
                """
                List all report names.
                """
            class generate_simulation_report(TUIMethod):
                """
                Generate a new simulation report or regenerate an existing simulation report with the provided name.
                """
            class view_simulation_report(TUIMethod):
                """
                View a simulation report that has already been generated. In batch mode this will print the report's URL.
                """
            class export_simulation_report_as_pdf(TUIMethod):
                """
                Export the provided simulation report as a PDF file.
                """
            class export_simulation_report_as_html(TUIMethod):
                """
                Export the provided simulation report as HTML.
                """
            class write_report_names_to_file(TUIMethod):
                """
                Write the list of currently generated report names to a txt file.
                """
            class rename_simulation_report(TUIMethod):
                """
                Rename a report which has already been generated.
                """
            class duplicate_simulation_report(TUIMethod):
                """
                Duplicate a report and all of its settings to a new report.
                """
            class reset_report_to_defaults(TUIMethod):
                """
                Reset all report settings to default for the provided simulation report.
                """
            class delete_simulation_report(TUIMethod):
                """
                Delete the provided simulation report.
                """
            class write_simulation_report_template_file(TUIMethod):
                """
                Write a JSON template file with this case's Simulation Report settings.
                """
            class read_simulation_report_template_file(TUIMethod):
                """
                Read a JSON template file with existing Simulation Report settings.
                """

    class results(TUIMenu):
        """
        Enter results menu.
        """
        def __init__(self, service, version, mode, path):
            self.animate = self.__class__.animate(service, version, mode, path + ["animate"])
            self.graphics = self.__class__.graphics(service, version, mode, path + ["graphics"])
            self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
            self.report = self.__class__.report(service, version, mode, path + ["report"])
            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
            self.graphics_window = self.__class__.graphics_window(service, version, mode, path + ["graphics_window"])
            super().__init__(service, version, mode, path)

        class animate(TUIMenu):
            """
            Enter the animation menu.
            """
            def __init__(self, service, version, mode, path):
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                super().__init__(service, version, mode, path)

            class playback(TUIMenu):
                """
                Enter animation playback menu.
                """
                def __init__(self, service, version, mode, path):
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.read = self.__class__.read(service, version, mode, path + ["read"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.stored_view = self.__class__.stored_view(service, version, mode, path + ["stored_view"])
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    super().__init__(service, version, mode, path)
                class read(TUIMethod):
                    """
                    Read new animation from file or already-defined animations.
                    """
                class play(TUIMethod):
                    """
                    Play the selected animation.
                    """
                class write(TUIMethod):
                    """
                    Write animation sequence to the file.
                    """
                class delete(TUIMethod):
                    """
                    Delete animation sequence.
                    """
                class stored_view(TUIMethod):
                    """
                    Play the 3D animation sequence using the view stored in the sequence.
                    """
                class set_custom_frames(TUIMethod):
                    """
                    Set custom frames start, end, skip frames for video export.
                    """

                class video(TUIMenu):
                    """
                    Set options for exporting video file menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        super().__init__(service, version, mode, path)
                    class fps(TUIMethod):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                    class format(TUIMethod):
                        """
                        Set format for exporting video file.
                        """
                    class quality(TUIMethod):
                        """
                        Set quality for exporting video file.
                        """
                    class name(TUIMethod):
                        """
                        Exporting video file name.
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        Enable original resolution.
                        """
                    class scale(TUIMethod):
                        """
                        Set scale by which video resolution will expand.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class width(TUIMethod):
                        """
                        Set the width for exporting video file.
                        """
                    class height(TUIMethod):
                        """
                        Set the height for exporting video file.
                        """

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate_scale(TUIMethod):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                        class enable_h264(TUIMethod):
                            """
                            H264 encoding flag.
                            """
                        class bitrate(TUIMethod):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                        class compression_method(TUIMethod):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                        class keyframe(TUIMethod):
                            """
                            Set video keyframe rate for exporting video file.
                            """

        class graphics(TUIMenu):
            """
            Enter graphics menu.
            """
            def __init__(self, service, version, mode, path):
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
                self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                self.update_scene = self.__class__.update_scene(service, version, mode, path + ["update_scene"])
                self.annotate = self.__class__.annotate(service, version, mode, path + ["annotate"])
                self.clear_annotations = self.__class__.clear_annotations(service, version, mode, path + ["clear_annotations"])
                self.color_map = self.__class__.color_map(service, version, mode, path + ["color_map"])
                self.hsf_file = self.__class__.hsf_file(service, version, mode, path + ["hsf_file"])
                super().__init__(service, version, mode, path)
            class annotate(TUIMethod):
                """
                Add a text annotation string to the active graphics window.
                """
            class clear_annotations(TUIMethod):
                """
                Delete all annotation text.
                """
            class color_map(TUIMethod):
                """
                Enter the color-map menu.
                """
            class hsf_file(TUIMethod):
                """
                Display hoops stream file data to active graphics window.
                """

            class expert(TUIMenu):
                """
                Enter expert menu.
                """
                def __init__(self, service, version, mode, path):
                    self.flamelet_data = self.__class__.flamelet_data(service, version, mode, path + ["flamelet_data"])
                    self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                    self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                    self.pdf_data = self.__class__.pdf_data(service, version, mode, path + ["pdf_data"])
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.add_custom_vector = self.__class__.add_custom_vector(service, version, mode, path + ["add_custom_vector"])
                    self.contour = self.__class__.contour(service, version, mode, path + ["contour"])
                    self.display_custom_vector = self.__class__.display_custom_vector(service, version, mode, path + ["display_custom_vector"])
                    self.graphics_window_layout = self.__class__.graphics_window_layout(service, version, mode, path + ["graphics_window_layout"])
                    self.mesh = self.__class__.mesh(service, version, mode, path + ["mesh"])
                    self.mesh_outline = self.__class__.mesh_outline(service, version, mode, path + ["mesh_outline"])
                    self.mesh_partition_boundary = self.__class__.mesh_partition_boundary(service, version, mode, path + ["mesh_partition_boundary"])
                    self.multigrid_coarsening = self.__class__.multigrid_coarsening(service, version, mode, path + ["multigrid_coarsening"])
                    self.profile = self.__class__.profile(service, version, mode, path + ["profile"])
                    self.reacting_channel_curves = self.__class__.reacting_channel_curves(service, version, mode, path + ["reacting_channel_curves"])
                    self.re_render = self.__class__.re_render(service, version, mode, path + ["re_render"])
                    self.re_scale = self.__class__.re_scale(service, version, mode, path + ["re_scale"])
                    self.set_list_tree_separator = self.__class__.set_list_tree_separator(service, version, mode, path + ["set_list_tree_separator"])
                    self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
                    self.surface_mesh = self.__class__.surface_mesh(service, version, mode, path + ["surface_mesh"])
                    self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                    self.velocity_vector = self.__class__.velocity_vector(service, version, mode, path + ["velocity_vector"])
                    self.zone_mesh = self.__class__.zone_mesh(service, version, mode, path + ["zone_mesh"])
                    super().__init__(service, version, mode, path)
                class add_custom_vector(TUIMethod):
                    """
                    Add new custom vector definition.
                    """
                class contour(TUIMethod):
                    """
                    Display contours of a flow variable.
                    """
                class display_custom_vector(TUIMethod):
                    """
                    Display custom vector.
                    """
                class graphics_window_layout(TUIMethod):
                    """
                    Arrange the graphics window layout.
                    """
                class mesh(TUIMethod):
                    """
                    Display the mesh.
                    """
                class mesh_outline(TUIMethod):
                    """
                    Display the mesh boundaries.
                    """
                class mesh_partition_boundary(TUIMethod):
                    """
                    Display mesh partition boundaries.
                    """
                class multigrid_coarsening(TUIMethod):
                    """
                    Display a coarse mesh level from the last multigrid coarsening.
                    """
                class profile(TUIMethod):
                    """
                    Display profiles of a flow variable.
                    """
                class reacting_channel_curves(TUIMethod):
                    """
                    Plot/Report the reacting channel variables.
                    """
                class re_render(TUIMethod):
                    """
                    Re-render the last contour, profile, or velocity vector plot
                    with updated surfaces, meshes, lights, colormap, rendering options, etc.,
                    without recalculating the contour data.
                    """
                class re_scale(TUIMethod):
                    """
                    Re-render the last contour, profile, or velocity vector plot
                    with updated scale, surfaces, meshes, lights, colormap, rendering options, etc.,
                    without recalculating the field data.
                    """
                class set_list_tree_separator(TUIMethod):
                    """
                    Set the separator character for list tree.
                    """
                class surface_cells(TUIMethod):
                    """
                    Draw the cells on the specified surfaces.
                    """
                class surface_mesh(TUIMethod):
                    """
                    Draw the mesh defined by the specified surfaces.
                    """
                class vector(TUIMethod):
                    """
                    Display space vectors.
                    """
                class velocity_vector(TUIMethod):
                    """
                    Display velocity vectors.
                    """
                class zone_mesh(TUIMethod):
                    """
                    Draw the mesh defined by specified face zones.
                    """

                class flamelet_data(TUIMenu):
                    """
                    Display flamelet data.
                    """
                    def __init__(self, service, version, mode, path):
                        self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                        self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                        self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                        self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                        super().__init__(service, version, mode, path)
                    class draw_number_box(TUIMethod):
                        """
                        Enable/disable display of the numbers box.
                        """
                    class plot_1d_slice(TUIMethod):
                        """
                        Enable/disable plot of the 1D-slice.
                        """
                    class write_to_file(TUIMethod):
                        """
                        Enable/disable writing the 1D-slice to file instead of plot.
                        """
                    class carpet_plot(TUIMethod):
                        """
                        Enable/disable display of carpet plot of a property.
                        """

                class particle_tracks(TUIMenu):
                    """
                    Enter the particle tracks menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                        self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                        super().__init__(service, version, mode, path)
                    class particle_tracks(TUIMethod):
                        """
                        Calculate and display particle tracks from defined injections.
                        """
                    class plot_write_xy_plot(TUIMethod):
                        """
                        Plot or write XY plot of particle tracks.
                        """

                class path_lines(TUIMenu):
                    """
                    Enter the pathlines menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                        self.plot_write_xy_plot = self.__class__.plot_write_xy_plot(service, version, mode, path + ["plot_write_xy_plot"])
                        self.write_to_files = self.__class__.write_to_files(service, version, mode, path + ["write_to_files"])
                        super().__init__(service, version, mode, path)
                    class path_lines(TUIMethod):
                        """
                        Display pathlines from a surface.
                        """
                    class plot_write_xy_plot(TUIMethod):
                        """
                        Plot or write XY plot of pathline.
                        """
                    class write_to_files(TUIMethod):
                        """
                        Write Pathlines to a File.
                        """

                class pdf_data(TUIMenu):
                    """
                    Enter the PDF data menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.draw_number_box = self.__class__.draw_number_box(service, version, mode, path + ["draw_number_box"])
                        self.plot_1d_slice = self.__class__.plot_1d_slice(service, version, mode, path + ["plot_1d_slice"])
                        self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                        self.carpet_plot = self.__class__.carpet_plot(service, version, mode, path + ["carpet_plot"])
                        super().__init__(service, version, mode, path)
                    class draw_number_box(TUIMethod):
                        """
                        Enable/disable the display of the numbers box.
                        """
                    class plot_1d_slice(TUIMethod):
                        """
                        Enable/disable a plot of the 1D-slice.
                        """
                    class write_to_file(TUIMethod):
                        """
                        Enable/disable writing the 1D-slice to file instead of plot.
                        """
                    class carpet_plot(TUIMethod):
                        """
                        Enable/disable the display of a carpet plot of a property.
                        """

                class set(TUIMenu):
                    """
                    Enter the set menu to set display parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.colors = self.__class__.colors(service, version, mode, path + ["colors"])
                        self.contours = self.__class__.contours(service, version, mode, path + ["contours"])
                        self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                        self.lights = self.__class__.lights(service, version, mode, path + ["lights"])
                        self.particle_tracks = self.__class__.particle_tracks(service, version, mode, path + ["particle_tracks"])
                        self.path_lines = self.__class__.path_lines(service, version, mode, path + ["path_lines"])
                        self.rendering_options = self.__class__.rendering_options(service, version, mode, path + ["rendering_options"])
                        self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                        self.velocity_vectors = self.__class__.velocity_vectors(service, version, mode, path + ["velocity_vectors"])
                        self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                        self.color_map = self.__class__.color_map(service, version, mode, path + ["color_map"])
                        self.element_shrink = self.__class__.element_shrink(service, version, mode, path + ["element_shrink"])
                        self.filled_mesh = self.__class__.filled_mesh(service, version, mode, path + ["filled_mesh"])
                        self.mesh_level = self.__class__.mesh_level(service, version, mode, path + ["mesh_level"])
                        self.mesh_partitions = self.__class__.mesh_partitions(service, version, mode, path + ["mesh_partitions"])
                        self.mesh_surfaces = self.__class__.mesh_surfaces(service, version, mode, path + ["mesh_surfaces"])
                        self.mesh_zones = self.__class__.mesh_zones(service, version, mode, path + ["mesh_zones"])
                        self.line_weight = self.__class__.line_weight(service, version, mode, path + ["line_weight"])
                        self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                        self.marker_symbol = self.__class__.marker_symbol(service, version, mode, path + ["marker_symbol"])
                        self.mesh_display_configuration = self.__class__.mesh_display_configuration(service, version, mode, path + ["mesh_display_configuration"])
                        self.mirror_zones = self.__class__.mirror_zones(service, version, mode, path + ["mirror_zones"])
                        self.n_stream_func = self.__class__.n_stream_func(service, version, mode, path + ["n_stream_func"])
                        self.nodewt_based_interp = self.__class__.nodewt_based_interp(service, version, mode, path + ["nodewt_based_interp"])
                        self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                        self.periodic_instancing = self.__class__.periodic_instancing(service, version, mode, path + ["periodic_instancing"])
                        self.proximity_zones = self.__class__.proximity_zones(service, version, mode, path + ["proximity_zones"])
                        self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                        self.reset_graphics = self.__class__.reset_graphics(service, version, mode, path + ["reset_graphics"])
                        self.zero_angle_dir = self.__class__.zero_angle_dir(service, version, mode, path + ["zero_angle_dir"])
                        self.duplicate_node_display = self.__class__.duplicate_node_display(service, version, mode, path + ["duplicate_node_display"])
                        super().__init__(service, version, mode, path)
                    class color_map(TUIMethod):
                        """
                        Enter the color-map menu.
                        """
                    class element_shrink(TUIMethod):
                        """
                        Set percentage to shrink elements.
                        """
                    class filled_mesh(TUIMethod):
                        """
                        Enable/disable the filled mesh option.
                        """
                    class mesh_level(TUIMethod):
                        """
                        Set coarse mesh level to be drawn.
                        """
                    class mesh_partitions(TUIMethod):
                        """
                        Enable/disable drawing of the mesh partition boundaries.
                        """
                    class mesh_surfaces(TUIMethod):
                        """
                        Set surface IDs to be drawn as mesh.
                        """
                    class mesh_zones(TUIMethod):
                        """
                        Set zone IDs to be drawn as mesh.
                        """
                    class line_weight(TUIMethod):
                        """
                        Set the line-weight factor for the window.
                        """
                    class marker_size(TUIMethod):
                        """
                        Set the size of markers used to represent points.
                        """
                    class marker_symbol(TUIMethod):
                        """
                        Set the type of markers used to represent points.
                        """
                    class mesh_display_configuration(TUIMethod):
                        """
                        Set mesh display configuration.
                        """
                    class mirror_zones(TUIMethod):
                        """
                        Set zones to mirror the domain about.
                        """
                    class n_stream_func(TUIMethod):
                        """
                        Set the number of iterations used in computing stream function.
                        """
                    class nodewt_based_interp(TUIMethod):
                        """
                        Use more accurate node-weight based interpolation for postprocessing.
                        """
                    class overlays(TUIMethod):
                        """
                        Enable/disable overlays.
                        """
                    class periodic_instancing(TUIMethod):
                        """
                        Set periodic instancing.
                        """
                    class proximity_zones(TUIMethod):
                        """
                        Set zones to be used for boundary cell distance and boundary proximity.
                        """
                    class render_mesh(TUIMethod):
                        """
                        Enable/disable rendering the mesh on top of contours, vectors, etc.
                        """
                    class reset_graphics(TUIMethod):
                        """
                        Reset the graphics system.
                        """
                    class zero_angle_dir(TUIMethod):
                        """
                        Set the vector having zero angular coordinates.
                        """
                    class duplicate_node_display(TUIMethod):
                        """
                        Set flag to remove duplicate nodes in mesh display.
                        """

                    class colors(TUIMenu):
                        """
                        Enter the color options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.by_type = self.__class__.by_type(service, version, mode, path + ["by_type"])
                            self.by_surface = self.__class__.by_surface(service, version, mode, path + ["by_surface"])
                            self.background = self.__class__.background(service, version, mode, path + ["background"])
                            self.color_by_type = self.__class__.color_by_type(service, version, mode, path + ["color_by_type"])
                            self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                            self.far_field_faces = self.__class__.far_field_faces(service, version, mode, path + ["far_field_faces"])
                            self.inlet_faces = self.__class__.inlet_faces(service, version, mode, path + ["inlet_faces"])
                            self.interior_faces = self.__class__.interior_faces(service, version, mode, path + ["interior_faces"])
                            self.internal_faces = self.__class__.internal_faces(service, version, mode, path + ["internal_faces"])
                            self.outlet_faces = self.__class__.outlet_faces(service, version, mode, path + ["outlet_faces"])
                            self.overset_faces = self.__class__.overset_faces(service, version, mode, path + ["overset_faces"])
                            self.periodic_faces = self.__class__.periodic_faces(service, version, mode, path + ["periodic_faces"])
                            self.rans_les_interface_faces = self.__class__.rans_les_interface_faces(service, version, mode, path + ["rans_les_interface_faces"])
                            self.reset_user_colors = self.__class__.reset_user_colors(service, version, mode, path + ["reset_user_colors"])
                            self.show_user_colors = self.__class__.show_user_colors(service, version, mode, path + ["show_user_colors"])
                            self.symmetry_faces = self.__class__.symmetry_faces(service, version, mode, path + ["symmetry_faces"])
                            self.axis_faces = self.__class__.axis_faces(service, version, mode, path + ["axis_faces"])
                            self.free_surface_faces = self.__class__.free_surface_faces(service, version, mode, path + ["free_surface_faces"])
                            self.traction_faces = self.__class__.traction_faces(service, version, mode, path + ["traction_faces"])
                            self.user_color = self.__class__.user_color(service, version, mode, path + ["user_color"])
                            self.wall_faces = self.__class__.wall_faces(service, version, mode, path + ["wall_faces"])
                            self.interface_faces = self.__class__.interface_faces(service, version, mode, path + ["interface_faces"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.reset_colors = self.__class__.reset_colors(service, version, mode, path + ["reset_colors"])
                            self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                            self.skip_label = self.__class__.skip_label(service, version, mode, path + ["skip_label"])
                            self.automatic_skip = self.__class__.automatic_skip(service, version, mode, path + ["automatic_skip"])
                            self.graphics_color_theme = self.__class__.graphics_color_theme(service, version, mode, path + ["graphics_color_theme"])
                            super().__init__(service, version, mode, path)
                        class background(TUIMethod):
                            """
                            Set the background (window) color.
                            """
                        class color_by_type(TUIMethod):
                            """
                            Determine whether to color meshes by type or by surface (ID).
                            """
                        class foreground(TUIMethod):
                            """
                            Set the foreground (text and window frame) color.
                            """
                        class far_field_faces(TUIMethod):
                            """
                            Set the color of far field faces.
                            """
                        class inlet_faces(TUIMethod):
                            """
                            Set the color of inlet faces.
                            """
                        class interior_faces(TUIMethod):
                            """
                            Set the color of interior faces.
                            """
                        class internal_faces(TUIMethod):
                            """
                            Set the color of internal interface faces.
                            """
                        class outlet_faces(TUIMethod):
                            """
                            Set the color of outlet faces.
                            """
                        class overset_faces(TUIMethod):
                            """
                            Set the color of overset faces.
                            """
                        class periodic_faces(TUIMethod):
                            """
                            Set the color of periodic faces.
                            """
                        class rans_les_interface_faces(TUIMethod):
                            """
                            Set the color of RANS/LES interface faces.
                            """
                        class reset_user_colors(TUIMethod):
                            """
                            Reset all user colors.
                            """
                        class show_user_colors(TUIMethod):
                            """
                            List currently defined user colors.
                            """
                        class symmetry_faces(TUIMethod):
                            """
                            Set the color of symmetric faces.
                            """
                        class axis_faces(TUIMethod):
                            """
                            Set the color of axisymmetric faces.
                            """
                        class free_surface_faces(TUIMethod):
                            """
                            Set the color of free-surface faces.
                            """
                        class traction_faces(TUIMethod):
                            """
                            Set the color of traction faces.
                            """
                        class user_color(TUIMethod):
                            """
                            Explicitly set color of display zone.
                            """
                        class wall_faces(TUIMethod):
                            """
                            Set the color of wall faces.
                            """
                        class interface_faces(TUIMethod):
                            """
                            Set the color of mesh Interfaces.
                            """
                        class list(TUIMethod):
                            """
                            List available colors.
                            """
                        class reset_colors(TUIMethod):
                            """
                            Reset individual mesh surface colors to the defaults.
                            """
                        class surface(TUIMethod):
                            """
                            Set the color of surfaces.
                            """
                        class skip_label(TUIMethod):
                            """
                            Set the number of labels to be skipped in the colopmap scale.
                            """
                        class automatic_skip(TUIMethod):
                            """
                            Determine whether to skip labels in the colopmap scale automatically.
                            """
                        class graphics_color_theme(TUIMethod):
                            """
                            Enter the graphics color theme menu.
                            """

                        class by_type(TUIMenu):
                            """
                            Enter the zone type color and material assignment menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.type_name = self.__class__.type_name(service, version, mode, path + ["type_name"])
                                self.only_list_case_boundaries = self.__class__.only_list_case_boundaries(service, version, mode, path + ["only_list_case_boundaries"])
                                self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                                super().__init__(service, version, mode, path)
                            class only_list_case_boundaries(TUIMethod):
                                """
                                Only list the boundary types that are assigned in this case.
                                """
                            class use_inherent_material_color(TUIMethod):
                                """
                                Use inherent material color for boundary zones.
                                """
                            class reset(TUIMethod):
                                """
                                To reset colors and/or materials to the defaults.
                                """

                            class type_name(TUIMenu):
                                """
                                Select the boundary type to specify colors and/or materials.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                                    self.far_field = self.__class__.far_field(service, version, mode, path + ["far_field"])
                                    self.free_surface = self.__class__.free_surface(service, version, mode, path + ["free_surface"])
                                    self.inlet = self.__class__.inlet(service, version, mode, path + ["inlet"])
                                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                                    self.internal = self.__class__.internal(service, version, mode, path + ["internal"])
                                    self.outlet = self.__class__.outlet(service, version, mode, path + ["outlet"])
                                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                                    self.surface = self.__class__.surface(service, version, mode, path + ["surface"])
                                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                                    self.traction = self.__class__.traction(service, version, mode, path + ["traction"])
                                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                                    super().__init__(service, version, mode, path)

                                class axis(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class far_field(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class free_surface(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class inlet(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class interface(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class interior(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class internal(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class outlet(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class overset(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class periodic(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class rans_les_interface(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class surface(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class symmetry(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class traction(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                                class wall(TUIMenu):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                                        self.material = self.__class__.material(service, version, mode, path + ["material"])
                                        super().__init__(service, version, mode, path)
                                    class color(TUIMethod):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                    class material(TUIMethod):
                                        """
                                        Set a material for the selected boundary type.
                                        """

                        class by_surface(TUIMenu):
                            """
                            Enter the surface(s) color and material assignment menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                                self.use_inherent_material_color = self.__class__.use_inherent_material_color(service, version, mode, path + ["use_inherent_material_color"])
                                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                                self.list_surfaces_by_color = self.__class__.list_surfaces_by_color(service, version, mode, path + ["list_surfaces_by_color"])
                                self.list_surfaces_by_material = self.__class__.list_surfaces_by_material(service, version, mode, path + ["list_surfaces_by_material"])
                                super().__init__(service, version, mode, path)
                            class surfaces(TUIMethod):
                                """
                                Select the surface(s) to specify colors and/or materials.
                                """
                            class use_inherent_material_color(TUIMethod):
                                """
                                Use inherent material color for surfaces.
                                """
                            class reset(TUIMethod):
                                """
                                To reset colors and/or materials to the defaults.
                                """
                            class list_surfaces_by_color(TUIMethod):
                                """
                                To list the surfaces by its color.
                                """
                            class list_surfaces_by_material(TUIMethod):
                                """
                                To list the surfaces by its material.
                                """

                    class contours(TUIMenu):
                        """
                        Enter the contour options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                            self.clip_to_range = self.__class__.clip_to_range(service, version, mode, path + ["clip_to_range"])
                            self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                            self.filled_contours = self.__class__.filled_contours(service, version, mode, path + ["filled_contours"])
                            self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                            self.line_contours = self.__class__.line_contours(service, version, mode, path + ["line_contours"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.n_contour = self.__class__.n_contour(service, version, mode, path + ["n_contour"])
                            self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                            self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                            self.coloring = self.__class__.coloring(service, version, mode, path + ["coloring"])
                            super().__init__(service, version, mode, path)
                        class auto_range(TUIMethod):
                            """
                            Enable/disable auto-computation of range for contours.
                            """
                        class clip_to_range(TUIMethod):
                            """
                            Enable/disable the clip to range option for filled contours.
                            """
                        class surfaces(TUIMethod):
                            """
                            Set surfaces to be contoured.
                            """
                        class filled_contours(TUIMethod):
                            """
                            Enable/disable the filled contour option.
                            """
                        class global_range(TUIMethod):
                            """
                            Enable/disable the global range for contours option.
                            """
                        class line_contours(TUIMethod):
                            """
                            Enable/disable the filled contour option.
                            """
                        class log_scale(TUIMethod):
                            """
                            Enable/disable the use of a log scale.
                            """
                        class n_contour(TUIMethod):
                            """
                            Set the number of contour levels.
                            """
                        class node_values(TUIMethod):
                            """
                            Enable/disable the plot of node values.
                            """
                        class render_mesh(TUIMethod):
                            """
                            Determine whether or not to render the mesh on top of contours, vectors, etc.
                            """
                        class coloring(TUIMethod):
                            """
                            Select coloring option.
                            """

                    class picture(TUIMenu):
                        """
                        Enter the hardcopy/save-picture options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                            self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                            self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                            self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                            self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                            self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                            self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                            self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                            self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                            self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                            self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                            super().__init__(service, version, mode, path)
                        class invert_background(TUIMethod):
                            """
                            Use a white background when the picture is saved.
                            """
                        class landscape(TUIMethod):
                            """
                            Plot hardcopies in landscape or portrait orientation.
                            """
                        class preview(TUIMethod):
                            """
                            Display a preview image of a hardcopy.
                            """
                        class x_resolution(TUIMethod):
                            """
                            Set the width of raster-formatted images in pixels (0 implies current window size).
                            """
                        class y_resolution(TUIMethod):
                            """
                            Set the height of raster-formatted images in pixels (0 implies current window size).
                            """
                        class dpi(TUIMethod):
                            """
                            Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                            """
                        class use_window_resolution(TUIMethod):
                            """
                            Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                            """
                        class set_standard_resolution(TUIMethod):
                            """
                            Select from pre-defined resolution list.
                            """
                        class jpeg_hardcopy_quality(TUIMethod):
                            """
                            To set jpeg hardcopy quality.
                            """

                        class color_mode(TUIMenu):
                            """
                            Enter the hardcopy color mode menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.color = self.__class__.color(service, version, mode, path + ["color"])
                                self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                                self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                super().__init__(service, version, mode, path)
                            class color(TUIMethod):
                                """
                                Plot hardcopies in color.
                                """
                            class gray_scale(TUIMethod):
                                """
                                Convert color to grayscale for hardcopy.
                                """
                            class mono_chrome(TUIMethod):
                                """
                                Convert color to monochrome (black and white) for hardcopy.
                                """
                            class list(TUIMethod):
                                """
                                Display the current hardcopy color mode.
                                """

                        class driver(TUIMenu):
                            """
                            Enter the set hardcopy driver menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                                self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                                self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                                self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                                self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                                self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                                self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                                self.png = self.__class__.png(service, version, mode, path + ["png"])
                                self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                                self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                                self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                                self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                                self.list = self.__class__.list(service, version, mode, path + ["list"])
                                self.options = self.__class__.options(service, version, mode, path + ["options"])
                                super().__init__(service, version, mode, path)
                            class dump_window(TUIMethod):
                                """
                                Set the command used to dump the graphics window to a file.
                                """
                            class eps(TUIMethod):
                                """
                                Produce encapsulated PostScript (EPS) output for hardcopies.
                                """
                            class jpeg(TUIMethod):
                                """
                                Produce JPEG output for hardcopies.
                                """
                            class post_script(TUIMethod):
                                """
                                Produce PostScript output for hardcopies.
                                """
                            class ppm(TUIMethod):
                                """
                                Produce PPM output for hardcopies.
                                """
                            class tiff(TUIMethod):
                                """
                                Use TIFF output for hardcopies.
                                """
                            class png(TUIMethod):
                                """
                                Use PNG output for hardcopies.
                                """
                            class hsf(TUIMethod):
                                """
                                Use HSF output for hardcopies.
                                """
                            class avz(TUIMethod):
                                """
                                Use AVZ output for hardcopies.
                                """
                            class glb(TUIMethod):
                                """
                                Use GLB output for hardcopies.
                                """
                            class vrml(TUIMethod):
                                """
                                Use VRML output for hardcopies.
                                """
                            class list(TUIMethod):
                                """
                                List the current hardcopy driver.
                                """
                            class options(TUIMethod):
                                """
                                Set the hardcopy options. Available options are:
                                "no gamma correction", disables gamma correction of colors,
                                "physical size = (width,height)", where width and height
                                are the actual measurements of the printable area of the page
                                in centimeters.
                                "subscreen = (left,right,bottom,top)", where left,right,
                                bottom, and top are numbers in [-1,1] describing a subwindow on
                                the page in which to place the hardcopy.
                                The options may be combined by separating them with commas.
                                """

                            class post_format(TUIMenu):
                                """
                                Enter the PostScript driver format menu.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                                    self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                                    self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                                    self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                                    super().__init__(service, version, mode, path)
                                class fast_raster(TUIMethod):
                                    """
                                    Use the new raster format.
                                    """
                                class raster(TUIMethod):
                                    """
                                    Use the original raster format.
                                    """
                                class rle_raster(TUIMethod):
                                    """
                                    Use the run-length encoded raster format.
                                    """
                                class vector(TUIMethod):
                                    """
                                    Use vector format.
                                    """

                    class lights(TUIMenu):
                        """
                        Enter the lights menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.lighting_interpolation = self.__class__.lighting_interpolation(service, version, mode, path + ["lighting_interpolation"])
                            self.lights_on = self.__class__.lights_on(service, version, mode, path + ["lights_on"])
                            self.set_ambient_color = self.__class__.set_ambient_color(service, version, mode, path + ["set_ambient_color"])
                            self.set_light = self.__class__.set_light(service, version, mode, path + ["set_light"])
                            self.headlight_on = self.__class__.headlight_on(service, version, mode, path + ["headlight_on"])
                            super().__init__(service, version, mode, path)
                        class lights_on(TUIMethod):
                            """
                            Turn all active lighting on/off.
                            """
                        class set_ambient_color(TUIMethod):
                            """
                            Set the ambient light color for the scene.
                            """
                        class set_light(TUIMethod):
                            """
                            Add or modify a directional, colored light.
                            """
                        class headlight_on(TUIMethod):
                            """
                            Turn the light that moves with the camera on or off.
                            """

                        class lighting_interpolation(TUIMenu):
                            """
                            Set lighting interpolation method.
                            """
                            def __init__(self, service, version, mode, path):
                                self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                                self.flat = self.__class__.flat(service, version, mode, path + ["flat"])
                                self.gouraud = self.__class__.gouraud(service, version, mode, path + ["gouraud"])
                                self.phong = self.__class__.phong(service, version, mode, path + ["phong"])
                                super().__init__(service, version, mode, path)
                            class automatic(TUIMethod):
                                """
                                Choose Automatic to automatically select the best lighting method for a given graphics object.
                                """
                            class flat(TUIMethod):
                                """
                                Use flat shading for meshes and polygons.
                                """
                            class gouraud(TUIMethod):
                                """
                                Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                                """
                            class phong(TUIMethod):
                                """
                                Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                                """

                    class particle_tracks(TUIMenu):
                        """
                        Enter the particle-tracks menu to set parameters for display of particle tracks.
                        """
                        def __init__(self, service, version, mode, path):
                            self.sphere_settings = self.__class__.sphere_settings(service, version, mode, path + ["sphere_settings"])
                            self.vector_settings = self.__class__.vector_settings(service, version, mode, path + ["vector_settings"])
                            self.filter_settings = self.__class__.filter_settings(service, version, mode, path + ["filter_settings"])
                            self.display = self.__class__.display(service, version, mode, path + ["display"])
                            self.history_filename = self.__class__.history_filename(service, version, mode, path + ["history_filename"])
                            self.report_to = self.__class__.report_to(service, version, mode, path + ["report_to"])
                            self.report_type = self.__class__.report_type(service, version, mode, path + ["report_type"])
                            self.report_variables = self.__class__.report_variables(service, version, mode, path + ["report_variables"])
                            self.report_default_variables = self.__class__.report_default_variables(service, version, mode, path + ["report_default_variables"])
                            self.track_single_particle_stream = self.__class__.track_single_particle_stream(service, version, mode, path + ["track_single_particle_stream"])
                            self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                            self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                            self.coarsen_factor = self.__class__.coarsen_factor(service, version, mode, path + ["coarsen_factor"])
                            self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                            self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                            self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                            self.style = self.__class__.style(service, version, mode, path + ["style"])
                            self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                            self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                            self.particle_skip = self.__class__.particle_skip(service, version, mode, path + ["particle_skip"])
                            super().__init__(service, version, mode, path)
                        class display(TUIMethod):
                            """
                            Determine whether particle tracks will be displayed or only tracked.
                            """
                        class history_filename(TUIMethod):
                            """
                            Specify the name of the particle history file.
                            """
                        class report_to(TUIMethod):
                            """
                            Specify the destination for the report (console, file, none).
                            """
                        class report_type(TUIMethod):
                            """
                            Set the report type for particle tracks.
                            """
                        class report_variables(TUIMethod):
                            """
                            Set the report variables.
                            """
                        class report_default_variables(TUIMethod):
                            """
                            Set the report variables to default.
                            """
                        class track_single_particle_stream(TUIMethod):
                            """
                            Specify the stream ID to be tracked.
                            """
                        class arrow_scale(TUIMethod):
                            """
                            Set the scale factor for arrows drawn on particle tracks.
                            """
                        class arrow_space(TUIMethod):
                            """
                            Set the spacing factor for arrows drawn on particle tracks.
                            """
                        class coarsen_factor(TUIMethod):
                            """
                            Set the particle tracks coarsening factor.
                            """
                        class line_width(TUIMethod):
                            """
                            Set the width for particle track.
                            """
                        class marker_size(TUIMethod):
                            """
                            Set the marker size for particle drawing.
                            """
                        class radius(TUIMethod):
                            """
                            Set the radius for particle track (ribbons/cylinder only) cross-section.
                            """
                        class style(TUIMethod):
                            """
                            Set the display style for particle track (line/ribbon/cylinder/sphere).
                            """
                        class twist_factor(TUIMethod):
                            """
                            Set the scale factor for twisting (ribbons only).
                            """
                        class sphere_attrib(TUIMethod):
                            """
                            Specify size and number of slices to be used in drawing spheres.
                            """
                        class particle_skip(TUIMethod):
                            """
                            Specify how many particle tracks should be displayed.
                            """

                        class sphere_settings(TUIMenu):
                            """
                            Provide sphere specific input.
                            """
                            def __init__(self, service, version, mode, path):
                                self.vary_diameter = self.__class__.vary_diameter(service, version, mode, path + ["vary_diameter"])
                                self.diameter = self.__class__.diameter(service, version, mode, path + ["diameter"])
                                self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                                self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                                self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                                self.smooth_parameter = self.__class__.smooth_parameter(service, version, mode, path + ["smooth_parameter"])
                                self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                                self.size_variable = self.__class__.size_variable(service, version, mode, path + ["size_variable"])
                                super().__init__(service, version, mode, path)
                            class vary_diameter(TUIMethod):
                                """
                                Specify whether the spheres can vary with another variable.
                                """
                            class diameter(TUIMethod):
                                """
                                Diameter of the spheres when vary-diameter? is disabled.
                                """
                            class auto_range(TUIMethod):
                                """
                                Specify whether displayed spheres should include auto range of variable to size spheres.
                                """
                            class minimum(TUIMethod):
                                """
                                Set the minimum value of the sphere to be displayed.
                                """
                            class maximum(TUIMethod):
                                """
                                Set the maximum value of the sphere to be displayed.
                                """
                            class smooth_parameter(TUIMethod):
                                """
                                Specify number of slices to be used in drawing spheres.
                                """
                            class scale_factor(TUIMethod):
                                """
                                Specify a scale factor to enlarge/reduce the size of spheres.
                                """
                            class size_variable(TUIMethod):
                                """
                                Select a particle variable to size the spheres.
                                """

                        class vector_settings(TUIMenu):
                            """
                            Set vector specific input.
                            """
                            def __init__(self, service, version, mode, path):
                                self.style = self.__class__.style(service, version, mode, path + ["style"])
                                self.vector_length = self.__class__.vector_length(service, version, mode, path + ["vector_length"])
                                self.vector_length_variable = self.__class__.vector_length_variable(service, version, mode, path + ["vector_length_variable"])
                                self.scale_factor = self.__class__.scale_factor(service, version, mode, path + ["scale_factor"])
                                self.length_variable = self.__class__.length_variable(service, version, mode, path + ["length_variable"])
                                self.length_to_head_ratio = self.__class__.length_to_head_ratio(service, version, mode, path + ["length_to_head_ratio"])
                                self.constant_color = self.__class__.constant_color(service, version, mode, path + ["constant_color"])
                                self.color_variable = self.__class__.color_variable(service, version, mode, path + ["color_variable"])
                                self.vector_variable = self.__class__.vector_variable(service, version, mode, path + ["vector_variable"])
                                super().__init__(service, version, mode, path)
                            class style(TUIMethod):
                                """
                                Enable and set the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                                """
                            class vector_length(TUIMethod):
                                """
                                Specify the length of constant vectors.
                                """
                            class vector_length_variable(TUIMethod):
                                """
                                Select a particle variable to specify the length of vectors.
                                """
                            class scale_factor(TUIMethod):
                                """
                                Specify a scale factor to enlarge/reduce the length of vectors.
                                """
                            class length_variable(TUIMethod):
                                """
                                Specify whether the displayed vectors have length varying with another variable.
                                """
                            class length_to_head_ratio(TUIMethod):
                                """
                                Specify ratio of length to head for vectors and length to diameter for cylinders.
                                """
                            class constant_color(TUIMethod):
                                """
                                Specify a constant color for the vectors.
                                """
                            class color_variable(TUIMethod):
                                """
                                Specify whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                                """
                            class vector_variable(TUIMethod):
                                """
                                Select a particle vector function to specify vector direction.
                                """

                        class filter_settings(TUIMenu):
                            """
                            Set filter for particle display.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_filtering = self.__class__.enable_filtering(service, version, mode, path + ["enable_filtering"])
                                self.inside = self.__class__.inside(service, version, mode, path + ["inside"])
                                self.filter_variable = self.__class__.filter_variable(service, version, mode, path + ["filter_variable"])
                                self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                                self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                                super().__init__(service, version, mode, path)
                            class enable_filtering(TUIMethod):
                                """
                                Specify whether particle display is filtered.
                                """
                            class inside(TUIMethod):
                                """
                                Specify whether filter variable needs to be inside min/max to be displayed (else outside min/max).
                                """
                            class filter_variable(TUIMethod):
                                """
                                Select a variable used for filtering of particles.
                                """
                            class minimum(TUIMethod):
                                """
                                Specify the lower bound for the filter variable.
                                """
                            class maximum(TUIMethod):
                                """
                                Specify the upper bound for the filter variable.
                                """

                    class path_lines(TUIMenu):
                        """
                        Enter the path-lines menu to set parameters for the display of pathlines.
                        """
                        def __init__(self, service, version, mode, path):
                            self.arrow_scale = self.__class__.arrow_scale(service, version, mode, path + ["arrow_scale"])
                            self.arrow_space = self.__class__.arrow_space(service, version, mode, path + ["arrow_space"])
                            self.display_steps = self.__class__.display_steps(service, version, mode, path + ["display_steps"])
                            self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                            self.line_width = self.__class__.line_width(service, version, mode, path + ["line_width"])
                            self.marker_size = self.__class__.marker_size(service, version, mode, path + ["marker_size"])
                            self.maximum_steps = self.__class__.maximum_steps(service, version, mode, path + ["maximum_steps"])
                            self.maximum_error = self.__class__.maximum_error(service, version, mode, path + ["maximum_error"])
                            self.radius = self.__class__.radius(service, version, mode, path + ["radius"])
                            self.relative_pathlines = self.__class__.relative_pathlines(service, version, mode, path + ["relative_pathlines"])
                            self.style = self.__class__.style(service, version, mode, path + ["style"])
                            self.twist_factor = self.__class__.twist_factor(service, version, mode, path + ["twist_factor"])
                            self.step_size = self.__class__.step_size(service, version, mode, path + ["step_size"])
                            self.reverse = self.__class__.reverse(service, version, mode, path + ["reverse"])
                            self.sphere_attrib = self.__class__.sphere_attrib(service, version, mode, path + ["sphere_attrib"])
                            self.track_in_phase = self.__class__.track_in_phase(service, version, mode, path + ["track_in_phase"])
                            super().__init__(service, version, mode, path)
                        class arrow_scale(TUIMethod):
                            """
                            Set the scale factor for arrows drawn on pathlines.
                            """
                        class arrow_space(TUIMethod):
                            """
                            Set the spacing factor for arrows drawn on pathlines.
                            """
                        class display_steps(TUIMethod):
                            """
                            Set the display stepping for pathlines.
                            """
                        class error_control(TUIMethod):
                            """
                            Set error control during pathline computation.
                            """
                        class line_width(TUIMethod):
                            """
                            Set the width for pathlines.
                            """
                        class marker_size(TUIMethod):
                            """
                            Set the marker size for particle drawing.
                            """
                        class maximum_steps(TUIMethod):
                            """
                            Set the maximum number of steps to take for pathlines.
                            """
                        class maximum_error(TUIMethod):
                            """
                            Set the maximum error allowed while computing the pathlines.
                            """
                        class radius(TUIMethod):
                            """
                            Set the radius for pathline (ribbons/cylinder only) cross-section.
                            """
                        class relative_pathlines(TUIMethod):
                            """
                            Enable/disable the tracking of pathlines in a relative coordinate system.
                            """
                        class style(TUIMethod):
                            """
                            Set display style for pathlines (line/ribbon/cylinder).
                            """
                        class twist_factor(TUIMethod):
                            """
                            Set the scale factor for twisting (ribbons only).
                            """
                        class step_size(TUIMethod):
                            """
                            Set the step length between particle positions for path-lines.
                            """
                        class reverse(TUIMethod):
                            """
                            Enable/disable the direction of path tracking.
                            """
                        class sphere_attrib(TUIMethod):
                            """
                            Specify size and no. of slices to be used in drawing sphere for sphere-style.
                            """
                        class track_in_phase(TUIMethod):
                            """
                            Assign phase to display pathlines in.
                            """

                    class rendering_options(TUIMenu):
                        """
                        Enter the rendering options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                            self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                            self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                            self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                            self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                            self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                            self.outer_face_cull = self.__class__.outer_face_cull(service, version, mode, path + ["outer_face_cull"])
                            self.surface_edge_visibility = self.__class__.surface_edge_visibility(service, version, mode, path + ["surface_edge_visibility"])
                            self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                            self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                            self.help_text_color = self.__class__.help_text_color(service, version, mode, path + ["help_text_color"])
                            self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                            self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                            self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                            super().__init__(service, version, mode, path)
                        class auto_spin(TUIMethod):
                            """
                            Enable/disable mouse view rotations to continue to spin the display after the button is released.
                            """
                        class device_info(TUIMethod):
                            """
                            List information for the graphics device.
                            """
                        class double_buffering(TUIMethod):
                            """
                            Enable/disable double-buffering.
                            """
                        class driver(TUIMethod):
                            """
                            Change the current graphics driver.
                            """
                        class hidden_surfaces(TUIMethod):
                            """
                            Enable/disable hidden surface removal.
                            """
                        class hidden_surface_method(TUIMethod):
                            """
                            Specify the method to perform hidden line and hidden surface rendering.
                            """
                        class outer_face_cull(TUIMethod):
                            """
                            Enable/disable discarding outer faces during display.
                            """
                        class surface_edge_visibility(TUIMethod):
                            """
                            Set edge visibility flags for surfaces.
                            """
                        class animation_option(TUIMethod):
                            """
                            Using Wireframe / All option during animation.
                            """
                        class color_map_alignment(TUIMethod):
                            """
                            Set the color bar alignment.
                            """
                        class help_text_color(TUIMethod):
                            """
                            Set the color of screen help text.
                            """
                        class face_displacement(TUIMethod):
                            """
                            Set face displacement value in Z-buffer units along the Camera Z-axis.
                            """
                        class set_rendering_options(TUIMethod):
                            """
                            Set the rendering options.
                            """
                        class show_colormap(TUIMethod):
                            """
                            Enable/Disable colormap.
                            """

                    class titles(TUIMenu):
                        """
                        Set problem title.
                        """
                        def __init__(self, service, version, mode, path):
                            self.left_top = self.__class__.left_top(service, version, mode, path + ["left_top"])
                            self.left_bottom = self.__class__.left_bottom(service, version, mode, path + ["left_bottom"])
                            self.right_top = self.__class__.right_top(service, version, mode, path + ["right_top"])
                            self.right_middle = self.__class__.right_middle(service, version, mode, path + ["right_middle"])
                            self.right_bottom = self.__class__.right_bottom(service, version, mode, path + ["right_bottom"])
                            super().__init__(service, version, mode, path)
                        class left_top(TUIMethod):
                            """
                            Set the title text for left top in title segment.
                            """
                        class left_bottom(TUIMethod):
                            """
                            Set the title text for left bottom in title segment.
                            """
                        class right_top(TUIMethod):
                            """
                            Set the title text for right top in title segment.
                            """
                        class right_middle(TUIMethod):
                            """
                            Set the title text for right middle in title segment.
                            """
                        class right_bottom(TUIMethod):
                            """
                            Set the title text for right bottom in title segment.
                            """

                    class velocity_vectors(TUIMenu):
                        """
                        Enter the menu to set parameters for display of velocity vectors.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                            self.color = self.__class__.color(service, version, mode, path + ["color"])
                            self.component_x = self.__class__.component_x(service, version, mode, path + ["component_x"])
                            self.component_y = self.__class__.component_y(service, version, mode, path + ["component_y"])
                            self.component_z = self.__class__.component_z(service, version, mode, path + ["component_z"])
                            self.constant_length = self.__class__.constant_length(service, version, mode, path + ["constant_length"])
                            self.color_levels = self.__class__.color_levels(service, version, mode, path + ["color_levels"])
                            self.global_range = self.__class__.global_range(service, version, mode, path + ["global_range"])
                            self.in_plane = self.__class__.in_plane(service, version, mode, path + ["in_plane"])
                            self.log_scale = self.__class__.log_scale(service, version, mode, path + ["log_scale"])
                            self.node_values = self.__class__.node_values(service, version, mode, path + ["node_values"])
                            self.relative = self.__class__.relative(service, version, mode, path + ["relative"])
                            self.render_mesh = self.__class__.render_mesh(service, version, mode, path + ["render_mesh"])
                            self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                            self.scale_head = self.__class__.scale_head(service, version, mode, path + ["scale_head"])
                            self.style = self.__class__.style(service, version, mode, path + ["style"])
                            self.surfaces = self.__class__.surfaces(service, version, mode, path + ["surfaces"])
                            super().__init__(service, version, mode, path)
                        class auto_scale(TUIMethod):
                            """
                            Enable/disable auto-scale of all vectors so that vector overlap is minimal.
                            """
                        class color(TUIMethod):
                            """
                            Set the color used for all vectors. Set color to the null string to use the color map.
                            """
                        class component_x(TUIMethod):
                            """
                            Enable/disable use of x-component of vectors.
                            """
                        class component_y(TUIMethod):
                            """
                            Enable/disable use of y-component of vectors.
                            """
                        class component_z(TUIMethod):
                            """
                            Enable/disable use of z-component of vectors.
                            """
                        class constant_length(TUIMethod):
                            """
                            Enable/disable setting all vectors to have the same length.
                            """
                        class color_levels(TUIMethod):
                            """
                            Set the number of colors used from the color map.
                            """
                        class global_range(TUIMethod):
                            """
                            Enable/disable the global range for vectors option.
                            """
                        class in_plane(TUIMethod):
                            """
                            Toggle the display of in-plane velocity vectors.
                            """
                        class log_scale(TUIMethod):
                            """
                            Enable/disable the use of a log scale.
                            """
                        class node_values(TUIMethod):
                            """
                            Enable/disable plotting node values. Cell values will be plotted if "no".
                            """
                        class relative(TUIMethod):
                            """
                            Enable/disable the display of relative velocity vectors.
                            """
                        class render_mesh(TUIMethod):
                            """
                            Enable/disable rendering the mseh on top of contours, vectors, etc.
                            """
                        class scale(TUIMethod):
                            """
                            Set the value by which the vector length will be scaled.
                            """
                        class scale_head(TUIMethod):
                            """
                            Set the value by which the vector head will be scaled.
                            """
                        class style(TUIMethod):
                            """
                            Set the style with which the vectors will be drawn.
                            """
                        class surfaces(TUIMethod):
                            """
                            Set surfaces on which vectors are drawn.
                            """

                    class windows(TUIMenu):
                        """
                        Enter the window options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                            self.main = self.__class__.main(service, version, mode, path + ["main"])
                            self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                            self.text = self.__class__.text(service, version, mode, path + ["text"])
                            self.video = self.__class__.video(service, version, mode, path + ["video"])
                            self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                            self.aspect_ratio = self.__class__.aspect_ratio(service, version, mode, path + ["aspect_ratio"])
                            self.logo = self.__class__.logo(service, version, mode, path + ["logo"])
                            self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                            self.logo_color = self.__class__.logo_color(service, version, mode, path + ["logo_color"])
                            super().__init__(service, version, mode, path)
                        class aspect_ratio(TUIMethod):
                            """
                            Set the aspect ratio of the active window.
                            """
                        class logo(TUIMethod):
                            """
                            Enable/disable visibility of the logo in graphics window.
                            """
                        class ruler(TUIMethod):
                            """
                            Enable/disable ruler visibility.
                            """
                        class logo_color(TUIMethod):
                            """
                            Set logo color to white/black.
                            """

                        class axes(TUIMenu):
                            """
                            Enter the axes window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.border = self.__class__.border(service, version, mode, path + ["border"])
                                self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                                self.right = self.__class__.right(service, version, mode, path + ["right"])
                                self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                                super().__init__(service, version, mode, path)
                            class border(TUIMethod):
                                """
                                Enable/disable drawing of a border around the axes window.
                                """
                            class bottom(TUIMethod):
                                """
                                Set the bottom boundary of the axes window.
                                """
                            class clear(TUIMethod):
                                """
                                Set the transparency of the axes window.
                                """
                            class right(TUIMethod):
                                """
                                Set the right boundary of the axes window.
                                """
                            class visible(TUIMethod):
                                """
                                Enable/disable axes visibility.
                                """

                        class main(TUIMenu):
                            """
                            Enter the main view window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.border = self.__class__.border(service, version, mode, path + ["border"])
                                self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                                self.left = self.__class__.left(service, version, mode, path + ["left"])
                                self.right = self.__class__.right(service, version, mode, path + ["right"])
                                self.top = self.__class__.top(service, version, mode, path + ["top"])
                                self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                                super().__init__(service, version, mode, path)
                            class border(TUIMethod):
                                """
                                Enable/disable drawing of borders around the main viewing window.
                                """
                            class bottom(TUIMethod):
                                """
                                Set the bottom boundary of the main viewing window.
                                """
                            class left(TUIMethod):
                                """
                                Set the left boundary of the main viewing window.
                                """
                            class right(TUIMethod):
                                """
                                Set the right boundary of the main viewing window.
                                """
                            class top(TUIMethod):
                                """
                                Set the top boundary of the main viewing window.
                                """
                            class visible(TUIMethod):
                                """
                                Enable/disable visibility of the main viewing window.
                                """

                        class scale(TUIMenu):
                            """
                            Enter the color scale window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.border = self.__class__.border(service, version, mode, path + ["border"])
                                self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                                self.format = self.__class__.format(service, version, mode, path + ["format"])
                                self.font_size = self.__class__.font_size(service, version, mode, path + ["font_size"])
                                self.left = self.__class__.left(service, version, mode, path + ["left"])
                                self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                                self.right = self.__class__.right(service, version, mode, path + ["right"])
                                self.top = self.__class__.top(service, version, mode, path + ["top"])
                                self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                                self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                                super().__init__(service, version, mode, path)
                            class border(TUIMethod):
                                """
                                Enable/disable drawing of borders around the color scale window.
                                """
                            class bottom(TUIMethod):
                                """
                                Set the bottom boundary of the color scale window.
                                """
                            class clear(TUIMethod):
                                """
                                Set the transparency of the scale window.
                                """
                            class format(TUIMethod):
                                """
                                Set the number format of the color scale window (e.g. %0.2e).
                                """
                            class font_size(TUIMethod):
                                """
                                Set the font size of the color scale window.
                                """
                            class left(TUIMethod):
                                """
                                Set the left boundary of the color scale window.
                                """
                            class margin(TUIMethod):
                                """
                                Set the margin of the color scale window.
                                """
                            class right(TUIMethod):
                                """
                                Set the right boundary of the color scale window.
                                """
                            class top(TUIMethod):
                                """
                                Set the top boundary of the color scale window.
                                """
                            class visible(TUIMethod):
                                """
                                Enable/disable visibility of the color scale window.
                                """
                            class alignment(TUIMethod):
                                """
                                Set colormap to bottom/left/top/right.
                                """

                        class text(TUIMenu):
                            """
                            Enter the text window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.application = self.__class__.application(service, version, mode, path + ["application"])
                                self.border = self.__class__.border(service, version, mode, path + ["border"])
                                self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                                self.company = self.__class__.company(service, version, mode, path + ["company"])
                                self.date = self.__class__.date(service, version, mode, path + ["date"])
                                self.left = self.__class__.left(service, version, mode, path + ["left"])
                                self.right = self.__class__.right(service, version, mode, path + ["right"])
                                self.top = self.__class__.top(service, version, mode, path + ["top"])
                                self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                                super().__init__(service, version, mode, path)
                            class application(TUIMethod):
                                """
                                Enable/disable the application name in the picture.
                                """
                            class border(TUIMethod):
                                """
                                Enable/disable drawing of borders around the text window.
                                """
                            class bottom(TUIMethod):
                                """
                                Set the bottom boundary of the text window.
                                """
                            class clear(TUIMethod):
                                """
                                Enable/disable text window transparency.
                                """
                            class company(TUIMethod):
                                """
                                Enable/disable the company name in the picture.
                                """
                            class date(TUIMethod):
                                """
                                Enable/disable the date in the picture.
                                """
                            class left(TUIMethod):
                                """
                                Set the left boundary of the text window.
                                """
                            class right(TUIMethod):
                                """
                                Set the right boundary of the text window.
                                """
                            class top(TUIMethod):
                                """
                                Set the top boundary of the text window.
                                """
                            class visible(TUIMethod):
                                """
                                Enable/disable text window transparency.
                                """

                        class video(TUIMenu):
                            """
                            Enter the video window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.background = self.__class__.background(service, version, mode, path + ["background"])
                                self.color_filter = self.__class__.color_filter(service, version, mode, path + ["color_filter"])
                                self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                                self.on = self.__class__.on(service, version, mode, path + ["on"])
                                self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                                super().__init__(service, version, mode, path)
                            class background(TUIMethod):
                                """
                                Set the background color in the video picture.
                                """
                            class color_filter(TUIMethod):
                                """
                                Set the color filter options for the picture.
                                """
                            class foreground(TUIMethod):
                                """
                                Set the foreground color in the video picture.
                                """
                            class on(TUIMethod):
                                """
                                Enable/disable video picture settings.
                                """
                            class pixel_size(TUIMethod):
                                """
                                Set the window size in pixels.
                                """

                        class xy(TUIMenu):
                            """
                            Enter the X-Y plot window options menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.border = self.__class__.border(service, version, mode, path + ["border"])
                                self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                                self.left = self.__class__.left(service, version, mode, path + ["left"])
                                self.right = self.__class__.right(service, version, mode, path + ["right"])
                                self.top = self.__class__.top(service, version, mode, path + ["top"])
                                self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                                super().__init__(service, version, mode, path)
                            class border(TUIMethod):
                                """
                                Enable/disable drawing of a border around the X-Y plotter window.
                                """
                            class bottom(TUIMethod):
                                """
                                Set the bottom boundary of the X-Y plotter window.
                                """
                            class left(TUIMethod):
                                """
                                Set the left boundary of the X-Y plotter window.
                                """
                            class right(TUIMethod):
                                """
                                Set the right boundary of the X-Y plotter window.
                                """
                            class top(TUIMethod):
                                """
                                Set the top boundary of the X-Y plotter window.
                                """
                            class visible(TUIMethod):
                                """
                                Enable/disable X-Y plotter window visibility.
                                """

            class lights(TUIMenu):
                """
                Enter the lights menu.
                """
                def __init__(self, service, version, mode, path):
                    self.lighting_interpolation = self.__class__.lighting_interpolation(service, version, mode, path + ["lighting_interpolation"])
                    self.lights_on = self.__class__.lights_on(service, version, mode, path + ["lights_on"])
                    self.set_ambient_color = self.__class__.set_ambient_color(service, version, mode, path + ["set_ambient_color"])
                    self.set_light = self.__class__.set_light(service, version, mode, path + ["set_light"])
                    self.headlight_on = self.__class__.headlight_on(service, version, mode, path + ["headlight_on"])
                    super().__init__(service, version, mode, path)
                class lights_on(TUIMethod):
                    """
                    Turn all active lighting on/off.
                    """
                class set_ambient_color(TUIMethod):
                    """
                    Set the ambient light color for the scene.
                    """
                class set_light(TUIMethod):
                    """
                    Add or modify a directional, colored light.
                    """
                class headlight_on(TUIMethod):
                    """
                    Turn the light that moves with the camera on or off.
                    """

                class lighting_interpolation(TUIMenu):
                    """
                    Set lighting interpolation method.
                    """
                    def __init__(self, service, version, mode, path):
                        self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                        self.flat = self.__class__.flat(service, version, mode, path + ["flat"])
                        self.gouraud = self.__class__.gouraud(service, version, mode, path + ["gouraud"])
                        self.phong = self.__class__.phong(service, version, mode, path + ["phong"])
                        super().__init__(service, version, mode, path)
                    class automatic(TUIMethod):
                        """
                        Choose Automatic to automatically select the best lighting method for a given graphics object.
                        """
                    class flat(TUIMethod):
                        """
                        Use flat shading for meshes and polygons.
                        """
                    class gouraud(TUIMethod):
                        """
                        Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                        """
                    class phong(TUIMethod):
                        """
                        Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                        """

            class objects(TUIMenu):
                """
                Enter to add, edit, delete or display graphics objects.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.add_to_graphics = self.__class__.add_to_graphics(service, version, mode, path + ["add_to_graphics"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create new graphics object.
                    """
                class edit(TUIMethod):
                    """
                    Edit graphics object.
                    """
                class copy(TUIMethod):
                    """
                    Copy graphics object.
                    """
                class delete(TUIMethod):
                    """
                    Delete graphics object.
                    """
                class display(TUIMethod):
                    """
                    Display graphics object.
                    """
                class add_to_graphics(TUIMethod):
                    """
                    Add graphics object to existing graphics.
                    """

            class rendering_options(TUIMenu):
                """
                Enter the rendering options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.auto_spin = self.__class__.auto_spin(service, version, mode, path + ["auto_spin"])
                    self.device_info = self.__class__.device_info(service, version, mode, path + ["device_info"])
                    self.double_buffering = self.__class__.double_buffering(service, version, mode, path + ["double_buffering"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.hidden_surfaces = self.__class__.hidden_surfaces(service, version, mode, path + ["hidden_surfaces"])
                    self.hidden_surface_method = self.__class__.hidden_surface_method(service, version, mode, path + ["hidden_surface_method"])
                    self.outer_face_cull = self.__class__.outer_face_cull(service, version, mode, path + ["outer_face_cull"])
                    self.surface_edge_visibility = self.__class__.surface_edge_visibility(service, version, mode, path + ["surface_edge_visibility"])
                    self.animation_option = self.__class__.animation_option(service, version, mode, path + ["animation_option"])
                    self.color_map_alignment = self.__class__.color_map_alignment(service, version, mode, path + ["color_map_alignment"])
                    self.help_text_color = self.__class__.help_text_color(service, version, mode, path + ["help_text_color"])
                    self.face_displacement = self.__class__.face_displacement(service, version, mode, path + ["face_displacement"])
                    self.set_rendering_options = self.__class__.set_rendering_options(service, version, mode, path + ["set_rendering_options"])
                    self.show_colormap = self.__class__.show_colormap(service, version, mode, path + ["show_colormap"])
                    super().__init__(service, version, mode, path)
                class auto_spin(TUIMethod):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                class device_info(TUIMethod):
                    """
                    List information for the graphics device.
                    """
                class double_buffering(TUIMethod):
                    """
                    Enable/disable double-buffering.
                    """
                class driver(TUIMethod):
                    """
                    Change the current graphics driver.
                    """
                class hidden_surfaces(TUIMethod):
                    """
                    Enable/disable hidden surface removal.
                    """
                class hidden_surface_method(TUIMethod):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                class outer_face_cull(TUIMethod):
                    """
                    Enable/disable discarding outer faces during display.
                    """
                class surface_edge_visibility(TUIMethod):
                    """
                    Set edge visibility flags for surfaces.
                    """
                class animation_option(TUIMethod):
                    """
                    Using Wireframe / All option during animation.
                    """
                class color_map_alignment(TUIMethod):
                    """
                    Set the color bar alignment.
                    """
                class help_text_color(TUIMethod):
                    """
                    Set the color of screen help text.
                    """
                class face_displacement(TUIMethod):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                class set_rendering_options(TUIMethod):
                    """
                    Set the rendering options.
                    """
                class show_colormap(TUIMethod):
                    """
                    Enable/Disable colormap.
                    """

            class update_scene(TUIMenu):
                """
                Enter the scene options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.select_geometry = self.__class__.select_geometry(service, version, mode, path + ["select_geometry"])
                    self.overlays = self.__class__.overlays(service, version, mode, path + ["overlays"])
                    self.draw_frame = self.__class__.draw_frame(service, version, mode, path + ["draw_frame"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.display = self.__class__.display(service, version, mode, path + ["display"])
                    self.transform = self.__class__.transform(service, version, mode, path + ["transform"])
                    self.pathline = self.__class__.pathline(service, version, mode, path + ["pathline"])
                    self.iso_sweep = self.__class__.iso_sweep(service, version, mode, path + ["iso_sweep"])
                    self.time = self.__class__.time(service, version, mode, path + ["time"])
                    self.set_frame = self.__class__.set_frame(service, version, mode, path + ["set_frame"])
                    super().__init__(service, version, mode, path)
                class select_geometry(TUIMethod):
                    """
                    Select geometry to be updated.
                    """
                class overlays(TUIMethod):
                    """
                    Enable/disable the overlays option.
                    """
                class draw_frame(TUIMethod):
                    """
                    Enable/disable drawing of the bounding frame.
                    """
                class delete(TUIMethod):
                    """
                    Delete selected geometries.
                    """
                class display(TUIMethod):
                    """
                    Display selected geometries.
                    """
                class transform(TUIMethod):
                    """
                    Apply transformation matrix on selected geometries.
                    """
                class pathline(TUIMethod):
                    """
                    Change pathline attributes.
                    """
                class iso_sweep(TUIMethod):
                    """
                    Change iso-sweep values.
                    """
                class time(TUIMethod):
                    """
                    Change time-step value.
                    """
                class set_frame(TUIMethod):
                    """
                    Change frame options.
                    """

        class plot(TUIMenu):
            """
            Enter the XY plot menu.
            """
            def __init__(self, service, version, mode, path):
                self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(service, version, mode, path + ["ansys_sound_analysis"])
                self.cumulative_plot = self.__class__.cumulative_plot(service, version, mode, path + ["cumulative_plot"])
                self.flamelet_curves = self.__class__.flamelet_curves(service, version, mode, path + ["flamelet_curves"])
                self.circum_avg_axial = self.__class__.circum_avg_axial(service, version, mode, path + ["circum_avg_axial"])
                self.circum_avg_radial = self.__class__.circum_avg_radial(service, version, mode, path + ["circum_avg_radial"])
                self.change_fft_ref_pressure = self.__class__.change_fft_ref_pressure(service, version, mode, path + ["change_fft_ref_pressure"])
                self.fft = self.__class__.fft(service, version, mode, path + ["fft"])
                self.fft_set = self.__class__.fft_set(service, version, mode, path + ["fft_set"])
                self.file = self.__class__.file(service, version, mode, path + ["file"])
                self.datasources = self.__class__.datasources(service, version, mode, path + ["datasources"])
                self.display_profile_data = self.__class__.display_profile_data(service, version, mode, path + ["display_profile_data"])
                self.file_list = self.__class__.file_list(service, version, mode, path + ["file_list"])
                self.file_set = self.__class__.file_set(service, version, mode, path + ["file_set"])
                self.histogram = self.__class__.histogram(service, version, mode, path + ["histogram"])
                self.histogram_set = self.__class__.histogram_set(service, version, mode, path + ["histogram_set"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                self.plot_direction = self.__class__.plot_direction(service, version, mode, path + ["plot_direction"])
                self.residuals = self.__class__.residuals(service, version, mode, path + ["residuals"])
                self.residuals_set = self.__class__.residuals_set(service, version, mode, path + ["residuals_set"])
                self.solution = self.__class__.solution(service, version, mode, path + ["solution"])
                self.solution_set = self.__class__.solution_set(service, version, mode, path + ["solution_set"])
                self.set_boundary_val_off = self.__class__.set_boundary_val_off(service, version, mode, path + ["set_boundary_val_off"])
                self.label_alignment = self.__class__.label_alignment(service, version, mode, path + ["label_alignment"])
                super().__init__(service, version, mode, path)
            class circum_avg_axial(TUIMethod):
                """
                Compute iso-axial band surfaces and plot data vs axial coordinate on them.
                """
            class circum_avg_radial(TUIMethod):
                """
                Compute iso-radial band surfaces and plot data vs radius on them.
                """
            class change_fft_ref_pressure(TUIMethod):
                """
                Change acoustic reference pressure.
                """
            class fft(TUIMethod):
                """
                Plot FFT of file data.
                """
            class fft_set(TUIMethod):
                """
                Enter the menu to set histogram plot parameters.
                """
            class file(TUIMethod):
                """
                Plot data from file.
                """
            class datasources(TUIMethod):
                """
                Enter the menu to set data sources.
                """
            class display_profile_data(TUIMethod):
                """
                Plot profile data.
                """
            class file_list(TUIMethod):
                """
                Plot data from multiple files.
                """
            class file_set(TUIMethod):
                """
                Enter the menu to set file plot parameters.
                """
            class histogram(TUIMethod):
                """
                Plot a histogram of a specified scalar quantity.
                """
            class histogram_set(TUIMethod):
                """
                Enter the menu to set histogram plot parameters.
                """
            class plot(TUIMethod):
                """
                Plot solution on surfaces.
                """
            class plot_direction(TUIMethod):
                """
                Set plot direction for xy plot.
                """
            class residuals(TUIMethod):
                """
                Plot equation residual history.
                """
            class residuals_set(TUIMethod):
                """
                Enter the menu to set residual plot parameters.
                """
            class solution(TUIMethod):
                """
                Plot solution on surfaces and/or zones.
                """
            class solution_set(TUIMethod):
                """
                Enter the menu to set solution plot parameters.
                """
            class set_boundary_val_off(TUIMethod):
                """
                Set boundary value off when node values off for XY/Solution Plot.
                Note: This setting is valid for current Fluent session only.
                """
            class label_alignment(TUIMethod):
                """
                Set the alignment of xy plot label to horizontal or axis aligned.
                """

            class ansys_sound_analysis(TUIMenu):
                """
                Ansys Sound analysis and specification.
                """
                def __init__(self, service, version, mode, path):
                    self.write_files = self.__class__.write_files(service, version, mode, path + ["write_files"])
                    self.print_indicators = self.__class__.print_indicators(service, version, mode, path + ["print_indicators"])
                    super().__init__(service, version, mode, path)
                class write_files(TUIMethod):
                    """
                    Write Ansys Sound out files.
                    """
                class print_indicators(TUIMethod):
                    """
                    Print Ansys Sound indicators.
                    """

            class cumulative_plot(TUIMenu):
                """
                Plot Cumulative Force and Moments.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class axes(TUIMethod):
                    """
                    Set axes options of an object.
                    """
                class curves(TUIMethod):
                    """
                    Set curves options of an object.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """
                class plot(TUIMethod):
                    """
                    Plot the Cumulative Forces/Moments.
                    """
                class print(TUIMethod):
                    """
                    Print the Cumulative Forces/Moments.
                    """
                class write(TUIMethod):
                    """
                    Write the Cumulative Forces/Moments.
                    """

            class flamelet_curves(TUIMenu):
                """
                Plot flamelet curves.
                """
                def __init__(self, service, version, mode, path):
                    self.write_to_file = self.__class__.write_to_file(service, version, mode, path + ["write_to_file"])
                    self.plot_curves = self.__class__.plot_curves(service, version, mode, path + ["plot_curves"])
                    super().__init__(service, version, mode, path)
                class write_to_file(TUIMethod):
                    """
                    Write curve to a file instead of plot.
                    """
                class plot_curves(TUIMethod):
                    """
                    Plot of a property.
                    """

        class report(TUIMenu):
            """
            Enter the report menu.
            """
            def __init__(self, service, version, mode, path):
                self.dpm_histogram = self.__class__.dpm_histogram(service, version, mode, path + ["dpm_histogram"])
                self.fluxes = self.__class__.fluxes(service, version, mode, path + ["fluxes"])
                self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                self.reference_values = self.__class__.reference_values(service, version, mode, path + ["reference_values"])
                self.surface_integrals = self.__class__.surface_integrals(service, version, mode, path + ["surface_integrals"])
                self.volume_integrals = self.__class__.volume_integrals(service, version, mode, path + ["volume_integrals"])
                self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
                self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.system = self.__class__.system(service, version, mode, path + ["system"])
                self.simulation_reports = self.__class__.simulation_reports(service, version, mode, path + ["simulation_reports"])
                self.aero_optical_distortions = self.__class__.aero_optical_distortions(service, version, mode, path + ["aero_optical_distortions"])
                self.dpm_summary = self.__class__.dpm_summary(service, version, mode, path + ["dpm_summary"])
                self.dpm_extended_summary = self.__class__.dpm_extended_summary(service, version, mode, path + ["dpm_extended_summary"])
                self.dpm_zone_summaries_per_injection = self.__class__.dpm_zone_summaries_per_injection(service, version, mode, path + ["dpm_zone_summaries_per_injection"])
                self.dpm_sample = self.__class__.dpm_sample(service, version, mode, path + ["dpm_sample"])
                self.dpm_sample_output_udf = self.__class__.dpm_sample_output_udf(service, version, mode, path + ["dpm_sample_output_udf"])
                self.dpm_sample_sort_file = self.__class__.dpm_sample_sort_file(service, version, mode, path + ["dpm_sample_sort_file"])
                self.particle_summary = self.__class__.particle_summary(service, version, mode, path + ["particle_summary"])
                self.path_line_summary = self.__class__.path_line_summary(service, version, mode, path + ["path_line_summary"])
                self.print_histogram = self.__class__.print_histogram(service, version, mode, path + ["print_histogram"])
                self.write_histogram = self.__class__.write_histogram(service, version, mode, path + ["write_histogram"])
                self.projected_surface_area = self.__class__.projected_surface_area(service, version, mode, path + ["projected_surface_area"])
                self.species_mass_flow = self.__class__.species_mass_flow(service, version, mode, path + ["species_mass_flow"])
                self.element_mass_flow = self.__class__.element_mass_flow(service, version, mode, path + ["element_mass_flow"])
                self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
                self.uds_flow = self.__class__.uds_flow(service, version, mode, path + ["uds_flow"])
                self.mphase_summary = self.__class__.mphase_summary(service, version, mode, path + ["mphase_summary"])
                super().__init__(service, version, mode, path)
            class aero_optical_distortions(TUIMethod):
                """
                Optics report menu.
                """
            class dpm_summary(TUIMethod):
                """
                Print discrete phase summary report of particle fates.
                """
            class dpm_extended_summary(TUIMethod):
                """
                Print extended discrete phase summary report of particle fates, with options.
                """
            class dpm_zone_summaries_per_injection(TUIMethod):
                """
                Enable per-injection zone DPM summaries.
                """
            class dpm_sample(TUIMethod):
                """
                Sample trajectories at boundaries and lines/planes.
                """
            class dpm_sample_output_udf(TUIMethod):
                """
                Set the DPM sampling output UDF.
                """
            class dpm_sample_sort_file(TUIMethod):
                """
                Enable writing of sorted DPM sample files.
                """
            class particle_summary(TUIMethod):
                """
                Print summary report for all current particles.
                """
            class path_line_summary(TUIMethod):
                """
                Print path-line-summary report.
                """
            class print_histogram(TUIMethod):
                """
                Print a histogram of a scalar quantity.
                """
            class write_histogram(TUIMethod):
                """
                Write a histogram of a scalar quantity to a file.
                """
            class projected_surface_area(TUIMethod):
                """
                Print total area of the projection of a group of surfaces to a plane.
                """
            class species_mass_flow(TUIMethod):
                """
                Print list of species mass flow rates at boundaries.
                """
            class element_mass_flow(TUIMethod):
                """
                Print list of element mass flow rates at boundaries.
                """
            class summary(TUIMethod):
                """
                Print report summary.
                """
            class uds_flow(TUIMethod):
                """
                Print list of UDS flow rate at boundaries.
                """
            class mphase_summary(TUIMethod):
                """
                Multiphase Summary and Recommendations.
                """

            class dpm_histogram(TUIMenu):
                """
                Enter the DPM histogram menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.setup_reduction = self.__class__.setup_reduction(service, version, mode, path + ["setup_reduction"])
                    self.compute_sample = self.__class__.compute_sample(service, version, mode, path + ["compute_sample"])
                    self.delete_sample = self.__class__.delete_sample(service, version, mode, path + ["delete_sample"])
                    self.list_samples = self.__class__.list_samples(service, version, mode, path + ["list_samples"])
                    self.plot_sample = self.__class__.plot_sample(service, version, mode, path + ["plot_sample"])
                    self.read_sample = self.__class__.read_sample(service, version, mode, path + ["read_sample"])
                    self.write_sample = self.__class__.write_sample(service, version, mode, path + ["write_sample"])
                    self.pick_sample_to_reduce = self.__class__.pick_sample_to_reduce(service, version, mode, path + ["pick_sample_to_reduce"])
                    self.reduce_picked_sample = self.__class__.reduce_picked_sample(service, version, mode, path + ["reduce_picked_sample"])
                    super().__init__(service, version, mode, path)
                class compute_sample(TUIMethod):
                    """
                    Compute minimum/maximum of a sample variable.
                    """
                class delete_sample(TUIMethod):
                    """
                    Delete a sample from loaded sample list.
                    """
                class list_samples(TUIMethod):
                    """
                    Show all samples in loaded sample list.
                    """
                class plot_sample(TUIMethod):
                    """
                    Plot a histogram of a loaded sample.
                    """
                class read_sample(TUIMethod):
                    """
                    Read a sample file and add it to the sample list.
                    """
                class write_sample(TUIMethod):
                    """
                    Write a histogram of a loaded sample into a file.
                    """
                class pick_sample_to_reduce(TUIMethod):
                    """
                    Pick a sample for which to first set-up and then perform the data reduction.
                    """
                class reduce_picked_sample(TUIMethod):
                    """
                    Reduce a sample after first picking it and setting up all data-reduction options and parameters.
                    """

                class set(TUIMenu):
                    """
                    Enter the settings menu for the histogram.
                    """
                    def __init__(self, service, version, mode, path):
                        self.auto_range = self.__class__.auto_range(service, version, mode, path + ["auto_range"])
                        self.correlation = self.__class__.correlation(service, version, mode, path + ["correlation"])
                        self.cumulation_curve = self.__class__.cumulation_curve(service, version, mode, path + ["cumulation_curve"])
                        self.diameter_statistics = self.__class__.diameter_statistics(service, version, mode, path + ["diameter_statistics"])
                        self.histogram_mode = self.__class__.histogram_mode(service, version, mode, path + ["histogram_mode"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                        self.percentage = self.__class__.percentage(service, version, mode, path + ["percentage"])
                        self.variable_power_3 = self.__class__.variable_power_3(service, version, mode, path + ["variable_power_3"])
                        self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                        self.weighting = self.__class__.weighting(service, version, mode, path + ["weighting"])
                        super().__init__(service, version, mode, path)
                    class auto_range(TUIMethod):
                        """
                        Automatically compute range of sampling variable for histogram plots.
                        """
                    class correlation(TUIMethod):
                        """
                        Compute correlation of sampling variable with other variable.
                        """
                    class cumulation_curve(TUIMethod):
                        """
                        Compute a cumulative curve for sampling variable or correlation variable when correlation? was specified.
                        """
                    class diameter_statistics(TUIMethod):
                        """
                        Compute Rosin Rammler parameters, Sauter and other mean diameters.
                        Requires specification of diameter as sampling variable.
                        """
                    class histogram_mode(TUIMethod):
                        """
                        Use bars for histogram plot or xy-style.
                        """
                    class minimum(TUIMethod):
                        """
                        Specify mimimum value of x-axis variable for histogram plots.
                        """
                    class maximum(TUIMethod):
                        """
                        Specify maximum value of x-axis variable for histogram plots.
                        """
                    class number_of_bins(TUIMethod):
                        """
                        Specify the number of bins.
                        """
                    class percentage(TUIMethod):
                        """
                        Use percentages of bins to be computed.
                        """
                    class variable_power_3(TUIMethod):
                        """
                        Use the cubic of the cumulation variable during computation of the cumulative curve.
                        When the particle mass was not sampled, the diameter can be used instead.
                        """
                    class logarithmic(TUIMethod):
                        """
                        Use logarithmic scaling on the abscissa (variable axis)? -- Will not work unless all values are positive.
                        """
                    class weighting(TUIMethod):
                        """
                        Use weighting with additional variable when sorting data into samples.
                        """

                class setup_reduction(TUIMenu):
                    """
                    Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                    """
                    def __init__(self, service, version, mode, path):
                        self.use_weighting = self.__class__.use_weighting(service, version, mode, path + ["use_weighting"])
                        self.weighting_variable = self.__class__.weighting_variable(service, version, mode, path + ["weighting_variable"])
                        self.make_steady_from_unsteady_file = self.__class__.make_steady_from_unsteady_file(service, version, mode, path + ["make_steady_from_unsteady_file"])
                        self.reset_min_and_max = self.__class__.reset_min_and_max(service, version, mode, path + ["reset_min_and_max"])
                        self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                        self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                        self.logarithmic = self.__class__.logarithmic(service, version, mode, path + ["logarithmic"])
                        self.number_of_bins = self.__class__.number_of_bins(service, version, mode, path + ["number_of_bins"])
                        self.all_variables_number_of_bins = self.__class__.all_variables_number_of_bins(service, version, mode, path + ["all_variables_number_of_bins"])
                        self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                        super().__init__(service, version, mode, path)
                    class use_weighting(TUIMethod):
                        """
                        Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                        """
                    class weighting_variable(TUIMethod):
                        """
                        Choose the weighting variable for the averaging in each bin in the data reduction.
                        """
                    class make_steady_from_unsteady_file(TUIMethod):
                        """
                        Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                        """
                    class reset_min_and_max(TUIMethod):
                        """
                        Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                        """
                    class minimum(TUIMethod):
                        """
                        Set the minimum value of the range to be considered for a specific variable in the data reduction.
                        """
                    class maximum(TUIMethod):
                        """
                        Set the maximum value of the range to be considered for a specific variable in the data reduction.
                        """
                    class logarithmic(TUIMethod):
                        """
                        Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                        """
                    class number_of_bins(TUIMethod):
                        """
                        Set the number of bins to be used for a specific variable in the data reduction.
                        """
                    class all_variables_number_of_bins(TUIMethod):
                        """
                        Set the number of bins to be used for ALL variables in the data reduction.
                        """
                    class list_settings(TUIMethod):
                        """
                        List all user inputs for the sample picked for data reduction.
                        """

            class fluxes(TUIMenu):
                """
                Flux report menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                    self.heat_transfer = self.__class__.heat_transfer(service, version, mode, path + ["heat_transfer"])
                    self.heat_transfer_sensible = self.__class__.heat_transfer_sensible(service, version, mode, path + ["heat_transfer_sensible"])
                    self.rad_heat_trans = self.__class__.rad_heat_trans(service, version, mode, path + ["rad_heat_trans"])
                    self.film_mass_flow = self.__class__.film_mass_flow(service, version, mode, path + ["film_mass_flow"])
                    self.film_heat_transfer = self.__class__.film_heat_transfer(service, version, mode, path + ["film_heat_transfer"])
                    self.pressure_work = self.__class__.pressure_work(service, version, mode, path + ["pressure_work"])
                    self.viscous_work = self.__class__.viscous_work(service, version, mode, path + ["viscous_work"])
                    super().__init__(service, version, mode, path)
                class mass_flow(TUIMethod):
                    """
                    Print mass flow rate at inlets and outlets.
                    """
                class heat_transfer(TUIMethod):
                    """
                    Print heat transfer rate at boundaries.
                    """
                class heat_transfer_sensible(TUIMethod):
                    """
                    Print sensible heat transfer rate at boundaries.
                    """
                class rad_heat_trans(TUIMethod):
                    """
                    Print radiation heat transfer rate at boundaries.
                    """
                class film_mass_flow(TUIMethod):
                    """
                    Print film mass flow rate at boundaries.
                    """
                class film_heat_transfer(TUIMethod):
                    """
                    Print film heat transfer rate at boundaries.
                    """
                class pressure_work(TUIMethod):
                    """
                    Print pressure work rate at moving boundaries.
                    """
                class viscous_work(TUIMethod):
                    """
                    Print viscous work rate at boundaries.
                    """

            class forces(TUIMenu):
                """
                Force report menu.
                """
                def __init__(self, service, version, mode, path):
                    self.wall_forces = self.__class__.wall_forces(service, version, mode, path + ["wall_forces"])
                    self.wall_moments = self.__class__.wall_moments(service, version, mode, path + ["wall_moments"])
                    self.pressure_center = self.__class__.pressure_center(service, version, mode, path + ["pressure_center"])
                    super().__init__(service, version, mode, path)
                class wall_forces(TUIMethod):
                    """
                    Print integrated pressure and viscous forces on wall zones.
                    """
                class wall_moments(TUIMethod):
                    """
                    Print integrated pressure and viscous moments on wall zones.
                    """
                class pressure_center(TUIMethod):
                    """
                    Print center of pressure on wall zones.
                    """

            class reference_values(TUIMenu):
                """
                Reference value menu.
                """
                def __init__(self, service, version, mode, path):
                    self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                    self.area = self.__class__.area(service, version, mode, path + ["area"])
                    self.depth = self.__class__.depth(service, version, mode, path + ["depth"])
                    self.density = self.__class__.density(service, version, mode, path + ["density"])
                    self.enthalpy = self.__class__.enthalpy(service, version, mode, path + ["enthalpy"])
                    self.length = self.__class__.length(service, version, mode, path + ["length"])
                    self.pressure = self.__class__.pressure(service, version, mode, path + ["pressure"])
                    self.temperature = self.__class__.temperature(service, version, mode, path + ["temperature"])
                    self.yplus = self.__class__.yplus(service, version, mode, path + ["yplus"])
                    self.velocity = self.__class__.velocity(service, version, mode, path + ["velocity"])
                    self.viscosity = self.__class__.viscosity(service, version, mode, path + ["viscosity"])
                    self.zone = self.__class__.zone(service, version, mode, path + ["zone"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    super().__init__(service, version, mode, path)
                class area(TUIMethod):
                    """
                    Set reference area for normalization.
                    """
                class depth(TUIMethod):
                    """
                    Set reference depth for volume calculation.
                    """
                class density(TUIMethod):
                    """
                    Set reference density for normalization.
                    """
                class enthalpy(TUIMethod):
                    """
                    Set reference enthalpy for enthalpy damping and normalization.
                    """
                class length(TUIMethod):
                    """
                    Set reference length for normalization.
                    """
                class pressure(TUIMethod):
                    """
                    Set reference pressure for normalization.
                    """
                class temperature(TUIMethod):
                    """
                    Set reference temperature for normalization.
                    """
                class yplus(TUIMethod):
                    """
                    Set reference yplus for normalization.
                    """
                class velocity(TUIMethod):
                    """
                    Set reference velocity for normalization.
                    """
                class viscosity(TUIMethod):
                    """
                    Set reference viscosity for normalization.
                    """
                class zone(TUIMethod):
                    """
                    Set reference zone.
                    """
                class list(TUIMethod):
                    """
                    List current reference values.
                    """

                class compute(TUIMenu):
                    """
                    Enter the compute menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                        self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                        self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                        self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                        self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                        self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                        self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                        self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                        self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                        self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                        self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                        self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                        self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                        self.network = self.__class__.network(service, version, mode, path + ["network"])
                        self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                        self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                        self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                        self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                        self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                        self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                        self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                        self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                        self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                        self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                        self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                        self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                        self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                        self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                        self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                        self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                        self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                        self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                        super().__init__(service, version, mode, path)
                    class axis(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class degassing(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class dummy_entry(TUIMethod):
                        """
                        .
                        """
                    class exhaust_fan(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class fan(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class fluid(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class geometry(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class inlet_vent(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class intake_fan(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class interface(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class interior(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class mass_flow_inlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class mass_flow_outlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class network(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class network_end(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class outflow(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class outlet_vent(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class overset(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class periodic(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class porous_jump(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class pressure_far_field(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class pressure_inlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class pressure_outlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class radiator(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class rans_les_interface(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class recirculation_inlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class recirculation_outlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class shadow(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class solid(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class symmetry(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class velocity_inlet(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """
                    class wall(TUIMethod):
                        """
                        Compute reference values from a zone of this type.
                        """

            class surface_integrals(TUIMenu):
                """
                Surface Integral menu.
                """
                def __init__(self, service, version, mode, path):
                    self.area = self.__class__.area(service, version, mode, path + ["area"])
                    self.area_weighted_avg = self.__class__.area_weighted_avg(service, version, mode, path + ["area_weighted_avg"])
                    self.facet_avg = self.__class__.facet_avg(service, version, mode, path + ["facet_avg"])
                    self.facet_max = self.__class__.facet_max(service, version, mode, path + ["facet_max"])
                    self.facet_min = self.__class__.facet_min(service, version, mode, path + ["facet_min"])
                    self.flow_rate = self.__class__.flow_rate(service, version, mode, path + ["flow_rate"])
                    self.integral = self.__class__.integral(service, version, mode, path + ["integral"])
                    self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                    self.mass_weighted_avg = self.__class__.mass_weighted_avg(service, version, mode, path + ["mass_weighted_avg"])
                    self.standard_deviation = self.__class__.standard_deviation(service, version, mode, path + ["standard_deviation"])
                    self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                    self.uniformity_index_area_weighted = self.__class__.uniformity_index_area_weighted(service, version, mode, path + ["uniformity_index_area_weighted"])
                    self.uniformity_index_mass_weighted = self.__class__.uniformity_index_mass_weighted(service, version, mode, path + ["uniformity_index_mass_weighted"])
                    self.vector_based_flux = self.__class__.vector_based_flux(service, version, mode, path + ["vector_based_flux"])
                    self.vector_flux = self.__class__.vector_flux(service, version, mode, path + ["vector_flux"])
                    self.vector_weighted_average = self.__class__.vector_weighted_average(service, version, mode, path + ["vector_weighted_average"])
                    self.vertex_avg = self.__class__.vertex_avg(service, version, mode, path + ["vertex_avg"])
                    self.vertex_max = self.__class__.vertex_max(service, version, mode, path + ["vertex_max"])
                    self.vertex_min = self.__class__.vertex_min(service, version, mode, path + ["vertex_min"])
                    self.volume_flow_rate = self.__class__.volume_flow_rate(service, version, mode, path + ["volume_flow_rate"])
                    super().__init__(service, version, mode, path)
                class area(TUIMethod):
                    """
                    Print total area of surfaces.
                    """
                class area_weighted_avg(TUIMethod):
                    """
                    Print area-weighted average of scalar on surfaces.
                    """
                class facet_avg(TUIMethod):
                    """
                    Print average of scalar at facet centroids of the surfaces.
                    """
                class facet_max(TUIMethod):
                    """
                    Print maximum of scalar at facet centroids of the surfaces.
                    """
                class facet_min(TUIMethod):
                    """
                    Print minimum of scalar at facet centroids of the surfaces.
                    """
                class flow_rate(TUIMethod):
                    """
                    Print flow rate of scalar through surfaces.
                    """
                class integral(TUIMethod):
                    """
                    Print integral of scalar over surfaces.
                    """
                class mass_flow_rate(TUIMethod):
                    """
                    Print mass flow rate through surfaces.
                    """
                class mass_weighted_avg(TUIMethod):
                    """
                    Print mass-average of scalar over surfaces.
                    """
                class standard_deviation(TUIMethod):
                    """
                    Print standard deviation of scalar.
                    """
                class sum(TUIMethod):
                    """
                    Print sum of scalar at facet centroids of the surfaces.
                    """
                class uniformity_index_area_weighted(TUIMethod):
                    """
                    Print uniformity index of scalar over surfaces.
                    """
                class uniformity_index_mass_weighted(TUIMethod):
                    """
                    Print uniformity index of scalar over surfaces.
                    """
                class vector_based_flux(TUIMethod):
                    """
                    Print custom vector based flux.
                    """
                class vector_flux(TUIMethod):
                    """
                    Print custom vector flux.
                    """
                class vector_weighted_average(TUIMethod):
                    """
                    Print custom vector weighted average.
                    """
                class vertex_avg(TUIMethod):
                    """
                    Print average of scalar at vertices of the surfaces.
                    """
                class vertex_max(TUIMethod):
                    """
                    Print maximkum of scalar at vertices of the surfaces.
                    """
                class vertex_min(TUIMethod):
                    """
                    Print minimum of scalar at vertices of the surfaces.
                    """
                class volume_flow_rate(TUIMethod):
                    """
                    Print volume flow rate through surfaces.
                    """

            class volume_integrals(TUIMenu):
                """
                Volume Integral menu.
                """
                def __init__(self, service, version, mode, path):
                    self.mass = self.__class__.mass(service, version, mode, path + ["mass"])
                    self.mass_avg = self.__class__.mass_avg(service, version, mode, path + ["mass_avg"])
                    self.mass_integral = self.__class__.mass_integral(service, version, mode, path + ["mass_integral"])
                    self.maximum = self.__class__.maximum(service, version, mode, path + ["maximum"])
                    self.minimum = self.__class__.minimum(service, version, mode, path + ["minimum"])
                    self.sum = self.__class__.sum(service, version, mode, path + ["sum"])
                    self.twopisum = self.__class__.twopisum(service, version, mode, path + ["twopisum"])
                    self.volume = self.__class__.volume(service, version, mode, path + ["volume"])
                    self.volume_avg = self.__class__.volume_avg(service, version, mode, path + ["volume_avg"])
                    self.volume_integral = self.__class__.volume_integral(service, version, mode, path + ["volume_integral"])
                    super().__init__(service, version, mode, path)
                class mass(TUIMethod):
                    """
                    Print total mass of specified cell zones.
                    """
                class mass_avg(TUIMethod):
                    """
                    Print mass-average of scalar over cell zones.
                    """
                class mass_integral(TUIMethod):
                    """
                    Print mass-weighted integral of scalar over cell zones.
                    """
                class maximum(TUIMethod):
                    """
                    Print maximum of scalar over all cell zones.
                    """
                class minimum(TUIMethod):
                    """
                    Print minimum of scalar over all cell zones.
                    """
                class sum(TUIMethod):
                    """
                    Print sum of scalar over all cell zones.
                    """
                class twopisum(TUIMethod):
                    """
                    Print sum of scalar over all cell zones multiplied by 2\*Pi.
                    """
                class volume(TUIMethod):
                    """
                    Print total volume of specified cell zones.
                    """
                class volume_avg(TUIMethod):
                    """
                    Print volume-weighted average of scalar over cell zones.
                    """
                class volume_integral(TUIMethod):
                    """
                    Print integral of scalar over cell zones.
                    """

            class modified_setting(TUIMenu):
                """
                Enter the menu for setting up the Modified Settings Summary table.
                """
                def __init__(self, service, version, mode, path):
                    self.modified_setting = self.__class__.modified_setting(service, version, mode, path + ["modified_setting"])
                    self.write_user_setting = self.__class__.write_user_setting(service, version, mode, path + ["write_user_setting"])
                    super().__init__(service, version, mode, path)
                class modified_setting(TUIMethod):
                    """
                    Specify which settings will be checked for non-default status for generating the Modified Settings Summary table.
                    """
                class write_user_setting(TUIMethod):
                    """
                    Write the contents of the Modified Settings Summary table to a file.
                    """

            class population_balance(TUIMenu):
                """
                Population Balance menu.
                """
                def __init__(self, service, version, mode, path):
                    self.moments = self.__class__.moments(service, version, mode, path + ["moments"])
                    self.number_density = self.__class__.number_density(service, version, mode, path + ["number_density"])
                    super().__init__(service, version, mode, path)
                class moments(TUIMethod):
                    """
                    Set moments for population balance.
                    """
                class number_density(TUIMethod):
                    """
                    Set number density functions.
                    """

            class heat_exchanger(TUIMenu):
                """
                Enter the heat exchanger menu.
                """
                def __init__(self, service, version, mode, path):
                    self.computed_heat_rejection = self.__class__.computed_heat_rejection(service, version, mode, path + ["computed_heat_rejection"])
                    self.inlet_temperature = self.__class__.inlet_temperature(service, version, mode, path + ["inlet_temperature"])
                    self.outlet_temperature = self.__class__.outlet_temperature(service, version, mode, path + ["outlet_temperature"])
                    self.mass_flow_rate = self.__class__.mass_flow_rate(service, version, mode, path + ["mass_flow_rate"])
                    self.specific_heat = self.__class__.specific_heat(service, version, mode, path + ["specific_heat"])
                    super().__init__(service, version, mode, path)
                class computed_heat_rejection(TUIMethod):
                    """
                    Print total heat rejection.
                    """
                class inlet_temperature(TUIMethod):
                    """
                    Print inlet temperature.
                    """
                class outlet_temperature(TUIMethod):
                    """
                    Print outlet temperature.
                    """
                class mass_flow_rate(TUIMethod):
                    """
                    Print mass flow rate.
                    """
                class specific_heat(TUIMethod):
                    """
                    Print fluid's specific heat.
                    """

            class system(TUIMenu):
                """
                Sytem menu.
                """
                def __init__(self, service, version, mode, path):
                    self.proc_stats = self.__class__.proc_stats(service, version, mode, path + ["proc_stats"])
                    self.sys_stats = self.__class__.sys_stats(service, version, mode, path + ["sys_stats"])
                    self.gpgpu_stats = self.__class__.gpgpu_stats(service, version, mode, path + ["gpgpu_stats"])
                    self.time_stats = self.__class__.time_stats(service, version, mode, path + ["time_stats"])
                    super().__init__(service, version, mode, path)
                class proc_stats(TUIMethod):
                    """
                    Fluent process information.
                    """
                class sys_stats(TUIMethod):
                    """
                    System information.
                    """
                class gpgpu_stats(TUIMethod):
                    """
                    GPGPU information.
                    """
                class time_stats(TUIMethod):
                    """
                    Time usage information.
                    """

            class simulation_reports(TUIMenu):
                """
                Enter the simulation reports menu.
                """
                def __init__(self, service, version, mode, path):
                    self.list_simulation_reports = self.__class__.list_simulation_reports(service, version, mode, path + ["list_simulation_reports"])
                    self.generate_simulation_report = self.__class__.generate_simulation_report(service, version, mode, path + ["generate_simulation_report"])
                    self.view_simulation_report = self.__class__.view_simulation_report(service, version, mode, path + ["view_simulation_report"])
                    self.export_simulation_report_as_pdf = self.__class__.export_simulation_report_as_pdf(service, version, mode, path + ["export_simulation_report_as_pdf"])
                    self.export_simulation_report_as_html = self.__class__.export_simulation_report_as_html(service, version, mode, path + ["export_simulation_report_as_html"])
                    self.write_report_names_to_file = self.__class__.write_report_names_to_file(service, version, mode, path + ["write_report_names_to_file"])
                    self.rename_simulation_report = self.__class__.rename_simulation_report(service, version, mode, path + ["rename_simulation_report"])
                    self.duplicate_simulation_report = self.__class__.duplicate_simulation_report(service, version, mode, path + ["duplicate_simulation_report"])
                    self.reset_report_to_defaults = self.__class__.reset_report_to_defaults(service, version, mode, path + ["reset_report_to_defaults"])
                    self.delete_simulation_report = self.__class__.delete_simulation_report(service, version, mode, path + ["delete_simulation_report"])
                    self.write_simulation_report_template_file = self.__class__.write_simulation_report_template_file(service, version, mode, path + ["write_simulation_report_template_file"])
                    self.read_simulation_report_template_file = self.__class__.read_simulation_report_template_file(service, version, mode, path + ["read_simulation_report_template_file"])
                    super().__init__(service, version, mode, path)
                class list_simulation_reports(TUIMethod):
                    """
                    List all report names.
                    """
                class generate_simulation_report(TUIMethod):
                    """
                    Generate a new simulation report or regenerate an existing simulation report with the provided name.
                    """
                class view_simulation_report(TUIMethod):
                    """
                    View a simulation report that has already been generated. In batch mode this will print the report's URL.
                    """
                class export_simulation_report_as_pdf(TUIMethod):
                    """
                    Export the provided simulation report as a PDF file.
                    """
                class export_simulation_report_as_html(TUIMethod):
                    """
                    Export the provided simulation report as HTML.
                    """
                class write_report_names_to_file(TUIMethod):
                    """
                    Write the list of currently generated report names to a txt file.
                    """
                class rename_simulation_report(TUIMethod):
                    """
                    Rename a report which has already been generated.
                    """
                class duplicate_simulation_report(TUIMethod):
                    """
                    Duplicate a report and all of its settings to a new report.
                    """
                class reset_report_to_defaults(TUIMethod):
                    """
                    Reset all report settings to default for the provided simulation report.
                    """
                class delete_simulation_report(TUIMethod):
                    """
                    Delete the provided simulation report.
                    """
                class write_simulation_report_template_file(TUIMethod):
                    """
                    Write a JSON template file with this case's Simulation Report settings.
                    """
                class read_simulation_report_template_file(TUIMethod):
                    """
                    Read a JSON template file with existing Simulation Report settings.
                    """

        class surface(TUIMenu):
            """
            Enter the data surface manipulation menu.
            """
            def __init__(self, service, version, mode, path):
                self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.circle_slice = self.__class__.circle_slice(service, version, mode, path + ["circle_slice"])
                self.delete_surface = self.__class__.delete_surface(service, version, mode, path + ["delete_surface"])
                self.group_surfaces = self.__class__.group_surfaces(service, version, mode, path + ["group_surfaces"])
                self.ungroup_surface = self.__class__.ungroup_surface(service, version, mode, path + ["ungroup_surface"])
                self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
                self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
                self.expression_volume = self.__class__.expression_volume(service, version, mode, path + ["expression_volume"])
                self.multiple_iso_surfaces = self.__class__.multiple_iso_surfaces(service, version, mode, path + ["multiple_iso_surfaces"])
                self.line_slice = self.__class__.line_slice(service, version, mode, path + ["line_slice"])
                self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
                self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                self.mouse_line = self.__class__.mouse_line(service, version, mode, path + ["mouse_line"])
                self.mouse_plane = self.__class__.mouse_plane(service, version, mode, path + ["mouse_plane"])
                self.mouse_rake = self.__class__.mouse_rake(service, version, mode, path + ["mouse_rake"])
                self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
                self.plane = self.__class__.plane(service, version, mode, path + ["plane"])
                self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
                self.multiple_plane_surfaces = self.__class__.multiple_plane_surfaces(service, version, mode, path + ["multiple_plane_surfaces"])
                self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
                self.point_array = self.__class__.point_array(service, version, mode, path + ["point_array"])
                self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
                self.structural_point_surface = self.__class__.structural_point_surface(service, version, mode, path + ["structural_point_surface"])
                self.quadric_slice = self.__class__.quadric_slice(service, version, mode, path + ["quadric_slice"])
                self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
                self.rename_surface = self.__class__.rename_surface(service, version, mode, path + ["rename_surface"])
                self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
                self.ellipsoid_slice = self.__class__.ellipsoid_slice(service, version, mode, path + ["ellipsoid_slice"])
                self.cone_slice = self.__class__.cone_slice(service, version, mode, path + ["cone_slice"])
                self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
                self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
                self.create_imprint_surface = self.__class__.create_imprint_surface(service, version, mode, path + ["create_imprint_surface"])
                self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
                self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
                self.multiple_zone_surfaces = self.__class__.multiple_zone_surfaces(service, version, mode, path + ["multiple_zone_surfaces"])
                self.edit_surface = self.__class__.edit_surface(service, version, mode, path + ["edit_surface"])
                super().__init__(service, version, mode, path)
            class circle_slice(TUIMethod):
                """
                Extract a circular slice.
                """
            class delete_surface(TUIMethod):
                """
                Remove a defined data surface.
                """
            class group_surfaces(TUIMethod):
                """
                Group a set of surfaces.
                """
            class ungroup_surface(TUIMethod):
                """
                Ungroup the surface(if grouped).
                """
            class iso_clip(TUIMethod):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
            class iso_surface(TUIMethod):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
            class expression_volume(TUIMethod):
                """
                Create volume with boolean expression.
                """
            class multiple_iso_surfaces(TUIMethod):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
            class line_slice(TUIMethod):
                """
                Extract a linear slice.
                """
            class line_surface(TUIMethod):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
            class list_surfaces(TUIMethod):
                """
                List the number of facets in the defined surfaces.
                """
            class mouse_line(TUIMethod):
                """
                Define a line surface using the mouse to select two points.
                """
            class mouse_plane(TUIMethod):
                """
                Define a plane surface using the mouse to select three points.
                """
            class mouse_rake(TUIMethod):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
            class partition_surface(TUIMethod):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
            class plane(TUIMethod):
                """
                Create a plane given 3 points bounded by the domain.
                """
            class plane_surface(TUIMethod):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
            class multiple_plane_surfaces(TUIMethod):
                """
                Create multiple plane surfaces at specified spacing.
                """
            class plane_slice(TUIMethod):
                """
                Extract a planar slice.
                """
            class point_array(TUIMethod):
                """
                Extract a rectangular array of data points.
                """
            class point_surface(TUIMethod):
                """
                Define a "point" surface by specifying the coordinates.
                """
            class structural_point_surface(TUIMethod):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
            class quadric_slice(TUIMethod):
                """
                Extract a quadric slice.
                """
            class rake_surface(TUIMethod):
                """
                Define a "rake" surface by specifying the end points.
                """
            class rename_surface(TUIMethod):
                """
                Rename a defined data surface.
                """
            class sphere_slice(TUIMethod):
                """
                Extract a spherical slice.
                """
            class ellipsoid_slice(TUIMethod):
                """
                Extract a ellipsoid slice.
                """
            class cone_slice(TUIMethod):
                """
                Extract a cone slice.
                """
            class surface_cells(TUIMethod):
                """
                Extract all cells intersected by a data surface.
                """
            class transform_surface(TUIMethod):
                """
                Transform surface.
                """
            class create_imprint_surface(TUIMethod):
                """
                Imprint surface.
                """
            class zone_surface(TUIMethod):
                """
                Define a data surface on a mesh zone.
                """
            class reset_zone_surfaces(TUIMethod):
                """
                Reset case surface list.
                """
            class multiple_zone_surfaces(TUIMethod):
                """
                Create multiple data surfaces at a time.
                """
            class edit_surface(TUIMethod):
                """
                Edit a defined data surface.
                """

            class post_processing_volume(TUIMenu):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create_from_file = self.__class__.create_from_file(service, version, mode, path + ["create_from_file"])
                    self.create_octree = self.__class__.create_octree(service, version, mode, path + ["create_octree"])
                    super().__init__(service, version, mode, path)
                class create_from_file(TUIMethod):
                    """
                    Read post-processing mesh from file.
                    """
                class create_octree(TUIMethod):
                    """
                    Create post-processing octree mesh based on current case.
                    """

            class query(TUIMenu):
                """
                Enter surface query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                    self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                    self.named_surface_list = self.__class__.named_surface_list(service, version, mode, path + ["named_surface_list"])
                    self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                    self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                    super().__init__(service, version, mode, path)
                class delete_query(TUIMethod):
                    """
                    Delete saved query.
                    """
                class list_surfaces(TUIMethod):
                    """
                    List surfaces.
                    """
                class named_surface_list(TUIMethod):
                    """
                    Create named list of surfaces.
                    """
                class list_named_selection(TUIMethod):
                    """
                    List named selection of surface type.
                    """
                class list_queries(TUIMethod):
                    """
                    List all saved queries.
                    """

        class graphics_window(TUIMenu):
            """
            Enter graphics window menu.
            """
            def __init__(self, service, version, mode, path):
                self.embedded_windows = self.__class__.embedded_windows(service, version, mode, path + ["embedded_windows"])
                self.picture = self.__class__.picture(service, version, mode, path + ["picture"])
                self.windows = self.__class__.windows(service, version, mode, path + ["windows"])
                self.titles = self.__class__.titles(service, version, mode, path + ["titles"])
                self.views = self.__class__.views(service, version, mode, path + ["views"])
                self.display_states = self.__class__.display_states(service, version, mode, path + ["display_states"])
                self.view_sync = self.__class__.view_sync(service, version, mode, path + ["view_sync"])
                self.close_window = self.__class__.close_window(service, version, mode, path + ["close_window"])
                self.close_window_by_name = self.__class__.close_window_by_name(service, version, mode, path + ["close_window_by_name"])
                self.open_window = self.__class__.open_window(service, version, mode, path + ["open_window"])
                self.save_picture = self.__class__.save_picture(service, version, mode, path + ["save_picture"])
                self.set_window = self.__class__.set_window(service, version, mode, path + ["set_window"])
                self.set_window_by_name = self.__class__.set_window_by_name(service, version, mode, path + ["set_window_by_name"])
                self.update_layout = self.__class__.update_layout(service, version, mode, path + ["update_layout"])
                super().__init__(service, version, mode, path)
            class close_window(TUIMethod):
                """
                Close a user graphics window.
                """
            class close_window_by_name(TUIMethod):
                """
                Close a reserved graphics window by its name.
                """
            class open_window(TUIMethod):
                """
                Open a user graphics window.
                """
            class save_picture(TUIMethod):
                """
                Generate a "hardcopy" of the active window.
                """
            class set_window(TUIMethod):
                """
                Set a user graphics window to be the active window.
                """
            class set_window_by_name(TUIMethod):
                """
                Set a reserved graphics window to be the active window by its name.
                """
            class update_layout(TUIMethod):
                """
                Update the fluent layout.
                """

            class embedded_windows(TUIMenu):
                """
                Enter to embed, close, move-out embedded windows.
                """
                def __init__(self, service, version, mode, path):
                    self.close = self.__class__.close(service, version, mode, path + ["close"])
                    self.close_all = self.__class__.close_all(service, version, mode, path + ["close_all"])
                    self.embed_in = self.__class__.embed_in(service, version, mode, path + ["embed_in"])
                    self.move_out = self.__class__.move_out(service, version, mode, path + ["move_out"])
                    self.move_out_all = self.__class__.move_out_all(service, version, mode, path + ["move_out_all"])
                    super().__init__(service, version, mode, path)
                class close(TUIMethod):
                    """
                    Close an embedded window.
                    """
                class close_all(TUIMethod):
                    """
                    Close all embedded windows for given parent window.
                    """
                class embed_in(TUIMethod):
                    """
                    Embed Window into another window.
                    """
                class move_out(TUIMethod):
                    """
                    Move out an embedded window.
                    """
                class move_out_all(TUIMethod):
                    """
                    Move out all embedded windows for given parent window.
                    """

            class picture(TUIMenu):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                    self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                    self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                    self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                    self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                    self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                    self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                    self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                    self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                    self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                    self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                    super().__init__(service, version, mode, path)
                class invert_background(TUIMethod):
                    """
                    Use a white background when the picture is saved.
                    """
                class landscape(TUIMethod):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                class preview(TUIMethod):
                    """
                    Display a preview image of a hardcopy.
                    """
                class x_resolution(TUIMethod):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                class y_resolution(TUIMethod):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """
                class dpi(TUIMethod):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                class use_window_resolution(TUIMethod):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                class set_standard_resolution(TUIMethod):
                    """
                    Select from pre-defined resolution list.
                    """
                class jpeg_hardcopy_quality(TUIMethod):
                    """
                    To set jpeg hardcopy quality.
                    """

                class color_mode(TUIMenu):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color = self.__class__.color(service, version, mode, path + ["color"])
                        self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                        self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        super().__init__(service, version, mode, path)
                    class color(TUIMethod):
                        """
                        Plot hardcopies in color.
                        """
                    class gray_scale(TUIMethod):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                    class mono_chrome(TUIMethod):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """
                    class list(TUIMethod):
                        """
                        Display the current hardcopy color mode.
                        """

                class driver(TUIMenu):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                        self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                        self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                        self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                        self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                        self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                        self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                        self.png = self.__class__.png(service, version, mode, path + ["png"])
                        self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                        self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                        self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                        self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.options = self.__class__.options(service, version, mode, path + ["options"])
                        super().__init__(service, version, mode, path)
                    class dump_window(TUIMethod):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                    class eps(TUIMethod):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                    class jpeg(TUIMethod):
                        """
                        Produce JPEG output for hardcopies.
                        """
                    class post_script(TUIMethod):
                        """
                        Produce PostScript output for hardcopies.
                        """
                    class ppm(TUIMethod):
                        """
                        Produce PPM output for hardcopies.
                        """
                    class tiff(TUIMethod):
                        """
                        Use TIFF output for hardcopies.
                        """
                    class png(TUIMethod):
                        """
                        Use PNG output for hardcopies.
                        """
                    class hsf(TUIMethod):
                        """
                        Use HSF output for hardcopies.
                        """
                    class avz(TUIMethod):
                        """
                        Use AVZ output for hardcopies.
                        """
                    class glb(TUIMethod):
                        """
                        Use GLB output for hardcopies.
                        """
                    class vrml(TUIMethod):
                        """
                        Use VRML output for hardcopies.
                        """
                    class list(TUIMethod):
                        """
                        List the current hardcopy driver.
                        """
                    class options(TUIMethod):
                        """
                        Set the hardcopy options. Available options are:
                        "no gamma correction", disables gamma correction of colors,
                        "physical size = (width,height)", where width and height
                        are the actual measurements of the printable area of the page
                        in centimeters.
                        "subscreen = (left,right,bottom,top)", where left,right,
                        bottom, and top are numbers in [-1,1] describing a subwindow on
                        the page in which to place the hardcopy.
                        The options may be combined by separating them with commas.
                        """

                    class post_format(TUIMenu):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                            self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                            self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                            self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                            super().__init__(service, version, mode, path)
                        class fast_raster(TUIMethod):
                            """
                            Use the new raster format.
                            """
                        class raster(TUIMethod):
                            """
                            Use the original raster format.
                            """
                        class rle_raster(TUIMethod):
                            """
                            Use the run-length encoded raster format.
                            """
                        class vector(TUIMethod):
                            """
                            Use vector format.
                            """

            class windows(TUIMenu):
                """
                Enter the window options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.main = self.__class__.main(service, version, mode, path + ["main"])
                    self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                    self.text = self.__class__.text(service, version, mode, path + ["text"])
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.xy = self.__class__.xy(service, version, mode, path + ["xy"])
                    self.aspect_ratio = self.__class__.aspect_ratio(service, version, mode, path + ["aspect_ratio"])
                    self.logo = self.__class__.logo(service, version, mode, path + ["logo"])
                    self.ruler = self.__class__.ruler(service, version, mode, path + ["ruler"])
                    self.logo_color = self.__class__.logo_color(service, version, mode, path + ["logo_color"])
                    super().__init__(service, version, mode, path)
                class aspect_ratio(TUIMethod):
                    """
                    Set the aspect ratio of the active window.
                    """
                class logo(TUIMethod):
                    """
                    Enable/disable visibility of the logo in graphics window.
                    """
                class ruler(TUIMethod):
                    """
                    Enable/disable ruler visibility.
                    """
                class logo_color(TUIMethod):
                    """
                    Set logo color to white/black.
                    """

                class axes(TUIMenu):
                    """
                    Enter the axes window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of a border around the axes window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the axes window.
                        """
                    class clear(TUIMethod):
                        """
                        Set the transparency of the axes window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the axes window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable axes visibility.
                        """

                class main(TUIMenu):
                    """
                    Enter the main view window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the main viewing window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the main viewing window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the main viewing window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the main viewing window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the main viewing window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable visibility of the main viewing window.
                        """

                class scale(TUIMenu):
                    """
                    Enter the color scale window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.font_size = self.__class__.font_size(service, version, mode, path + ["font_size"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.margin = self.__class__.margin(service, version, mode, path + ["margin"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        self.alignment = self.__class__.alignment(service, version, mode, path + ["alignment"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the color scale window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the color scale window.
                        """
                    class clear(TUIMethod):
                        """
                        Set the transparency of the scale window.
                        """
                    class format(TUIMethod):
                        """
                        Set the number format of the color scale window (e.g. %0.2e).
                        """
                    class font_size(TUIMethod):
                        """
                        Set the font size of the color scale window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the color scale window.
                        """
                    class margin(TUIMethod):
                        """
                        Set the margin of the color scale window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the color scale window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the color scale window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable visibility of the color scale window.
                        """
                    class alignment(TUIMethod):
                        """
                        Set colormap to bottom/left/top/right.
                        """

                class text(TUIMenu):
                    """
                    Enter the text window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.application = self.__class__.application(service, version, mode, path + ["application"])
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                        self.company = self.__class__.company(service, version, mode, path + ["company"])
                        self.date = self.__class__.date(service, version, mode, path + ["date"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class application(TUIMethod):
                        """
                        Enable/disable the application name in the picture.
                        """
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of borders around the text window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the text window.
                        """
                    class clear(TUIMethod):
                        """
                        Enable/disable text window transparency.
                        """
                    class company(TUIMethod):
                        """
                        Enable/disable the company name in the picture.
                        """
                    class date(TUIMethod):
                        """
                        Enable/disable the date in the picture.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the text window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the text window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the text window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable text window transparency.
                        """

                class video(TUIMenu):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.background = self.__class__.background(service, version, mode, path + ["background"])
                        self.color_filter = self.__class__.color_filter(service, version, mode, path + ["color_filter"])
                        self.foreground = self.__class__.foreground(service, version, mode, path + ["foreground"])
                        self.on = self.__class__.on(service, version, mode, path + ["on"])
                        self.pixel_size = self.__class__.pixel_size(service, version, mode, path + ["pixel_size"])
                        super().__init__(service, version, mode, path)
                    class background(TUIMethod):
                        """
                        Set the background color in the video picture.
                        """
                    class color_filter(TUIMethod):
                        """
                        Set the color filter options for the picture.
                        """
                    class foreground(TUIMethod):
                        """
                        Set the foreground color in the video picture.
                        """
                    class on(TUIMethod):
                        """
                        Enable/disable video picture settings.
                        """
                    class pixel_size(TUIMethod):
                        """
                        Set the window size in pixels.
                        """

                class xy(TUIMenu):
                    """
                    Enter the X-Y plot window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.border = self.__class__.border(service, version, mode, path + ["border"])
                        self.bottom = self.__class__.bottom(service, version, mode, path + ["bottom"])
                        self.left = self.__class__.left(service, version, mode, path + ["left"])
                        self.right = self.__class__.right(service, version, mode, path + ["right"])
                        self.top = self.__class__.top(service, version, mode, path + ["top"])
                        self.visible = self.__class__.visible(service, version, mode, path + ["visible"])
                        super().__init__(service, version, mode, path)
                    class border(TUIMethod):
                        """
                        Enable/disable drawing of a border around the X-Y plotter window.
                        """
                    class bottom(TUIMethod):
                        """
                        Set the bottom boundary of the X-Y plotter window.
                        """
                    class left(TUIMethod):
                        """
                        Set the left boundary of the X-Y plotter window.
                        """
                    class right(TUIMethod):
                        """
                        Set the right boundary of the X-Y plotter window.
                        """
                    class top(TUIMethod):
                        """
                        Set the top boundary of the X-Y plotter window.
                        """
                    class visible(TUIMethod):
                        """
                        Enable/disable X-Y plotter window visibility.
                        """

            class titles(TUIMenu):
                """
                Set problem title.
                """
                def __init__(self, service, version, mode, path):
                    self.left_top = self.__class__.left_top(service, version, mode, path + ["left_top"])
                    self.left_bottom = self.__class__.left_bottom(service, version, mode, path + ["left_bottom"])
                    self.right_top = self.__class__.right_top(service, version, mode, path + ["right_top"])
                    self.right_middle = self.__class__.right_middle(service, version, mode, path + ["right_middle"])
                    self.right_bottom = self.__class__.right_bottom(service, version, mode, path + ["right_bottom"])
                    super().__init__(service, version, mode, path)
                class left_top(TUIMethod):
                    """
                    Set the title text for left top in title segment.
                    """
                class left_bottom(TUIMethod):
                    """
                    Set the title text for left bottom in title segment.
                    """
                class right_top(TUIMethod):
                    """
                    Set the title text for right top in title segment.
                    """
                class right_middle(TUIMethod):
                    """
                    Set the title text for right middle in title segment.
                    """
                class right_bottom(TUIMethod):
                    """
                    Set the title text for right bottom in title segment.
                    """

            class views(TUIMenu):
                """
                Enter the view manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
                    self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
                    self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
                    self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
                    self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
                    self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
                    self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
                    self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
                    self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
                    self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
                    self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
                    super().__init__(service, version, mode, path)
                class auto_scale(TUIMethod):
                    """
                    Scale and center the current scene.
                    """
                class default_view(TUIMethod):
                    """
                    Reset view to front and center.
                    """
                class delete_view(TUIMethod):
                    """
                    Remove a view from the list.
                    """
                class last_view(TUIMethod):
                    """
                    Return to the camera position before the last manipulation.
                    """
                class next_view(TUIMethod):
                    """
                    Return to the camera position after the current position in the stack.
                    """
                class list_views(TUIMethod):
                    """
                    List predefined and saved views.
                    """
                class restore_view(TUIMethod):
                    """
                    Use a saved view.
                    """
                class read_views(TUIMethod):
                    """
                    Read views from a view file.
                    """
                class save_view(TUIMethod):
                    """
                    Save the current view to the view list.
                    """
                class write_views(TUIMethod):
                    """
                    Write selected views to a view file.
                    """

                class camera(TUIMenu):
                    """
                    Enter the camera menu to modify the current viewing parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.dolly_camera = self.__class__.dolly_camera(service, version, mode, path + ["dolly_camera"])
                        self.field = self.__class__.field(service, version, mode, path + ["field"])
                        self.orbit_camera = self.__class__.orbit_camera(service, version, mode, path + ["orbit_camera"])
                        self.pan_camera = self.__class__.pan_camera(service, version, mode, path + ["pan_camera"])
                        self.position = self.__class__.position(service, version, mode, path + ["position"])
                        self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                        self.roll_camera = self.__class__.roll_camera(service, version, mode, path + ["roll_camera"])
                        self.target = self.__class__.target(service, version, mode, path + ["target"])
                        self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                        self.zoom_camera = self.__class__.zoom_camera(service, version, mode, path + ["zoom_camera"])
                        super().__init__(service, version, mode, path)
                    class dolly_camera(TUIMethod):
                        """
                        Adjust the camera position and target.
                        """
                    class field(TUIMethod):
                        """
                        Set the field of view (width and height).
                        """
                    class orbit_camera(TUIMethod):
                        """
                        Adjust the camera position without modifying the target.
                        """
                    class pan_camera(TUIMethod):
                        """
                        Adjust the camera target without modifying the position.
                        """
                    class position(TUIMethod):
                        """
                        Set the camera position.
                        """
                    class projection(TUIMethod):
                        """
                        Set the camera projection type.
                        """
                    class roll_camera(TUIMethod):
                        """
                        Adjust the camera up-vector.
                        """
                    class target(TUIMethod):
                        """
                        Set the point to be the center of the camera view.
                        """
                    class up_vector(TUIMethod):
                        """
                        Set the camera up-vector.
                        """
                    class zoom_camera(TUIMethod):
                        """
                        Adjust the camera field of view.
                        """

            class display_states(TUIMenu):
                """
                Enter the display state manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.apply = self.__class__.apply(service, version, mode, path + ["apply"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.use_active = self.__class__.use_active(service, version, mode, path + ["use_active"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.read = self.__class__.read(service, version, mode, path + ["read"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    super().__init__(service, version, mode, path)
                class list(TUIMethod):
                    """
                    Print the names of the available display states to the console.
                    """
                class apply(TUIMethod):
                    """
                    Apply a display state to the active window.
                    """
                class delete(TUIMethod):
                    """
                    Delete a display state.
                    """
                class use_active(TUIMethod):
                    """
                    Update an existing display state's settings to match those of the active graphics window.
                    """
                class copy(TUIMethod):
                    """
                    Create a new display state with settings copied from an existing display state.
                    """
                class read(TUIMethod):
                    """
                    Read display states from a file.
                    """
                class write(TUIMethod):
                    """
                    Write display states to a file.
                    """
                class edit(TUIMethod):
                    """
                    Edit a particular display state setting.
                    """
                class create(TUIMethod):
                    """
                    Create a new display state.
                    """

            class view_sync(TUIMenu):
                """
                Enter the display state manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.start = self.__class__.start(service, version, mode, path + ["start"])
                    self.stop = self.__class__.stop(service, version, mode, path + ["stop"])
                    self.remove_all = self.__class__.remove_all(service, version, mode, path + ["remove_all"])
                    self.add_all = self.__class__.add_all(service, version, mode, path + ["add_all"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.remove = self.__class__.remove(service, version, mode, path + ["remove"])
                    super().__init__(service, version, mode, path)
                class list(TUIMethod):
                    """
                    Print window ids of open windows.
                    """
                class start(TUIMethod):
                    """
                    Start view synchronization.
                    """
                class stop(TUIMethod):
                    """
                    Stop view synchronization.
                    """
                class remove_all(TUIMethod):
                    """
                    Unsynchronize all windows.
                    """
                class add_all(TUIMethod):
                    """
                    Synchronize all windows.
                    """
                class add(TUIMethod):
                    """
                    Add list of window ids for synchronization.
                    """
                class remove(TUIMethod):
                    """
                    Remove list of window ids from synchronization.
                    """

    class solution(TUIMenu):
        """
        Enter solution menu.
        """
        def __init__(self, service, version, mode, path):
            self.calculation_activities = self.__class__.calculation_activities(service, version, mode, path + ["calculation_activities"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
            self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.run_calculation = self.__class__.run_calculation(service, version, mode, path + ["run_calculation"])
            super().__init__(service, version, mode, path)

        class calculation_activities(TUIMenu):
            """
            Enter calculation activities menu.
            """
            def __init__(self, service, version, mode, path):
                self.animate = self.__class__.animate(service, version, mode, path + ["animate"])
                self.auto_save = self.__class__.auto_save(service, version, mode, path + ["auto_save"])
                self.cell_register_operations = self.__class__.cell_register_operations(service, version, mode, path + ["cell_register_operations"])
                self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
                self.solution_strategy = self.__class__.solution_strategy(service, version, mode, path + ["solution_strategy"])
                super().__init__(service, version, mode, path)

            class animate(TUIMenu):
                """
                Enter the animation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.define = self.__class__.define(service, version, mode, path + ["define"])
                    self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
                    super().__init__(service, version, mode, path)

                class define(TUIMenu):
                    """
                    Enter the animation definition menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.define_monitor = self.__class__.define_monitor(service, version, mode, path + ["define_monitor"])
                        self.edit_monitor = self.__class__.edit_monitor(service, version, mode, path + ["edit_monitor"])
                        super().__init__(service, version, mode, path)
                    class define_monitor(TUIMethod):
                        """
                        Define new animation.
                        """
                    class edit_monitor(TUIMethod):
                        """
                        Change animation monitor attributes.
                        """

                class objects(TUIMenu):
                    """
                    Enter to define, edit, delete solution animation objects.
                    """
                    def __init__(self, service, version, mode, path):
                        self.create = self.__class__.create(service, version, mode, path + ["create"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                        super().__init__(service, version, mode, path)
                    class create(TUIMethod):
                        """
                        Create new graphics object.
                        """
                    class edit(TUIMethod):
                        """
                        Edit graphics object.
                        """
                    class copy(TUIMethod):
                        """
                        Copy graphics object.
                        """
                    class delete(TUIMethod):
                        """
                        Delete graphics object.
                        """
                    class clear_history(TUIMethod):
                        """
                        Clear object history.
                        """

            class auto_save(TUIMenu):
                """
                Enter the auto save menu.
                """
                def __init__(self, service, version, mode, path):
                    self.case_frequency = self.__class__.case_frequency(service, version, mode, path + ["case_frequency"])
                    self.data_frequency = self.__class__.data_frequency(service, version, mode, path + ["data_frequency"])
                    self.root_name = self.__class__.root_name(service, version, mode, path + ["root_name"])
                    self.retain_most_recent_files = self.__class__.retain_most_recent_files(service, version, mode, path + ["retain_most_recent_files"])
                    self.max_files = self.__class__.max_files(service, version, mode, path + ["max_files"])
                    self.append_file_name_with = self.__class__.append_file_name_with(service, version, mode, path + ["append_file_name_with"])
                    self.save_data_file_every = self.__class__.save_data_file_every(service, version, mode, path + ["save_data_file_every"])
                    super().__init__(service, version, mode, path)
                class case_frequency(TUIMethod):
                    """
                    Set the preference for saving case files.
                    """
                class data_frequency(TUIMethod):
                    """
                    Set the iteration or time step increment for saving data files.
                    """
                class root_name(TUIMethod):
                    """
                    Set the root name for auto-saved files. The number of iterations or time steps will be appended to this root name.
                    """
                class retain_most_recent_files(TUIMethod):
                    """
                    After the maximum (as in max-files) is reached, a file will be deleted for each file saved.
                    """
                class max_files(TUIMethod):
                    """
                    Set the maximum number of data files to save. After the maximum is reached, a file will be deleted for each file saved.
                    """
                class append_file_name_with(TUIMethod):
                    """
                    Set the suffix for auto-saved files. The file name can be appended by flow-time, time-step value or by user specified flags in file name.
                    """
                class save_data_file_every(TUIMethod):
                    """
                    Set the auto save frequency type to either time-step or crank-angle and set the corresponding frequency.
                    """

            class cell_register_operations(TUIMenu):
                """
                Manage Cell Register Operations.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """

            class execute_commands(TUIMenu):
                """
                Enter the execute-monitor-commands menu.
                """
                def __init__(self, service, version, mode, path):
                    self.add_edit = self.__class__.add_edit(service, version, mode, path + ["add_edit"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.export = self.__class__.export(service, version, mode, path + ["export"])
                    self.import_ = self.__class__.import_(service, version, mode, path + ["import"])
                    super().__init__(service, version, mode, path)
                class add_edit(TUIMethod):
                    """
                    Add or edit execute-commands.
                    """
                class enable(TUIMethod):
                    """
                    Enable an execute-command.
                    """
                class disable(TUIMethod):
                    """
                    Disable an execute-command.
                    """
                class copy(TUIMethod):
                    """
                    Copy an execute-command.
                    """
                class delete(TUIMethod):
                    """
                    Delete an execute-command.
                    """
                class export(TUIMethod):
                    """
                    Export execute-commands to a TSV file.
                    """
                class import_(TUIMethod):
                    """
                    Import execute-commands from a TSV file.
                    """

            class solution_strategy(TUIMenu):
                """
                Enter the automatic initialization and case modification strategy menu.
                """
                def __init__(self, service, version, mode, path):
                    self.automatic_case_modification = self.__class__.automatic_case_modification(service, version, mode, path + ["automatic_case_modification"])
                    self.enable_strategy = self.__class__.enable_strategy(service, version, mode, path + ["enable_strategy"])
                    self.execute_strategy = self.__class__.execute_strategy(service, version, mode, path + ["execute_strategy"])
                    self.add_edit_modification = self.__class__.add_edit_modification(service, version, mode, path + ["add_edit_modification"])
                    self.copy_modification = self.__class__.copy_modification(service, version, mode, path + ["copy_modification"])
                    self.delete_modification = self.__class__.delete_modification(service, version, mode, path + ["delete_modification"])
                    self.enable_modification = self.__class__.enable_modification(service, version, mode, path + ["enable_modification"])
                    self.disable_modification = self.__class__.disable_modification(service, version, mode, path + ["disable_modification"])
                    self.import_modifications = self.__class__.import_modifications(service, version, mode, path + ["import_modifications"])
                    self.export_modifications = self.__class__.export_modifications(service, version, mode, path + ["export_modifications"])
                    self.continue_strategy_execution = self.__class__.continue_strategy_execution(service, version, mode, path + ["continue_strategy_execution"])
                    self.automatic_initialization = self.__class__.automatic_initialization(service, version, mode, path + ["automatic_initialization"])
                    super().__init__(service, version, mode, path)
                class enable_strategy(TUIMethod):
                    """
                    Specify whether automatic initialization and case modification should be enabled.
                    """
                class execute_strategy(TUIMethod):
                    """
                    Execute the automatic initialization and case modification strategy defined at present.
                    """
                class add_edit_modification(TUIMethod):
                    """
                    Define a single case modification.
                    """
                class copy_modification(TUIMethod):
                    """
                    Copy a single case modification.
                    """
                class delete_modification(TUIMethod):
                    """
                    Delete a single case modification.
                    """
                class enable_modification(TUIMethod):
                    """
                    Enable a single defined case modification.
                    """
                class disable_modification(TUIMethod):
                    """
                    Disable a single defined case modification.
                    """
                class import_modifications(TUIMethod):
                    """
                    Import a list of case modifications from a tsv file.
                    """
                class export_modifications(TUIMethod):
                    """
                    Export all case modifications to a tsv file.
                    """
                class continue_strategy_execution(TUIMethod):
                    """
                    Continue execution of the automatic initialization and case modification strategy defined at present.
                    """
                class automatic_initialization(TUIMethod):
                    """
                    Define how the case is to be initialized automatically.
                    """

                class automatic_case_modification(TUIMenu):
                    """
                    Define how the case is to be modified as the solution progresses.
                    """
                    def __init__(self, service, version, mode, path):
                        self.before_init_modification = self.__class__.before_init_modification(service, version, mode, path + ["before_init_modification"])
                        self.original_settings = self.__class__.original_settings(service, version, mode, path + ["original_settings"])
                        self.modifications = self.__class__.modifications(service, version, mode, path + ["modifications"])
                        super().__init__(service, version, mode, path)
                    class before_init_modification(TUIMethod):
                        """
                        Specify modification to be performed before initialization.
                        """
                    class original_settings(TUIMethod):
                        """
                        Specify modification to be performed after initialization to restore to original settings.
                        """
                    class modifications(TUIMethod):
                        """
                        Specify modifications to be performed during solution.
                        """

        class cell_registers(TUIMenu):
            """
            Manage Cell Registers.
            """
            def __init__(self, service, version, mode, path):
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.apply_poor_mesh_numerics = self.__class__.apply_poor_mesh_numerics(service, version, mode, path + ["apply_poor_mesh_numerics"])
                self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                super().__init__(service, version, mode, path)
            class adapt(TUIMethod):
                """
                Adapt cell register objects.
                """
            class add(TUIMethod):
                """
                Add a new object.
                """
            class apply_poor_mesh_numerics(TUIMethod):
                """
                Apply poor mesh numerics to cell register objects.
                """
            class coarsen(TUIMethod):
                """
                Coarsen cell register objects.
                """
            class display(TUIMethod):
                """
                Display cell register objects.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """
            class refine(TUIMethod):
                """
                Refine cell register objects.
                """

        class controls(TUIMenu):
            """
            Enter the controls menu.
            """
            def __init__(self, service, version, mode, path):
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(service, version, mode, path + ["acoustics_wave_equation_controls"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                self.set_controls_to_default = self.__class__.set_controls_to_default(service, version, mode, path + ["set_controls_to_default"])
                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                super().__init__(service, version, mode, path)
            class courant_number(TUIMethod):
                """
                Set the fine mesh Courant number (time step factor).
                """
            class equations(TUIMethod):
                """
                Enter the equations menu.
                """
            class limits(TUIMethod):
                """
                Set solver limits for the values of various solution variables.
                """
            class p_v_controls(TUIMethod):
                """
                Set P-V-Controls.
                """
            class relaxation_factor(TUIMethod):
                """
                Enter the relaxation-factor menu.
                """
            class set_controls_to_default(TUIMethod):
                """
                Set controls to default values.
                """
            class under_relaxation(TUIMethod):
                """
                Enter the under-relaxation menu.
                """

            class acoustics_wave_equation_controls(TUIMenu):
                """
                Enter menu for acoustics wave equation solver controls.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.relative_convergence_criterion = self.__class__.relative_convergence_criterion(service, version, mode, path + ["relative_convergence_criterion"])
                    self.max_iterations_per_timestep = self.__class__.max_iterations_per_timestep(service, version, mode, path + ["max_iterations_per_timestep"])
                    super().__init__(service, version, mode, path)
                class relative_convergence_criterion(TUIMethod):
                    """
                    Specify convergence tolerance for the timestep iterations
                    as the target residual reduction factor.
                    """
                class max_iterations_per_timestep(TUIMethod):
                    """
                    Specify maximum number of iterations per timestep.
                    """

                class expert(TUIMenu):
                    """
                    Enter menu for expert controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self.under_relaxation_factor = self.__class__.under_relaxation_factor(service, version, mode, path + ["under_relaxation_factor"])
                        self.explicit_relaxation_factor = self.__class__.explicit_relaxation_factor(service, version, mode, path + ["explicit_relaxation_factor"])
                        super().__init__(service, version, mode, path)
                    class under_relaxation_factor(TUIMethod):
                        """
                        Specify under-relaxation factor to be used in
                        the diagonal matrix elements of implicit solver.
                        """
                    class explicit_relaxation_factor(TUIMethod):
                        """
                        Specify explicit relaxation factor to be applied to
                        the solution correction when updating solution in the timestep iterations.
                        """

            class advanced(TUIMenu):
                """
                Controls advanced options.
                """
                def __init__(self, service, version, mode, path):
                    self.amg_options = self.__class__.amg_options(service, version, mode, path + ["amg_options"])
                    self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                    self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                    self.multi_grid_amg = self.__class__.multi_grid_amg(service, version, mode, path + ["multi_grid_amg"])
                    self.multi_grid_controls = self.__class__.multi_grid_controls(service, version, mode, path + ["multi_grid_controls"])
                    self.multi_grid_fas = self.__class__.multi_grid_fas(service, version, mode, path + ["multi_grid_fas"])
                    self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    self.slope_limiter_set = self.__class__.slope_limiter_set(service, version, mode, path + ["slope_limiter_set"])
                    super().__init__(service, version, mode, path)
                class correction_tolerance(TUIMethod):
                    """
                    Enter the correction tolerance menu.
                    """
                class multi_grid_amg(TUIMethod):
                    """
                    Set the parameters that govern the algebraic multigrid procedure.
                    """
                class multi_grid_controls(TUIMethod):
                    """
                    Enter the multi-grid-controls menu.
                    """
                class multi_grid_fas(TUIMethod):
                    """
                    Set the coefficients that govern the FAS multigrid procedure.
                    """
                class multi_stage(TUIMethod):
                    """
                    Set the multiple-stage time stepping scheme coefficients.
                    """
                class relaxation_method(TUIMethod):
                    """
                    Set the solver relaxation method.
                    """
                class slope_limiter_set(TUIMethod):
                    """
                    Enter the slope limiter set menu.
                    """

                class amg_options(TUIMenu):
                    """
                    Enter AMG options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                        self.conservative_amg_coarsening = self.__class__.conservative_amg_coarsening(service, version, mode, path + ["conservative_amg_coarsening"])
                        self.aggressive_amg_coarsening = self.__class__.aggressive_amg_coarsening(service, version, mode, path + ["aggressive_amg_coarsening"])
                        self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                        super().__init__(service, version, mode, path)
                    class laplace_coarsening(TUIMethod):
                        """
                        Set AMG laplace coarsening options.
                        """
                    class conservative_amg_coarsening(TUIMethod):
                        """
                        Use conservative AMG coarsening?.
                        """
                    class aggressive_amg_coarsening(TUIMethod):
                        """
                        Use aggressive AMG coarsening.
                        """
                    class amg_gpgpu_options(TUIMethod):
                        """
                        Set GPGPU AMG solver options.
                        """

                class fast_transient_settings(TUIMenu):
                    """
                    Enter the fast transient settings menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.rk2 = self.__class__.rk2(service, version, mode, path + ["rk2"])
                        super().__init__(service, version, mode, path)
                    class rk2(TUIMethod):
                        """
                        Enable the use of a two-stage Runge-Kutta scheme for time integration.
                        """

            class contact_solution_controls(TUIMenu):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, service, version, mode, path):
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.set_settings_to_default = self.__class__.set_settings_to_default(service, version, mode, path + ["set_settings_to_default"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class solution_stabilization(TUIMethod):
                    """
                    Automatic solver settings adjustment for solution stabilization during contact process.
                    """
                class set_settings_to_default(TUIMethod):
                    """
                    Set contact solution stabilization to default.
                    """
                class verbosity(TUIMethod):
                    """
                    Specify verbosity level for contact solution controls.
                    """

                class parameters(TUIMenu):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, service, version, mode, path):
                        self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                        self.solution_stabilization_persistence = self.__class__.solution_stabilization_persistence(service, version, mode, path + ["solution_stabilization_persistence"])
                        self.persistence_fixed_time_steps = self.__class__.persistence_fixed_time_steps(service, version, mode, path + ["persistence_fixed_time_steps"])
                        self.persistence_fixed_duration = self.__class__.persistence_fixed_duration(service, version, mode, path + ["persistence_fixed_duration"])
                        self.extrapolation_method = self.__class__.extrapolation_method(service, version, mode, path + ["extrapolation_method"])
                        super().__init__(service, version, mode, path)
                    class iterations(TUIMethod):
                        """
                        Specify additional iterations to accomodate contact solution stabilization.
                        """
                    class solution_stabilization_persistence(TUIMethod):
                        """
                        Persistence of the solution stabilization based on events [0-contact based, 1-always on].
                        """
                    class persistence_fixed_time_steps(TUIMethod):
                        """
                        Specify fixed time-steps for solution stabilization persistence after trigger.
                        """
                    class persistence_fixed_duration(TUIMethod):
                        """
                        Specify fixed time for solution stabilization persistence after trigger.
                        """
                    class extrapolation_method(TUIMethod):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """

                class spatial(TUIMenu):
                    """
                    Spatial discretization control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.first_to_second_order_blending = self.__class__.first_to_second_order_blending(service, version, mode, path + ["first_to_second_order_blending"])
                        self.first_to_second_order_blending_list = self.__class__.first_to_second_order_blending_list(service, version, mode, path + ["first_to_second_order_blending_list"])
                        self.scheme = self.__class__.scheme(service, version, mode, path + ["scheme"])
                        self.flow_skew_diffusion_exclude = self.__class__.flow_skew_diffusion_exclude(service, version, mode, path + ["flow_skew_diffusion_exclude"])
                        self.scalars_skew_diffusion_exclude = self.__class__.scalars_skew_diffusion_exclude(service, version, mode, path + ["scalars_skew_diffusion_exclude"])
                        self.rhie_chow_flux_specify = self.__class__.rhie_chow_flux_specify(service, version, mode, path + ["rhie_chow_flux_specify"])
                        self.rhie_chow_method = self.__class__.rhie_chow_method(service, version, mode, path + ["rhie_chow_method"])
                        super().__init__(service, version, mode, path)
                    class first_to_second_order_blending(TUIMethod):
                        """
                        Set factor to control first order to second order blending.
                        """
                    class first_to_second_order_blending_list(TUIMethod):
                        """
                        List set factor to control first order to second order blending.
                        """
                    class scheme(TUIMethod):
                        """
                        Set advection scheme for contact event stability.
                        """
                    class flow_skew_diffusion_exclude(TUIMethod):
                        """
                        Exclude skew diffusion discretization contribution for momentum.
                        """
                    class scalars_skew_diffusion_exclude(TUIMethod):
                        """
                        Exclude skew diffusion discretization contribution for scalars.
                        """
                    class rhie_chow_flux_specify(TUIMethod):
                        """
                        Allow specification of the the rhie-chow flux method.
                        """
                    class rhie_chow_method(TUIMethod):
                        """
                        Enter the rhie-chow flux method.
                        """

                class transient(TUIMenu):
                    """
                    Transient discretization control options .
                    """
                    def __init__(self, service, version, mode, path):
                        self.transient_parameters_specify = self.__class__.transient_parameters_specify(service, version, mode, path + ["transient_parameters_specify"])
                        self.transient_scheme = self.__class__.transient_scheme(service, version, mode, path + ["transient_scheme"])
                        self.time_scale_modification_method = self.__class__.time_scale_modification_method(service, version, mode, path + ["time_scale_modification_method"])
                        self.time_scale_modification_factor = self.__class__.time_scale_modification_factor(service, version, mode, path + ["time_scale_modification_factor"])
                        super().__init__(service, version, mode, path)
                    class transient_parameters_specify(TUIMethod):
                        """
                        Allow transient parameter specification.
                        """
                    class transient_scheme(TUIMethod):
                        """
                        Specify temporal scheme to be used.
                        """
                    class time_scale_modification_method(TUIMethod):
                        """
                        Enter time scale modification method.
                        """
                    class time_scale_modification_factor(TUIMethod):
                        """
                        Specify time-scale modification factor.
                        """

                class amg(TUIMenu):
                    """
                    AMG control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enforce_laplace_coarsening = self.__class__.enforce_laplace_coarsening(service, version, mode, path + ["enforce_laplace_coarsening"])
                        self.increase_pre_sweeps = self.__class__.increase_pre_sweeps(service, version, mode, path + ["increase_pre_sweeps"])
                        self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                        self.specify_coarsening_rate = self.__class__.specify_coarsening_rate(service, version, mode, path + ["specify_coarsening_rate"])
                        self.coarsen_rate = self.__class__.coarsen_rate(service, version, mode, path + ["coarsen_rate"])
                        super().__init__(service, version, mode, path)
                    class enforce_laplace_coarsening(TUIMethod):
                        """
                        Enforce the use of laplace coarsening in AMG.
                        """
                    class increase_pre_sweeps(TUIMethod):
                        """
                        Allow increase in AMG pre-sweep.
                        """
                    class pre_sweeps(TUIMethod):
                        """
                        Specify the number of AMG pre-sweeps.
                        """
                    class specify_coarsening_rate(TUIMethod):
                        """
                        Modify AMG coarsening rate.
                        """
                    class coarsen_rate(TUIMethod):
                        """
                        Specify AMG coarsening rate.
                        """

                class models(TUIMenu):
                    """
                    Model control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.model_ramping = self.__class__.model_ramping(service, version, mode, path + ["model_ramping"])
                        self.ramp_flow = self.__class__.ramp_flow(service, version, mode, path + ["ramp_flow"])
                        self.ramp_turbulence = self.__class__.ramp_turbulence(service, version, mode, path + ["ramp_turbulence"])
                        self.ramp_scalars = self.__class__.ramp_scalars(service, version, mode, path + ["ramp_scalars"])
                        super().__init__(service, version, mode, path)
                    class model_ramping(TUIMethod):
                        """
                        Activate model ramping for solver stability and accuracy.
                        """
                    class ramp_flow(TUIMethod):
                        """
                        Ramp flow for solver stability and accuracy.
                        """
                    class ramp_turbulence(TUIMethod):
                        """
                        Ramp turbulence for solver stability and accuracy.
                        """
                    class ramp_scalars(TUIMethod):
                        """
                        Ramp all scalar transport equations for solver stability and accuracy.
                        """

                class methods(TUIMenu):
                    """
                    Methods control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.pressure_velocity_coupling_controls = self.__class__.pressure_velocity_coupling_controls(service, version, mode, path + ["pressure_velocity_coupling_controls"])
                        self.pressure_velocity_coupling_method = self.__class__.pressure_velocity_coupling_method(service, version, mode, path + ["pressure_velocity_coupling_method"])
                        self.gradient_controls = self.__class__.gradient_controls(service, version, mode, path + ["gradient_controls"])
                        self.specify_gradient_method = self.__class__.specify_gradient_method(service, version, mode, path + ["specify_gradient_method"])
                        super().__init__(service, version, mode, path)
                    class pressure_velocity_coupling_controls(TUIMethod):
                        """
                        Enable pressure-velocity coupling method change for solver stability and accuracy.
                        """
                    class pressure_velocity_coupling_method(TUIMethod):
                        """
                        Specify pressure-velocity coupling method change for solver stability and accuracy.
                        """
                    class gradient_controls(TUIMethod):
                        """
                        Modify gradient method for solver stability and accuracy.
                        """
                    class specify_gradient_method(TUIMethod):
                        """
                        Specify gradient method for solver stability and accuracy.
                        """

                class miscellaneous(TUIMenu):
                    """
                    Miscellaneous.
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_statistics = self.__class__.compute_statistics(service, version, mode, path + ["compute_statistics"])
                        self.statistics_level = self.__class__.statistics_level(service, version, mode, path + ["statistics_level"])
                        super().__init__(service, version, mode, path)
                    class compute_statistics(TUIMethod):
                        """
                        Compute solution statistics for contact updates.
                        """
                    class statistics_level(TUIMethod):
                        """
                        Solution statistics level for contact updates.
                        """

            class query(TUIMenu):
                """
                Enter controls query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(service, version, mode, path + ["acoustics_wave_equation_controls"])
                    self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                    self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                    self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                    self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                    self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                    self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                    self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                    super().__init__(service, version, mode, path)
                class courant_number(TUIMethod):
                    """
                    Get the fine mesh Courant number (time step factor).
                    """
                class equations(TUIMethod):
                    """
                    Enter the equations menu.
                    """
                class limits(TUIMethod):
                    """
                    Get solver limits for the values of various solution variables.
                    """
                class p_v_controls(TUIMethod):
                    """
                    Get P-V-Controls.
                    """
                class relaxation_factor(TUIMethod):
                    """
                    Enter the relaxation-factor menu.
                    """
                class under_relaxation(TUIMethod):
                    """
                    Enter under relaxation menu.
                    """

                class acoustics_wave_equation_controls(TUIMenu):
                    """
                    Enter menu for acoustics wave equation solver controls.
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.relative_convergence_criterion = self.__class__.relative_convergence_criterion(service, version, mode, path + ["relative_convergence_criterion"])
                        self.max_iterations_per_timestep = self.__class__.max_iterations_per_timestep(service, version, mode, path + ["max_iterations_per_timestep"])
                        super().__init__(service, version, mode, path)
                    class relative_convergence_criterion(TUIMethod):
                        """
                        Specify convergence tolerance for the timestep iterations
                        as the target residual reduction factor.
                        """
                    class max_iterations_per_timestep(TUIMethod):
                        """
                        Specify maximum number of iterations per timestep.
                        """

                    class expert(TUIMenu):
                        """
                        Enter menu for expert controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.under_relaxation_factor = self.__class__.under_relaxation_factor(service, version, mode, path + ["under_relaxation_factor"])
                            self.explicit_relaxation_factor = self.__class__.explicit_relaxation_factor(service, version, mode, path + ["explicit_relaxation_factor"])
                            super().__init__(service, version, mode, path)
                        class under_relaxation_factor(TUIMethod):
                            """
                            Specify under-relaxation factor to be used in
                            the diagonal matrix elements of implicit solver.
                            """
                        class explicit_relaxation_factor(TUIMethod):
                            """
                            Specify explicit relaxation factor to be applied to
                            the solution correction when updating solution in the timestep iterations.
                            """

                class advanced(TUIMenu):
                    """
                    Controls advanced options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.amg_options = self.__class__.amg_options(service, version, mode, path + ["amg_options"])
                        self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                        self.multi_grid_amg = self.__class__.multi_grid_amg(service, version, mode, path + ["multi_grid_amg"])
                        self.multi_grid_controls = self.__class__.multi_grid_controls(service, version, mode, path + ["multi_grid_controls"])
                        self.multi_grid_fas = self.__class__.multi_grid_fas(service, version, mode, path + ["multi_grid_fas"])
                        self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                        self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                        super().__init__(service, version, mode, path)
                    class correction_tolerance(TUIMethod):
                        """
                        Enter the correction tolerance menu.
                        """
                    class multi_grid_amg(TUIMethod):
                        """
                        Get the parameters that govern the algebraic multigrid procedure.
                        """
                    class multi_grid_controls(TUIMethod):
                        """
                        Enter the multi-grid-controls menu.
                        """
                    class multi_grid_fas(TUIMethod):
                        """
                        Get the coefficients that govern the FAS multigrid procedure.
                        """
                    class multi_stage(TUIMethod):
                        """
                        Set the multiple-stage time stepping scheme coefficients.
                        """
                    class relaxation_method(TUIMethod):
                        """
                        Set the solver relaxation method.
                        """

                    class amg_options(TUIMenu):
                        """
                        Enter AMG options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                            self.conservative_amg_coarsening = self.__class__.conservative_amg_coarsening(service, version, mode, path + ["conservative_amg_coarsening"])
                            self.aggressive_amg_coarsening = self.__class__.aggressive_amg_coarsening(service, version, mode, path + ["aggressive_amg_coarsening"])
                            self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                            super().__init__(service, version, mode, path)
                        class laplace_coarsening(TUIMethod):
                            """
                            Get AMG laplace coarsening options.
                            """
                        class conservative_amg_coarsening(TUIMethod):
                            """
                            Use conservative AMG coarsening?.
                            """
                        class aggressive_amg_coarsening(TUIMethod):
                            """
                            Use aggressive AMG coarsening.
                            """
                        class amg_gpgpu_options(TUIMethod):
                            """
                            Amg gpu options.
                            """

        class expert(TUIMenu):
            """
            Enter expert options for solution.
            """
            def __init__(self, service, version, mode, path):
                self.divergence_prevention = self.__class__.divergence_prevention(service, version, mode, path + ["divergence_prevention"])
                self.high_speed_numerics = self.__class__.high_speed_numerics(service, version, mode, path + ["high_speed_numerics"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                self.previous_defaults = self.__class__.previous_defaults(service, version, mode, path + ["previous_defaults"])
                self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(service, version, mode, path + ["non_reflecting_boundary_treatment"])
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(service, version, mode, path + ["open_channel_wave_options"])
                self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(service, version, mode, path + ["secondary_gradient_limiting"])
                self.alternate_wall_temp_formulation = self.__class__.alternate_wall_temp_formulation(service, version, mode, path + ["alternate_wall_temp_formulation"])
                self.bc_pressure_extrapolations = self.__class__.bc_pressure_extrapolations(service, version, mode, path + ["bc_pressure_extrapolations"])
                self.bcd_boundedness = self.__class__.bcd_boundedness(service, version, mode, path + ["bcd_boundedness"])
                self.bcd_weights_freeze = self.__class__.bcd_weights_freeze(service, version, mode, path + ["bcd_weights_freeze"])
                self.correction_form = self.__class__.correction_form(service, version, mode, path + ["correction_form"])
                self.disable_reconstruction = self.__class__.disable_reconstruction(service, version, mode, path + ["disable_reconstruction"])
                self.energy_numerical_noise_filter = self.__class__.energy_numerical_noise_filter(service, version, mode, path + ["energy_numerical_noise_filter"])
                self.explicit_under_relaxation_value = self.__class__.explicit_under_relaxation_value(service, version, mode, path + ["explicit_under_relaxation_value"])
                self.equation_ordering = self.__class__.equation_ordering(service, version, mode, path + ["equation_ordering"])
                self.flow_warnings = self.__class__.flow_warnings(service, version, mode, path + ["flow_warnings"])
                self.limiter_warnings = self.__class__.limiter_warnings(service, version, mode, path + ["limiter_warnings"])
                self.linearized_mass_transfer_udf = self.__class__.linearized_mass_transfer_udf(service, version, mode, path + ["linearized_mass_transfer_udf"])
                self.lock_solid_temperature = self.__class__.lock_solid_temperature(service, version, mode, path + ["lock_solid_temperature"])
                self.material_property_warnings = self.__class__.material_property_warnings(service, version, mode, path + ["material_property_warnings"])
                self.mp_mfluid_aniso_drag = self.__class__.mp_mfluid_aniso_drag(service, version, mode, path + ["mp_mfluid_aniso_drag"])
                self.mp_reference_density = self.__class__.mp_reference_density(service, version, mode, path + ["mp_reference_density"])
                self.numerical_beach_controls = self.__class__.numerical_beach_controls(service, version, mode, path + ["numerical_beach_controls"])
                self.open_channel_controls = self.__class__.open_channel_controls(service, version, mode, path + ["open_channel_controls"])
                self.retain_cell_residuals = self.__class__.retain_cell_residuals(service, version, mode, path + ["retain_cell_residuals"])
                self.retain_temporary_solver_mem = self.__class__.retain_temporary_solver_mem(service, version, mode, path + ["retain_temporary_solver_mem"])
                self.set_all_species_together = self.__class__.set_all_species_together(service, version, mode, path + ["set_all_species_together"])
                self.show_all_discretization_schemes = self.__class__.show_all_discretization_schemes(service, version, mode, path + ["show_all_discretization_schemes"])
                self.singhal_et_al_cavitation_model = self.__class__.singhal_et_al_cavitation_model(service, version, mode, path + ["singhal_et_al_cavitation_model"])
                self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                self.surface_tension_expert = self.__class__.surface_tension_expert(service, version, mode, path + ["surface_tension_expert"])
                self.vof_explicit_controls = self.__class__.vof_explicit_controls(service, version, mode, path + ["vof_explicit_controls"])
                super().__init__(service, version, mode, path)
            class alternate_wall_temp_formulation(TUIMethod):
                """
                Alternate formulation for wall temperatures?.
                """
            class bc_pressure_extrapolations(TUIMethod):
                """
                Setting pressure extrapolations schemes on boundaries.
                """
            class bcd_boundedness(TUIMethod):
                """
                BCD scheme boundedness strength, constant or expression (0 to 1).
                """
            class bcd_weights_freeze(TUIMethod):
                """
                At each timestep, freeze BCD scheme weights after specified iteration
                in order to improve timestep convergence.
                """
            class correction_form(TUIMethod):
                """
                Discretize momentum equations in correction form for the pressure-based solver.
                """
            class disable_reconstruction(TUIMethod):
                """
                Enable/Disable reconstruction. When disabled, accuracy will be first-order.
                """
            class energy_numerical_noise_filter(TUIMethod):
                """
                The energy equation numerical noise filter can be enabled to eliminate non-physical numerical noise in the energy field.
                The numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present.
                Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive.
                """
            class explicit_under_relaxation_value(TUIMethod):
                """
                Explicit under-relaxation value.
                """
            class equation_ordering(TUIMethod):
                """
                Set the equation order.
                """
            class flow_warnings(TUIMethod):
                """
                Control the display of warning diagnostics for boundaries with reversed flow, etc.
                """
            class limiter_warnings(TUIMethod):
                """
                Control the display of limiter warning diagnostics.
                """
            class linearized_mass_transfer_udf(TUIMethod):
                """
                Use linearized mass transfer UDFs?.
                """
            class lock_solid_temperature(TUIMethod):
                """
                Lock the temperature for all solid and shell cell zones in the domain.
                """
            class material_property_warnings(TUIMethod):
                """
                Control the display of material property warning diagnostics:
                0 - off (no messages)
                1 - messages per material
                2 - messages per material and per property.
                """
            class mp_mfluid_aniso_drag(TUIMethod):
                """
                Set anisotropic drag parameters for Eulerian multiphase.
                """
            class mp_reference_density(TUIMethod):
                """
                Set reference density option for Eulerian multiphase.
                """
            class numerical_beach_controls(TUIMethod):
                """
                Set damping function in flow direction.
                """
            class open_channel_controls(TUIMethod):
                """
                Set additional open channel controls.
                """
            class retain_cell_residuals(TUIMethod):
                """
                Retain cell residuals for postprocessing?.
                """
            class retain_temporary_solver_mem(TUIMethod):
                """
                Retain temporary solver memory?.
                """
            class set_all_species_together(TUIMethod):
                """
                Set all species discretizations and URFs together.
                """
            class show_all_discretization_schemes(TUIMethod):
                """
                Allow selection of all applicable discretization schemes?.
                """
            class singhal_et_al_cavitation_model(TUIMethod):
                """
                Use Singhal-et-al cavitation model?.
                """
            class surface_tension(TUIMethod):
                """
                Set surface-tension calculation options.
                """
            class surface_tension_expert(TUIMethod):
                """
                Set surface-tension expert options.
                """
            class vof_explicit_controls(TUIMethod):
                """
                Set Explicit VOF controls.
                """

            class divergence_prevention(TUIMenu):
                """
                Enter the divergence prevention menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable divergence prevention.
                    """

            class high_speed_numerics(TUIMenu):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.visualize_pressure_discontinuity_sensor = self.__class__.visualize_pressure_discontinuity_sensor(service, version, mode, path + ["visualize_pressure_discontinuity_sensor"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable/disable high-speed-numerics.
                    """
                class expert(TUIMethod):
                    """
                    Expert high-speed-numerics.
                    """
                class visualize_pressure_discontinuity_sensor(TUIMethod):
                    """
                    Enable/disable pressure-discontinuity-sensor visualization.
                    """

            class poor_mesh_numerics(TUIMenu):
                """
                Enter Poor Mesh Numerics Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.solution_based_pmn = self.__class__.solution_based_pmn(service, version, mode, path + ["solution_based_pmn"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.cell_quality_based = self.__class__.cell_quality_based(service, version, mode, path + ["cell_quality_based"])
                    self.set_quality_threshold = self.__class__.set_quality_threshold(service, version, mode, path + ["set_quality_threshold"])
                    self.solution_and_quality_based = self.__class__.solution_and_quality_based(service, version, mode, path + ["solution_and_quality_based"])
                    self.gradient_quality_based = self.__class__.gradient_quality_based(service, version, mode, path + ["gradient_quality_based"])
                    self.orthogonality_enhancing_cell_centroids = self.__class__.orthogonality_enhancing_cell_centroids(service, version, mode, path + ["orthogonality_enhancing_cell_centroids"])
                    self.user_defined_on_register = self.__class__.user_defined_on_register(service, version, mode, path + ["user_defined_on_register"])
                    self.reset_poor_elements = self.__class__.reset_poor_elements(service, version, mode, path + ["reset_poor_elements"])
                    self.print_poor_elements_count = self.__class__.print_poor_elements_count(service, version, mode, path + ["print_poor_elements_count"])
                    self.enhanced_pmn = self.__class__.enhanced_pmn(service, version, mode, path + ["enhanced_pmn"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Solution correction on meshes of poor quality.
                    """
                class cell_quality_based(TUIMethod):
                    """
                    Enable/disable poor mesh numerics on cells with low quality.
                    """
                class set_quality_threshold(TUIMethod):
                    """
                    Set quality threshold.
                    """
                class solution_and_quality_based(TUIMethod):
                    """
                    Enable/disable poor mesh numerics based on solution and cell quality.
                    """
                class gradient_quality_based(TUIMethod):
                    """
                    Enable/disable poor mesh numerics based on cell gradient quality.
                    """
                class orthogonality_enhancing_cell_centroids(TUIMethod):
                    """
                    Relocate select cell centroids, to improve orthogonality metrics and solution stability.
                    """
                class user_defined_on_register(TUIMethod):
                    """
                    Include cells in register in poor mesh numerics.
                    """
                class reset_poor_elements(TUIMethod):
                    """
                    Reset marking of poor cell elements.
                    """
                class print_poor_elements_count(TUIMethod):
                    """
                    Print poor cells count.
                    """
                class enhanced_pmn(TUIMethod):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """

                class solution_based_pmn(TUIMenu):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.mark_primary_solution_limits = self.__class__.mark_primary_solution_limits(service, version, mode, path + ["mark_primary_solution_limits"])
                        self.mark_velocity_limit = self.__class__.mark_velocity_limit(service, version, mode, path + ["mark_velocity_limit"])
                        self.mark_cfl_limit = self.__class__.mark_cfl_limit(service, version, mode, path + ["mark_cfl_limit"])
                        self.mark_cfl_jump = self.__class__.mark_cfl_jump(service, version, mode, path + ["mark_cfl_jump"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable solution based treatment.
                        """
                    class mark_primary_solution_limits(TUIMethod):
                        """
                        Mark cells violating solution limits.
                        """
                    class mark_velocity_limit(TUIMethod):
                        """
                        Mark cells exceeding velocity limit.
                        """
                    class mark_cfl_limit(TUIMethod):
                        """
                        Mark cells exceeding cfl limit.
                        """
                    class mark_cfl_jump(TUIMethod):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """

            class previous_defaults(TUIMenu):
                """
                Enter previous defaults menu.
                """
                def __init__(self, service, version, mode, path):
                    self.undo_r19_point_0_default_changes = self.__class__.undo_r19_point_0_default_changes(service, version, mode, path + ["undo_r19_point_0_default_changes"])
                    self.undo_2019r1_default_changes = self.__class__.undo_2019r1_default_changes(service, version, mode, path + ["undo_2019r1_default_changes"])
                    self.undo_2019r3_default_changes = self.__class__.undo_2019r3_default_changes(service, version, mode, path + ["undo_2019r3_default_changes"])
                    self.undo_2021r1_default_changes = self.__class__.undo_2021r1_default_changes(service, version, mode, path + ["undo_2021r1_default_changes"])
                    self.undo_2021r2_default_changes = self.__class__.undo_2021r2_default_changes(service, version, mode, path + ["undo_2021r2_default_changes"])
                    self.undo_2022r1_default_changes = self.__class__.undo_2022r1_default_changes(service, version, mode, path + ["undo_2022r1_default_changes"])
                    super().__init__(service, version, mode, path)
                class undo_r19_point_0_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in R19.0.
                    """
                class undo_2019r1_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2019R1.
                    """
                class undo_2019r3_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2019R3.
                    """
                class undo_2021r1_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2021R1.
                    """
                class undo_2021r2_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2021R2.
                    """
                class undo_2022r1_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in 2022R1.
                    """

            class non_reflecting_boundary_treatment(TUIMenu):
                """
                Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                """
                def __init__(self, service, version, mode, path):
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    super().__init__(service, version, mode, path)
                class pressure_inlet(TUIMethod):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """

            class open_channel_wave_options(TUIMenu):
                """
                Enter the open-channel-wave-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    self.stokes_wave_variants = self.__class__.stokes_wave_variants(service, version, mode, path + ["stokes_wave_variants"])
                    self.set_buffer_layer_ht = self.__class__.set_buffer_layer_ht(service, version, mode, path + ["set_buffer_layer_ht"])
                    super().__init__(service, version, mode, path)
                class set_verbosity(TUIMethod):
                    """
                    Set open channel wave verbosity.
                    """
                class stokes_wave_variants(TUIMethod):
                    """
                    Set stokes wave theory variants.
                    """
                class set_buffer_layer_ht(TUIMethod):
                    """
                    Set bufer layer height between phases for segregated velocity inputs.
                    """

            class secondary_gradient_limiting(TUIMenu):
                """
                Enter the Secondary Gradient Limiting Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                    self.uds = self.__class__.uds(service, version, mode, path + ["uds"])
                    self.mesh_quality_limits = self.__class__.mesh_quality_limits(service, version, mode, path + ["mesh_quality_limits"])
                    super().__init__(service, version, mode, path)
                class energy(TUIMethod):
                    """
                    Enable/disable secondary gradient limiting at coupled walls for energy equation.
                    """
                class uds(TUIMethod):
                    """
                    Enable/disable secondary gradient limiting at coupled walls for user-defined scalars.
                    """
                class mesh_quality_limits(TUIMethod):
                    """
                    Specify minimum and maximum mesh quality limits.
                    """

        class initialize(TUIMenu):
            """
            Enter the flow initialization menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute_defaults = self.__class__.compute_defaults(service, version, mode, path + ["compute_defaults"])
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(service, version, mode, path + ["mp_localized_turb_init"])
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(service, version, mode, path + ["vof_patch_smooth_options"])
                self.set_fmg_options = self.__class__.set_fmg_options(service, version, mode, path + ["set_fmg_options"])
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(service, version, mode, path + ["set_hyb_initialization"])
                self.open_channel_auto_init = self.__class__.open_channel_auto_init(service, version, mode, path + ["open_channel_auto_init"])
                self.levelset_auto_init = self.__class__.levelset_auto_init(service, version, mode, path + ["levelset_auto_init"])
                self.dpm_reset = self.__class__.dpm_reset(service, version, mode, path + ["dpm_reset"])
                self.lwf_initialization = self.__class__.lwf_initialization(service, version, mode, path + ["lwf_initialization"])
                self.initialize_flow = self.__class__.initialize_flow(service, version, mode, path + ["initialize_flow"])
                self.init_acoustics_options = self.__class__.init_acoustics_options(service, version, mode, path + ["init_acoustics_options"])
                self.hyb_initialization = self.__class__.hyb_initialization(service, version, mode, path + ["hyb_initialization"])
                self.init_flow_statistics = self.__class__.init_flow_statistics(service, version, mode, path + ["init_flow_statistics"])
                self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
                self.show_time_sampled = self.__class__.show_time_sampled(service, version, mode, path + ["show_time_sampled"])
                self.show_iterations_sampled = self.__class__.show_iterations_sampled(service, version, mode, path + ["show_iterations_sampled"])
                self.init_turb_vel_fluctuations = self.__class__.init_turb_vel_fluctuations(service, version, mode, path + ["init_turb_vel_fluctuations"])
                self.fmg_initialization = self.__class__.fmg_initialization(service, version, mode, path + ["fmg_initialization"])
                self.repair_wall_distance = self.__class__.repair_wall_distance(service, version, mode, path + ["repair_wall_distance"])
                self.set_defaults = self.__class__.set_defaults(service, version, mode, path + ["set_defaults"])
                self.set_fmg_initialization = self.__class__.set_fmg_initialization(service, version, mode, path + ["set_fmg_initialization"])
                self.list_defaults = self.__class__.list_defaults(service, version, mode, path + ["list_defaults"])
                self.reference_frame = self.__class__.reference_frame(service, version, mode, path + ["reference_frame"])
                super().__init__(service, version, mode, path)
            class open_channel_auto_init(TUIMethod):
                """
                Open channel automatic initialization.
                """
            class levelset_auto_init(TUIMethod):
                """
                Levelset function automatic initialization.
                """
            class dpm_reset(TUIMethod):
                """
                Reset discrete phase source terms to zero.
                """
            class lwf_initialization(TUIMethod):
                """
                Delete wall film particles and initialize wall film variables to zero.
                """
            class initialize_flow(TUIMethod):
                """
                Initialize the flow field with the current default values.
                """
            class init_acoustics_options(TUIMethod):
                """
                Specify number of timesteps for ramping of sources
                and initialize acoustics model variables.
                During ramping the sound sources are multiplied by a factor smoothly growing from 0 to 1.
                """
            class hyb_initialization(TUIMethod):
                """
                Initialize using the hybrid initialization method.
                """
            class init_flow_statistics(TUIMethod):
                """
                Initialize statistics.
                """
            class patch(TUIMethod):
                """
                Patch a value for a flow variable in the domain.
                """
            class show_time_sampled(TUIMethod):
                """
                Display the amount of simulated time covered by the data sampled for unsteady statistics.
                """
            class show_iterations_sampled(TUIMethod):
                """
                Display the amount of simulated iterations covered by the data sampled for steady statistics.
                """
            class init_turb_vel_fluctuations(TUIMethod):
                """
                Initialize turbulent velocity fluctuations.
                """
            class fmg_initialization(TUIMethod):
                """
                Initialize using the full-multigrid initialization (FMG).
                """
            class repair_wall_distance(TUIMethod):
                """
                Correct wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
            class set_defaults(TUIMethod):
                """
                Enter the set defaults menu.
                """
            class set_fmg_initialization(TUIMethod):
                """
                Enter the set full-multigrid for initialization menu.
                """
            class list_defaults(TUIMethod):
                """
                List default values.
                """
            class reference_frame(TUIMethod):
                """
                Set reference frame absolute or relative.
                """

            class compute_defaults(TUIMenu):
                """
                Enter the compute defaults menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.all_zones = self.__class__.all_zones(service, version, mode, path + ["all_zones"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class all_zones(TUIMethod):
                    """
                    Initialize the flow field with the default values.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """

            class mp_localized_turb_init(TUIMenu):
                """
                Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turb_init_parameters = self.__class__.turb_init_parameters(service, version, mode, path + ["turb_init_parameters"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                    """
                class turb_init_parameters(TUIMethod):
                    """
                    Turbulent flow parameters for localized initialization.
                    """

            class vof_patch_smooth_options(TUIMenu):
                """
                Enter the vof patch/smooth options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_options = self.__class__.set_options(service, version, mode, path + ["set_options"])
                    self.execute_smoothing = self.__class__.execute_smoothing(service, version, mode, path + ["execute_smoothing"])
                    super().__init__(service, version, mode, path)
                class set_options(TUIMethod):
                    """
                    Patch and smoothing options for volume fraction.
                    """
                class execute_smoothing(TUIMethod):
                    """
                    Execute volumetric smoothing for volume fraction.
                    """

            class set_fmg_options(TUIMenu):
                """
                Enter the full-multigrid option menu.
                """
                def __init__(self, service, version, mode, path):
                    self.viscous_terms = self.__class__.viscous_terms(service, version, mode, path + ["viscous_terms"])
                    self.species_reactions = self.__class__.species_reactions(service, version, mode, path + ["species_reactions"])
                    self.set_turbulent_viscosity_ratio = self.__class__.set_turbulent_viscosity_ratio(service, version, mode, path + ["set_turbulent_viscosity_ratio"])
                    super().__init__(service, version, mode, path)
                class viscous_terms(TUIMethod):
                    """
                    Enable/disable viscous terms during FMG initialization.
                    """
                class species_reactions(TUIMethod):
                    """
                    Enable/disable species volumetric reactions during FMG initialization.
                    """
                class set_turbulent_viscosity_ratio(TUIMethod):
                    """
                    Set turbulent viscosity ratio used during FMG initialization.
                    """

            class set_hyb_initialization(TUIMenu):
                """
                Enter the settings for hybrid initialization method.
                """
                def __init__(self, service, version, mode, path):
                    self.general_settings = self.__class__.general_settings(service, version, mode, path + ["general_settings"])
                    self.turbulent_settings = self.__class__.turbulent_settings(service, version, mode, path + ["turbulent_settings"])
                    self.species_settings = self.__class__.species_settings(service, version, mode, path + ["species_settings"])
                    super().__init__(service, version, mode, path)
                class general_settings(TUIMethod):
                    """
                    Enter the general settings menu.
                    """
                class turbulent_settings(TUIMethod):
                    """
                    Enter the turbulent settings menu.
                    """
                class species_settings(TUIMethod):
                    """
                    Enter the species settings menu.
                    """

        class methods(TUIMenu):
            """
            Enter the methods menu.
            """
            def __init__(self, service, version, mode, path):
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.accelerated_non_iterative_time_marching = self.__class__.accelerated_non_iterative_time_marching(service, version, mode, path + ["accelerated_non_iterative_time_marching"])
                self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                self.frozen_flux = self.__class__.frozen_flux(service, version, mode, path + ["frozen_flux"])
                self.gradient_scheme = self.__class__.gradient_scheme(service, version, mode, path + ["gradient_scheme"])
                self.nb_gradient_boundary_option = self.__class__.nb_gradient_boundary_option(service, version, mode, path + ["nb_gradient_boundary_option"])
                self.noniterative_time_advance = self.__class__.noniterative_time_advance(service, version, mode, path + ["noniterative_time_advance"])
                self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                self.phase_based_vof_discretization = self.__class__.phase_based_vof_discretization(service, version, mode, path + ["phase_based_vof_discretization"])
                self.reduced_rank_extrapolation = self.__class__.reduced_rank_extrapolation(service, version, mode, path + ["reduced_rank_extrapolation"])
                self.reduced_rank_extrapolation_options = self.__class__.reduced_rank_extrapolation_options(service, version, mode, path + ["reduced_rank_extrapolation_options"])
                self.residual_smoothing = self.__class__.residual_smoothing(service, version, mode, path + ["residual_smoothing"])
                self.set_solution_methods_to_default = self.__class__.set_solution_methods_to_default(service, version, mode, path + ["set_solution_methods_to_default"])
                self.unsteady_1st_order = self.__class__.unsteady_1st_order(service, version, mode, path + ["unsteady_1st_order"])
                self.unsteady_2nd_order = self.__class__.unsteady_2nd_order(service, version, mode, path + ["unsteady_2nd_order"])
                self.unsteady_2nd_order_bounded = self.__class__.unsteady_2nd_order_bounded(service, version, mode, path + ["unsteady_2nd_order_bounded"])
                self.unsteady_global_time = self.__class__.unsteady_global_time(service, version, mode, path + ["unsteady_global_time"])
                self.vof_numerics = self.__class__.vof_numerics(service, version, mode, path + ["vof_numerics"])
                super().__init__(service, version, mode, path)
            class accelerated_non_iterative_time_marching(TUIMethod):
                """
                Enable/disable accelerated non-iterative time marching.
                """
            class convergence_acceleration_for_stretched_meshes(TUIMethod):
                """
                Enable convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
            class discretization_scheme(TUIMethod):
                """
                Enter the discretization-scheme menu.
                """
            class flux_type(TUIMethod):
                """
                Enter the flux type.
                """
            class frozen_flux(TUIMethod):
                """
                Enable/disable frozen flux formulation for transient flows.
                """
            class gradient_scheme(TUIMethod):
                """
                Set gradient options.
                """
            class nb_gradient_boundary_option(TUIMethod):
                """
                Set ggnb options.
                """
            class noniterative_time_advance(TUIMethod):
                """
                Enable/disable the noniterative time advancement scheme.
                """
            class p_v_coupling(TUIMethod):
                """
                Select the pressure velocity coupling scheme.
                """
            class phase_based_vof_discretization(TUIMethod):
                """
                Set phase based slope limiter for VOF compressive scheme.
                """
            class reduced_rank_extrapolation(TUIMethod):
                """
                Enable Reduced Rank Extrapolation method to accelerate solution time.
                """
            class reduced_rank_extrapolation_options(TUIMethod):
                """
                Reduced Rank Extrapolation options.
                """
            class residual_smoothing(TUIMethod):
                """
                Set residual smoothing factor and number of iterations.
                """
            class set_solution_methods_to_default(TUIMethod):
                """
                Set solution methods to default values.
                """
            class unsteady_1st_order(TUIMethod):
                """
                Enable/disable first-order unsteady solution model.
                """
            class unsteady_2nd_order(TUIMethod):
                """
                Enable/disable the second-order unsteady solution model.
                """
            class unsteady_2nd_order_bounded(TUIMethod):
                """
                Enable/disable bounded second-order unsteady formulation.
                """
            class unsteady_global_time(TUIMethod):
                """
                Enable/disable the unsteady global-time-step solution model.
                """
            class vof_numerics(TUIMethod):
                """
                Set VOF numeric options.
                """

            class expert(TUIMenu):
                """
                Enter expert menu.
                """
                def __init__(self, service, version, mode, path):
                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                    self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                    super().__init__(service, version, mode, path)
                class reactions(TUIMethod):
                    """
                    Enable/disable the species reaction sources and set relaxation factor.
                    """
                class numerics(TUIMethod):
                    """
                    Set numeric options.
                    """

            class high_order_term_relaxation(TUIMenu):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable/Disable High Order Term Relaxation.
                    """

                class options(TUIMenu):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.variables = self.__class__.variables(service, version, mode, path + ["variables"])
                        self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        super().__init__(service, version, mode, path)
                    class relaxation_factor(TUIMethod):
                        """
                        Sets relaxation factor.
                        """
                    class expert(TUIMethod):
                        """
                        Enter high order relaxation option with respect to diffusion gradient.
                        """

                    class variables(TUIMenu):
                        """
                        Select Variables.
                        """
                        def __init__(self, service, version, mode, path):
                            self.select = self.__class__.select(service, version, mode, path + ["select"])
                            super().__init__(service, version, mode, path)
                        class select(TUIMethod):
                            """
                            Select variables for high order term relaxation.
                            """

            class multiphase_numerics(TUIMenu):
                """
                Enter the multiphase numerics options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    super().__init__(service, version, mode, path)

                class porous_media(TUIMenu):
                    """
                    Multiphase relative permeability numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.relative_permeability = self.__class__.relative_permeability(service, version, mode, path + ["relative_permeability"])
                        super().__init__(service, version, mode, path)
                    class relative_permeability(TUIMethod):
                        """
                        Multiphase relative permeability fix option.
                        """

                class compressible_flow(TUIMenu):
                    """
                    Multiphase compressible numerics options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enhanced_numerics = self.__class__.enhanced_numerics(service, version, mode, path + ["enhanced_numerics"])
                        self.alternate_bc_formulation = self.__class__.alternate_bc_formulation(service, version, mode, path + ["alternate_bc_formulation"])
                        super().__init__(service, version, mode, path)
                    class enhanced_numerics(TUIMethod):
                        """
                        Multiphase enhanced compressible flow numerics options.
                        """
                    class alternate_bc_formulation(TUIMethod):
                        """
                        Multiphase compressible flow BC alternate method.
                        """

                class boiling_parameters(TUIMenu):
                    """
                    Multiphase boiling parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.thin_film = self.__class__.thin_film(service, version, mode, path + ["thin_film"])
                        self.liquid_vof_factor = self.__class__.liquid_vof_factor(service, version, mode, path + ["liquid_vof_factor"])
                        super().__init__(service, version, mode, path)
                    class thin_film(TUIMethod):
                        """
                        Multiphase boiling thin film effects.
                        """
                    class liquid_vof_factor(TUIMethod):
                        """
                        Multiphase boiling liquid volume fraction effects.
                        """

                class viscous_flow(TUIMenu):
                    """
                    Multiphase viscous flow numerics options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.viscosity_averaging = self.__class__.viscosity_averaging(service, version, mode, path + ["viscosity_averaging"])
                        self.turb_visc_based_damping = self.__class__.turb_visc_based_damping(service, version, mode, path + ["turb_visc_based_damping"])
                        self.interfacial_artificial_viscosity = self.__class__.interfacial_artificial_viscosity(service, version, mode, path + ["interfacial_artificial_viscosity"])
                        super().__init__(service, version, mode, path)
                    class viscosity_averaging(TUIMethod):
                        """
                        Multiphase options for viscosity averaging.
                        """
                    class turb_visc_based_damping(TUIMethod):
                        """
                        Turbulence viscosity based damping controls.
                        """
                    class interfacial_artificial_viscosity(TUIMethod):
                        """
                        Interfacial artifical viscosity controls.
                        """

                class heat_mass_transfer(TUIMenu):
                    """
                    Multiphase interphase heat and mass transfer numerics options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.alternative_energy_treatment = self.__class__.alternative_energy_treatment(service, version, mode, path + ["alternative_energy_treatment"])
                        super().__init__(service, version, mode, path)
                    class alternative_energy_treatment(TUIMethod):
                        """
                        Alternative treatment of latent heat source due to mass transfer.
                        """

                    class cavitation(TUIMenu):
                        """
                        Cavitation numerics options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.schnerr_evap_coeff = self.__class__.schnerr_evap_coeff(service, version, mode, path + ["schnerr_evap_coeff"])
                            self.schnerr_cond_coeff = self.__class__.schnerr_cond_coeff(service, version, mode, path + ["schnerr_cond_coeff"])
                            self.max_vapor_pressure_ratio = self.__class__.max_vapor_pressure_ratio(service, version, mode, path + ["max_vapor_pressure_ratio"])
                            self.min_vapor_pressure = self.__class__.min_vapor_pressure(service, version, mode, path + ["min_vapor_pressure"])
                            self.display_clipped_pressure = self.__class__.display_clipped_pressure(service, version, mode, path + ["display_clipped_pressure"])
                            self.turbulent_diffusion = self.__class__.turbulent_diffusion(service, version, mode, path + ["turbulent_diffusion"])
                            super().__init__(service, version, mode, path)
                        class schnerr_evap_coeff(TUIMethod):
                            """
                            Evaporation coefficient for Schnerr-Sauer model.
                            """
                        class schnerr_cond_coeff(TUIMethod):
                            """
                            Condensation coefficient for Schnerr-Sauer model.
                            """
                        class max_vapor_pressure_ratio(TUIMethod):
                            """
                            Maximum limit on vapor pressure after turbulence and thermal correction.
                            """
                        class min_vapor_pressure(TUIMethod):
                            """
                            Minimum vapor pressure limit for cavitation model.
                            """
                        class display_clipped_pressure(TUIMethod):
                            """
                            Clipped pressure is just used for the properties evaluation. Mass Transfer Rate uses unclipped pressure.
                            """
                        class turbulent_diffusion(TUIMethod):
                            """
                            Enable/disable turbulent diffusion treatment between phases participating in cavitation.
                            This treatment is generally recommended for better solution stability.
                            However, in case of numerical difficulties, it can be disabled.
                            """

                    class evaporation_condensation(TUIMenu):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.vof_from_min_limit = self.__class__.vof_from_min_limit(service, version, mode, path + ["vof_from_min_limit"])
                            self.vof_from_max_limit = self.__class__.vof_from_max_limit(service, version, mode, path + ["vof_from_max_limit"])
                            self.vof_to_min_limit = self.__class__.vof_to_min_limit(service, version, mode, path + ["vof_to_min_limit"])
                            self.vof_to_max_limit = self.__class__.vof_to_max_limit(service, version, mode, path + ["vof_to_max_limit"])
                            self.ia_norm_min_limit = self.__class__.ia_norm_min_limit(service, version, mode, path + ["ia_norm_min_limit"])
                            self.max_rel_humidity = self.__class__.max_rel_humidity(service, version, mode, path + ["max_rel_humidity"])
                            super().__init__(service, version, mode, path)
                        class vof_from_min_limit(TUIMethod):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                        class vof_from_max_limit(TUIMethod):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                        class vof_to_min_limit(TUIMethod):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                        class vof_to_max_limit(TUIMethod):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                        class ia_norm_min_limit(TUIMethod):
                            """
                            Minimum normalized area density below which mass transfer rate is set to zero.
                            """
                        class max_rel_humidity(TUIMethod):
                            """
                            Maximum value of relative humidity to limit condensation rate.
                            """

                    class boiling(TUIMenu):
                        """
                        Boiling advanced options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.heat_flux_relaxation_factor = self.__class__.heat_flux_relaxation_factor(service, version, mode, path + ["heat_flux_relaxation_factor"])
                            self.show_expert_options = self.__class__.show_expert_options(service, version, mode, path + ["show_expert_options"])
                            self.two_resistance_boiling_framework = self.__class__.two_resistance_boiling_framework(service, version, mode, path + ["two_resistance_boiling_framework"])
                            super().__init__(service, version, mode, path)
                        class heat_flux_relaxation_factor(TUIMethod):
                            """
                            Under-relaxation factor for boiling heat flux.
                            """
                        class show_expert_options(TUIMethod):
                            """
                            Exposes expert options of min/max superheat along with wetting fraction controls.
                            """
                        class two_resistance_boiling_framework(TUIMethod):
                            """
                            Allow generalized two-resistance framework for boiling model.
                            """

                    class area_density(TUIMenu):
                        """
                        Interfacial area density menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.vof_min_seeding = self.__class__.vof_min_seeding(service, version, mode, path + ["vof_min_seeding"])
                            self.ia_grad_sym = self.__class__.ia_grad_sym(service, version, mode, path + ["ia_grad_sym"])
                            super().__init__(service, version, mode, path)
                        class vof_min_seeding(TUIMethod):
                            """
                            Minimum vof seeding for non-zero area density in heat and mass transfer.
                            """
                        class ia_grad_sym(TUIMethod):
                            """
                            Interfacial area density gradient-symmetric mechanism.
                            """

                class advanced_stability_controls(TUIMenu):
                    """
                    Stability controls for multiphase flow.
                    """
                    def __init__(self, service, version, mode, path):
                        self.pseudo_time = self.__class__.pseudo_time(service, version, mode, path + ["pseudo_time"])
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        super().__init__(service, version, mode, path)

                    class pseudo_time(TUIMenu):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            self.smoothed_density_stabilization_method = self.__class__.smoothed_density_stabilization_method(service, version, mode, path + ["smoothed_density_stabilization_method"])
                            self.false_time_step_linearization = self.__class__.false_time_step_linearization(service, version, mode, path + ["false_time_step_linearization"])
                            super().__init__(service, version, mode, path)
                        class smoothed_density_stabilization_method(TUIMethod):
                            """
                            Set smoothed density stabilization method.
                            """
                        class false_time_step_linearization(TUIMethod):
                            """
                            Set false time-step linearization for added stability.
                            """

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.dt_init_limit = self.__class__.dt_init_limit(service, version, mode, path + ["dt_init_limit"])
                                self.dt_max = self.__class__.dt_max(service, version, mode, path + ["dt_max"])
                                self.dt_factor_min = self.__class__.dt_factor_min(service, version, mode, path + ["dt_factor_min"])
                                self.dt_factor_max = self.__class__.dt_factor_max(service, version, mode, path + ["dt_factor_max"])
                                self.max_velocity_ratio = self.__class__.max_velocity_ratio(service, version, mode, path + ["max_velocity_ratio"])
                                super().__init__(service, version, mode, path)
                            class enable(TUIMethod):
                                """
                                Enable advanced automatic time stepping for better stability.
                                """
                            class dt_init_limit(TUIMethod):
                                """
                                Set maximum value for pseudo time step size during first iteration.
                                """
                            class dt_max(TUIMethod):
                                """
                                Set maximum value for pseudo time step size.
                                """
                            class dt_factor_min(TUIMethod):
                                """
                                Set minimum limit for reduction in pseudo time step size.
                                """
                            class dt_factor_max(TUIMethod):
                                """
                                Set maximum limit for increase in pseudo time step size.
                                """
                            class max_velocity_ratio(TUIMethod):
                                """
                                Set velocity ratio to freeze the time step size for better solution stability.
                                """

                    class p_v_coupling(TUIMenu):
                        """
                        Pressure velocity coupling controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            super().__init__(service, version, mode, path)

                        class coupled_vof(TUIMenu):
                            """
                            Set Coupled VOF stability controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self.buoyancy_force_linearization = self.__class__.buoyancy_force_linearization(service, version, mode, path + ["buoyancy_force_linearization"])
                                super().__init__(service, version, mode, path)
                            class buoyancy_force_linearization(TUIMethod):
                                """
                                Set buoynacy force linerization options in coupled vof.
                                """

                        class rhie_chow_flux(TUIMenu):
                            """
                            Set Rhie-Chow related stability controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self.low_order_rhie_chow = self.__class__.low_order_rhie_chow(service, version, mode, path + ["low_order_rhie_chow"])
                                super().__init__(service, version, mode, path)
                            class low_order_rhie_chow(TUIMethod):
                                """
                                Use low order velocity interpolation in flux calculation.
                                """

                        class skewness_correction(TUIMenu):
                            """
                            Skewness correction related stabiity controls for multiphase flow.
                            """
                            def __init__(self, service, version, mode, path):
                                self.limit_pressure_correction_gradient = self.__class__.limit_pressure_correction_gradient(service, version, mode, path + ["limit_pressure_correction_gradient"])
                                super().__init__(service, version, mode, path)
                            class limit_pressure_correction_gradient(TUIMethod):
                                """
                                Use limited pressure correction gradient in skewness corrections for better stability.
                                """

                    class hybrid_nita(TUIMenu):
                        """
                        Hybrid NITA stability controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            self.outer_iterations = self.__class__.outer_iterations(service, version, mode, path + ["outer_iterations"])
                            self.initial_outer_iterations = self.__class__.initial_outer_iterations(service, version, mode, path + ["initial_outer_iterations"])
                            super().__init__(service, version, mode, path)
                        class outer_iterations(TUIMethod):
                            """
                            Set number of outer iterations in hybrid nita.
                            """
                        class initial_outer_iterations(TUIMethod):
                            """
                            Set hybrid nita start-up controls.
                            """

                        class instability_detector(TUIMenu):
                            """
                            Set Hybrid NITA instability detector controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_instability_detector = self.__class__.enable_instability_detector(service, version, mode, path + ["enable_instability_detector"])
                                self.set_cfl_limit = self.__class__.set_cfl_limit(service, version, mode, path + ["set_cfl_limit"])
                                self.set_cfl_type = self.__class__.set_cfl_type(service, version, mode, path + ["set_cfl_type"])
                                self.set_velocity_limit = self.__class__.set_velocity_limit(service, version, mode, path + ["set_velocity_limit"])
                                self.unstable_event_outer_iterations = self.__class__.unstable_event_outer_iterations(service, version, mode, path + ["unstable_event_outer_iterations"])
                                super().__init__(service, version, mode, path)
                            class enable_instability_detector(TUIMethod):
                                """
                                Enable instability detector for better stability.
                                """
                            class set_cfl_limit(TUIMethod):
                                """
                                Set Courant Number limit for detection of unstable event.
                                """
                            class set_cfl_type(TUIMethod):
                                """
                                Set Courant Number type for detection of unstable event.
                                """
                            class set_velocity_limit(TUIMethod):
                                """
                                Set velocity limit for detection of unstable event.
                                """
                            class unstable_event_outer_iterations(TUIMethod):
                                """
                                Set number of outer iterations for unstable event.
                                """

                    class equation_order(TUIMenu):
                        """
                        Equation Order Menu for Homogeneous Multiphase Flow Models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.solve_flow_last = self.__class__.solve_flow_last(service, version, mode, path + ["solve_flow_last"])
                            self.solve_exp_vof_at_end = self.__class__.solve_exp_vof_at_end(service, version, mode, path + ["solve_exp_vof_at_end"])
                            super().__init__(service, version, mode, path)
                        class solve_flow_last(TUIMethod):
                            """
                            Solve flow equation at the end of iteration as an alternative.
                            """
                        class solve_exp_vof_at_end(TUIMethod):
                            """
                            Solve Explicit VOF at the end of time-step as an alternative.
                            """

                    class anti_diffusion(TUIMenu):
                        """
                        Anti Diffusion Menu for VOF/Multi-Fluid VOF Models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_dynamic_strength = self.__class__.enable_dynamic_strength(service, version, mode, path + ["enable_dynamic_strength"])
                            self.set_dynamic_strength_exponent = self.__class__.set_dynamic_strength_exponent(service, version, mode, path + ["set_dynamic_strength_exponent"])
                            self.set_maximum_dynamic_strength = self.__class__.set_maximum_dynamic_strength(service, version, mode, path + ["set_maximum_dynamic_strength"])
                            super().__init__(service, version, mode, path)
                        class enable_dynamic_strength(TUIMethod):
                            """
                            Enable dynamic strength to reduce compression in the tangential direction to the interface.
                            """
                        class set_dynamic_strength_exponent(TUIMethod):
                            """
                            Set cosine exponent in dynamic strength treatment.
                            """
                        class set_maximum_dynamic_strength(TUIMethod):
                            """
                            Set maximum value of dynamic anti-diffusion strength.
                            """

                class default_controls(TUIMenu):
                    """
                    Multiphase default controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.recommended_defaults_for_existing_cases = self.__class__.recommended_defaults_for_existing_cases(service, version, mode, path + ["recommended_defaults_for_existing_cases"])
                        self.revert_to_pre_r20_point_1_default_settings = self.__class__.revert_to_pre_r20_point_1_default_settings(service, version, mode, path + ["revert_to_pre_r20_point_1_default_settings"])
                        super().__init__(service, version, mode, path)
                    class recommended_defaults_for_existing_cases(TUIMethod):
                        """
                        Activate multiphase defaults for loaded case.
                        """
                    class revert_to_pre_r20_point_1_default_settings(TUIMethod):
                        """
                        Revert to pre-R20.1 multiphase flow default settings.
                        """

                class face_pressure_controls(TUIMenu):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.face_pressure_options = self.__class__.face_pressure_options(service, version, mode, path + ["face_pressure_options"])
                        super().__init__(service, version, mode, path)
                    class face_pressure_options(TUIMethod):
                        """
                        Set face pressure options.
                        """

                class solution_stabilization(TUIMenu):
                    """
                    VOF solution stabilization menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        self.execute_settings_optimization = self.__class__.execute_settings_optimization(service, version, mode, path + ["execute_settings_optimization"])
                        self.execute_advanced_stabilization = self.__class__.execute_advanced_stabilization(service, version, mode, path + ["execute_advanced_stabilization"])
                        self.execute_additional_stability_controls = self.__class__.execute_additional_stability_controls(service, version, mode, path + ["execute_additional_stability_controls"])
                        super().__init__(service, version, mode, path)
                    class execute_settings_optimization(TUIMethod):
                        """
                        Execute optimized settings for VOF.
                        """
                    class execute_advanced_stabilization(TUIMethod):
                        """
                        Execute advanced stabilization for VOF.
                        """
                    class execute_additional_stability_controls(TUIMethod):
                        """
                        Execute additional stability controls for VOF.
                        """

                    class additional_stabilization_controls(TUIMenu):
                        """
                        Additional advanced stability controls for VOF.
                        """
                        def __init__(self, service, version, mode, path):
                            self.blended_compressive_scheme = self.__class__.blended_compressive_scheme(service, version, mode, path + ["blended_compressive_scheme"])
                            self.pseudo_time_stabilization = self.__class__.pseudo_time_stabilization(service, version, mode, path + ["pseudo_time_stabilization"])
                            super().__init__(service, version, mode, path)
                        class blended_compressive_scheme(TUIMethod):
                            """
                            Blended Compressive discretization scheme for VOF.
                            """
                        class pseudo_time_stabilization(TUIMethod):
                            """
                            Pseudo-Time Momentum stabilization and False Time Step Linearization methods for VOF.
                            """

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        Velocity limiting related stabiity controls for VOF.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_velocity_limiting = self.__class__.enable_velocity_limiting(service, version, mode, path + ["enable_velocity_limiting"])
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            self.set_velocity_cutoff = self.__class__.set_velocity_cutoff(service, version, mode, path + ["set_velocity_cutoff"])
                            self.set_damping_strength = self.__class__.set_damping_strength(service, version, mode, path + ["set_damping_strength"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class enable_velocity_limiting(TUIMethod):
                            """
                            Enable velocity limiting treatment.
                            """
                        class set_velocity_and_vof_cutoffs(TUIMethod):
                            """
                            Set phase based velocity limiting controls.
                            """
                        class set_damping_strengths(TUIMethod):
                            """
                            Set phase based damping strength.
                            """
                        class set_velocity_cutoff(TUIMethod):
                            """
                            Enter max velocity magnitude.
                            """
                        class set_damping_strength(TUIMethod):
                            """
                            Enter damping strength.
                            """
                        class verbosity(TUIMethod):
                            """
                            Enable verbosity to print number of velocity limited cells during iterations.
                            """

            class nita_expert_controls(TUIMenu):
                """
                Enter the nita expert controls menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    self.skewness_neighbor_coupling = self.__class__.skewness_neighbor_coupling(service, version, mode, path + ["skewness_neighbor_coupling"])
                    self.hybrid_nita_settings = self.__class__.hybrid_nita_settings(service, version, mode, path + ["hybrid_nita_settings"])
                    super().__init__(service, version, mode, path)
                class set_verbosity(TUIMethod):
                    """
                    Set nita verbosity option.
                    """
                class skewness_neighbor_coupling(TUIMethod):
                    """
                    Set skewness neighbor coupling for nita.
                    """
                class hybrid_nita_settings(TUIMethod):
                    """
                    Select a hybrid NITA settings option for faster performance and better robustness.
                    """

            class overset(TUIMenu):
                """
                Enter overset solver options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.high_order_pressure = self.__class__.high_order_pressure(service, version, mode, path + ["high_order_pressure"])
                    self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                    self.orphan_cell_treatment = self.__class__.orphan_cell_treatment(service, version, mode, path + ["orphan_cell_treatment"])
                    super().__init__(service, version, mode, path)
                class high_order_pressure(TUIMethod):
                    """
                    High order pressure extrapolation at overset interface.
                    """
                class interpolation_method(TUIMethod):
                    """
                    Choose the interpolation method for overset interface(s).
                    """
                class orphan_cell_treatment(TUIMethod):
                    """
                    Enable solver to run with orphans present.
                    """

                class expert(TUIMenu):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mass_flux_correction_method = self.__class__.mass_flux_correction_method(service, version, mode, path + ["mass_flux_correction_method"])
                        self.hybrid_mode_selection = self.__class__.hybrid_mode_selection(service, version, mode, path + ["hybrid_mode_selection"])
                        super().__init__(service, version, mode, path)
                    class mass_flux_correction_method(TUIMethod):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """
                    class hybrid_mode_selection(TUIMethod):
                        """
                        Mode for hybrid interpolation.
                        """

            class pseudo_time_method(TUIMenu):
                """
                Enter the pseudo time method menu.
                """
                def __init__(self, service, version, mode, path):
                    self.formulation = self.__class__.formulation(service, version, mode, path + ["formulation"])
                    self.local_time_step_settings = self.__class__.local_time_step_settings(service, version, mode, path + ["local_time_step_settings"])
                    self.global_time_step_settings = self.__class__.global_time_step_settings(service, version, mode, path + ["global_time_step_settings"])
                    self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                    self.relaxation_factors = self.__class__.relaxation_factors(service, version, mode, path + ["relaxation_factors"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    self.relaxation_bounds = self.__class__.relaxation_bounds(service, version, mode, path + ["relaxation_bounds"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class formulation(TUIMethod):
                    """
                    Select the pseudo time step size formulation for the pseudo time method.
                    """
                class local_time_step_settings(TUIMethod):
                    """
                    Adjust the settings for the local time step formulation.
                    """
                class global_time_step_settings(TUIMethod):
                    """
                    Adjust the settings for the global time step formulation.
                    """
                class advanced_options(TUIMethod):
                    """
                    Enter the advanced options menu to define pseudo time settings for equations.
                    """
                class relaxation_factors(TUIMethod):
                    """
                    Enter the relaxation factors menu to set the pseudo time explicit relaxation factors for equations.
                    """
                class relaxation_method(TUIMethod):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                class relaxation_bounds(TUIMethod):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                class verbosity(TUIMethod):
                    """
                    Set the verbosity for the pseudo time method.
                    """

            class query(TUIMenu):
                """
                Enter methods query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                    self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                    super().__init__(service, version, mode, path)
                class discretization_scheme(TUIMethod):
                    """
                    Enter the discretization-scheme menu.
                    """
                class p_v_coupling(TUIMethod):
                    """
                    Get the pressure velocity coupling scheme.
                    """

            class warped_face_gradient_correction(TUIMenu):
                """
                Enter warped-face-gradient-correction menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turbulence_options = self.__class__.turbulence_options(service, version, mode, path + ["turbulence_options"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable Warped-Face Gradient Correction.
                    """
                class turbulence_options(TUIMethod):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """

        class monitors(TUIMenu):
            """
            Enter the monitors menu.
            """
            def __init__(self, service, version, mode, path):
                self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
                self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
                self.residual = self.__class__.residual(service, version, mode, path + ["residual"])
                self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
                self.set_average_over = self.__class__.set_average_over(service, version, mode, path + ["set_average_over"])
                super().__init__(service, version, mode, path)
            class convergence_conditions(TUIMethod):
                """
                Manage convergence report.
                """
            class set_average_over(TUIMethod):
                """
                Set the average over input for monitors.
                """

            class report_files(TUIMenu):
                """
                Manage report files.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class clear_data(TUIMethod):
                    """
                    Delete the report file from the system.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete all report file objects.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """

            class report_plots(TUIMenu):
                """
                Manage report plots.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class axes(TUIMethod):
                    """
                    Set axes options of an object.
                    """
                class clear_data(TUIMethod):
                    """
                    Clear report plot data.
                    """
                class curves(TUIMethod):
                    """
                    Set curves options of an object.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete all plot objects.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """
                class plot(TUIMethod):
                    """
                    Plot.
                    """

            class residual(TUIMenu):
                """
                Enter the residual monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self.check_convergence = self.__class__.check_convergence(service, version, mode, path + ["check_convergence"])
                    self.convergence_criteria = self.__class__.convergence_criteria(service, version, mode, path + ["convergence_criteria"])
                    self.criterion_type = self.__class__.criterion_type(service, version, mode, path + ["criterion_type"])
                    self.monitor = self.__class__.monitor(service, version, mode, path + ["monitor"])
                    self.enhanced_continuity_residual = self.__class__.enhanced_continuity_residual(service, version, mode, path + ["enhanced_continuity_residual"])
                    self.n_display = self.__class__.n_display(service, version, mode, path + ["n_display"])
                    self.n_maximize_norms = self.__class__.n_maximize_norms(service, version, mode, path + ["n_maximize_norms"])
                    self.normalization_factors = self.__class__.normalization_factors(service, version, mode, path + ["normalization_factors"])
                    self.normalize = self.__class__.normalize(service, version, mode, path + ["normalize"])
                    self.n_save = self.__class__.n_save(service, version, mode, path + ["n_save"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.relative_conv_criteria = self.__class__.relative_conv_criteria(service, version, mode, path + ["relative_conv_criteria"])
                    self.re_normalize = self.__class__.re_normalize(service, version, mode, path + ["re_normalize"])
                    self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                    self.scale_by_coefficient = self.__class__.scale_by_coefficient(service, version, mode, path + ["scale_by_coefficient"])
                    super().__init__(service, version, mode, path)
                class check_convergence(TUIMethod):
                    """
                    Choose which currently-monitored residuals
                    should be checked for convergence.
                    """
                class convergence_criteria(TUIMethod):
                    """
                    Set convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                class criterion_type(TUIMethod):
                    """
                    Set convergence criterion type.
                    """
                class monitor(TUIMethod):
                    """
                    Choose which residuals to monitor as printed and/or plotted output.
                    """
                class enhanced_continuity_residual(TUIMethod):
                    """
                    Scale the continuity residuals locally based on the enhanced formulation.
                    """
                class n_display(TUIMethod):
                    """
                    Set the number of most recent residuals to display in plots.
                    """
                class n_maximize_norms(TUIMethod):
                    """
                    Set the number of iterations through which normalization
                    factors will be maximized.
                    """
                class normalization_factors(TUIMethod):
                    """
                    Set normalization factors for currently-monitored residuals.
                    """
                class normalize(TUIMethod):
                    """
                    Choose whether or not to normalize residuals in printed and plotted output.
                    """
                class n_save(TUIMethod):
                    """
                    Set number of residuals to be saved with data.
                    History is automatically compacted when buffer becomes full.
                    """
                class plot(TUIMethod):
                    """
                    Choose whether or not residuals will be plotted during iteration.
                    """
                class print(TUIMethod):
                    """
                    Choose whether or not residuals will be printed during iteration.
                    """
                class relative_conv_criteria(TUIMethod):
                    """
                    Set relative convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                class re_normalize(TUIMethod):
                    """
                    Renormalize residuals by maximum values.
                    """
                class reset(TUIMethod):
                    """
                    Delete the residual history and reset iteration counter to unity.
                    """
                class scale_by_coefficient(TUIMethod):
                    """
                    Enable/disable scaling of residuals by coefficient sum in printed and plotted output.
                    """

        class report_definitions(TUIMenu):
            """
            Manage report definitions.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class compute(TUIMethod):
                """
                Computes selected report definition.
                """
            class copy(TUIMethod):
                """
                Makes a copy of selected report definition with new name.
                """
            class delete_all(TUIMethod):
                """
                Delete all report definition objects.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """
            class rename(TUIMethod):
                """
                Rename selected report definition with new name.
                """

        class run_calculation(TUIMenu):
            """
            Enter run calculation menu.
            """
            def __init__(self, service, version, mode, path):
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.adaptive_time_stepping = self.__class__.adaptive_time_stepping(service, version, mode, path + ["adaptive_time_stepping"])
                self.cfl_based_adaptive_time_stepping = self.__class__.cfl_based_adaptive_time_stepping(service, version, mode, path + ["cfl_based_adaptive_time_stepping"])
                self.data_sampling = self.__class__.data_sampling(service, version, mode, path + ["data_sampling"])
                self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
                self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
                self.max_corrections = self.__class__.max_corrections(service, version, mode, path + ["max_corrections"])
                self.mesh_motion = self.__class__.mesh_motion(service, version, mode, path + ["mesh_motion"])
                self.multistage_time_iterate = self.__class__.multistage_time_iterate(service, version, mode, path + ["multistage_time_iterate"])
                self.number_of_iterations = self.__class__.number_of_iterations(service, version, mode, path + ["number_of_iterations"])
                self.reporting_interval = self.__class__.reporting_interval(service, version, mode, path + ["reporting_interval"])
                self.residual_tolerance = self.__class__.residual_tolerance(service, version, mode, path + ["residual_tolerance"])
                self.residual_verbosity = self.__class__.residual_verbosity(service, version, mode, path + ["residual_verbosity"])
                self.second_order_time_options = self.__class__.second_order_time_options(service, version, mode, path + ["second_order_time_options"])
                self.solution_steering = self.__class__.solution_steering(service, version, mode, path + ["solution_steering"])
                self.set_solution_steering = self.__class__.set_solution_steering(service, version, mode, path + ["set_solution_steering"])
                self.summary = self.__class__.summary(service, version, mode, path + ["summary"])
                self.time_step = self.__class__.time_step(service, version, mode, path + ["time_step"])
                self.update_physical_time = self.__class__.update_physical_time(service, version, mode, path + ["update_physical_time"])
                self.variable_time_stepping = self.__class__.variable_time_stepping(service, version, mode, path + ["variable_time_stepping"])
                super().__init__(service, version, mode, path)
            class adaptive_time_stepping(TUIMethod):
                """
                Set Error-based adaptive time-stepping parameters.
                """
            class cfl_based_adaptive_time_stepping(TUIMethod):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
            class data_sampling(TUIMethod):
                """
                Set iteration options.
                """
            class dual_time_iterate(TUIMethod):
                """
                Perform unsteady iterations.
                """
            class iterate(TUIMethod):
                """
                Perform a specified number of iterations.
                """
            class max_corrections(TUIMethod):
                """
                Enter the max-corrections menu.
                """
            class mesh_motion(TUIMethod):
                """
                Perform mesh motion.
                """
            class multistage_time_iterate(TUIMethod):
                """
                Perform unsteady iterations.
                """
            class number_of_iterations(TUIMethod):
                """
                Set number of iterations.
                """
            class reporting_interval(TUIMethod):
                """
                Set number of solver iterations before returning to scheme.
                """
            class residual_tolerance(TUIMethod):
                """
                Enter the residual tolerance menu.
                """
            class residual_verbosity(TUIMethod):
                """
                Set the residual report verbosity.
                """
            class second_order_time_options(TUIMethod):
                """
                Set options for second-order time formulation.
                """
            class solution_steering(TUIMethod):
                """
                Enable solution steering for density-based solver.
                """
            class set_solution_steering(TUIMethod):
                """
                Set Solution Steering Parameters.
                """
            class summary(TUIMethod):
                """
                Print report summary.
                """
            class time_step(TUIMethod):
                """
                Set the time step.
                """
            class update_physical_time(TUIMethod):
                """
                Update the solution to the next physical time level.
                """
            class variable_time_stepping(TUIMethod):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """

            class data_sampling_options(TUIMenu):
                """
                Data sampling options for statistics.
                """
                def __init__(self, service, version, mode, path):
                    self.add_datasets = self.__class__.add_datasets(service, version, mode, path + ["add_datasets"])
                    self.add_rtdft_datasets = self.__class__.add_rtdft_datasets(service, version, mode, path + ["add_rtdft_datasets"])
                    self.remove_dataset = self.__class__.remove_dataset(service, version, mode, path + ["remove_dataset"])
                    self.list_datasets = self.__class__.list_datasets(service, version, mode, path + ["list_datasets"])
                    super().__init__(service, version, mode, path)
                class add_datasets(TUIMethod):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                class add_rtdft_datasets(TUIMethod):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                class remove_dataset(TUIMethod):
                    """
                    Remove dataset.
                    """
                class list_datasets(TUIMethod):
                    """
                    List dataset.
                    """

            class transient_controls(TUIMenu):
                """
                Enter into the transient controls menu.
                """
                def __init__(self, service, version, mode, path):
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    self.specified_time_step = self.__class__.specified_time_step(service, version, mode, path + ["specified_time_step"])
                    self.fixed_user_specified = self.__class__.fixed_user_specified(service, version, mode, path + ["fixed_user_specified"])
                    self.fixed_periodic = self.__class__.fixed_periodic(service, version, mode, path + ["fixed_periodic"])
                    self.duration_specification_method = self.__class__.duration_specification_method(service, version, mode, path + ["duration_specification_method"])
                    self.incremental_time = self.__class__.incremental_time(service, version, mode, path + ["incremental_time"])
                    self.max_iterations_per_time_step = self.__class__.max_iterations_per_time_step(service, version, mode, path + ["max_iterations_per_time_step"])
                    self.number_of_time_steps = self.__class__.number_of_time_steps(service, version, mode, path + ["number_of_time_steps"])
                    self.total_number_of_time_steps = self.__class__.total_number_of_time_steps(service, version, mode, path + ["total_number_of_time_steps"])
                    self.total_time = self.__class__.total_time(service, version, mode, path + ["total_time"])
                    self.time_step_size = self.__class__.time_step_size(service, version, mode, path + ["time_step_size"])
                    self.solution_status = self.__class__.solution_status(service, version, mode, path + ["solution_status"])
                    self.extrapolate_vars = self.__class__.extrapolate_vars(service, version, mode, path + ["extrapolate_vars"])
                    self.extrapolate_eqn_vars = self.__class__.extrapolate_eqn_vars(service, version, mode, path + ["extrapolate_eqn_vars"])
                    self.max_flow_time = self.__class__.max_flow_time(service, version, mode, path + ["max_flow_time"])
                    self.cfl_based_time_stepping_advanced_options = self.__class__.cfl_based_time_stepping_advanced_options(service, version, mode, path + ["cfl_based_time_stepping_advanced_options"])
                    self.cfl_based_time_stepping = self.__class__.cfl_based_time_stepping(service, version, mode, path + ["cfl_based_time_stepping"])
                    self.multiphase_specific_time_stepping = self.__class__.multiphase_specific_time_stepping(service, version, mode, path + ["multiphase_specific_time_stepping"])
                    self.udf_based_time_stepping = self.__class__.udf_based_time_stepping(service, version, mode, path + ["udf_based_time_stepping"])
                    self.error_based_time_stepping = self.__class__.error_based_time_stepping(service, version, mode, path + ["error_based_time_stepping"])
                    self.undo_timestep = self.__class__.undo_timestep(service, version, mode, path + ["undo_timestep"])
                    self.predict_next_time = self.__class__.predict_next_time(service, version, mode, path + ["predict_next_time"])
                    self.rotating_mesh_flow_predictor = self.__class__.rotating_mesh_flow_predictor(service, version, mode, path + ["rotating_mesh_flow_predictor"])
                    self.solid_time_step_size = self.__class__.solid_time_step_size(service, version, mode, path + ["solid_time_step_size"])
                    self.time_step_size_for_acoustic_export = self.__class__.time_step_size_for_acoustic_export(service, version, mode, path + ["time_step_size_for_acoustic_export"])
                    super().__init__(service, version, mode, path)
                class specified_time_step(TUIMethod):
                    """
                    Use specified time step or courant number.
                    """
                class fixed_user_specified(TUIMethod):
                    """
                    Enable user-specified fixed time stepping method.
                    """
                class fixed_periodic(TUIMethod):
                    """
                    Set period- or frequency-based fixed time-stepping parameters.
                    """
                class duration_specification_method(TUIMethod):
                    """
                    Set Duration Specification Method: [0] Incremental Time Steps, [1] Total Time Steps, [2] Total Time, [3] Incremental Time.
                    """
                class incremental_time(TUIMethod):
                    """
                    Set Incremental Time.
                    """
                class max_iterations_per_time_step(TUIMethod):
                    """
                    Set Max Iterations/Time step.
                    """
                class number_of_time_steps(TUIMethod):
                    """
                    Set inceremtal number of Time steps.
                    """
                class total_number_of_time_steps(TUIMethod):
                    """
                    Set total number of Time steps.
                    """
                class total_time(TUIMethod):
                    """
                    Set Total Simulation Time.
                    """
                class time_step_size(TUIMethod):
                    """
                    Set the physical time step size.
                    """
                class solution_status(TUIMethod):
                    """
                    Activate the simulation status panel.
                    """
                class extrapolate_vars(TUIMethod):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                class extrapolate_eqn_vars(TUIMethod):
                    """
                    Enter the extrapolation menu.
                    """
                class max_flow_time(TUIMethod):
                    """
                    Set maximum flow time.
                    """
                class cfl_based_time_stepping_advanced_options(TUIMethod):
                    """
                    Set CFL-based adaptive time-stepping advanced parameters.
                    """
                class cfl_based_time_stepping(TUIMethod):
                    """
                    Set CFL-based adaptive time-stepping parameters.
                    """
                class multiphase_specific_time_stepping(TUIMethod):
                    """
                    Set Multiphase-specific adaptive time stepping parameters.
                    """
                class udf_based_time_stepping(TUIMethod):
                    """
                    Set the time-stepping parameters for user-defined time stepping method.
                    """
                class error_based_time_stepping(TUIMethod):
                    """
                    Set Error-based adaptive time-stepping parameters.
                    """
                class undo_timestep(TUIMethod):
                    """
                    Undo the previous time step.
                    """
                class predict_next_time(TUIMethod):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                class rotating_mesh_flow_predictor(TUIMethod):
                    """
                    Improve prediction of flow field at time step n+1 for rotating mesh.
                    """
                class solid_time_step_size(TUIMethod):
                    """
                    Specify a different time step size for solid zones.
                    """
                class time_step_size_for_acoustic_export(TUIMethod):
                    """
                    Set number of time step size for acoustic export.
                    """

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    Set Multiphase-specific time constraints.
                    """
                    def __init__(self, service, version, mode, path):
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        self.moving_mesh_cfl_constraint = self.__class__.moving_mesh_cfl_constraint(service, version, mode, path + ["moving_mesh_cfl_constraint"])
                        self.physics_based_constraint = self.__class__.physics_based_constraint(service, version, mode, path + ["physics_based_constraint"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class moving_mesh_cfl_constraint(TUIMethod):
                        """
                        Enable time step size constraints based on moving mesh courant number.
                        """
                    class physics_based_constraint(TUIMethod):
                        """
                        Include physics driven time-step constraints.
                        """
                    class verbosity(TUIMethod):
                        """
                        Set verbosity to print multiphase specific time scales.
                        """

                    class time_scale_options(TUIMenu):
                        """
                        Set physics based time scale options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.viscous_scale = self.__class__.viscous_scale(service, version, mode, path + ["viscous_scale"])
                            self.gravity_scale = self.__class__.gravity_scale(service, version, mode, path + ["gravity_scale"])
                            self.surface_tension_scale = self.__class__.surface_tension_scale(service, version, mode, path + ["surface_tension_scale"])
                            self.acoustic_scale = self.__class__.acoustic_scale(service, version, mode, path + ["acoustic_scale"])
                            super().__init__(service, version, mode, path)
                        class viscous_scale(TUIMethod):
                            """
                            Include viscous time scale.
                            """
                        class gravity_scale(TUIMethod):
                            """
                            Include gravity based time scale.
                            """
                        class surface_tension_scale(TUIMethod):
                            """
                            Include surface tension based time scale.
                            """
                        class acoustic_scale(TUIMethod):
                            """
                            Include acoustic time scale.
                            """

    class solve(TUIMenu):
        """
        Enter the solve menu.
        """
        def __init__(self, service, version, mode, path):
            self.animate = self.__class__.animate(service, version, mode, path + ["animate"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.monitors = self.__class__.monitors(service, version, mode, path + ["monitors"])
            self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
            self.report_definitions = self.__class__.report_definitions(service, version, mode, path + ["report_definitions"])
            self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
            self.cell_registers = self.__class__.cell_registers(service, version, mode, path + ["cell_registers"])
            self.cell_register_operations = self.__class__.cell_register_operations(service, version, mode, path + ["cell_register_operations"])
            self.set = self.__class__.set(service, version, mode, path + ["set"])
            self.execute_commands = self.__class__.execute_commands(service, version, mode, path + ["execute_commands"])
            self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
            self.iterate = self.__class__.iterate(service, version, mode, path + ["iterate"])
            self.iterate_steady_2way_fsi = self.__class__.iterate_steady_2way_fsi(service, version, mode, path + ["iterate_steady_2way_fsi"])
            self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
            self.dpm_update = self.__class__.dpm_update(service, version, mode, path + ["dpm_update"])
            self.dual_time_iterate = self.__class__.dual_time_iterate(service, version, mode, path + ["dual_time_iterate"])
            self.multistage_time_iterate = self.__class__.multistage_time_iterate(service, version, mode, path + ["multistage_time_iterate"])
            self.update_physical_time = self.__class__.update_physical_time(service, version, mode, path + ["update_physical_time"])
            self.mesh_motion = self.__class__.mesh_motion(service, version, mode, path + ["mesh_motion"])
            super().__init__(service, version, mode, path)
        class patch(TUIMethod):
            """
            Patches a value for a flow variable in the domain. You can either provide a numerical value, which you can enter directly, or you can enter an expression, which must be entered within quotation marks.
            """
        class iterate(TUIMethod):
            """
            Performs a specified number of iterations.  This option is still available during transient simulations, since it can be used to add more iterations to the same time step after interrupting iterations within a time step.
            """
        class iterate_steady_2way_fsi(TUIMethod):
            """
            Perform a specified number of steps.
            """
        class convergence_conditions(TUIMethod):
            """
            Enters the convergence conditions menu.
            """
        class dpm_update(TUIMethod):
            """
            Updates discrete phase source terms.
            """
        class dual_time_iterate(TUIMethod):
            """
            Performs unsteady iterations for a specified number of time steps.
            """
        class multistage_time_iterate(TUIMethod):
            """
            Perform unsteady iterations.
            """
        class update_physical_time(TUIMethod):
            """
            Advances the unsteady solution to the next physical time level. Using this command in conjunction with theiterate command allows you to manually advance the solution in time (rather than doing it automatically with the dual-time-iterate command).
            """
        class mesh_motion(TUIMethod):
            """
            Performs mesh motion.
            """

        class animate(TUIMenu):
            """
            Enters the animation menu.
            """
            def __init__(self, service, version, mode, path):
                self.define = self.__class__.define(service, version, mode, path + ["define"])
                self.playback = self.__class__.playback(service, version, mode, path + ["playback"])
                self.objects = self.__class__.objects(service, version, mode, path + ["objects"])
                self.pulse = self.__class__.pulse(service, version, mode, path + ["pulse"])
                super().__init__(service, version, mode, path)

            class define(TUIMenu):
                """
                Enters the animation definition menu.
                """
                def __init__(self, service, version, mode, path):
                    self.define_monitor = self.__class__.define_monitor(service, version, mode, path + ["define_monitor"])
                    self.edit_monitor = self.__class__.edit_monitor(service, version, mode, path + ["edit_monitor"])
                    super().__init__(service, version, mode, path)
                class define_monitor(TUIMethod):
                    """
                    Defines new animation.
                    """
                class edit_monitor(TUIMethod):
                    """
                    Changes animation monitor attributes.
                    """

            class playback(TUIMenu):
                """
                Enters the animation playback menu.
                """
                def __init__(self, service, version, mode, path):
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.read = self.__class__.read(service, version, mode, path + ["read"])
                    self.play = self.__class__.play(service, version, mode, path + ["play"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.stored_view = self.__class__.stored_view(service, version, mode, path + ["stored_view"])
                    self.set_custom_frames = self.__class__.set_custom_frames(service, version, mode, path + ["set_custom_frames"])
                    super().__init__(service, version, mode, path)
                class read(TUIMethod):
                    """
                    Reads new animation from file or already defined animations.
                    """
                class play(TUIMethod):
                    """
                    Plays the selected animation.
                    """
                class write(TUIMethod):
                    """
                    Writes animation sequence to the file.
                    """
                class delete(TUIMethod):
                    """
                    Deletes animation sequence.
                    """
                class stored_view(TUIMethod):
                    """
                    Plays the 3D animation sequence using the view stored in the sequence.
                    """
                class set_custom_frames(TUIMethod):
                    """
                    Specify a custom start frame, increment, and end frame for video export.
                    """

                class video(TUIMenu):
                    """
                    Enters the video menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        super().__init__(service, version, mode, path)
                    class fps(TUIMethod):
                        """
                        Sets the target frames per second (FPS) for the saved video  file.
                        """
                    class format(TUIMethod):
                        """
                        Specifies what format the video file will be written in (MP4 | AVI |  FLV | MOV | MPEG).
                        """
                    class quality(TUIMethod):
                        """
                        Set quality for exporting video file.
                        """
                    class name(TUIMethod):
                        """
                        Sets the name of the saved video file.
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        Controls whether the resolution of the saved video file matches that  of the images used to create it.
                        """
                    class scale(TUIMethod):
                        """
                        Expands or collapses the resolution based on this scaling  factor.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class width(TUIMethod):
                        """
                        Set the width for exporting video file.
                        """
                    class height(TUIMethod):
                        """
                        Set the height for exporting video file.
                        """

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate_scale(TUIMethod):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                        class enable_h264(TUIMethod):
                            """
                            H264 encoding flag.
                            """
                        class bitrate(TUIMethod):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                        class compression_method(TUIMethod):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                        class keyframe(TUIMethod):
                            """
                            Set video keyframe rate for exporting video file.
                            """

            class objects(TUIMenu):
                """
                Enters the object manipulation menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.clear_history = self.__class__.clear_history(service, version, mode, path + ["clear_history"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Creates new solution animation object.
                    """
                class edit(TUIMethod):
                    """
                    Edits solution animation object.
                    """
                class copy(TUIMethod):
                    """
                    Copies solution animation object.
                    """
                class delete(TUIMethod):
                    """
                    Deletes solution animation object.
                    """
                class clear_history(TUIMethod):
                    """
                    Clears solution animation object history.
                    """

            class pulse(TUIMenu):
                """
                Enter the pulse animation menu (only available when one or more particle track or pathline graphics objects are defined).
                """
                def __init__(self, service, version, mode, path):
                    self.video = self.__class__.video(service, version, mode, path + ["video"])
                    self.hardcopy = self.__class__.hardcopy(service, version, mode, path + ["hardcopy"])
                    self.pulse_mode = self.__class__.pulse_mode(service, version, mode, path + ["pulse_mode"])
                    self.write = self.__class__.write(service, version, mode, path + ["write"])
                    super().__init__(service, version, mode, path)
                class pulse_mode(TUIMethod):
                    """
                    Set whether the pulse is a single pulse or continuous.
                    """
                class write(TUIMethod):
                    """
                    Select a pathline or particle track graphics object, specify whether you want to write a video file or picture files, and enter the destination directory for the files. Continuous pulse animations result in a 5 second video. Single pulse animations run for a full cycle.
                    """

                class video(TUIMenu):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.advance_quality = self.__class__.advance_quality(service, version, mode, path + ["advance_quality"])
                        self.fps = self.__class__.fps(service, version, mode, path + ["fps"])
                        self.format = self.__class__.format(service, version, mode, path + ["format"])
                        self.quality = self.__class__.quality(service, version, mode, path + ["quality"])
                        self.name = self.__class__.name(service, version, mode, path + ["name"])
                        self.use_original_resolution = self.__class__.use_original_resolution(service, version, mode, path + ["use_original_resolution"])
                        self.scale = self.__class__.scale(service, version, mode, path + ["scale"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.width = self.__class__.width(service, version, mode, path + ["width"])
                        self.height = self.__class__.height(service, version, mode, path + ["height"])
                        super().__init__(service, version, mode, path)
                    class fps(TUIMethod):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                    class format(TUIMethod):
                        """
                        Set format for exporting video file.
                        """
                    class quality(TUIMethod):
                        """
                        Set quality for exporting video file.
                        """
                    class name(TUIMethod):
                        """
                        Exporting video file name.
                        """
                    class use_original_resolution(TUIMethod):
                        """
                        Enable original resolution.
                        """
                    class scale(TUIMethod):
                        """
                        Set scale by which video resolution will expand.
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class width(TUIMethod):
                        """
                        Set the width for exporting video file.
                        """
                    class height(TUIMethod):
                        """
                        Set the height for exporting video file.
                        """

                    class advance_quality(TUIMenu):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, service, version, mode, path):
                            self.bitrate_scale = self.__class__.bitrate_scale(service, version, mode, path + ["bitrate_scale"])
                            self.enable_h264 = self.__class__.enable_h264(service, version, mode, path + ["enable_h264"])
                            self.bitrate = self.__class__.bitrate(service, version, mode, path + ["bitrate"])
                            self.compression_method = self.__class__.compression_method(service, version, mode, path + ["compression_method"])
                            self.keyframe = self.__class__.keyframe(service, version, mode, path + ["keyframe"])
                            super().__init__(service, version, mode, path)
                        class bitrate_scale(TUIMethod):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                        class enable_h264(TUIMethod):
                            """
                            H264 encoding flag.
                            """
                        class bitrate(TUIMethod):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                        class compression_method(TUIMethod):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                        class keyframe(TUIMethod):
                            """
                            Set video keyframe rate for exporting video file.
                            """

                class hardcopy(TUIMenu):
                    """
                    Hardcopy options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.color_mode = self.__class__.color_mode(service, version, mode, path + ["color_mode"])
                        self.driver = self.__class__.driver(service, version, mode, path + ["driver"])
                        self.invert_background = self.__class__.invert_background(service, version, mode, path + ["invert_background"])
                        self.landscape = self.__class__.landscape(service, version, mode, path + ["landscape"])
                        self.preview = self.__class__.preview(service, version, mode, path + ["preview"])
                        self.x_resolution = self.__class__.x_resolution(service, version, mode, path + ["x_resolution"])
                        self.y_resolution = self.__class__.y_resolution(service, version, mode, path + ["y_resolution"])
                        self.dpi = self.__class__.dpi(service, version, mode, path + ["dpi"])
                        self.use_window_resolution = self.__class__.use_window_resolution(service, version, mode, path + ["use_window_resolution"])
                        self.set_standard_resolution = self.__class__.set_standard_resolution(service, version, mode, path + ["set_standard_resolution"])
                        self.jpeg_hardcopy_quality = self.__class__.jpeg_hardcopy_quality(service, version, mode, path + ["jpeg_hardcopy_quality"])
                        super().__init__(service, version, mode, path)
                    class invert_background(TUIMethod):
                        """
                        Use a white background when the picture is saved.
                        """
                    class landscape(TUIMethod):
                        """
                        Plot hardcopies in landscape or portrait orientation.
                        """
                    class preview(TUIMethod):
                        """
                        Display a preview image of a hardcopy.
                        """
                    class x_resolution(TUIMethod):
                        """
                        Set the width of raster-formatted images in pixels (0 implies current window size).
                        """
                    class y_resolution(TUIMethod):
                        """
                        Set the height of raster-formatted images in pixels (0 implies current window size).
                        """
                    class dpi(TUIMethod):
                        """
                        Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                        """
                    class use_window_resolution(TUIMethod):
                        """
                        Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                        """
                    class set_standard_resolution(TUIMethod):
                        """
                        Select from pre-defined resolution list.
                        """
                    class jpeg_hardcopy_quality(TUIMethod):
                        """
                        To set jpeg hardcopy quality.
                        """

                    class color_mode(TUIMenu):
                        """
                        Enter the hardcopy color mode menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.color = self.__class__.color(service, version, mode, path + ["color"])
                            self.gray_scale = self.__class__.gray_scale(service, version, mode, path + ["gray_scale"])
                            self.mono_chrome = self.__class__.mono_chrome(service, version, mode, path + ["mono_chrome"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            super().__init__(service, version, mode, path)
                        class color(TUIMethod):
                            """
                            Plot hardcopies in color.
                            """
                        class gray_scale(TUIMethod):
                            """
                            Convert color to grayscale for hardcopy.
                            """
                        class mono_chrome(TUIMethod):
                            """
                            Convert color to monochrome (black and white) for hardcopy.
                            """
                        class list(TUIMethod):
                            """
                            Display the current hardcopy color mode.
                            """

                    class driver(TUIMenu):
                        """
                        Enter the set hardcopy driver menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.post_format = self.__class__.post_format(service, version, mode, path + ["post_format"])
                            self.dump_window = self.__class__.dump_window(service, version, mode, path + ["dump_window"])
                            self.eps = self.__class__.eps(service, version, mode, path + ["eps"])
                            self.jpeg = self.__class__.jpeg(service, version, mode, path + ["jpeg"])
                            self.post_script = self.__class__.post_script(service, version, mode, path + ["post_script"])
                            self.ppm = self.__class__.ppm(service, version, mode, path + ["ppm"])
                            self.tiff = self.__class__.tiff(service, version, mode, path + ["tiff"])
                            self.png = self.__class__.png(service, version, mode, path + ["png"])
                            self.hsf = self.__class__.hsf(service, version, mode, path + ["hsf"])
                            self.avz = self.__class__.avz(service, version, mode, path + ["avz"])
                            self.glb = self.__class__.glb(service, version, mode, path + ["glb"])
                            self.vrml = self.__class__.vrml(service, version, mode, path + ["vrml"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.options = self.__class__.options(service, version, mode, path + ["options"])
                            super().__init__(service, version, mode, path)
                        class dump_window(TUIMethod):
                            """
                            Set the command used to dump the graphics window to a file.
                            """
                        class eps(TUIMethod):
                            """
                            Produce encapsulated PostScript (EPS) output for hardcopies.
                            """
                        class jpeg(TUIMethod):
                            """
                            Produce JPEG output for hardcopies.
                            """
                        class post_script(TUIMethod):
                            """
                            Produce PostScript output for hardcopies.
                            """
                        class ppm(TUIMethod):
                            """
                            Produce PPM output for hardcopies.
                            """
                        class tiff(TUIMethod):
                            """
                            Use TIFF output for hardcopies.
                            """
                        class png(TUIMethod):
                            """
                            Use PNG output for hardcopies.
                            """
                        class hsf(TUIMethod):
                            """
                            Use HSF output for hardcopies.
                            """
                        class avz(TUIMethod):
                            """
                            Use AVZ output for hardcopies.
                            """
                        class glb(TUIMethod):
                            """
                            Use GLB output for hardcopies.
                            """
                        class vrml(TUIMethod):
                            """
                            Use VRML output for hardcopies.
                            """
                        class list(TUIMethod):
                            """
                            List the current hardcopy driver.
                            """
                        class options(TUIMethod):
                            """
                            Set the hardcopy options. Available options are:
                            "no gamma correction", disables gamma correction of colors,
                            "physical size = (width,height)", where width and height
                            are the actual measurements of the printable area of the page
                            in centimeters.
                            "subscreen = (left,right,bottom,top)", where left,right,
                            bottom, and top are numbers in [-1,1] describing a subwindow on
                            the page in which to place the hardcopy.
                            The options may be combined by separating them with commas.
                            """

                        class post_format(TUIMenu):
                            """
                            Enter the PostScript driver format menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.fast_raster = self.__class__.fast_raster(service, version, mode, path + ["fast_raster"])
                                self.raster = self.__class__.raster(service, version, mode, path + ["raster"])
                                self.rle_raster = self.__class__.rle_raster(service, version, mode, path + ["rle_raster"])
                                self.vector = self.__class__.vector(service, version, mode, path + ["vector"])
                                super().__init__(service, version, mode, path)
                            class fast_raster(TUIMethod):
                                """
                                Use the new raster format.
                                """
                            class raster(TUIMethod):
                                """
                                Use the original raster format.
                                """
                            class rle_raster(TUIMethod):
                                """
                                Use the run-length encoded raster format.
                                """
                            class vector(TUIMethod):
                                """
                                Use vector format.
                                """

        class initialize(TUIMenu):
            """
            Enters the flow initialization menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute_defaults = self.__class__.compute_defaults(service, version, mode, path + ["compute_defaults"])
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(service, version, mode, path + ["mp_localized_turb_init"])
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(service, version, mode, path + ["vof_patch_smooth_options"])
                self.set_fmg_options = self.__class__.set_fmg_options(service, version, mode, path + ["set_fmg_options"])
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(service, version, mode, path + ["set_hyb_initialization"])
                self.open_channel_auto_init = self.__class__.open_channel_auto_init(service, version, mode, path + ["open_channel_auto_init"])
                self.levelset_auto_init = self.__class__.levelset_auto_init(service, version, mode, path + ["levelset_auto_init"])
                self.dpm_reset = self.__class__.dpm_reset(service, version, mode, path + ["dpm_reset"])
                self.lwf_initialization = self.__class__.lwf_initialization(service, version, mode, path + ["lwf_initialization"])
                self.initialize_flow = self.__class__.initialize_flow(service, version, mode, path + ["initialize_flow"])
                self.init_acoustics_options = self.__class__.init_acoustics_options(service, version, mode, path + ["init_acoustics_options"])
                self.hyb_initialization = self.__class__.hyb_initialization(service, version, mode, path + ["hyb_initialization"])
                self.init_flow_statistics = self.__class__.init_flow_statistics(service, version, mode, path + ["init_flow_statistics"])
                self.patch = self.__class__.patch(service, version, mode, path + ["patch"])
                self.show_time_sampled = self.__class__.show_time_sampled(service, version, mode, path + ["show_time_sampled"])
                self.show_iterations_sampled = self.__class__.show_iterations_sampled(service, version, mode, path + ["show_iterations_sampled"])
                self.init_turb_vel_fluctuations = self.__class__.init_turb_vel_fluctuations(service, version, mode, path + ["init_turb_vel_fluctuations"])
                self.fmg_initialization = self.__class__.fmg_initialization(service, version, mode, path + ["fmg_initialization"])
                self.repair_wall_distance = self.__class__.repair_wall_distance(service, version, mode, path + ["repair_wall_distance"])
                self.set_defaults = self.__class__.set_defaults(service, version, mode, path + ["set_defaults"])
                self.set_fmg_initialization = self.__class__.set_fmg_initialization(service, version, mode, path + ["set_fmg_initialization"])
                self.list_defaults = self.__class__.list_defaults(service, version, mode, path + ["list_defaults"])
                self.reference_frame = self.__class__.reference_frame(service, version, mode, path + ["reference_frame"])
                super().__init__(service, version, mode, path)
            class open_channel_auto_init(TUIMethod):
                """
                Opens channel automatic initialization.
                """
            class levelset_auto_init(TUIMethod):
                """
                Levelset function automatic initialization.
                """
            class dpm_reset(TUIMethod):
                """
                Resets discrete phase source terms to zero.
                """
            class lwf_initialization(TUIMethod):
                """
                Deletes wall film particles and initializes wall film variables to zero. This option is available only with the wall-film DPM boundary condition.
                """
            class initialize_flow(TUIMethod):
                """
                Initializes the flow field with the current default values.
                """
            class init_acoustics_options(TUIMethod):
                """
                Specifies the number of timesteps for ramping of sound sources and re-initializes the acoustics wave equation solution. For the initialized acoustics solution, Fluent reports the current state of the sound sources ramping.
                """
            class hyb_initialization(TUIMethod):
                """
                Initializes using the hybrid initialization method.
                """
            class init_flow_statistics(TUIMethod):
                """
                Initializes unsteady statistics.
                """
            class patch(TUIMethod):
                """
                Patch a value for a flow variable in the domain.
                """
            class show_time_sampled(TUIMethod):
                """
                Displays the amount of simulated time covered by the data sampled for unsteady statistics.
                """
            class show_iterations_sampled(TUIMethod):
                """
                Displays the number of iterations covered by the data sampled for steady statistics.
                """
            class init_turb_vel_fluctuations(TUIMethod):
                """
                Initializes instantaneous velocity field out of steady state RANS results, for use before enabling a scale resolving simulation such as LES.
                """
            class fmg_initialization(TUIMethod):
                """
                Initializes using the full-multigrid initialization (FMG).
                """
            class repair_wall_distance(TUIMethod):
                """
                Corrects wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
            class set_defaults(TUIMethod):
                """
                Sets default initial values.
                """
            class set_fmg_initialization(TUIMethod):
                """
                Enters the set full-multigrid for initialization menu. Initial values for each variable can be set within this menu.
                """
            class list_defaults(TUIMethod):
                """
                Lists default values.
                """
            class reference_frame(TUIMethod):
                """
                Sets reference frame to absolute or relative.
                """

            class compute_defaults(TUIMenu):
                """
                Enters the compute default values menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.all_zones = self.__class__.all_zones(service, version, mode, path + ["all_zones"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class all_zones(TUIMethod):
                    """
                    Initializes the flow field with the default values.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """

            class mp_localized_turb_init(TUIMenu):
                """
                Enters the menu for localized turbulent flow initialization.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turb_init_parameters = self.__class__.turb_init_parameters(service, version, mode, path + ["turb_init_parameters"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables localized initialization of turbulent flow variables.
                    """
                class turb_init_parameters(TUIMethod):
                    """
                    Sets values for the turbulent intensity and turbulent viscosity ratio for localized initialization.
                    """

            class vof_patch_smooth_options(TUIMenu):
                """
                Enters the vof patch/smooth options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_options = self.__class__.set_options(service, version, mode, path + ["set_options"])
                    self.execute_smoothing = self.__class__.execute_smoothing(service, version, mode, path + ["execute_smoothing"])
                    super().__init__(service, version, mode, path)
                class set_options(TUIMethod):
                    """
                    Sets options for patching and smoothing volume fraction.
                    """
                class execute_smoothing(TUIMethod):
                    """
                    Execute volumetric smoothing for volume fraction.
                    """

            class set_fmg_options(TUIMenu):
                """
                Enter the full-multigrid option menu.
                """
                def __init__(self, service, version, mode, path):
                    self.viscous_terms = self.__class__.viscous_terms(service, version, mode, path + ["viscous_terms"])
                    self.species_reactions = self.__class__.species_reactions(service, version, mode, path + ["species_reactions"])
                    self.set_turbulent_viscosity_ratio = self.__class__.set_turbulent_viscosity_ratio(service, version, mode, path + ["set_turbulent_viscosity_ratio"])
                    super().__init__(service, version, mode, path)
                class viscous_terms(TUIMethod):
                    """
                    Enable/disable viscous terms during FMG initialization.
                    """
                class species_reactions(TUIMethod):
                    """
                    Enable/disable species volumetric reactions during FMG initialization.
                    """
                class set_turbulent_viscosity_ratio(TUIMethod):
                    """
                    Set turbulent viscosity ratio used during FMG initialization.
                    """

            class set_hyb_initialization(TUIMenu):
                """
                Enters the hybrid initialization menu.
                """
                def __init__(self, service, version, mode, path):
                    self.general_settings = self.__class__.general_settings(service, version, mode, path + ["general_settings"])
                    self.turbulent_settings = self.__class__.turbulent_settings(service, version, mode, path + ["turbulent_settings"])
                    self.species_settings = self.__class__.species_settings(service, version, mode, path + ["species_settings"])
                    super().__init__(service, version, mode, path)
                class general_settings(TUIMethod):
                    """
                    Enters the general settings menu.
                    """
                class turbulent_settings(TUIMethod):
                    """
                    Enter the turbulent settings menu.
                    """
                class species_settings(TUIMethod):
                    """
                    Enters the species-settings menu.
                    """

        class monitors(TUIMenu):
            """
            Sets solution monitors.
            """
            def __init__(self, service, version, mode, path):
                self.report_files = self.__class__.report_files(service, version, mode, path + ["report_files"])
                self.report_plots = self.__class__.report_plots(service, version, mode, path + ["report_plots"])
                self.residual = self.__class__.residual(service, version, mode, path + ["residual"])
                self.convergence_conditions = self.__class__.convergence_conditions(service, version, mode, path + ["convergence_conditions"])
                self.set_average_over = self.__class__.set_average_over(service, version, mode, path + ["set_average_over"])
                super().__init__(service, version, mode, path)
            class convergence_conditions(TUIMethod):
                """
                Manage convergence report.
                """
            class set_average_over(TUIMethod):
                """
                Set the average over input for monitors.
                """

            class report_files(TUIMenu):
                """
                Manage report files.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class clear_data(TUIMethod):
                    """
                    Delete the report file from the system.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete all report file objects.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """

            class report_plots(TUIMenu):
                """
                Manage report plots.
                """
                def __init__(self, service, version, mode, path):
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                    self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                    self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add a new object.
                    """
                class axes(TUIMethod):
                    """
                    Set axes options of an object.
                    """
                class clear_data(TUIMethod):
                    """
                    Clear report plot data.
                    """
                class curves(TUIMethod):
                    """
                    Set curves options of an object.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete all plot objects.
                    """
                class edit(TUIMethod):
                    """
                    Edit an object.
                    """
                class delete(TUIMethod):
                    """
                    Delete an object.
                    """
                class list(TUIMethod):
                    """
                    List objects.
                    """
                class list_properties(TUIMethod):
                    """
                    List properties of an object.
                    """
                class plot(TUIMethod):
                    """
                    Plot.
                    """

            class residual(TUIMenu):
                """
                Enters the residual monitors menu.
                """
                def __init__(self, service, version, mode, path):
                    self.check_convergence = self.__class__.check_convergence(service, version, mode, path + ["check_convergence"])
                    self.convergence_criteria = self.__class__.convergence_criteria(service, version, mode, path + ["convergence_criteria"])
                    self.criterion_type = self.__class__.criterion_type(service, version, mode, path + ["criterion_type"])
                    self.monitor = self.__class__.monitor(service, version, mode, path + ["monitor"])
                    self.enhanced_continuity_residual = self.__class__.enhanced_continuity_residual(service, version, mode, path + ["enhanced_continuity_residual"])
                    self.n_display = self.__class__.n_display(service, version, mode, path + ["n_display"])
                    self.n_maximize_norms = self.__class__.n_maximize_norms(service, version, mode, path + ["n_maximize_norms"])
                    self.normalization_factors = self.__class__.normalization_factors(service, version, mode, path + ["normalization_factors"])
                    self.normalize = self.__class__.normalize(service, version, mode, path + ["normalize"])
                    self.n_save = self.__class__.n_save(service, version, mode, path + ["n_save"])
                    self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                    self.print = self.__class__.print(service, version, mode, path + ["print"])
                    self.relative_conv_criteria = self.__class__.relative_conv_criteria(service, version, mode, path + ["relative_conv_criteria"])
                    self.re_normalize = self.__class__.re_normalize(service, version, mode, path + ["re_normalize"])
                    self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                    self.scale_by_coefficient = self.__class__.scale_by_coefficient(service, version, mode, path + ["scale_by_coefficient"])
                    super().__init__(service, version, mode, path)
                class check_convergence(TUIMethod):
                    """
                    Chooses which currently monitored residuals should be checked for convergence.
                    """
                class convergence_criteria(TUIMethod):
                    """
                    Sets convergence criteria for residuals that are currently being both monitored and checked.
                    """
                class criterion_type(TUIMethod):
                    """
                    Sets convergence criterion type.
                    """
                class monitor(TUIMethod):
                    """
                    Chooses which residuals to monitor as printed and/or plotted output.
                    """
                class enhanced_continuity_residual(TUIMethod):
                    """
                    Enables/disables an enhanced formulation for the local scaling of the continuity residuals with the pressure-based solver, so that the absolute mass flow rate at each cell is used. This text command is only available when the computing of the local scale is enabled through the solve/monitors/residual/scale-by-coefficient? text command.
                    """
                class n_display(TUIMethod):
                    """
                    Sets the number of most recent residuals to display in plots.
                    """
                class n_maximize_norms(TUIMethod):
                    """
                    Sets the number of iterations through which normalization factors will be maximized.
                    """
                class normalization_factors(TUIMethod):
                    """
                    Sets normalization factors for currently monitored residuals (if normalize? is set to yes).
                    """
                class normalize(TUIMethod):
                    """
                    Chooses whether to normalize residuals in printed and plotted output.
                    """
                class n_save(TUIMethod):
                    """
                    Sets number of residuals to be saved with data. History is automatically compacted when buffer becomes full.
                    """
                class plot(TUIMethod):
                    """
                    Chooses whether residuals will be plotted during iteration.
                    """
                class print(TUIMethod):
                    """
                    Chooses whether residuals will be printed during iteration.
                    """
                class relative_conv_criteria(TUIMethod):
                    """
                    Sets relative convergence criteria for residuals that are currently being both monitored and checked.
                    """
                class re_normalize(TUIMethod):
                    """
                    Re-normalize residuals by maximum values.
                    """
                class reset(TUIMethod):
                    """
                    Chooses whether to delete the residual history and reset iteration counter to 1.
                    """
                class scale_by_coefficient(TUIMethod):
                    """
                    Chooses whether to scale residuals by coefficient sum in printed and plotted output.
                    """

        class report_files(TUIMenu):
            """
            Enters the report files menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a report file.
                """
            class clear_data(TUIMethod):
                """
                Clears the data associated with a report file.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report file objects.
                """
            class edit(TUIMethod):
                """
                Edits a report file.
                """
            class delete(TUIMethod):
                """
                Deletes a report file object.
                """
            class list(TUIMethod):
                """
                Lists all defined report files.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report file.
                """

        class report_definitions(TUIMenu):
            """
            Enters the report definitions menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class compute(TUIMethod):
                """
                Computes selected report definition.
                """
            class copy(TUIMethod):
                """
                Creates a copy of a report definition.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report definition objects.
                """
            class edit(TUIMethod):
                """
                Edits a report definition.
                """
            class delete(TUIMethod):
                """
                Deletes a report definition.
                """
            class list(TUIMethod):
                """
                Lists all defined report definitions.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report definition.
                """
            class rename(TUIMethod):
                """
                Renames a report definition.
                """

        class report_plots(TUIMenu):
            """
            Enters the report plots menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.axes = self.__class__.axes(service, version, mode, path + ["axes"])
                self.clear_data = self.__class__.clear_data(service, version, mode, path + ["clear_data"])
                self.curves = self.__class__.curves(service, version, mode, path + ["curves"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.plot = self.__class__.plot(service, version, mode, path + ["plot"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a report plot.
                """
            class axes(TUIMethod):
                """
                Defines the axes for a report plot.
                """
            class clear_data(TUIMethod):
                """
                Clears the data associated with a report plot.
                """
            class curves(TUIMethod):
                """
                Defines the curves for a report plot.
                """
            class delete_all(TUIMethod):
                """
                Deletes all of the report plot objects.
                """
            class edit(TUIMethod):
                """
                Edits a report plot.
                """
            class delete(TUIMethod):
                """
                Deletes a report plot object.
                """
            class list(TUIMethod):
                """
                Lists all defined report plots.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report plot.
                """
            class plot(TUIMethod):
                """
                Plots the specified report plot.
                """

        class cell_registers(TUIMenu):
            """
            Enters the cell registers menu.
            """
            def __init__(self, service, version, mode, path):
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.apply_poor_mesh_numerics = self.__class__.apply_poor_mesh_numerics(service, version, mode, path + ["apply_poor_mesh_numerics"])
                self.coarsen = self.__class__.coarsen(service, version, mode, path + ["coarsen"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                self.refine = self.__class__.refine(service, version, mode, path + ["refine"])
                super().__init__(service, version, mode, path)
            class adapt(TUIMethod):
                """
                Adapt cell register objects.
                """
            class add(TUIMethod):
                """
                Add a new object.
                """
            class apply_poor_mesh_numerics(TUIMethod):
                """
                Applies poor mesh numerics to the mesh of a cell register.
                """
            class coarsen(TUIMethod):
                """
                Coarsen cell register objects.
                """
            class display(TUIMethod):
                """
                Displays a cell register.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class delete(TUIMethod):
                """
                Deletes a cell register.
                """
            class list(TUIMethod):
                """
                Lists all of the currently defined cell registers.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a cell register.
                """
            class refine(TUIMethod):
                """
                Refine cell register objects.
                """

        class cell_register_operations(TUIMenu):
            """
            Enters the cell register operations menu.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Creates a new cell register operation.
                """
            class edit(TUIMethod):
                """
                Edits an existing cell register operation.
                """
            class delete(TUIMethod):
                """
                Deletes a cell register operation.
                """
            class list(TUIMethod):
                """
                Lists the currently defined cell register operations.
                """
            class list_properties(TUIMethod):
                """
                Lists the properties of a report register operation.
                """

        class set(TUIMenu):
            """
            Enters the set solution parameters menu.
            """
            def __init__(self, service, version, mode, path):
                self.contact_solution_controls = self.__class__.contact_solution_controls(service, version, mode, path + ["contact_solution_controls"])
                self.transient_controls = self.__class__.transient_controls(service, version, mode, path + ["transient_controls"])
                self.data_sampling_options = self.__class__.data_sampling_options(service, version, mode, path + ["data_sampling_options"])
                self.pseudo_time_method = self.__class__.pseudo_time_method(service, version, mode, path + ["pseudo_time_method"])
                self.nita_expert_controls = self.__class__.nita_expert_controls(service, version, mode, path + ["nita_expert_controls"])
                self.multiphase_numerics = self.__class__.multiphase_numerics(service, version, mode, path + ["multiphase_numerics"])
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(service, version, mode, path + ["open_channel_wave_options"])
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(service, version, mode, path + ["high_order_term_relaxation"])
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(service, version, mode, path + ["poor_mesh_numerics"])
                self.amg_options = self.__class__.amg_options(service, version, mode, path + ["amg_options"])
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(service, version, mode, path + ["warped_face_gradient_correction"])
                self.fast_transient_settings = self.__class__.fast_transient_settings(service, version, mode, path + ["fast_transient_settings"])
                self.divergence_prevention = self.__class__.divergence_prevention(service, version, mode, path + ["divergence_prevention"])
                self.advanced = self.__class__.advanced(service, version, mode, path + ["advanced"])
                self.high_speed_numerics = self.__class__.high_speed_numerics(service, version, mode, path + ["high_speed_numerics"])
                self.previous_defaults = self.__class__.previous_defaults(service, version, mode, path + ["previous_defaults"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(service, version, mode, path + ["acoustics_wave_equation_controls"])
                self.p_v_controls_advanced = self.__class__.p_v_controls_advanced(service, version, mode, path + ["p_v_controls_advanced"])
                self.adaptive_time_stepping = self.__class__.adaptive_time_stepping(service, version, mode, path + ["adaptive_time_stepping"])
                self.cfl_based_adaptive_time_stepping = self.__class__.cfl_based_adaptive_time_stepping(service, version, mode, path + ["cfl_based_adaptive_time_stepping"])
                self.variable_time_stepping = self.__class__.variable_time_stepping(service, version, mode, path + ["variable_time_stepping"])
                self.bc_pressure_extrapolations = self.__class__.bc_pressure_extrapolations(service, version, mode, path + ["bc_pressure_extrapolations"])
                self.correction_tolerance = self.__class__.correction_tolerance(service, version, mode, path + ["correction_tolerance"])
                self.courant_number = self.__class__.courant_number(service, version, mode, path + ["courant_number"])
                self.data_sampling = self.__class__.data_sampling(service, version, mode, path + ["data_sampling"])
                self.disable_reconstruction = self.__class__.disable_reconstruction(service, version, mode, path + ["disable_reconstruction"])
                self.discretization_scheme = self.__class__.discretization_scheme(service, version, mode, path + ["discretization_scheme"])
                self.flux_type = self.__class__.flux_type(service, version, mode, path + ["flux_type"])
                self.equations = self.__class__.equations(service, version, mode, path + ["equations"])
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.flow_warnings = self.__class__.flow_warnings(service, version, mode, path + ["flow_warnings"])
                self.gradient_scheme = self.__class__.gradient_scheme(service, version, mode, path + ["gradient_scheme"])
                self.nb_gradient_boundary_option = self.__class__.nb_gradient_boundary_option(service, version, mode, path + ["nb_gradient_boundary_option"])
                self.limits = self.__class__.limits(service, version, mode, path + ["limits"])
                self.limiter_warnings = self.__class__.limiter_warnings(service, version, mode, path + ["limiter_warnings"])
                self.mp_mfluid_aniso_drag = self.__class__.mp_mfluid_aniso_drag(service, version, mode, path + ["mp_mfluid_aniso_drag"])
                self.material_property_warnings = self.__class__.material_property_warnings(service, version, mode, path + ["material_property_warnings"])
                self.mp_reference_density = self.__class__.mp_reference_density(service, version, mode, path + ["mp_reference_density"])
                self.max_corrections = self.__class__.max_corrections(service, version, mode, path + ["max_corrections"])
                self.multi_grid_amg = self.__class__.multi_grid_amg(service, version, mode, path + ["multi_grid_amg"])
                self.multi_grid_fas = self.__class__.multi_grid_fas(service, version, mode, path + ["multi_grid_fas"])
                self.multi_grid_controls = self.__class__.multi_grid_controls(service, version, mode, path + ["multi_grid_controls"])
                self.multi_stage = self.__class__.multi_stage(service, version, mode, path + ["multi_stage"])
                self.number_of_iterations = self.__class__.number_of_iterations(service, version, mode, path + ["number_of_iterations"])
                self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                self.second_order_time_options = self.__class__.second_order_time_options(service, version, mode, path + ["second_order_time_options"])
                self.solution_steering = self.__class__.solution_steering(service, version, mode, path + ["solution_steering"])
                self.set_solution_steering = self.__class__.set_solution_steering(service, version, mode, path + ["set_solution_steering"])
                self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                self.p_v_controls = self.__class__.p_v_controls(service, version, mode, path + ["p_v_controls"])
                self.phase_based_vof_discretization = self.__class__.phase_based_vof_discretization(service, version, mode, path + ["phase_based_vof_discretization"])
                self.accelerated_non_iterative_time_marching = self.__class__.accelerated_non_iterative_time_marching(service, version, mode, path + ["accelerated_non_iterative_time_marching"])
                self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                self.reporting_interval = self.__class__.reporting_interval(service, version, mode, path + ["reporting_interval"])
                self.residual_smoothing = self.__class__.residual_smoothing(service, version, mode, path + ["residual_smoothing"])
                self.residual_tolerance = self.__class__.residual_tolerance(service, version, mode, path + ["residual_tolerance"])
                self.residual_verbosity = self.__class__.residual_verbosity(service, version, mode, path + ["residual_verbosity"])
                self.set_solution_methods_to_default = self.__class__.set_solution_methods_to_default(service, version, mode, path + ["set_solution_methods_to_default"])
                self.set_controls_to_default = self.__class__.set_controls_to_default(service, version, mode, path + ["set_controls_to_default"])
                self.set_all_species_together = self.__class__.set_all_species_together(service, version, mode, path + ["set_all_species_together"])
                self.slope_limiter_set = self.__class__.slope_limiter_set(service, version, mode, path + ["slope_limiter_set"])
                self.vof_numerics = self.__class__.vof_numerics(service, version, mode, path + ["vof_numerics"])
                self.vof_explicit_controls = self.__class__.vof_explicit_controls(service, version, mode, path + ["vof_explicit_controls"])
                self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                self.surface_tension_expert = self.__class__.surface_tension_expert(service, version, mode, path + ["surface_tension_expert"])
                self.open_channel_controls = self.__class__.open_channel_controls(service, version, mode, path + ["open_channel_controls"])
                self.numerical_beach_controls = self.__class__.numerical_beach_controls(service, version, mode, path + ["numerical_beach_controls"])
                self.heterogeneous_stiff_chemistry = self.__class__.heterogeneous_stiff_chemistry(service, version, mode, path + ["heterogeneous_stiff_chemistry"])
                self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                self.time_step = self.__class__.time_step(service, version, mode, path + ["time_step"])
                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                self.convergence_acceleration_for_stretched_meshes = self.__class__.convergence_acceleration_for_stretched_meshes(service, version, mode, path + ["convergence_acceleration_for_stretched_meshes"])
                self.reduced_rank_extrapolation = self.__class__.reduced_rank_extrapolation(service, version, mode, path + ["reduced_rank_extrapolation"])
                self.reduced_rank_extrapolation_options = self.__class__.reduced_rank_extrapolation_options(service, version, mode, path + ["reduced_rank_extrapolation_options"])
                self.moving_mesh_numerics = self.__class__.moving_mesh_numerics(service, version, mode, path + ["moving_mesh_numerics"])
                self.lock_solid_temperature = self.__class__.lock_solid_temperature(service, version, mode, path + ["lock_solid_temperature"])
                self.enable_output_dp_dt = self.__class__.enable_output_dp_dt(service, version, mode, path + ["enable_output_dp_dt"])
                self.equation_ordering = self.__class__.equation_ordering(service, version, mode, path + ["equation_ordering"])
                super().__init__(service, version, mode, path)
            class adaptive_time_stepping(TUIMethod):
                """
                Set Error-based adaptive time-stepping parameters.
                """
            class cfl_based_adaptive_time_stepping(TUIMethod):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
            class variable_time_stepping(TUIMethod):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """
            class bc_pressure_extrapolations(TUIMethod):
                """
                Sets pressure extrapolations schemes on boundaries.
                """
            class correction_tolerance(TUIMethod):
                """
                Enters the correction tolerance menu.
                """
            class courant_number(TUIMethod):
                """
                Sets the fine-grid Courant number (time step factor). This command is available only for the coupled solvers.
                """
            class data_sampling(TUIMethod):
                """
                Enables data sampling for steady or unsteady flow statistics.
                """
            class disable_reconstruction(TUIMethod):
                """
                Completely disables reconstruction, resulting in totally first-order accuracy.
                """
            class discretization_scheme(TUIMethod):
                """
                Enters the discretization scheme menu. This allows you to select the discretization scheme for the convection terms in the solution equations. The following text commands can make a selection from a subset of the models in the following table:.
                """
            class flux_type(TUIMethod):
                """
                Enter the flux type.
                """
            class equations(TUIMethod):
                """
                Selects the equations to be solved.
                """
            class expert(TUIMethod):
                """
                Sets expert options.
                """
            class flow_warnings(TUIMethod):
                """
                Specifies whether or not to print warning messages when reversed flow occurs at inlets and outlets, and when mass-flow inlets develop supersonic regions. By default, flow warnings are printed.
                """
            class gradient_scheme(TUIMethod):
                """
                Sets gradient options.
                """
            class nb_gradient_boundary_option(TUIMethod):
                """
                Switches between the modified treatment of node-based gradients at boundary cells and the legacy treatment (R14.5.7 and earlier). If using the density-based solver, you can also specify the extended treatment. For details, see .
                """
            class limits(TUIMethod):
                """
                Sets solver limits for various solution variables, in order to improve the stability of the solution.
                """
            class limiter_warnings(TUIMethod):
                """
                Specifies whether or not to print warning messages when quantities are being limited. By default, limiter warnings are printed.
                """
            class mp_mfluid_aniso_drag(TUIMethod):
                """
                Sets anisotropic drag parameters for the Eulerian multiphase model.
                """
            class material_property_warnings(TUIMethod):
                """
                Control the display of material property warning diagnostics:
                0 - off (no messages)
                1 - messages per material
                2 - messages per material and per property.
                """
            class mp_reference_density(TUIMethod):
                """
                Sets the reference density method for the Eulerian multiphase model. The following options are available:
                0 (default): Averaged density of the phase
                1: Cell density of the phase
                1: Constant value of 1
                1: Cell density of the phase
                See  for more information.
                """
            class max_corrections(TUIMethod):
                """
                Enters the max-corrections menu.
                """
            class multi_grid_amg(TUIMethod):
                """
                Sets the parameters that govern the algebraic multigrid procedure.
                """
            class multi_grid_fas(TUIMethod):
                """
                Sets the parameters that control the FAS multigrid solver. This command appears only when the explicit coupled solver is used.
                """
            class multi_grid_controls(TUIMethod):
                """
                Sets multigrid parameters and termination criteria.
                """
            class multi_stage(TUIMethod):
                """
                Sets the multi-stage coefficients and the dissipation and viscous evaluation stages. This command appears only when the explicit coupled solver is used.
                """
            class number_of_iterations(TUIMethod):
                """
                Sets the number of iterations for a steady-state simulation without starting the calculation.
                """
            class numerics(TUIMethod):
                """
                Sets numerics options.
                """
            class second_order_time_options(TUIMethod):
                """
                Enables / disables the variable time step size formulation for second-order implicit transient formulations. If you disable the variable time step size formulation, note that any change in the time step size will introduce an error proportional to the change in the time step size ratio.
                """
            class solution_steering(TUIMethod):
                """
                Enables solution steering for the density-based solver.
                """
            class set_solution_steering(TUIMethod):
                """
                Sets solution steering parameters.
                """
            class p_v_coupling(TUIMethod):
                """
                Selects which pressure-velocity coupling scheme is to be used. Five schemes are available:.
                """
            class p_v_controls(TUIMethod):
                """
                Sets pressure-velocity controls.
                """
            class phase_based_vof_discretization(TUIMethod):
                """
                Sets phase based slope limiter for VOF compressive scheme.
                """
            class accelerated_non_iterative_time_marching(TUIMethod):
                """
                Enables a modified NITA scheme and other setting changes that can speed up the simulation. This option is only available with the Large Eddy Simulation (LES) turbulence model, and is intended for unreacting flow simulations that use a constant-density fluid.
                """
            class relaxation_method(TUIMethod):
                """
                Sets the solver relaxation method.
                """
            class reactions(TUIMethod):
                """
                Enables the species reaction sources and sets relaxation factor.
                """
            class relaxation_factor(TUIMethod):
                """
                Enters the relaxation-factor menu.
                """
            class reporting_interval(TUIMethod):
                """
                Sets the number of iterations for which convergence monitors are reported. The default is 1 (after every iteration).
                """
            class residual_smoothing(TUIMethod):
                """
                Sets the implicit residual smoothing parameters. This command is available only for the explicit coupled solver.
                """
            class residual_tolerance(TUIMethod):
                """
                Enters the residual tolerance menu.
                """
            class residual_verbosity(TUIMethod):
                """
                Sets the amount of residual information to be printed. A value of 0 (the default) prints residuals at the end of each fine grid iteration. A value of 1 prints residuals after every stage of the fine grid iteration. A value of 2 prints residuals after every stage on every grid level.
                """
            class set_solution_methods_to_default(TUIMethod):
                """
                Sets the solution methods to the default settings.
                """
            class set_controls_to_default(TUIMethod):
                """
                Sets controls to default values.
                """
            class set_all_species_together(TUIMethod):
                """
                Sets all species discretizations and URFs together.
                """
            class slope_limiter_set(TUIMethod):
                """
                Selects a new Fluent solver slope limiter.
                """
            class vof_numerics(TUIMethod):
                """
                Sets VOF numeric options.
                """
            class vof_explicit_controls(TUIMethod):
                """
                Sets the sub time step calculation method for VOF calculations.
                """
            class surface_tension(TUIMethod):
                """
                Sets surface-tension calculation options.
                """
            class surface_tension_expert(TUIMethod):
                """
                Set surface-tension expert options.
                """
            class open_channel_controls(TUIMethod):
                """
                For flows that do not transition from sub-critical to super-critical, or vice-versa, you can speed-up the solution calculation by updating the frequency of Froude number during run time.
                """
            class numerical_beach_controls(TUIMethod):
                """
                Sets damping function in flow direction. This command appears only when the VOF model is enabled. Select the damping function to be used:
                Index
                Damping Function
                0
                Linear
                1
                Quadratic
                2
                Cubic
                3
                Cosine.
                """
            class heterogeneous_stiff_chemistry(TUIMethod):
                """
                Sets the heterogeneous stiff-chemistry solver.
                """
            class stiff_chemistry(TUIMethod):
                """
                Sets solver options for stiff chemistry solutions.
                """
            class time_step(TUIMethod):
                """
                Set the time step.
                """
            class under_relaxation(TUIMethod):
                """
                Enters the under-relaxation menu, which allows you to set the under-relaxation factor for each equation that is being solved in a segregated manner.
                """
            class convergence_acceleration_for_stretched_meshes(TUIMethod):
                """
                Enables convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
            class reduced_rank_extrapolation(TUIMethod):
                """
                Enable Reduced Rank Extrapolation method to accelerate solution time.
                """
            class reduced_rank_extrapolation_options(TUIMethod):
                """
                Reduced Rank Extrapolation options.
                """
            class moving_mesh_numerics(TUIMethod):
                """
                Transient options for sliding, moving, and/or dynamic mesh.
                """
            class lock_solid_temperature(TUIMethod):
                """
                Specifies whether you want to lock (or “freeze”) the temperature values for all the cells in solid zones (including those to which you have a hooked an energy source through a UDF) and in walls that have shell conduction enabled, so that the values do not change during further solver iterations.
                """
            class enable_output_dp_dt(TUIMethod):
                """
                Controls whether the output field variabledp-dt will be available for transient simulation postprocessing. If you select no, pressure fields at the previous time steps will not be stored in memory which reduces memory usage.
                """
            class equation_ordering(TUIMethod):
                """
                Sets the order in which the model equations are solved, which can affect the convergence speed when you are using the pressure-based solver. The standard method is enabled by default and corresponds to the ordering shown in  and  in the Theory Guide; alternatively, you can select theoptimized-for-volumetric-expansion method, which is recommended for flows in which the density is strongly dependent on thermal effects, chemical composition, and so on (such as combustion simulations). This text command is not available for steady simulations and/or when a multiphase model is enabled.
                """

            class contact_solution_controls(TUIMenu):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, service, version, mode, path):
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.spatial = self.__class__.spatial(service, version, mode, path + ["spatial"])
                    self.transient = self.__class__.transient(service, version, mode, path + ["transient"])
                    self.amg = self.__class__.amg(service, version, mode, path + ["amg"])
                    self.models = self.__class__.models(service, version, mode, path + ["models"])
                    self.methods = self.__class__.methods(service, version, mode, path + ["methods"])
                    self.miscellaneous = self.__class__.miscellaneous(service, version, mode, path + ["miscellaneous"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.set_settings_to_default = self.__class__.set_settings_to_default(service, version, mode, path + ["set_settings_to_default"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class solution_stabilization(TUIMethod):
                    """
                    Automatic solver settings adjustment for solution stabilization during contact process.
                    """
                class set_settings_to_default(TUIMethod):
                    """
                    Set contact solution stabilization to default.
                    """
                class verbosity(TUIMethod):
                    """
                    Specify verbosity level for contact solution controls.
                    """

                class parameters(TUIMenu):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, service, version, mode, path):
                        self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                        self.solution_stabilization_persistence = self.__class__.solution_stabilization_persistence(service, version, mode, path + ["solution_stabilization_persistence"])
                        self.persistence_fixed_time_steps = self.__class__.persistence_fixed_time_steps(service, version, mode, path + ["persistence_fixed_time_steps"])
                        self.persistence_fixed_duration = self.__class__.persistence_fixed_duration(service, version, mode, path + ["persistence_fixed_duration"])
                        self.extrapolation_method = self.__class__.extrapolation_method(service, version, mode, path + ["extrapolation_method"])
                        super().__init__(service, version, mode, path)
                    class iterations(TUIMethod):
                        """
                        Specify additional iterations to accomodate contact solution stabilization.
                        """
                    class solution_stabilization_persistence(TUIMethod):
                        """
                        Persistence of the solution stabilization based on events [0-contact based, 1-always on].
                        """
                    class persistence_fixed_time_steps(TUIMethod):
                        """
                        Specify fixed time-steps for solution stabilization persistence after trigger.
                        """
                    class persistence_fixed_duration(TUIMethod):
                        """
                        Specify fixed time for solution stabilization persistence after trigger.
                        """
                    class extrapolation_method(TUIMethod):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """

                class spatial(TUIMenu):
                    """
                    Spatial discretization control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.first_to_second_order_blending = self.__class__.first_to_second_order_blending(service, version, mode, path + ["first_to_second_order_blending"])
                        self.first_to_second_order_blending_list = self.__class__.first_to_second_order_blending_list(service, version, mode, path + ["first_to_second_order_blending_list"])
                        self.scheme = self.__class__.scheme(service, version, mode, path + ["scheme"])
                        self.flow_skew_diffusion_exclude = self.__class__.flow_skew_diffusion_exclude(service, version, mode, path + ["flow_skew_diffusion_exclude"])
                        self.scalars_skew_diffusion_exclude = self.__class__.scalars_skew_diffusion_exclude(service, version, mode, path + ["scalars_skew_diffusion_exclude"])
                        self.rhie_chow_flux_specify = self.__class__.rhie_chow_flux_specify(service, version, mode, path + ["rhie_chow_flux_specify"])
                        self.rhie_chow_method = self.__class__.rhie_chow_method(service, version, mode, path + ["rhie_chow_method"])
                        super().__init__(service, version, mode, path)
                    class first_to_second_order_blending(TUIMethod):
                        """
                        Set factor to control first order to second order blending.
                        """
                    class first_to_second_order_blending_list(TUIMethod):
                        """
                        List set factor to control first order to second order blending.
                        """
                    class scheme(TUIMethod):
                        """
                        Set advection scheme for contact event stability.
                        """
                    class flow_skew_diffusion_exclude(TUIMethod):
                        """
                        Exclude skew diffusion discretization contribution for momentum.
                        """
                    class scalars_skew_diffusion_exclude(TUIMethod):
                        """
                        Exclude skew diffusion discretization contribution for scalars.
                        """
                    class rhie_chow_flux_specify(TUIMethod):
                        """
                        Allow specification of the the rhie-chow flux method.
                        """
                    class rhie_chow_method(TUIMethod):
                        """
                        Enter the rhie-chow flux method.
                        """

                class transient(TUIMenu):
                    """
                    Transient discretization control options .
                    """
                    def __init__(self, service, version, mode, path):
                        self.transient_parameters_specify = self.__class__.transient_parameters_specify(service, version, mode, path + ["transient_parameters_specify"])
                        self.transient_scheme = self.__class__.transient_scheme(service, version, mode, path + ["transient_scheme"])
                        self.time_scale_modification_method = self.__class__.time_scale_modification_method(service, version, mode, path + ["time_scale_modification_method"])
                        self.time_scale_modification_factor = self.__class__.time_scale_modification_factor(service, version, mode, path + ["time_scale_modification_factor"])
                        super().__init__(service, version, mode, path)
                    class transient_parameters_specify(TUIMethod):
                        """
                        Allow transient parameter specification.
                        """
                    class transient_scheme(TUIMethod):
                        """
                        Specify temporal scheme to be used.
                        """
                    class time_scale_modification_method(TUIMethod):
                        """
                        Enter time scale modification method.
                        """
                    class time_scale_modification_factor(TUIMethod):
                        """
                        Specify time-scale modification factor.
                        """

                class amg(TUIMenu):
                    """
                    AMG control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enforce_laplace_coarsening = self.__class__.enforce_laplace_coarsening(service, version, mode, path + ["enforce_laplace_coarsening"])
                        self.increase_pre_sweeps = self.__class__.increase_pre_sweeps(service, version, mode, path + ["increase_pre_sweeps"])
                        self.pre_sweeps = self.__class__.pre_sweeps(service, version, mode, path + ["pre_sweeps"])
                        self.specify_coarsening_rate = self.__class__.specify_coarsening_rate(service, version, mode, path + ["specify_coarsening_rate"])
                        self.coarsen_rate = self.__class__.coarsen_rate(service, version, mode, path + ["coarsen_rate"])
                        super().__init__(service, version, mode, path)
                    class enforce_laplace_coarsening(TUIMethod):
                        """
                        Enforce the use of laplace coarsening in AMG.
                        """
                    class increase_pre_sweeps(TUIMethod):
                        """
                        Allow increase in AMG pre-sweep.
                        """
                    class pre_sweeps(TUIMethod):
                        """
                        Specify the number of AMG pre-sweeps.
                        """
                    class specify_coarsening_rate(TUIMethod):
                        """
                        Modify AMG coarsening rate.
                        """
                    class coarsen_rate(TUIMethod):
                        """
                        Specify AMG coarsening rate.
                        """

                class models(TUIMenu):
                    """
                    Model control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.model_ramping = self.__class__.model_ramping(service, version, mode, path + ["model_ramping"])
                        self.ramp_flow = self.__class__.ramp_flow(service, version, mode, path + ["ramp_flow"])
                        self.ramp_turbulence = self.__class__.ramp_turbulence(service, version, mode, path + ["ramp_turbulence"])
                        self.ramp_scalars = self.__class__.ramp_scalars(service, version, mode, path + ["ramp_scalars"])
                        super().__init__(service, version, mode, path)
                    class model_ramping(TUIMethod):
                        """
                        Activate model ramping for solver stability and accuracy.
                        """
                    class ramp_flow(TUIMethod):
                        """
                        Ramp flow for solver stability and accuracy.
                        """
                    class ramp_turbulence(TUIMethod):
                        """
                        Ramp turbulence for solver stability and accuracy.
                        """
                    class ramp_scalars(TUIMethod):
                        """
                        Ramp all scalar transport equations for solver stability and accuracy.
                        """

                class methods(TUIMenu):
                    """
                    Methods control options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.pressure_velocity_coupling_controls = self.__class__.pressure_velocity_coupling_controls(service, version, mode, path + ["pressure_velocity_coupling_controls"])
                        self.pressure_velocity_coupling_method = self.__class__.pressure_velocity_coupling_method(service, version, mode, path + ["pressure_velocity_coupling_method"])
                        self.gradient_controls = self.__class__.gradient_controls(service, version, mode, path + ["gradient_controls"])
                        self.specify_gradient_method = self.__class__.specify_gradient_method(service, version, mode, path + ["specify_gradient_method"])
                        super().__init__(service, version, mode, path)
                    class pressure_velocity_coupling_controls(TUIMethod):
                        """
                        Enable pressure-velocity coupling method change for solver stability and accuracy.
                        """
                    class pressure_velocity_coupling_method(TUIMethod):
                        """
                        Specify pressure-velocity coupling method change for solver stability and accuracy.
                        """
                    class gradient_controls(TUIMethod):
                        """
                        Modify gradient method for solver stability and accuracy.
                        """
                    class specify_gradient_method(TUIMethod):
                        """
                        Specify gradient method for solver stability and accuracy.
                        """

                class miscellaneous(TUIMenu):
                    """
                    Miscellaneous.
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_statistics = self.__class__.compute_statistics(service, version, mode, path + ["compute_statistics"])
                        self.statistics_level = self.__class__.statistics_level(service, version, mode, path + ["statistics_level"])
                        super().__init__(service, version, mode, path)
                    class compute_statistics(TUIMethod):
                        """
                        Compute solution statistics for contact updates.
                        """
                    class statistics_level(TUIMethod):
                        """
                        Solution statistics level for contact updates.
                        """

            class transient_controls(TUIMenu):
                """
                Enters the transient controls menu, which allows you to define settings related to time advancement for transient flow calculations.
                """
                def __init__(self, service, version, mode, path):
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(service, version, mode, path + ["multiphase_specific_time_constraints"])
                    self.specified_time_step = self.__class__.specified_time_step(service, version, mode, path + ["specified_time_step"])
                    self.fixed_user_specified = self.__class__.fixed_user_specified(service, version, mode, path + ["fixed_user_specified"])
                    self.fixed_periodic = self.__class__.fixed_periodic(service, version, mode, path + ["fixed_periodic"])
                    self.duration_specification_method = self.__class__.duration_specification_method(service, version, mode, path + ["duration_specification_method"])
                    self.incremental_time = self.__class__.incremental_time(service, version, mode, path + ["incremental_time"])
                    self.max_iterations_per_time_step = self.__class__.max_iterations_per_time_step(service, version, mode, path + ["max_iterations_per_time_step"])
                    self.number_of_time_steps = self.__class__.number_of_time_steps(service, version, mode, path + ["number_of_time_steps"])
                    self.total_number_of_time_steps = self.__class__.total_number_of_time_steps(service, version, mode, path + ["total_number_of_time_steps"])
                    self.total_time = self.__class__.total_time(service, version, mode, path + ["total_time"])
                    self.time_step_size = self.__class__.time_step_size(service, version, mode, path + ["time_step_size"])
                    self.solution_status = self.__class__.solution_status(service, version, mode, path + ["solution_status"])
                    self.extrapolate_vars = self.__class__.extrapolate_vars(service, version, mode, path + ["extrapolate_vars"])
                    self.extrapolate_eqn_vars = self.__class__.extrapolate_eqn_vars(service, version, mode, path + ["extrapolate_eqn_vars"])
                    self.max_flow_time = self.__class__.max_flow_time(service, version, mode, path + ["max_flow_time"])
                    self.cfl_based_time_stepping_advanced_options = self.__class__.cfl_based_time_stepping_advanced_options(service, version, mode, path + ["cfl_based_time_stepping_advanced_options"])
                    self.cfl_based_time_stepping = self.__class__.cfl_based_time_stepping(service, version, mode, path + ["cfl_based_time_stepping"])
                    self.multiphase_specific_time_stepping = self.__class__.multiphase_specific_time_stepping(service, version, mode, path + ["multiphase_specific_time_stepping"])
                    self.udf_based_time_stepping = self.__class__.udf_based_time_stepping(service, version, mode, path + ["udf_based_time_stepping"])
                    self.error_based_time_stepping = self.__class__.error_based_time_stepping(service, version, mode, path + ["error_based_time_stepping"])
                    self.undo_timestep = self.__class__.undo_timestep(service, version, mode, path + ["undo_timestep"])
                    self.predict_next_time = self.__class__.predict_next_time(service, version, mode, path + ["predict_next_time"])
                    self.rotating_mesh_flow_predictor = self.__class__.rotating_mesh_flow_predictor(service, version, mode, path + ["rotating_mesh_flow_predictor"])
                    self.solid_time_step_size = self.__class__.solid_time_step_size(service, version, mode, path + ["solid_time_step_size"])
                    self.time_step_size_for_acoustic_export = self.__class__.time_step_size_for_acoustic_export(service, version, mode, path + ["time_step_size_for_acoustic_export"])
                    super().__init__(service, version, mode, path)
                class specified_time_step(TUIMethod):
                    """
                    Specifies whether to define the transient advancement either directly by entering a time step size / period / frequency (using the text commands available in thesolve/set/transient-controls menu) or indirectly by entering a Courant number value (using the solve/set/courant-number text command). This text command is only available for the density-based solver when both the explicit formulation and explicit transient formulation are used.
                    """
                class fixed_user_specified(TUIMethod):
                    """
                    Allows you to specify that a fixed time stepping method is used in which you directly specify the time step size and number of time steps.
                    """
                class fixed_periodic(TUIMethod):
                    """
                    Allows you to specify that a fixed time stepping method is used in which a specified period or frequency is the basis for determining the time step size and number of time steps.
                    """
                class duration_specification_method(TUIMethod):
                    """
                    Sets the method by which you will specify the duration of the calculation. The duration can be defined by the total time, the total number of time steps, the incremental time, or the number of incremental time steps. In this context, "total" indicates that Fluent will consider the amount of time / steps that have already been solved and stop appropriately, whereas "incremental" indicates that the solution will proceed for a specified amount of time / steps regardless of what has previously been calculated. This text command is only available when the time stepping is adaptive or based on a user-defined function.
                    """
                class incremental_time(TUIMethod):
                    """
                    Sets the amount of incremental (that is, additional) time to run the simulation, regardless of how much time has already been run in previous calculations. This text command is only available when the solve/set/transient-controls/duration-specification-method is set to3.
                    """
                class max_iterations_per_time_step(TUIMethod):
                    """
                    Sets the number of time steps for a transient simulation.  This option is available when automatic initialization and case modification is enabled.
                    """
                class number_of_time_steps(TUIMethod):
                    """
                    Sets the number of time steps for a transient simulation without starting the calculation.
                    """
                class total_number_of_time_steps(TUIMethod):
                    """
                    Sets the total number of time steps that the simulation will run (which includes any time steps that have already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to1.
                    """
                class total_time(TUIMethod):
                    """
                    Sets the total amount of time that the simulation will be run (which includes any time that has already been run in previous calculations). This text command is only available when the solve/set/transient-controls/duration-specification-method is set to2.
                    """
                class time_step_size(TUIMethod):
                    """
                    Sets the magnitude of the (physical) time step . This text command is only available when the solve/set/transient-controls/fixed-user-specified text command is set toyes.
                    """
                class solution_status(TUIMethod):
                    """
                    Allows you to open theSimulation Status dialog box, which reports details about the simulation.
                    """
                class extrapolate_vars(TUIMethod):
                    """
                    Applies a predictor algorithm for computing initial conditions at time step n+1. The predictor algorithm is a computation that sets a better initial condition for the time step.
                    """
                class extrapolate_eqn_vars(TUIMethod):
                    """
                    Enters the extrapolation menu.
                    """
                class max_flow_time(TUIMethod):
                    """
                    Sets the maximum flow time.
                    """
                class cfl_based_time_stepping_advanced_options(TUIMethod):
                    """
                    Set CFL-based adaptive time-stepping advanced parameters.
                    """
                class cfl_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent as the calculation proceeds such that the Courant–Friedrichs–Lewy (CFL) condition is satisfied, using the specified Courant number.
                    """
                class multiphase_specific_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the convective time scale (global Courant number): the time-step-size calculation depends on the mesh density and velocity in interfacial cells. This method is available for all multiphase models using the implicit or explicit volume fraction formulation, except for the wet steam model.
                    """
                class udf_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that the time step size is defined by a user-defined function (UDF) that uses theDEFINE_DELTAT macro.
                    """
                class error_based_time_stepping(TUIMethod):
                    """
                    Allows you to specify that an adaptive time stepping method is used in which the time step gets modified by ANSYS Fluent  based on the specified truncation error tolerance.
                    """
                class undo_timestep(TUIMethod):
                    """
                    When enabled, if the truncation error within a time step exceeds the specified tolerance Fluent will automatically undo the current calculation and make another attempt with the time step reduced by 1/2. This will be attempted up to 5 times after which Fluent will accept the result and proceed to the next time step.
                    """
                class predict_next_time(TUIMethod):
                    """
                    Applies a predictor algorithm for computing the next time step. The predictor algorithm is a computation that sets a better initial condition for the time step. It uses the rate of change between the prediction and the correction as an indicator for whether the next time step should be larger, smaller, or the same as the current one.
                    """
                class rotating_mesh_flow_predictor(TUIMethod):
                    """
                    Enables / disables an option that allows for better prediction of the flow field in rotating fluid zones at every time step, in order to speed up the calculation. This text command is only available for transient simulations.
                    """
                class solid_time_step_size(TUIMethod):
                    """
                    Allows you to specify that the time step size used for solid zones is independent from that used for fluid zones. This text command is only available when both a solid zone exists and energy is enabled.
                    """
                class time_step_size_for_acoustic_export(TUIMethod):
                    """
                    Specifies the time interval for acoustic data sampling. This text command is only available when both the Ffowcs Williams and Hawkings model is selected and the density-based solver is used with the explicit formulation and explicit transient formulation.
                    """

                class multiphase_specific_time_constraints(TUIMenu):
                    """
                    Enters the menu for setting multiphase-specific time constraints.
                    """
                    def __init__(self, service, version, mode, path):
                        self.time_scale_options = self.__class__.time_scale_options(service, version, mode, path + ["time_scale_options"])
                        self.moving_mesh_cfl_constraint = self.__class__.moving_mesh_cfl_constraint(service, version, mode, path + ["moving_mesh_cfl_constraint"])
                        self.physics_based_constraint = self.__class__.physics_based_constraint(service, version, mode, path + ["physics_based_constraint"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class moving_mesh_cfl_constraint(TUIMethod):
                        """
                        Enable time step size constraints based on moving mesh courant number.
                        """
                    class physics_based_constraint(TUIMethod):
                        """
                        Enables/disables the physics-driven time-step constraints.
                        """
                    class verbosity(TUIMethod):
                        """
                        When enabled, various time scales (depending on the selection) are  printed to the console window at every time step. This text command is  available with the moving mesh CFL constraint and with the physics-based  constraint.
                        """

                    class time_scale_options(TUIMenu):
                        """
                        Enters the menu for choosing the time-scale options. This menu  becomes available after you enable the physics-driven time-step  constraints using the solve/set/transient-controls/multiphase-specific-time-constraints/physics-based-constraint?  text command.
                        """
                        def __init__(self, service, version, mode, path):
                            self.viscous_scale = self.__class__.viscous_scale(service, version, mode, path + ["viscous_scale"])
                            self.gravity_scale = self.__class__.gravity_scale(service, version, mode, path + ["gravity_scale"])
                            self.surface_tension_scale = self.__class__.surface_tension_scale(service, version, mode, path + ["surface_tension_scale"])
                            self.acoustic_scale = self.__class__.acoustic_scale(service, version, mode, path + ["acoustic_scale"])
                            super().__init__(service, version, mode, path)
                        class viscous_scale(TUIMethod):
                            """
                            Allows you to Include the viscous time scale. This option is disabled by default. This command is not available with inviscid flows.
                            """
                        class gravity_scale(TUIMethod):
                            """
                            Allows you to Include the gravitational time scale. This option is available only if gravity is enabled.
                            """
                        class surface_tension_scale(TUIMethod):
                            """
                            Allows you to Include the surface-tension-driven time scale. This option is available only if the surface tension force modeling is enabled.
                            """
                        class acoustic_scale(TUIMethod):
                            """
                            Allows you to Include the acoustic time scale. This option is available only for compressible flows.
                            """

            class data_sampling_options(TUIMenu):
                """
                Enter the menu for specifying quantities and zones for steady and unsteady flow statistics.
                """
                def __init__(self, service, version, mode, path):
                    self.add_datasets = self.__class__.add_datasets(service, version, mode, path + ["add_datasets"])
                    self.add_rtdft_datasets = self.__class__.add_rtdft_datasets(service, version, mode, path + ["add_rtdft_datasets"])
                    self.remove_dataset = self.__class__.remove_dataset(service, version, mode, path + ["remove_dataset"])
                    self.list_datasets = self.__class__.list_datasets(service, version, mode, path + ["list_datasets"])
                    super().__init__(service, version, mode, path)
                class add_datasets(TUIMethod):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                class add_rtdft_datasets(TUIMethod):
                    """
                    Specify zone and quantity combinations for sampling Fourier coefficients of unsteady flows.
                    """
                class remove_dataset(TUIMethod):
                    """
                    Remove dataset.
                    """
                class list_datasets(TUIMethod):
                    """
                    Lists the combinations of zones and quantities that are defined for sampling steady and unsteady flow statistics.
                    """

            class pseudo_time_method(TUIMenu):
                """
                Enters the pseudo time method menu. This menu is only available for cases that use a pressure-based segregated solver (SIMPLE, SIMPLEC, or PISO) or for steady-state cases that use the pressure-based coupled solver or the density-based implicit solver.
                """
                def __init__(self, service, version, mode, path):
                    self.formulation = self.__class__.formulation(service, version, mode, path + ["formulation"])
                    self.local_time_step_settings = self.__class__.local_time_step_settings(service, version, mode, path + ["local_time_step_settings"])
                    self.global_time_step_settings = self.__class__.global_time_step_settings(service, version, mode, path + ["global_time_step_settings"])
                    self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                    self.relaxation_factors = self.__class__.relaxation_factors(service, version, mode, path + ["relaxation_factors"])
                    self.relaxation_method = self.__class__.relaxation_method(service, version, mode, path + ["relaxation_method"])
                    self.relaxation_bounds = self.__class__.relaxation_bounds(service, version, mode, path + ["relaxation_bounds"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class formulation(TUIMethod):
                    """
                    Select the pseudo time step size formulation for the pseudo time method.
                    """
                class local_time_step_settings(TUIMethod):
                    """
                    Defines the pseudo time Courant number when the local time step formulation is selected.
                    """
                class global_time_step_settings(TUIMethod):
                    """
                    Defines the pseudo time settings for the calculation when the global time step formulation is selected.
                    """
                class advanced_options(TUIMethod):
                    """
                    Enters the advanced options menu, which allows you to enable / disable the pseudo time method for individual equations and define their pseudo time scale factors or under-relaxation factors, respectively. These settings only apply when the global time step formulation is selected.
                    """
                class relaxation_factors(TUIMethod):
                    """
                    Enter the relaxation factors menu to set the pseudo time explicit relaxation factors for equations.
                    """
                class relaxation_method(TUIMethod):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                class relaxation_bounds(TUIMethod):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                class verbosity(TUIMethod):
                    """
                    Sets the verbosity of the messages related to the pseudo time method.
                    """

            class nita_expert_controls(TUIMenu):
                """
                Enters the NITA expert control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    self.skewness_neighbor_coupling = self.__class__.skewness_neighbor_coupling(service, version, mode, path + ["skewness_neighbor_coupling"])
                    self.hybrid_nita_settings = self.__class__.hybrid_nita_settings(service, version, mode, path + ["hybrid_nita_settings"])
                    super().__init__(service, version, mode, path)
                class set_verbosity(TUIMethod):
                    """
                    Setting this to 1, enables the verbosity for NITA diagnostics. The default value of 0 disables verbosity output for NITA diagnostics.
                    """
                class skewness_neighbor_coupling(TUIMethod):
                    """
                    Enables/disables coupling of the neighbor and skewness corrections.
                    """
                class hybrid_nita_settings(TUIMethod):
                    """
                    Enables and sets hybrid NITA options. For more details, see .
                    """

            class multiphase_numerics(TUIMenu):
                """
                Sets multiphase numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self.porous_media = self.__class__.porous_media(service, version, mode, path + ["porous_media"])
                    self.compressible_flow = self.__class__.compressible_flow(service, version, mode, path + ["compressible_flow"])
                    self.boiling_parameters = self.__class__.boiling_parameters(service, version, mode, path + ["boiling_parameters"])
                    self.viscous_flow = self.__class__.viscous_flow(service, version, mode, path + ["viscous_flow"])
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(service, version, mode, path + ["heat_mass_transfer"])
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(service, version, mode, path + ["advanced_stability_controls"])
                    self.default_controls = self.__class__.default_controls(service, version, mode, path + ["default_controls"])
                    self.face_pressure_controls = self.__class__.face_pressure_controls(service, version, mode, path + ["face_pressure_controls"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    super().__init__(service, version, mode, path)

                class porous_media(TUIMenu):
                    """
                    Enters the porous media numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.relative_permeability = self.__class__.relative_permeability(service, version, mode, path + ["relative_permeability"])
                        super().__init__(service, version, mode, path)
                    class relative_permeability(TUIMethod):
                        """
                        Allows you to fix the saturation (volume fraction) of the phase at  its user-specified residual saturation value.
                        """

                class compressible_flow(TUIMenu):
                    """
                    Enters the compressible multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enhanced_numerics = self.__class__.enhanced_numerics(service, version, mode, path + ["enhanced_numerics"])
                        self.alternate_bc_formulation = self.__class__.alternate_bc_formulation(service, version, mode, path + ["alternate_bc_formulation"])
                        super().__init__(service, version, mode, path)
                    class enhanced_numerics(TUIMethod):
                        """
                        Enables an enhanced numerical treatment that provides better  stability at startup and during calculation of compressible  flows.
                        """
                    class alternate_bc_formulation(TUIMethod):
                        """
                        Enables an alternative formulation for compressible phases at an  inlet boundary. This formulation calculates static temperature and  pressure using an iterative method based on fundamental thermodynamic  relations.
                        """

                class boiling_parameters(TUIMenu):
                    """
                    Enters the menu for the multiphase boiling model parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.thin_film = self.__class__.thin_film(service, version, mode, path + ["thin_film"])
                        self.liquid_vof_factor = self.__class__.liquid_vof_factor(service, version, mode, path + ["liquid_vof_factor"])
                        super().__init__(service, version, mode, path)
                    class thin_film(TUIMethod):
                        """
                        When enabled, includes multiphase boiling thin film effects using .
                        """
                    class liquid_vof_factor(TUIMethod):
                        """
                        When enabled, considers liquid volume fraction effects by multiplying the heat transfer coefficients by the local liquid volume fraction.
                        """

                class viscous_flow(TUIMenu):
                    """
                    Enters the viscous multiphase flow numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.viscosity_averaging = self.__class__.viscosity_averaging(service, version, mode, path + ["viscosity_averaging"])
                        self.turb_visc_based_damping = self.__class__.turb_visc_based_damping(service, version, mode, path + ["turb_visc_based_damping"])
                        self.interfacial_artificial_viscosity = self.__class__.interfacial_artificial_viscosity(service, version, mode, path + ["interfacial_artificial_viscosity"])
                        super().__init__(service, version, mode, path)
                    class viscosity_averaging(TUIMethod):
                        """
                        Forces harmonic averaging of cell viscosities to calculate face  viscosity used in momentum equation. This can improve convergence for  highly viscous flow applications (the VOF model only).
                        """
                    class turb_visc_based_damping(TUIMethod):
                        """
                        Turbulence viscosity based damping controls.
                        """
                    class interfacial_artificial_viscosity(TUIMethod):
                        """
                        Interfacial artifical viscosity controls.
                        """

                class heat_mass_transfer(TUIMenu):
                    """
                    Enters the menu for the multiphase heat mass transfer parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                        self.evaporation_condensation = self.__class__.evaporation_condensation(service, version, mode, path + ["evaporation_condensation"])
                        self.boiling = self.__class__.boiling(service, version, mode, path + ["boiling"])
                        self.area_density = self.__class__.area_density(service, version, mode, path + ["area_density"])
                        self.alternative_energy_treatment = self.__class__.alternative_energy_treatment(service, version, mode, path + ["alternative_energy_treatment"])
                        super().__init__(service, version, mode, path)
                    class alternative_energy_treatment(TUIMethod):
                        """
                        Enables the alternative treatment of the energy sources. For more  information, see .
                        """

                    class cavitation(TUIMenu):
                        """
                        Enters the cavitation heat mass transfer menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.schnerr_evap_coeff = self.__class__.schnerr_evap_coeff(service, version, mode, path + ["schnerr_evap_coeff"])
                            self.schnerr_cond_coeff = self.__class__.schnerr_cond_coeff(service, version, mode, path + ["schnerr_cond_coeff"])
                            self.max_vapor_pressure_ratio = self.__class__.max_vapor_pressure_ratio(service, version, mode, path + ["max_vapor_pressure_ratio"])
                            self.min_vapor_pressure = self.__class__.min_vapor_pressure(service, version, mode, path + ["min_vapor_pressure"])
                            self.display_clipped_pressure = self.__class__.display_clipped_pressure(service, version, mode, path + ["display_clipped_pressure"])
                            self.turbulent_diffusion = self.__class__.turbulent_diffusion(service, version, mode, path + ["turbulent_diffusion"])
                            super().__init__(service, version, mode, path)
                        class schnerr_evap_coeff(TUIMethod):
                            """
                            Sets the evaporation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 1.
                            """
                        class schnerr_cond_coeff(TUIMethod):
                            """
                            Sets the condensation coefficient for the Schnerr-Sauer model (  in ). The default and recommended value of 0.2.
                            """
                        class max_vapor_pressure_ratio(TUIMethod):
                            """
                            Sets the maximum limit on the vapor pressure after the turbulence and thermal correction. The default value is five times the vapor pressure, with consideration of turbulent and thermal effects for each cell and phase.
                            """
                        class min_vapor_pressure(TUIMethod):
                            """
                            Sets the minimum vapor pressure limit for the cavitation mass-transfer model. The default value is 1 Pa.
                            """
                        class display_clipped_pressure(TUIMethod):
                            """
                            Clipped pressure is just used for the properties evaluation. Mass Transfer Rate uses unclipped pressure.
                            """
                        class turbulent_diffusion(TUIMethod):
                            """
                            Enables/disables the turbulent diffusion treatment for a cavitating turbulent flow. See  for details.
                            """

                    class evaporation_condensation(TUIMenu):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.vof_from_min_limit = self.__class__.vof_from_min_limit(service, version, mode, path + ["vof_from_min_limit"])
                            self.vof_from_max_limit = self.__class__.vof_from_max_limit(service, version, mode, path + ["vof_from_max_limit"])
                            self.vof_to_min_limit = self.__class__.vof_to_min_limit(service, version, mode, path + ["vof_to_min_limit"])
                            self.vof_to_max_limit = self.__class__.vof_to_max_limit(service, version, mode, path + ["vof_to_max_limit"])
                            self.ia_norm_min_limit = self.__class__.ia_norm_min_limit(service, version, mode, path + ["ia_norm_min_limit"])
                            self.max_rel_humidity = self.__class__.max_rel_humidity(service, version, mode, path + ["max_rel_humidity"])
                            super().__init__(service, version, mode, path)
                        class vof_from_min_limit(TUIMethod):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                        class vof_from_max_limit(TUIMethod):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                        class vof_to_min_limit(TUIMethod):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                        class vof_to_max_limit(TUIMethod):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                        class ia_norm_min_limit(TUIMethod):
                            """
                            Minimum normalized area density below which mass transfer rate is set to zero.
                            """
                        class max_rel_humidity(TUIMethod):
                            """
                            Maximum value of relative humidity to limit condensation rate.
                            """

                    class boiling(TUIMenu):
                        """
                        Enters the menu for the advanced boiling options for the  semi-mechanistic boiling model.
                        """
                        def __init__(self, service, version, mode, path):
                            self.heat_flux_relaxation_factor = self.__class__.heat_flux_relaxation_factor(service, version, mode, path + ["heat_flux_relaxation_factor"])
                            self.show_expert_options = self.__class__.show_expert_options(service, version, mode, path + ["show_expert_options"])
                            self.two_resistance_boiling_framework = self.__class__.two_resistance_boiling_framework(service, version, mode, path + ["two_resistance_boiling_framework"])
                            super().__init__(service, version, mode, path)
                        class heat_flux_relaxation_factor(TUIMethod):
                            """
                            Sets the under-relaxation factor for boiling heat flux. See  for details.
                            """
                        class show_expert_options(TUIMethod):
                            """
                            Exposes the expert options for the semi-mechanistic boiling model. For more information about these options, see .
                            """
                        class two_resistance_boiling_framework(TUIMethod):
                            """
                            Enables/disables the two-resistance boiling framework to improve the robustness and accuracy of the solution of cases with multiple boiling mechanisms. For more information about this item, see .
                            """

                    class area_density(TUIMenu):
                        """
                        Enters the menu for the area density.
                        """
                        def __init__(self, service, version, mode, path):
                            self.vof_min_seeding = self.__class__.vof_min_seeding(service, version, mode, path + ["vof_min_seeding"])
                            self.ia_grad_sym = self.__class__.ia_grad_sym(service, version, mode, path + ["ia_grad_sym"])
                            super().__init__(service, version, mode, path)
                        class vof_min_seeding(TUIMethod):
                            """
                            Sets the minimum volume fraction for the area density and cavitation. This may be useful, for example, in cases when a species mass transfer model (such as the Symmetric model or Particle model) do not consider evaporation or condensation if the volume fraction of one of the phases is zero. The seeding allows for a phase change to occur in the fluid flow. The default value is 1e-6.
                            """
                        class ia_grad_sym(TUIMethod):
                            """
                            Enables/disables the interfacial area density Gradient-Symmetric model. For more information about this model, see .
                            """

                class advanced_stability_controls(TUIMenu):
                    """
                    Enters the menu for the stability controls for multiphase flows. For more information about the below option, see  and .
                    """
                    def __init__(self, service, version, mode, path):
                        self.pseudo_time = self.__class__.pseudo_time(service, version, mode, path + ["pseudo_time"])
                        self.p_v_coupling = self.__class__.p_v_coupling(service, version, mode, path + ["p_v_coupling"])
                        self.hybrid_nita = self.__class__.hybrid_nita(service, version, mode, path + ["hybrid_nita"])
                        self.equation_order = self.__class__.equation_order(service, version, mode, path + ["equation_order"])
                        self.anti_diffusion = self.__class__.anti_diffusion(service, version, mode, path + ["anti_diffusion"])
                        super().__init__(service, version, mode, path)

                    class pseudo_time(TUIMenu):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, service, version, mode, path):
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(service, version, mode, path + ["auto_dt_advanced_controls"])
                            self.smoothed_density_stabilization_method = self.__class__.smoothed_density_stabilization_method(service, version, mode, path + ["smoothed_density_stabilization_method"])
                            self.false_time_step_linearization = self.__class__.false_time_step_linearization(service, version, mode, path + ["false_time_step_linearization"])
                            super().__init__(service, version, mode, path)
                        class smoothed_density_stabilization_method(TUIMethod):
                            """
                            Set smoothed density stabilization method.
                            """
                        class false_time_step_linearization(TUIMethod):
                            """
                            Set false time-step linearization for added stability.
                            """

                        class auto_dt_advanced_controls(TUIMenu):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                                self.dt_init_limit = self.__class__.dt_init_limit(service, version, mode, path + ["dt_init_limit"])
                                self.dt_max = self.__class__.dt_max(service, version, mode, path + ["dt_max"])
                                self.dt_factor_min = self.__class__.dt_factor_min(service, version, mode, path + ["dt_factor_min"])
                                self.dt_factor_max = self.__class__.dt_factor_max(service, version, mode, path + ["dt_factor_max"])
                                self.max_velocity_ratio = self.__class__.max_velocity_ratio(service, version, mode, path + ["max_velocity_ratio"])
                                super().__init__(service, version, mode, path)
                            class enable(TUIMethod):
                                """
                                Enable advanced automatic time stepping for better stability.
                                """
                            class dt_init_limit(TUIMethod):
                                """
                                Set maximum value for pseudo time step size during first iteration.
                                """
                            class dt_max(TUIMethod):
                                """
                                Set maximum value for pseudo time step size.
                                """
                            class dt_factor_min(TUIMethod):
                                """
                                Set minimum limit for reduction in pseudo time step size.
                                """
                            class dt_factor_max(TUIMethod):
                                """
                                Set maximum limit for increase in pseudo time step size.
                                """
                            class max_velocity_ratio(TUIMethod):
                                """
                                Set velocity ratio to freeze the time step size for better solution stability.
                                """

                    class p_v_coupling(TUIMenu):
                        """
                        Enters the menu for the pressure-velocity coupling controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.coupled_vof = self.__class__.coupled_vof(service, version, mode, path + ["coupled_vof"])
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(service, version, mode, path + ["rhie_chow_flux"])
                            self.skewness_correction = self.__class__.skewness_correction(service, version, mode, path + ["skewness_correction"])
                            super().__init__(service, version, mode, path)

                        class coupled_vof(TUIMenu):
                            """
                            Enters the stability control menu for VOF cases that involve the Coupled pressure-velocity coupling scheme.
                            """
                            def __init__(self, service, version, mode, path):
                                self.buoyancy_force_linearization = self.__class__.buoyancy_force_linearization(service, version, mode, path + ["buoyancy_force_linearization"])
                                super().__init__(service, version, mode, path)
                            class buoyancy_force_linearization(TUIMethod):
                                """
                                Allows you to use the linearized buoyancy force and the  blended treatment for the buoyancy force.
                                """

                        class rhie_chow_flux(TUIMenu):
                            """
                            Enters the stability controls menu for the Rhie-Chow interpolation.
                            """
                            def __init__(self, service, version, mode, path):
                                self.low_order_rhie_chow = self.__class__.low_order_rhie_chow(service, version, mode, path + ["low_order_rhie_chow"])
                                super().__init__(service, version, mode, path)
                            class low_order_rhie_chow(TUIMethod):
                                """
                                Enables/disables the low-order velocity interpolation in  the flux calculation.
                                """

                        class skewness_correction(TUIMenu):
                            """
                            Enters the skewness correction menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.limit_pressure_correction_gradient = self.__class__.limit_pressure_correction_gradient(service, version, mode, path + ["limit_pressure_correction_gradient"])
                                super().__init__(service, version, mode, path)
                            class limit_pressure_correction_gradient(TUIMethod):
                                """
                                Enables/disables the limited pressure correction  gradient in skewness terms for the PISO, SIMPLEC, or  fractional step pressure-coupling schemes.
                                """

                    class hybrid_nita(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.instability_detector = self.__class__.instability_detector(service, version, mode, path + ["instability_detector"])
                            self.outer_iterations = self.__class__.outer_iterations(service, version, mode, path + ["outer_iterations"])
                            self.initial_outer_iterations = self.__class__.initial_outer_iterations(service, version, mode, path + ["initial_outer_iterations"])
                            super().__init__(service, version, mode, path)
                        class outer_iterations(TUIMethod):
                            """
                            Sets the number of outer iterations.
                            """
                        class initial_outer_iterations(TUIMethod):
                            """
                            Allows you to change the number of initial time-steps and the number of initial outer iterations to control solution stability.
                            """

                        class instability_detector(TUIMenu):
                            """
                            Enters the menu for the instability detector controls.
                            """
                            def __init__(self, service, version, mode, path):
                                self.enable_instability_detector = self.__class__.enable_instability_detector(service, version, mode, path + ["enable_instability_detector"])
                                self.set_cfl_limit = self.__class__.set_cfl_limit(service, version, mode, path + ["set_cfl_limit"])
                                self.set_cfl_type = self.__class__.set_cfl_type(service, version, mode, path + ["set_cfl_type"])
                                self.set_velocity_limit = self.__class__.set_velocity_limit(service, version, mode, path + ["set_velocity_limit"])
                                self.unstable_event_outer_iterations = self.__class__.unstable_event_outer_iterations(service, version, mode, path + ["unstable_event_outer_iterations"])
                                super().__init__(service, version, mode, path)
                            class enable_instability_detector(TUIMethod):
                                """
                                Enables/disables the instability detector to deal with  possible instability problems. Once this option is enabled,  additional instability detection options become  available.
                                """
                            class set_cfl_limit(TUIMethod):
                                """
                                Sets the Courant number limit for detecting unstable  events. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class set_cfl_type(TUIMethod):
                                """
                                Selects the CFL number type for detection of an unstable  event. This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class set_velocity_limit(TUIMethod):
                                """
                                Sets the velocity limit for detecting unstable events.  This command becomes available once the enable-instability-detector? text  option has been enabled.
                                """
                            class unstable_event_outer_iterations(TUIMethod):
                                """
                                Sets the number of outer iterations for an unstable  event.
                                """

                    class equation_order(TUIMenu):
                        """
                        Enters the equation order menu for homogeneous multiphase flow  models.
                        """
                        def __init__(self, service, version, mode, path):
                            self.solve_flow_last = self.__class__.solve_flow_last(service, version, mode, path + ["solve_flow_last"])
                            self.solve_exp_vof_at_end = self.__class__.solve_exp_vof_at_end(service, version, mode, path + ["solve_exp_vof_at_end"])
                            super().__init__(service, version, mode, path)
                        class solve_flow_last(TUIMethod):
                            """
                            When enabled, solves the flow equation at the end of the iteration. This improves the behavior at the start of new time-step if the solution does not converge properly.
                            """
                        class solve_exp_vof_at_end(TUIMethod):
                            """
                            Solve Explicit VOF at the end of time-step as an alternative.
                            """

                    class anti_diffusion(TUIMenu):
                        """
                        Enters the anti-diffusion menu. This item is available for VOF cases  with the Interfacial Anti-Diffusion option  enabled.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_dynamic_strength = self.__class__.enable_dynamic_strength(service, version, mode, path + ["enable_dynamic_strength"])
                            self.set_dynamic_strength_exponent = self.__class__.set_dynamic_strength_exponent(service, version, mode, path + ["set_dynamic_strength_exponent"])
                            self.set_maximum_dynamic_strength = self.__class__.set_maximum_dynamic_strength(service, version, mode, path + ["set_maximum_dynamic_strength"])
                            super().__init__(service, version, mode, path)
                        class enable_dynamic_strength(TUIMethod):
                            """
                            Enables dynamic strength to reduce compression in the direction tangential to the interface.
                            """
                        class set_dynamic_strength_exponent(TUIMethod):
                            """
                            Sets the cosine exponent in the dynamic strength treatment in ).
                            """
                        class set_maximum_dynamic_strength(TUIMethod):
                            """
                            Sets the maximum value of dynamic anti-diffusion strength in ).
                            """

                class default_controls(TUIMenu):
                    """
                    Enters the default controls menu. This menu is available only for multiphase flows.
                    """
                    def __init__(self, service, version, mode, path):
                        self.recommended_defaults_for_existing_cases = self.__class__.recommended_defaults_for_existing_cases(service, version, mode, path + ["recommended_defaults_for_existing_cases"])
                        self.revert_to_pre_r20_point_1_default_settings = self.__class__.revert_to_pre_r20_point_1_default_settings(service, version, mode, path + ["revert_to_pre_r20_point_1_default_settings"])
                        super().__init__(service, version, mode, path)
                    class recommended_defaults_for_existing_cases(TUIMethod):
                        """
                        Applies the multiphase defaults (version 2020 R1) to the loaded case  file.
                        """
                    class revert_to_pre_r20_point_1_default_settings(TUIMethod):
                        """
                        Revert to pre-R20.1 multiphase flow default settings.
                        """

                class face_pressure_controls(TUIMenu):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.face_pressure_options = self.__class__.face_pressure_options(service, version, mode, path + ["face_pressure_options"])
                        super().__init__(service, version, mode, path)
                    class face_pressure_options(TUIMethod):
                        """
                        Set face pressure options.
                        """

                class solution_stabilization(TUIMenu):
                    """
                    Enters the solution-stabilization numerics menu. This item is available only for the VOF model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(service, version, mode, path + ["additional_stabilization_controls"])
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(service, version, mode, path + ["velocity_limiting_treatment"])
                        self.execute_settings_optimization = self.__class__.execute_settings_optimization(service, version, mode, path + ["execute_settings_optimization"])
                        self.execute_advanced_stabilization = self.__class__.execute_advanced_stabilization(service, version, mode, path + ["execute_advanced_stabilization"])
                        self.execute_additional_stability_controls = self.__class__.execute_additional_stability_controls(service, version, mode, path + ["execute_additional_stability_controls"])
                        super().__init__(service, version, mode, path)
                    class execute_settings_optimization(TUIMethod):
                        """
                        Execute optimized settings for VOF.
                        """
                    class execute_advanced_stabilization(TUIMethod):
                        """
                        When enabled, modifies solver settings for improved solution  stability.
                        """
                    class execute_additional_stability_controls(TUIMethod):
                        """
                        When enabled, uses additional controls for improved solution  stability.
                        """

                    class additional_stabilization_controls(TUIMenu):
                        """
                        Enters the menu for additional advanced stability controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.blended_compressive_scheme = self.__class__.blended_compressive_scheme(service, version, mode, path + ["blended_compressive_scheme"])
                            self.pseudo_time_stabilization = self.__class__.pseudo_time_stabilization(service, version, mode, path + ["pseudo_time_stabilization"])
                            super().__init__(service, version, mode, path)
                        class blended_compressive_scheme(TUIMethod):
                            """
                            Enables/disables the blended compressive discretization scheme.
                            """
                        class pseudo_time_stabilization(TUIMethod):
                            """
                            Pseudo-Time Momentum stabilization and False Time Step Linearization methods for VOF.
                            """

                    class velocity_limiting_treatment(TUIMenu):
                        """
                        Enters the menu for the velocity-limiting-treatment.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable_velocity_limiting = self.__class__.enable_velocity_limiting(service, version, mode, path + ["enable_velocity_limiting"])
                            self.set_velocity_and_vof_cutoffs = self.__class__.set_velocity_and_vof_cutoffs(service, version, mode, path + ["set_velocity_and_vof_cutoffs"])
                            self.set_damping_strengths = self.__class__.set_damping_strengths(service, version, mode, path + ["set_damping_strengths"])
                            self.set_velocity_cutoff = self.__class__.set_velocity_cutoff(service, version, mode, path + ["set_velocity_cutoff"])
                            self.set_damping_strength = self.__class__.set_damping_strength(service, version, mode, path + ["set_damping_strength"])
                            self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                            super().__init__(service, version, mode, path)
                        class enable_velocity_limiting(TUIMethod):
                            """
                            Enables/disables the velocity limiting treatment.
                            """
                        class set_velocity_and_vof_cutoffs(TUIMethod):
                            """
                            Set phase based velocity limiting controls.
                            """
                        class set_damping_strengths(TUIMethod):
                            """
                            Set phase based damping strength.
                            """
                        class set_velocity_cutoff(TUIMethod):
                            """
                            Specifies the maximum velocity magnitude.
                            """
                        class set_damping_strength(TUIMethod):
                            """
                            Enter damping strength.
                            """
                        class verbosity(TUIMethod):
                            """
                            When enabled, the solver prints the number of velocity limited cells at each iteration.
                            """

            class open_channel_wave_options(TUIMenu):
                """
                Sets buffer layer height, verbosity, and open channel wave theory formulation.
                """
                def __init__(self, service, version, mode, path):
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    self.stokes_wave_variants = self.__class__.stokes_wave_variants(service, version, mode, path + ["stokes_wave_variants"])
                    self.set_buffer_layer_ht = self.__class__.set_buffer_layer_ht(service, version, mode, path + ["set_buffer_layer_ht"])
                    super().__init__(service, version, mode, path)
                class set_verbosity(TUIMethod):
                    """
                    Sets the open channel wave verbosity.
                    """
                class stokes_wave_variants(TUIMethod):
                    """
                    Specifies which open channel wave theory formulation Fluent uses.
                    """
                class set_buffer_layer_ht(TUIMethod):
                    """
                    Sets the buffer layer height.
                    """

            class high_order_term_relaxation(TUIMenu):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, service, version, mode, path):
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables High Order Term Relaxation.
                    """

                class options(TUIMenu):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.variables = self.__class__.variables(service, version, mode, path + ["variables"])
                        self.relaxation_factor = self.__class__.relaxation_factor(service, version, mode, path + ["relaxation_factor"])
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        super().__init__(service, version, mode, path)
                    class relaxation_factor(TUIMethod):
                        """
                        Sets the relaxation factor.
                        """
                    class expert(TUIMethod):
                        """
                        Enter high order relaxation option with respect to diffusion gradient.
                        """

                    class variables(TUIMenu):
                        """
                        Selects the variables.
                        """
                        def __init__(self, service, version, mode, path):
                            self.select = self.__class__.select(service, version, mode, path + ["select"])
                            super().__init__(service, version, mode, path)
                        class select(TUIMethod):
                            """
                            Select variables for high order term relaxation.
                            """

            class poor_mesh_numerics(TUIMenu):
                """
                Enters the poor mesh numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.solution_based_pmn = self.__class__.solution_based_pmn(service, version, mode, path + ["solution_based_pmn"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.cell_quality_based = self.__class__.cell_quality_based(service, version, mode, path + ["cell_quality_based"])
                    self.set_quality_threshold = self.__class__.set_quality_threshold(service, version, mode, path + ["set_quality_threshold"])
                    self.solution_and_quality_based = self.__class__.solution_and_quality_based(service, version, mode, path + ["solution_and_quality_based"])
                    self.gradient_quality_based = self.__class__.gradient_quality_based(service, version, mode, path + ["gradient_quality_based"])
                    self.orthogonality_enhancing_cell_centroids = self.__class__.orthogonality_enhancing_cell_centroids(service, version, mode, path + ["orthogonality_enhancing_cell_centroids"])
                    self.user_defined_on_register = self.__class__.user_defined_on_register(service, version, mode, path + ["user_defined_on_register"])
                    self.reset_poor_elements = self.__class__.reset_poor_elements(service, version, mode, path + ["reset_poor_elements"])
                    self.print_poor_elements_count = self.__class__.print_poor_elements_count(service, version, mode, path + ["print_poor_elements_count"])
                    self.enhanced_pmn = self.__class__.enhanced_pmn(service, version, mode, path + ["enhanced_pmn"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables the application of poor mesh numerics on cells (those with an orthogonal quality of 0, as well as those identified by other enabled criteria), and defines whether the local solution correction is 0th, 1st, or 2nd order.
                    """
                class cell_quality_based(TUIMethod):
                    """
                    Enables/disables the application of poor mesh numerics on cells with an orthogonal quality that is equal to or less than the threshold defined by the solve/set/poor-mesh-numerics/set-quality-threshold text command (which by default is set to 0.05).
                    """
                class set_quality_threshold(TUIMethod):
                    """
                    Sets the orthogonal quality threshold used for applying poor mesh numerics when the solve/set/poor-mesh-numerics/cell-quality-based? text command is enabled. By default, cells with an orthogonal quality of 0.05 or lower are corrected.
                    """
                class solution_and_quality_based(TUIMethod):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the solution and cell quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command, and at a specified frequency (of iterations or time steps). This criterion is only available with the pressure-based solver.
                    """
                class gradient_quality_based(TUIMethod):
                    """
                    Enables/disables the detection and treatment of poor cells using a criterion based on the cell gradient quality. Poor mesh numerics are applied when the criterion value is equal to or less than a threshold value defined as part of this text command. This criterion is only available with the pressure-based solver, and is not supported for cases that have periodic boundaries.
                    """
                class orthogonality_enhancing_cell_centroids(TUIMethod):
                    """
                    Enables/disables the relocation of select cell centroids, to improve the orthogonality metrics and solution stability. It is applied to cells when the criterion value is equal to or less than a threshold value defined as part of the text command. Note that the enhanced metrics are only apparent when reporting the quality in the solution mode of Fluent, and not in the meshing mode.
                    """
                class user_defined_on_register(TUIMethod):
                    """
                    Includes a register for the poor mesh numerics or not.
                    """
                class reset_poor_elements(TUIMethod):
                    """
                    Resets the list of poor cells included by the default, cell quality, user-defined, cell gradient quality, and solution and cell quality criteria.
                    """
                class print_poor_elements_count(TUIMethod):
                    """
                    Prints out a listing of the poor cells for each criterion: default, cell quality, and user-defined, and (if enabled) cell gradient quality and solution and cell quality.
                    """
                class enhanced_pmn(TUIMethod):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """

                class solution_based_pmn(TUIMenu):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.mark_primary_solution_limits = self.__class__.mark_primary_solution_limits(service, version, mode, path + ["mark_primary_solution_limits"])
                        self.mark_velocity_limit = self.__class__.mark_velocity_limit(service, version, mode, path + ["mark_velocity_limit"])
                        self.mark_cfl_limit = self.__class__.mark_cfl_limit(service, version, mode, path + ["mark_cfl_limit"])
                        self.mark_cfl_jump = self.__class__.mark_cfl_jump(service, version, mode, path + ["mark_cfl_jump"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable solution based treatment.
                        """
                    class mark_primary_solution_limits(TUIMethod):
                        """
                        Mark cells violating solution limits.
                        """
                    class mark_velocity_limit(TUIMethod):
                        """
                        Mark cells exceeding velocity limit.
                        """
                    class mark_cfl_limit(TUIMethod):
                        """
                        Mark cells exceeding cfl limit.
                        """
                    class mark_cfl_jump(TUIMethod):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """

            class amg_options(TUIMenu):
                """
                Enters the AMG options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.laplace_coarsening = self.__class__.laplace_coarsening(service, version, mode, path + ["laplace_coarsening"])
                    self.conservative_amg_coarsening = self.__class__.conservative_amg_coarsening(service, version, mode, path + ["conservative_amg_coarsening"])
                    self.aggressive_amg_coarsening = self.__class__.aggressive_amg_coarsening(service, version, mode, path + ["aggressive_amg_coarsening"])
                    self.amg_gpgpu_options = self.__class__.amg_gpgpu_options(service, version, mode, path + ["amg_gpgpu_options"])
                    super().__init__(service, version, mode, path)
                class laplace_coarsening(TUIMethod):
                    """
                    Enables / disables Laplace coarsening for scalar and/or coupled equations.
                    """
                class conservative_amg_coarsening(TUIMethod):
                    """
                    Enables / disables the use of conservative coarsening techniques for scalar and/or coupled equations that can improve parallel performance and/or convergence for some difficult cases.
                    """
                class aggressive_amg_coarsening(TUIMethod):
                    """
                    Enables / disables the use of a version of the AMG solver that is optimized for high coarsening rates. This option is recommended if the AMG solver diverges with the default settings.
                    """
                class amg_gpgpu_options(TUIMethod):
                    """
                    Set GPGPU AMG solver options.
                    """

            class warped_face_gradient_correction(TUIMenu):
                """
                Enters the warped-face gradient correction menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.turbulence_options = self.__class__.turbulence_options(service, version, mode, path + ["turbulence_options"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables gradient enhancement computations and specifies whether Fluent uses fast or memory saving mode.
                    """
                class turbulence_options(TUIMethod):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """

            class fast_transient_settings(TUIMenu):
                """
                Enters the fast transient settings menu. This menu is only available for transient cases that use the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self.rk2 = self.__class__.rk2(service, version, mode, path + ["rk2"])
                    super().__init__(service, version, mode, path)
                class rk2(TUIMethod):
                    """
                    Allows you to enable the use of a two-stage Runge-Kutta scheme for time integration, or revert to the default multi-stage Runge-Kutta scheme. This text command is only available for transient cases that use the density-based explicit formulation.
                    """

            class divergence_prevention(TUIMenu):
                """
                Enters the divergence prevention menu. This menu is only available for the density-based solver.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables a divergence prevention option so that Fluent applies under-relaxation to the variables in select cells where the temperature and/or pressure values are approaching the minimum and/or maximum limits.
                    """

            class advanced(TUIMenu):
                """
                Enters the advanced settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(service, version, mode, path + ["non_reflecting_boundary_treatment"])
                    self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(service, version, mode, path + ["secondary_gradient_limiting"])
                    self.turbo_solver_options = self.__class__.turbo_solver_options(service, version, mode, path + ["turbo_solver_options"])
                    self.energy_numerical_noise_filter = self.__class__.energy_numerical_noise_filter(service, version, mode, path + ["energy_numerical_noise_filter"])
                    self.linearized_mass_transfer_udf = self.__class__.linearized_mass_transfer_udf(service, version, mode, path + ["linearized_mass_transfer_udf"])
                    self.singhal_et_al_cavitation_model = self.__class__.singhal_et_al_cavitation_model(service, version, mode, path + ["singhal_et_al_cavitation_model"])
                    self.alternate_wall_temp_formulation = self.__class__.alternate_wall_temp_formulation(service, version, mode, path + ["alternate_wall_temp_formulation"])
                    self.retain_cell_residuals = self.__class__.retain_cell_residuals(service, version, mode, path + ["retain_cell_residuals"])
                    self.retain_temporary_solver_mem = self.__class__.retain_temporary_solver_mem(service, version, mode, path + ["retain_temporary_solver_mem"])
                    self.show_all_discretization_schemes = self.__class__.show_all_discretization_schemes(service, version, mode, path + ["show_all_discretization_schemes"])
                    self.explicit_under_relaxation_value = self.__class__.explicit_under_relaxation_value(service, version, mode, path + ["explicit_under_relaxation_value"])
                    self.correction_form = self.__class__.correction_form(service, version, mode, path + ["correction_form"])
                    self.energy_reconstruction_gradient_limiting = self.__class__.energy_reconstruction_gradient_limiting(service, version, mode, path + ["energy_reconstruction_gradient_limiting"])
                    self.bcd_boundedness = self.__class__.bcd_boundedness(service, version, mode, path + ["bcd_boundedness"])
                    self.bcd_weights_freeze = self.__class__.bcd_weights_freeze(service, version, mode, path + ["bcd_weights_freeze"])
                    self.anisotropic_heat_flux = self.__class__.anisotropic_heat_flux(service, version, mode, path + ["anisotropic_heat_flux"])
                    self.skewness_correction_enhanced = self.__class__.skewness_correction_enhanced(service, version, mode, path + ["skewness_correction_enhanced"])
                    super().__init__(service, version, mode, path)
                class energy_numerical_noise_filter(TUIMethod):
                    """
                    Enables/disables a filter to eliminate non-physical numerical noise in the energy field. Numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present. Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive. This text command is only available with the pressure-based solver.
                    """
                class linearized_mass_transfer_udf(TUIMethod):
                    """
                    Enables/disables the use of a linearized mass transfer user-defined function (that is, the DEFINE_LINEARIZED_MASS_TRANSFER macro), as opposed to a mass transfer user-defined function (that is, the DEFINE_MASS_TRANSFER macro).
                    """
                class singhal_et_al_cavitation_model(TUIMethod):
                    """
                    Enables/disables the availability of the Singhal et al. cavitation model option, which can then be enabled in the Multiphase Model dialog box or by using the following text command: define/phases/set-domain-properties/interaction-domain/heat-mass-reaction/cavitation/cavitation?.
                    """
                class alternate_wall_temp_formulation(TUIMethod):
                    """
                    Enables/disables an alternate formulation for wall temperatures.
                    """
                class retain_cell_residuals(TUIMethod):
                    """
                    Enables/disables the retention of cell residuals for postprocessing.
                    """
                class retain_temporary_solver_mem(TUIMethod):
                    """
                    Enables/disables the retention of temporary solver memory, which retains gradient data and makes some advanced options available for postprocessing.
                    """
                class show_all_discretization_schemes(TUIMethod):
                    """
                    Enables/disables the availability of all applicable discretization schemes.
                    """
                class explicit_under_relaxation_value(TUIMethod):
                    """
                    Explicit under-relaxation value.
                    """
                class correction_form(TUIMethod):
                    """
                    S.
                    """
                class energy_reconstruction_gradient_limiting(TUIMethod):
                    """
                    Enable limiting of reconstruction gradient for the energy equation.
                    """
                class bcd_boundedness(TUIMethod):
                    """
                    Specifies the BCD scheme parameter, which controls the boundedness strength of the BCD scheme in the pressure-based solver, as described in .
                    """
                class bcd_weights_freeze(TUIMethod):
                    """
                    Enables/disables freezing of weighting coefficients of the central differencing and the upwind components of the BCD scheme. This dialog command requires the iteration number, after which the BCD scheme weights are to be frozen at each timestep. Freezing the BCD weighting coefficients may help to improve convergence of the timestep iterations as described in .
                    """
                class anisotropic_heat_flux(TUIMethod):
                    """
                    Select the heat flux calculation methods.
                    """
                class skewness_correction_enhanced(TUIMethod):
                    """
                    Enable enhanced skewness correction scheme.
                    """

                class non_reflecting_boundary_treatment(TUIMenu):
                    """
                    Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                        self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                        self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                        super().__init__(service, version, mode, path)
                    class pressure_inlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                    class pressure_outlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                    class velocity_inlet(TUIMethod):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """

                class secondary_gradient_limiting(TUIMenu):
                    """
                    Enters the secondary gradient limiting menu. This menu is only available when the define/models/solver/pressure-based text command is enabled.
                    """
                    def __init__(self, service, version, mode, path):
                        self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                        self.uds = self.__class__.uds(service, version, mode, path + ["uds"])
                        self.mesh_quality_limits = self.__class__.mesh_quality_limits(service, version, mode, path + ["mesh_quality_limits"])
                        super().__init__(service, version, mode, path)
                    class energy(TUIMethod):
                        """
                        Enables/disables secondary gradient limiting for the energy  calculations on coupled two-sided walls. This limiting can help prevent  divergence when the cells on such walls have poor orthogonality.
                        """
                    class uds(TUIMethod):
                        """
                        Enables/disables secondary gradient limiting for the user-defined  scalar (UDS) calculations on coupled two-sided walls. This limiting can  help prevent divergence when the cells on such walls have poor  orthogonality.
                        """
                    class mesh_quality_limits(TUIMethod):
                        """
                        Defines the mesh quality limits used when applying secondary  gradient limiting to faces on coupled two-sided walls. Shifting this  range closer to 1 will decrease the risk of divergence, but at the cost  of accuracy.
                        """

                class turbo_solver_options(TUIMenu):
                    """
                    Enter turbo expert solver options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.continuity_relaxation_at_walls = self.__class__.continuity_relaxation_at_walls(service, version, mode, path + ["continuity_relaxation_at_walls"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable/disable turbomachinery expert solver options.
                        """
                    class continuity_relaxation_at_walls(TUIMethod):
                        """
                        Enable and specify options for continuity relaxation at wall boundaries.
                        """

            class high_speed_numerics(TUIMenu):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.visualize_pressure_discontinuity_sensor = self.__class__.visualize_pressure_discontinuity_sensor(service, version, mode, path + ["visualize_pressure_discontinuity_sensor"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enables/disables High Speed Numerics.
                    """
                class expert(TUIMethod):
                    """
                    Sets the level of stabilization used to achieve fast convergence. Enter a number 0-5 corresponding to the Mach number range that best characterizes the flow.
                    """
                class visualize_pressure_discontinuity_sensor(TUIMethod):
                    """
                    Makes available the Pressure Discontinuity Sensor which is a binary identifier equal to 1 if a cell is in proximity of a pressure discontinuity.
                    """

            class previous_defaults(TUIMenu):
                """
                Provides text commands that allow you to undo enhancements to the default solver behavior.
                """
                def __init__(self, service, version, mode, path):
                    self.undo_r19_point_0_default_changes = self.__class__.undo_r19_point_0_default_changes(service, version, mode, path + ["undo_r19_point_0_default_changes"])
                    self.undo_2019r1_default_changes = self.__class__.undo_2019r1_default_changes(service, version, mode, path + ["undo_2019r1_default_changes"])
                    self.undo_2019r3_default_changes = self.__class__.undo_2019r3_default_changes(service, version, mode, path + ["undo_2019r3_default_changes"])
                    self.undo_2021r1_default_changes = self.__class__.undo_2021r1_default_changes(service, version, mode, path + ["undo_2021r1_default_changes"])
                    self.undo_2021r2_default_changes = self.__class__.undo_2021r2_default_changes(service, version, mode, path + ["undo_2021r2_default_changes"])
                    self.undo_2022r1_default_changes = self.__class__.undo_2022r1_default_changes(service, version, mode, path + ["undo_2022r1_default_changes"])
                    super().__init__(service, version, mode, path)
                class undo_r19_point_0_default_changes(TUIMethod):
                    """
                    Undo default changes introduced in R19.0.
                    """
                class undo_2019r1_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2019 R1 of ANSYS Fluent, including:.
                    """
                class undo_2019r3_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2019 R3 of ANSYS Fluent, including:.
                    """
                class undo_2021r1_default_changes(TUIMethod):
                    """
                    Allows you to undo enhancements introduced in version 2021 R1 of ANSYS Fluent, including:.
                    """
                class undo_2021r2_default_changes(TUIMethod):
                    """
                    Allows you to undo the following enhancements introduced in version 2021 R2 of ANSYS Fluent:.
                    """
                class undo_2022r1_default_changes(TUIMethod):
                    """
                    Allows you to undo the following enhancements introduced in version 2022 R1 of ANSYS Fluent:.
                    """

            class overset(TUIMenu):
                """
                Specifies overset meshing solver options.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.high_order_pressure = self.__class__.high_order_pressure(service, version, mode, path + ["high_order_pressure"])
                    self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                    self.orphan_cell_treatment = self.__class__.orphan_cell_treatment(service, version, mode, path + ["orphan_cell_treatment"])
                    super().__init__(service, version, mode, path)
                class high_order_pressure(TUIMethod):
                    """
                    Uses the pressure gradient of the donor cell in the interpolation of pressure for its receptor cell.
                    """
                class interpolation_method(TUIMethod):
                    """
                    Selects the interpolation method for overset interfaces. Note that the least squares method is recommended for sliding mesh cases.
                    """
                class orphan_cell_treatment(TUIMethod):
                    """
                    Enables/disables a numerical treatment that attempts to assign reasonable data values to orphan cells.
                    """

                class expert(TUIMenu):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mass_flux_correction_method = self.__class__.mass_flux_correction_method(service, version, mode, path + ["mass_flux_correction_method"])
                        self.hybrid_mode_selection = self.__class__.hybrid_mode_selection(service, version, mode, path + ["hybrid_mode_selection"])
                        super().__init__(service, version, mode, path)
                    class mass_flux_correction_method(TUIMethod):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """
                    class hybrid_mode_selection(TUIMethod):
                        """
                        Mode for hybrid interpolation.
                        """

            class acoustics_wave_equation_controls(TUIMenu):
                """
                Enters the menu to specify parameters of the acoustics wave equation solver.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.relative_convergence_criterion = self.__class__.relative_convergence_criterion(service, version, mode, path + ["relative_convergence_criterion"])
                    self.max_iterations_per_timestep = self.__class__.max_iterations_per_timestep(service, version, mode, path + ["max_iterations_per_timestep"])
                    super().__init__(service, version, mode, path)
                class relative_convergence_criterion(TUIMethod):
                    """
                    Specify convergence tolerance for the timestep iterations
                    as the target residual reduction factor.
                    """
                class max_iterations_per_timestep(TUIMethod):
                    """
                    Specify maximum number of iterations per timestep.
                    """

                class expert(TUIMenu):
                    """
                    Enters the menu to specify the expert parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.under_relaxation_factor = self.__class__.under_relaxation_factor(service, version, mode, path + ["under_relaxation_factor"])
                        self.explicit_relaxation_factor = self.__class__.explicit_relaxation_factor(service, version, mode, path + ["explicit_relaxation_factor"])
                        super().__init__(service, version, mode, path)
                    class under_relaxation_factor(TUIMethod):
                        """
                        Specifies the implicit under-relaxation factor. Should be used only  with bad meshes, when the AMG linear solver does not converge.
                        """
                    class explicit_relaxation_factor(TUIMethod):
                        """
                        Specifies the explicit relaxation factor. Should be used only with  bad meshes, when iterations do not converge.
                        """

            class p_v_controls_advanced(TUIMenu):
                """
                Set advanced pressure-velocity coupling controls.
                """
                def __init__(self, service, version, mode, path):
                    self.pp_face_gradient_linearization = self.__class__.pp_face_gradient_linearization(service, version, mode, path + ["pp_face_gradient_linearization"])
                    self.pp_face_interpolation = self.__class__.pp_face_interpolation(service, version, mode, path + ["pp_face_interpolation"])
                    self.pp_node_based_grad = self.__class__.pp_node_based_grad(service, version, mode, path + ["pp_node_based_grad"])
                    super().__init__(service, version, mode, path)
                class pp_face_gradient_linearization(TUIMethod):
                    """
                    End of pp-face-gradient-linearization.
                    """
                class pp_face_interpolation(TUIMethod):
                    """
                    End of pp-face-interpolation.
                    """
                class pp_node_based_grad(TUIMethod):
                    """
                    End of pp-node-based-grad.
                    """

        class execute_commands(TUIMenu):
            """
            Enters the execute commands menu.
            """
            def __init__(self, service, version, mode, path):
                self.add_edit = self.__class__.add_edit(service, version, mode, path + ["add_edit"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.export = self.__class__.export(service, version, mode, path + ["export"])
                self.import_ = self.__class__.import_(service, version, mode, path + ["import"])
                super().__init__(service, version, mode, path)
            class add_edit(TUIMethod):
                """
                Adds or edits execute commands.
                """
            class enable(TUIMethod):
                """
                Enables an execute command.
                """
            class disable(TUIMethod):
                """
                Disables an execute command.
                """
            class copy(TUIMethod):
                """
                Copy an execute-command.
                """
            class delete(TUIMethod):
                """
                Delete an execute-command.
                """
            class export(TUIMethod):
                """
                Export execute-commands to a TSV file.
                """
            class import_(TUIMethod):
                """
                Import execute-commands from a TSV file.
                """

    class setup(TUIMenu):
        """
        Enter setup menu.
        """
        def __init__(self, service, version, mode, path):
            self.boundary_conditions = self.__class__.boundary_conditions(service, version, mode, path + ["boundary_conditions"])
            self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
            self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
            self.gap_model = self.__class__.gap_model(service, version, mode, path + ["gap_model"])
            self.materials = self.__class__.materials(service, version, mode, path + ["materials"])
            self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
            self.mixing_planes = self.__class__.mixing_planes(service, version, mode, path + ["mixing_planes"])
            self.models = self.__class__.models(service, version, mode, path + ["models"])
            self.named_expressions = self.__class__.named_expressions(service, version, mode, path + ["named_expressions"])
            self.operating_conditions = self.__class__.operating_conditions(service, version, mode, path + ["operating_conditions"])
            self.overset_interfaces = self.__class__.overset_interfaces(service, version, mode, path + ["overset_interfaces"])
            self.reference_frames = self.__class__.reference_frames(service, version, mode, path + ["reference_frames"])
            self.reference_values = self.__class__.reference_values(service, version, mode, path + ["reference_values"])
            self.turbo_model = self.__class__.turbo_model(service, version, mode, path + ["turbo_model"])
            super().__init__(service, version, mode, path)

        class boundary_conditions(TUIMenu):
            """
            Enter the boudary conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.bc_settings = self.__class__.bc_settings(service, version, mode, path + ["bc_settings"])
                self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                self.modify_zones = self.__class__.modify_zones(service, version, mode, path + ["modify_zones"])
                self.profiles = self.__class__.profiles(service, version, mode, path + ["profiles"])
                self.query = self.__class__.query(service, version, mode, path + ["query"])
                self.rename_zone = self.__class__.rename_zone(service, version, mode, path + ["rename_zone"])
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                self.copy_bc = self.__class__.copy_bc(service, version, mode, path + ["copy_bc"])
                self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                self.network = self.__class__.network(service, version, mode, path + ["network"])
                self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                super().__init__(service, version, mode, path)
            class axis(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class copy_bc(TUIMethod):
                """
                Copy boundary conditions to another zone.
                """
            class degassing(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class exhaust_fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class fluid(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class geometry(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class inlet_vent(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class intake_fan(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class interface(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class interior(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class list_zones(TUIMethod):
                """
                List zone IDs, types, kinds, and names.
                """
            class mass_flow_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class mass_flow_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class network(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class network_end(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class outflow(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class outlet_vent(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class overset(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class periodic(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class porous_jump(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_far_field(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class pressure_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class radiator(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class rans_les_interface(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class recirculation_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class recirculation_outlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class shadow(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class solid(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class symmetry(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class velocity_inlet(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class wall(TUIMethod):
                """
                Set boundary conditions for a zone of this type.
                """
            class zone_name(TUIMethod):
                """
                Give a zone a new name.
                """
            class zone_type(TUIMethod):
                """
                Set a zone's type.
                """

            class bc_settings(TUIMenu):
                """
                .
                """
                def __init__(self, service, version, mode, path):
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.mass_flow = self.__class__.mass_flow(service, version, mode, path + ["mass_flow"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    super().__init__(service, version, mode, path)
                class mass_flow(TUIMethod):
                    """
                    Select method for setting the mass flow rate.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Select pressure specification method on pressure-outlet boundaries.
                    """

                class pressure_far_field(TUIMenu):
                    """
                    Select presure-far-field boundary-condition options.
                    """
                    def __init__(self, service, version, mode, path):
                        self.riemann_invariants_tangency_correction = self.__class__.riemann_invariants_tangency_correction(service, version, mode, path + ["riemann_invariants_tangency_correction"])
                        self.type = self.__class__.type(service, version, mode, path + ["type?"])
                        super().__init__(service, version, mode, path)
                    class riemann_invariants_tangency_correction(TUIMethod):
                        """
                        Apply a local correction where the flow is tangential to the boundary.
                        """
                    class type(TUIMethod):
                        """
                        Choose pressure-far-field boundary-condition type.
                        """

            class expert(TUIMenu):
                """
                Enter expert bc menu.
                """
                def __init__(self, service, version, mode, path):
                    self.impedance_data_fitting = self.__class__.impedance_data_fitting(service, version, mode, path + ["impedance_data_fitting"])
                    self.non_reflecting_bc = self.__class__.non_reflecting_bc(service, version, mode, path + ["non_reflecting_bc"])
                    self.perforated_walls = self.__class__.perforated_walls(service, version, mode, path + ["perforated_walls"])
                    self.periodic_conditions = self.__class__.periodic_conditions(service, version, mode, path + ["periodic_conditions"])
                    self.non_overlapping_zone_name = self.__class__.non_overlapping_zone_name(service, version, mode, path + ["non_overlapping_zone_name"])
                    self.openchannel_threads = self.__class__.openchannel_threads(service, version, mode, path + ["openchannel_threads"])
                    self.open_channel_wave_settings = self.__class__.open_channel_wave_settings(service, version, mode, path + ["open_channel_wave_settings"])
                    self.target_mass_flow_rate_settings = self.__class__.target_mass_flow_rate_settings(service, version, mode, path + ["target_mass_flow_rate_settings"])
                    super().__init__(service, version, mode, path)
                class non_overlapping_zone_name(TUIMethod):
                    """
                    Get non-overlapping zone name from the associated interface zone.
                    """
                class openchannel_threads(TUIMethod):
                    """
                    List open channel group IDs, names, types, and variables.
                    """
                class open_channel_wave_settings(TUIMethod):
                    """
                    Open channel wave input analysis.
                    """
                class target_mass_flow_rate_settings(TUIMethod):
                    """
                    Enter the targeted mass flow rate setting menu.
                    """

                class impedance_data_fitting(TUIMenu):
                    """
                    Enter the impedance data fitting menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.impedance_data = self.__class__.impedance_data(service, version, mode, path + ["impedance_data"])
                        self.reflection_data = self.__class__.reflection_data(service, version, mode, path + ["reflection_data"])
                        self.absorption_data = self.__class__.absorption_data(service, version, mode, path + ["absorption_data"])
                        self.iterations = self.__class__.iterations(service, version, mode, path + ["iterations"])
                        self.convergence_tolerance = self.__class__.convergence_tolerance(service, version, mode, path + ["convergence_tolerance"])
                        self.residue_tolerance = self.__class__.residue_tolerance(service, version, mode, path + ["residue_tolerance"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.import_parameters = self.__class__.import_parameters(service, version, mode, path + ["import_parameters"])
                        super().__init__(service, version, mode, path)
                    class impedance_data(TUIMethod):
                        """
                        Read experimental impedance data and output impedance parameters for a boundary condition.
                        """
                    class reflection_data(TUIMethod):
                        """
                        Read experimental reflection coefficient data and output impedance parameters for a boundary condition.
                        """
                    class absorption_data(TUIMethod):
                        """
                        Read experimental absorption coefficient data and output impedance parameters for a boundary condition.
                        """
                    class iterations(TUIMethod):
                        """
                        Set the number of iterations for the fitting algorithm.
                        """
                    class convergence_tolerance(TUIMethod):
                        """
                        Set the convergence tolerance for the fitting algorithm.
                        """
                    class residue_tolerance(TUIMethod):
                        """
                        Set the residue tolerance for the fitting algorithm.
                        """
                    class verbosity(TUIMethod):
                        """
                        Set verbosity level [0, 1] for fitting algorithm.
                        """
                    class import_parameters(TUIMethod):
                        """
                        Import impedance parameters into boundary condition.
                        """

                class non_reflecting_bc(TUIMenu):
                    """
                    Enter the non-reflecting b.c. menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.general_nrbc = self.__class__.general_nrbc(service, version, mode, path + ["general_nrbc"])
                        self.turbo_specific_nrbc = self.__class__.turbo_specific_nrbc(service, version, mode, path + ["turbo_specific_nrbc"])
                        super().__init__(service, version, mode, path)

                    class general_nrbc(TUIMenu):
                        """
                        Enter the menu for setting general non-reflecting boundary conditions.
                        """
                        def __init__(self, service, version, mode, path):
                            self.set = self.__class__.set(service, version, mode, path + ["set"])
                            super().__init__(service, version, mode, path)

                        class set(TUIMenu):
                            """
                            Enter the general non-reflecting b.c. menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.sigma = self.__class__.sigma(service, version, mode, path + ["sigma"])
                                self.sigma2 = self.__class__.sigma2(service, version, mode, path + ["sigma2"])
                                self.relax = self.__class__.relax(service, version, mode, path + ["relax"])
                                self.tangential_source = self.__class__.tangential_source(service, version, mode, path + ["tangential_source"])
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class sigma(TUIMethod):
                                """
                                Set nrbc sigma factor (default value 0.15).
                                """
                            class sigma2(TUIMethod):
                                """
                                Set nrbc sigma2 factor (default value 5.0).
                                """
                            class relax(TUIMethod):
                                """
                                Set NRBC relaxation factor (default value 0.5).
                                """
                            class tangential_source(TUIMethod):
                                """
                                Include or not NRBC tangential source (default value #t).
                                """
                            class verbosity(TUIMethod):
                                """
                                Print boundary equations convergence info.
                                """

                    class turbo_specific_nrbc(TUIMenu):
                        """
                        Enter the turbo-specific n.r.b.c. menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.set = self.__class__.set(service, version, mode, path + ["set"])
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
                            self.show_status = self.__class__.show_status(service, version, mode, path + ["show_status"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            Enable/disable turbo-specific non-reflecting b.c.'s.
                            """
                        class initialize(TUIMethod):
                            """
                            Initialize turbo-specific non-reflecting b.c.'s.
                            """
                        class show_status(TUIMethod):
                            """
                            Show current status of turbo-specific non-reflecting b.c.'s.
                            """

                        class set(TUIMenu):
                            """
                            Enter the set menu for turbo-specific non-reflecting b.c. parameters.
                            """
                            def __init__(self, service, version, mode, path):
                                self.discretization = self.__class__.discretization(service, version, mode, path + ["discretization"])
                                self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                                super().__init__(service, version, mode, path)
                            class discretization(TUIMethod):
                                """
                                Enable use of higher-order reconstruction at boundaries if available.
                                """
                            class under_relaxation(TUIMethod):
                                """
                                Set turbo-specific non-reflecting b.c. under-relaxation factor.
                                specify < 0 => use P/a_ave
                                specify = 0 => use 1/N
                                specify > 0 => use specified.
                                """
                            class verbosity(TUIMethod):
                                """
                                Set turbo-specific non-reflecting b.c. verbosity level.
                                0 : silent
                                1 : basic info. default
                                2 : detailed info. for debugging
                                .
                                """

                class perforated_walls(TUIMenu):
                    """
                    Enter the perforated walls setting menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.read_input_file = self.__class__.read_input_file(service, version, mode, path + ["read_input_file"])
                        self.model_setup = self.__class__.model_setup(service, version, mode, path + ["model_setup"])
                        super().__init__(service, version, mode, path)
                    class read_input_file(TUIMethod):
                        """
                        Read an input file.
                        """
                    class model_setup(TUIMethod):
                        """
                        Set up perforated walls.
                        """

                class periodic_conditions(TUIMenu):
                    """
                    Enter the periodic conditions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.massflow_rate_specification = self.__class__.massflow_rate_specification(service, version, mode, path + ["massflow_rate_specification"])
                        self.pressure_gradient_specification = self.__class__.pressure_gradient_specification(service, version, mode, path + ["pressure_gradient_specification"])
                        super().__init__(service, version, mode, path)
                    class massflow_rate_specification(TUIMethod):
                        """
                        Enable/disable specification of mass flow rate at the periodic boundary.
                        """
                    class pressure_gradient_specification(TUIMethod):
                        """
                        Enable/disable specification of pressure gradient at the periodic boundary.
                        """

            class modify_zones(TUIMenu):
                """
                Enter the modify zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self.activate_cell_zone = self.__class__.activate_cell_zone(service, version, mode, path + ["activate_cell_zone"])
                    self.append_mesh = self.__class__.append_mesh(service, version, mode, path + ["append_mesh"])
                    self.append_mesh_data = self.__class__.append_mesh_data(service, version, mode, path + ["append_mesh_data"])
                    self.copy_move_cell_zone = self.__class__.copy_move_cell_zone(service, version, mode, path + ["copy_move_cell_zone"])
                    self.create_all_shell_threads = self.__class__.create_all_shell_threads(service, version, mode, path + ["create_all_shell_threads"])
                    self.deactivate_cell_zone = self.__class__.deactivate_cell_zone(service, version, mode, path + ["deactivate_cell_zone"])
                    self.recreate_all_shells = self.__class__.recreate_all_shells(service, version, mode, path + ["recreate_all_shells"])
                    self.delete_all_shells = self.__class__.delete_all_shells(service, version, mode, path + ["delete_all_shells"])
                    self.delete_cell_zone = self.__class__.delete_cell_zone(service, version, mode, path + ["delete_cell_zone"])
                    self.extrude_face_zone_delta = self.__class__.extrude_face_zone_delta(service, version, mode, path + ["extrude_face_zone_delta"])
                    self.extrude_face_zone_para = self.__class__.extrude_face_zone_para(service, version, mode, path + ["extrude_face_zone_para"])
                    self.fuse_face_zones = self.__class__.fuse_face_zones(service, version, mode, path + ["fuse_face_zones"])
                    self.list_zones = self.__class__.list_zones(service, version, mode, path + ["list_zones"])
                    self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                    self.create_periodic_interface = self.__class__.create_periodic_interface(service, version, mode, path + ["create_periodic_interface"])
                    self.scale_zone = self.__class__.scale_zone(service, version, mode, path + ["scale_zone"])
                    self.rotate_zone = self.__class__.rotate_zone(service, version, mode, path + ["rotate_zone"])
                    self.translate_zone = self.__class__.translate_zone(service, version, mode, path + ["translate_zone"])
                    self.matching_tolerance = self.__class__.matching_tolerance(service, version, mode, path + ["matching_tolerance"])
                    self.merge_zones = self.__class__.merge_zones(service, version, mode, path + ["merge_zones"])
                    self.mrf_to_sliding_mesh = self.__class__.mrf_to_sliding_mesh(service, version, mode, path + ["mrf_to_sliding_mesh"])
                    self.convert_all_solid_mrf_to_solid_motion = self.__class__.convert_all_solid_mrf_to_solid_motion(service, version, mode, path + ["convert_all_solid_mrf_to_solid_motion"])
                    self.orient_face_zone = self.__class__.orient_face_zone(service, version, mode, path + ["orient_face_zone"])
                    self.replace_zone = self.__class__.replace_zone(service, version, mode, path + ["replace_zone"])
                    self.sep_cell_zone_mark = self.__class__.sep_cell_zone_mark(service, version, mode, path + ["sep_cell_zone_mark"])
                    self.sep_cell_zone_region = self.__class__.sep_cell_zone_region(service, version, mode, path + ["sep_cell_zone_region"])
                    self.sep_face_zone_angle = self.__class__.sep_face_zone_angle(service, version, mode, path + ["sep_face_zone_angle"])
                    self.sep_face_zone_face = self.__class__.sep_face_zone_face(service, version, mode, path + ["sep_face_zone_face"])
                    self.sep_face_zone_mark = self.__class__.sep_face_zone_mark(service, version, mode, path + ["sep_face_zone_mark"])
                    self.sep_face_zone_region = self.__class__.sep_face_zone_region(service, version, mode, path + ["sep_face_zone_region"])
                    self.slit_periodic = self.__class__.slit_periodic(service, version, mode, path + ["slit_periodic"])
                    self.slit_face_zone = self.__class__.slit_face_zone(service, version, mode, path + ["slit_face_zone"])
                    self.slit_interior_between_diff_solids = self.__class__.slit_interior_between_diff_solids(service, version, mode, path + ["slit_interior_between_diff_solids"])
                    self.zone_name = self.__class__.zone_name(service, version, mode, path + ["zone_name"])
                    self.zone_type = self.__class__.zone_type(service, version, mode, path + ["zone_type"])
                    self.copy_mrf_to_mesh_motion = self.__class__.copy_mrf_to_mesh_motion(service, version, mode, path + ["copy_mrf_to_mesh_motion"])
                    self.copy_mesh_to_mrf_motion = self.__class__.copy_mesh_to_mrf_motion(service, version, mode, path + ["copy_mesh_to_mrf_motion"])
                    self.change_zone_state = self.__class__.change_zone_state(service, version, mode, path + ["change_zone_state"])
                    self.change_zone_phase = self.__class__.change_zone_phase(service, version, mode, path + ["change_zone_phase"])
                    super().__init__(service, version, mode, path)
                class activate_cell_zone(TUIMethod):
                    """
                    Activate a cell thread.
                    """
                class append_mesh(TUIMethod):
                    """
                    Append new mesh.
                    """
                class append_mesh_data(TUIMethod):
                    """
                    Append new mesh with data.
                    """
                class copy_move_cell_zone(TUIMethod):
                    """
                    Copy and translate or rotate a cell zone.
                    """
                class create_all_shell_threads(TUIMethod):
                    """
                    Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                    """
                class deactivate_cell_zone(TUIMethod):
                    """
                    Deactivate cell thread.
                    """
                class recreate_all_shells(TUIMethod):
                    """
                    Create shell on all the walls where which were deleted using the command delete-all-shells.
                    """
                class delete_all_shells(TUIMethod):
                    """
                    Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                    """
                class delete_cell_zone(TUIMethod):
                    """
                    Delete a cell thread.
                    """
                class extrude_face_zone_delta(TUIMethod):
                    """
                    Extrude a face thread a specified distance based on a list of deltas.
                    """
                class extrude_face_zone_para(TUIMethod):
                    """
                    Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                    """
                class fuse_face_zones(TUIMethod):
                    """
                    Attempt to fuse zones by removing duplicate faces and nodes.
                    """
                class list_zones(TUIMethod):
                    """
                    List zone IDs, types, kinds, and names.
                    """
                class make_periodic(TUIMethod):
                    """
                    Attempt to establish periodic/shadow face zone connectivity.
                    """
                class create_periodic_interface(TUIMethod):
                    """
                    Create a conformal or non-conformal periodic interface.
                    """
                class scale_zone(TUIMethod):
                    """
                    Scale nodal coordinates of input cell zones.
                    """
                class rotate_zone(TUIMethod):
                    """
                    Rotate nodal coordinates of input cell zones.
                    """
                class translate_zone(TUIMethod):
                    """
                    Translate nodal coordinates of input cell zones.
                    """
                class matching_tolerance(TUIMethod):
                    """
                    Set the normalized tolerance used for finding coincident nodes.
                    """
                class merge_zones(TUIMethod):
                    """
                    Merge zones of the same type and condition into one.
                    """
                class mrf_to_sliding_mesh(TUIMethod):
                    """
                    Change motion specification from MRF to moving mesh.
                    """
                class convert_all_solid_mrf_to_solid_motion(TUIMethod):
                    """
                    Change all solid zones motion specification from MRF to solid motion.
                    """
                class orient_face_zone(TUIMethod):
                    """
                    Orient the face zone.
                    """
                class replace_zone(TUIMethod):
                    """
                    Replace a cell zone.
                    """
                class sep_cell_zone_mark(TUIMethod):
                    """
                    Separate a cell zone based on cell marking.
                    """
                class sep_cell_zone_region(TUIMethod):
                    """
                    Separate a cell zone based on contiguous regions.
                    """
                class sep_face_zone_angle(TUIMethod):
                    """
                    Separate a face zone based on significant angle.
                    """
                class sep_face_zone_face(TUIMethod):
                    """
                    Separate each face in a zone into unique zone.
                    """
                class sep_face_zone_mark(TUIMethod):
                    """
                    Separate a face zone based on cell marking.
                    """
                class sep_face_zone_region(TUIMethod):
                    """
                    Separate a face zone based on contiguous regions.
                    """
                class slit_periodic(TUIMethod):
                    """
                    Slit a periodic zone into two symmetry zones.
                    """
                class slit_face_zone(TUIMethod):
                    """
                    Slit a two-sided wall into two connected wall zones.
                    """
                class slit_interior_between_diff_solids(TUIMethod):
                    """
                    Slit interior created between different solids into coupled walls.
                    """
                class zone_name(TUIMethod):
                    """
                    Give a zone a new name.
                    """
                class zone_type(TUIMethod):
                    """
                    Set a zone's type.
                    """
                class copy_mrf_to_mesh_motion(TUIMethod):
                    """
                    Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                    """
                class copy_mesh_to_mrf_motion(TUIMethod):
                    """
                    Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                    """
                class change_zone_state(TUIMethod):
                    """
                    Change the realgas material state for a zone.
                    """
                class change_zone_phase(TUIMethod):
                    """
                    Change the realgas phase for a zone.
                    """

            class profiles(TUIMenu):
                """
                Enter the boundary profiles menu.
                """
                def __init__(self, service, version, mode, path):
                    self.display_profile_surface = self.__class__.display_profile_surface(service, version, mode, path + ["display_profile_surface"])
                    self.display_profile_point_cloud_data = self.__class__.display_profile_point_cloud_data(service, version, mode, path + ["display_profile_point_cloud_data"])
                    self.overlay_profile_surface = self.__class__.overlay_profile_surface(service, version, mode, path + ["overlay_profile_surface"])
                    self.overlay_profile_point_cloud_data = self.__class__.overlay_profile_point_cloud_data(service, version, mode, path + ["overlay_profile_point_cloud_data"])
                    self.set_preference_profile_point_cloud_data = self.__class__.set_preference_profile_point_cloud_data(service, version, mode, path + ["set_preference_profile_point_cloud_data"])
                    self.list_profile_parameters = self.__class__.list_profile_parameters(service, version, mode, path + ["list_profile_parameters"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.list_profiles = self.__class__.list_profiles(service, version, mode, path + ["list_profiles"])
                    self.list_profile_fields = self.__class__.list_profile_fields(service, version, mode, path + ["list_profile_fields"])
                    self.interpolation_method = self.__class__.interpolation_method(service, version, mode, path + ["interpolation_method"])
                    self.morphing = self.__class__.morphing(service, version, mode, path + ["morphing"])
                    self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                    self.link_profile_to_reference_frame = self.__class__.link_profile_to_reference_frame(service, version, mode, path + ["link_profile_to_reference_frame"])
                    self.replicate_profile = self.__class__.replicate_profile(service, version, mode, path + ["replicate_profile"])
                    self.orient_profile = self.__class__.orient_profile(service, version, mode, path + ["orient_profile"])
                    super().__init__(service, version, mode, path)
                class display_profile_surface(TUIMethod):
                    """
                    Display a profile.
                    """
                class display_profile_point_cloud_data(TUIMethod):
                    """
                    Display Profile Point Cloud Data.
                    """
                class overlay_profile_surface(TUIMethod):
                    """
                    Overlay Profile Surface.
                    """
                class overlay_profile_point_cloud_data(TUIMethod):
                    """
                    Overlay Profile Point Cloud Data.
                    """
                class set_preference_profile_point_cloud_data(TUIMethod):
                    """
                    Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                    """
                class list_profile_parameters(TUIMethod):
                    """
                    List the parameters of a particular profile.
                    """
                class delete(TUIMethod):
                    """
                    Delete a profile.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete all boundary-profiles.
                    """
                class list_profiles(TUIMethod):
                    """
                    List all profiles.
                    """
                class list_profile_fields(TUIMethod):
                    """
                    List the fields of a particular profile.
                    """
                class interpolation_method(TUIMethod):
                    """
                    Choose the method for interpolation of profiles.
                    """
                class morphing(TUIMethod):
                    """
                    Enable/disable profile morphing options in Orient Profile panel.
                    """
                class update_interval(TUIMethod):
                    """
                    Set interval between updates of dynamic profiles.
                    """
                class link_profile_to_reference_frame(TUIMethod):
                    """
                    Link profile to a reference frame.
                    """
                class replicate_profile(TUIMethod):
                    """
                    Replicate Profile.
                    """
                class orient_profile(TUIMethod):
                    """
                    Orient Profile.
                    """

            class query(TUIMenu):
                """
                Enter zone query menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.list_boundary_conditions = self.__class__.list_boundary_conditions(service, version, mode, path + ["list_boundary_conditions"])
                    self.list_cell_zone_conditions = self.__class__.list_cell_zone_conditions(service, version, mode, path + ["list_cell_zone_conditions"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.named_zone_list = self.__class__.named_zone_list(service, version, mode, path + ["named_zone_list"])
                    self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                    self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class delete_query(TUIMethod):
                    """
                    Delete saved query.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class list_boundary_conditions(TUIMethod):
                    """
                    List boundary conditions.
                    """
                class list_cell_zone_conditions(TUIMethod):
                    """
                    List cell zone conditions.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class named_zone_list(TUIMethod):
                    """
                    Create named list of zones.
                    """
                class list_named_selection(TUIMethod):
                    """
                    List named selection of zone type.
                    """
                class list_queries(TUIMethod):
                    """
                    List all saved queries.
                    """
                class network(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Show boundary conditions for a zone of this type.
                    """

            class rename_zone(TUIMenu):
                """
                Enter zone rename menu.
                """
                def __init__(self, service, version, mode, path):
                    self.rename_by_adjacency = self.__class__.rename_by_adjacency(service, version, mode, path + ["rename_by_adjacency"])
                    self.rename_to_default = self.__class__.rename_to_default(service, version, mode, path + ["rename_to_default"])
                    self.add_suffix_or_prefix = self.__class__.add_suffix_or_prefix(service, version, mode, path + ["add_suffix_or_prefix"])
                    super().__init__(service, version, mode, path)
                class rename_by_adjacency(TUIMethod):
                    """
                    Rename zone to adjacent zones.
                    """
                class rename_to_default(TUIMethod):
                    """
                    Rename zone to default name.
                    """
                class add_suffix_or_prefix(TUIMethod):
                    """
                    Add suffix or prefix to zone name.
                    """

            class set(TUIMenu):
                """
                Enter the set boundary conditions menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class interface(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class interior(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class network(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class overset(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class solid(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                class wall(TUIMethod):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """

        class dynamic_mesh(TUIMenu):
            """
            Enter the dynamic mesh menu.
            """
            def __init__(self, service, version, mode, path):
                self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                self.events = self.__class__.events(service, version, mode, path + ["events"])
                self.zones = self.__class__.zones(service, version, mode, path + ["zones"])
                self.actions = self.__class__.actions(service, version, mode, path + ["actions"])
                self.transient_settings = self.__class__.transient_settings(service, version, mode, path + ["transient_settings"])
                self.dynamic_mesh = self.__class__.dynamic_mesh(service, version, mode, path + ["dynamic_mesh"])
                super().__init__(service, version, mode, path)
            class dynamic_mesh(TUIMethod):
                """
                Enable/disable the dynamic mesh solver and options.
                """

            class controls(TUIMenu):
                """
                Enter the dynamic mesh control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.smoothing_parameters = self.__class__.smoothing_parameters(service, version, mode, path + ["smoothing_parameters"])
                    self.layering_parameters = self.__class__.layering_parameters(service, version, mode, path + ["layering_parameters"])
                    self.remeshing_parameters = self.__class__.remeshing_parameters(service, version, mode, path + ["remeshing_parameters"])
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(service, version, mode, path + ["in_cylinder_parameters"])
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(service, version, mode, path + ["implicit_update_parameters"])
                    self.six_dof_parameters = self.__class__.six_dof_parameters(service, version, mode, path + ["six_dof_parameters"])
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(service, version, mode, path + ["periodic_displacement_parameters"])
                    self.contact_parameters = self.__class__.contact_parameters(service, version, mode, path + ["contact_parameters"])
                    self.in_cylinder_output = self.__class__.in_cylinder_output(service, version, mode, path + ["in_cylinder_output"])
                    self.smoothing = self.__class__.smoothing(service, version, mode, path + ["smoothing"])
                    self.layering = self.__class__.layering(service, version, mode, path + ["layering"])
                    self.remeshing = self.__class__.remeshing(service, version, mode, path + ["remeshing"])
                    self.steady_pseudo_time_control = self.__class__.steady_pseudo_time_control(service, version, mode, path + ["steady_pseudo_time_control"])
                    super().__init__(service, version, mode, path)
                class in_cylinder_output(TUIMethod):
                    """
                    Enable/disable in-cylinder output.
                    """
                class smoothing(TUIMethod):
                    """
                    Enable/disable dynamic mesh smoothing.
                    """
                class layering(TUIMethod):
                    """
                    Enable/disable dynamic-layering in quad/hex cell zones.
                    """
                class remeshing(TUIMethod):
                    """
                    Enable/disable local remeshing in tri/tet and mixed cell zones.
                    """
                class steady_pseudo_time_control(TUIMethod):
                    """
                    Enable/disable pseudo time step control in user interface.
                    """

                class smoothing_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh smoothing menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.smoothing_method = self.__class__.smoothing_method(service, version, mode, path + ["smoothing_method"])
                        self.constant_factor = self.__class__.constant_factor(service, version, mode, path + ["constant_factor"])
                        self.bnd_node_relaxation = self.__class__.bnd_node_relaxation(service, version, mode, path + ["bnd_node_relaxation"])
                        self.bnd_stiffness_factor = self.__class__.bnd_stiffness_factor(service, version, mode, path + ["bnd_stiffness_factor"])
                        self.convergence_tolerance = self.__class__.convergence_tolerance(service, version, mode, path + ["convergence_tolerance"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        self.spring_on_all_elements = self.__class__.spring_on_all_elements(service, version, mode, path + ["spring_on_all_elements"])
                        self.spring_on_simplex_elements = self.__class__.spring_on_simplex_elements(service, version, mode, path + ["spring_on_simplex_elements"])
                        self.skew_smooth_niter = self.__class__.skew_smooth_niter(service, version, mode, path + ["skew_smooth_niter"])
                        self.skew_smooth_cell_skew_max = self.__class__.skew_smooth_cell_skew_max(service, version, mode, path + ["skew_smooth_cell_skew_max"])
                        self.skew_smooth_face_skew_max = self.__class__.skew_smooth_face_skew_max(service, version, mode, path + ["skew_smooth_face_skew_max"])
                        self.skew_smooth_all_deforming_boundaries = self.__class__.skew_smooth_all_deforming_boundaries(service, version, mode, path + ["skew_smooth_all_deforming_boundaries"])
                        self.laplace_node_relaxation = self.__class__.laplace_node_relaxation(service, version, mode, path + ["laplace_node_relaxation"])
                        self.diffusion_coeff_function = self.__class__.diffusion_coeff_function(service, version, mode, path + ["diffusion_coeff_function"])
                        self.diffusion_coeff_parameter = self.__class__.diffusion_coeff_parameter(service, version, mode, path + ["diffusion_coeff_parameter"])
                        self.diffusion_fvm = self.__class__.diffusion_fvm(service, version, mode, path + ["diffusion_fvm"])
                        self.poisson_ratio = self.__class__.poisson_ratio(service, version, mode, path + ["poisson_ratio"])
                        self.smooth_from_reference_position = self.__class__.smooth_from_reference_position(service, version, mode, path + ["smooth_from_reference_position"])
                        self.relative_convergence_tolerance = self.__class__.relative_convergence_tolerance(service, version, mode, path + ["relative_convergence_tolerance"])
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.boundary_distance_method = self.__class__.boundary_distance_method(service, version, mode, path + ["boundary_distance_method"])
                        super().__init__(service, version, mode, path)
                    class smoothing_method(TUIMethod):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                    class constant_factor(TUIMethod):
                        """
                        Set the spring constant relaxation factor.
                        """
                    class bnd_node_relaxation(TUIMethod):
                        """
                        Set the spring boundary node relaxation factor.
                        """
                    class bnd_stiffness_factor(TUIMethod):
                        """
                        Set the stiffness factor for springs connected to boundary nodes.
                        """
                    class convergence_tolerance(TUIMethod):
                        """
                        Set the convergence tolerance for spring-based solver.
                        """
                    class max_iter(TUIMethod):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                    class spring_on_all_elements(TUIMethod):
                        """
                        Enable/disable spring-based smoothing for all cell shapes.
                        """
                    class spring_on_simplex_elements(TUIMethod):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                    class skew_smooth_niter(TUIMethod):
                        """
                        Set the number of skewness-based smoothing cycles.
                        """
                    class skew_smooth_cell_skew_max(TUIMethod):
                        """
                        Set the cell skewness threshold above which cells will be smoothed
                        using the skewness method.
                        """
                    class skew_smooth_face_skew_max(TUIMethod):
                        """
                        Set the face skewness threshold above which deforming boundary faces
                        will be smoothed using the skewness method.
                        """
                    class skew_smooth_all_deforming_boundaries(TUIMethod):
                        """
                        Enable/disable skewness smoothing for all deforming
                        dynamic boundary zones. If disabled, only the deforming dynamic boundary zones are
                        smoothed which have smoothing explicitly enabled or use local face remeshing.
                        """
                    class laplace_node_relaxation(TUIMethod):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                    class diffusion_coeff_function(TUIMethod):
                        """
                        Specify whether the diffusion coefficient is based on the
                        boundary distance or the cell volume.
                        """
                    class diffusion_coeff_parameter(TUIMethod):
                        """
                        Set the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                    class diffusion_fvm(TUIMethod):
                        """
                        Set the numerical method used for diffusion-based smoothing.
                        """
                    class poisson_ratio(TUIMethod):
                        """
                        Set the Poisson's ratio used by the linearly elastic solid model.
                        """
                    class smooth_from_reference_position(TUIMethod):
                        """
                        Enable smoothing from reference position.
                        """
                    class relative_convergence_tolerance(TUIMethod):
                        """
                        Set the relative residual convergence tolerance for diffusion-based (FVM) smoothing.
                        """
                    class amg_stabilization(TUIMethod):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                    class verbosity(TUIMethod):
                        """
                        Set the verbosity for spring smoothing.
                        """
                    class boundary_distance_method(TUIMethod):
                        """
                        Set the method used to evaluate the boundary distance for the
                        diffusion coefficient calculation.
                        """

                class layering_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh layering menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.split_factor = self.__class__.split_factor(service, version, mode, path + ["split_factor"])
                        self.collapse_factor = self.__class__.collapse_factor(service, version, mode, path + ["collapse_factor"])
                        self.constant_height = self.__class__.constant_height(service, version, mode, path + ["constant_height"])
                        super().__init__(service, version, mode, path)
                    class split_factor(TUIMethod):
                        """
                        Set the factor determining when to split dynamic layers.
                        """
                    class collapse_factor(TUIMethod):
                        """
                        Set the factor determining when to collapse dynamic layers.
                        """
                    class constant_height(TUIMethod):
                        """
                        Enable/disable layering based on constant height, else layering based on constant ratio.
                        """

                class remeshing_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh remeshing menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.prism_controls = self.__class__.prism_controls(service, version, mode, path + ["prism_controls"])
                        self.sizing_controls = self.__class__.sizing_controls(service, version, mode, path + ["sizing_controls"])
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(service, version, mode, path + ["prism_layer_parameters"])
                        self.unified_remeshing = self.__class__.unified_remeshing(service, version, mode, path + ["unified_remeshing"])
                        self.retain_size_distribution = self.__class__.retain_size_distribution(service, version, mode, path + ["retain_size_distribution"])
                        self.poly_remeshing = self.__class__.poly_remeshing(service, version, mode, path + ["poly_remeshing"])
                        self.remeshing_methods = self.__class__.remeshing_methods(service, version, mode, path + ["remeshing_methods"])
                        self.zone_remeshing = self.__class__.zone_remeshing(service, version, mode, path + ["zone_remeshing"])
                        self.length_min = self.__class__.length_min(service, version, mode, path + ["length_min"])
                        self.length_max = self.__class__.length_max(service, version, mode, path + ["length_max"])
                        self.cell_skew_max = self.__class__.cell_skew_max(service, version, mode, path + ["cell_skew_max"])
                        self.face_skew_max = self.__class__.face_skew_max(service, version, mode, path + ["face_skew_max"])
                        self.size_remesh_interval = self.__class__.size_remesh_interval(service, version, mode, path + ["size_remesh_interval"])
                        self.sizing_function = self.__class__.sizing_function(service, version, mode, path + ["sizing_function"])
                        self.sizing_funct_defaults = self.__class__.sizing_funct_defaults(service, version, mode, path + ["sizing_funct_defaults"])
                        self.sizing_funct_resolution = self.__class__.sizing_funct_resolution(service, version, mode, path + ["sizing_funct_resolution"])
                        self.sizing_funct_variation = self.__class__.sizing_funct_variation(service, version, mode, path + ["sizing_funct_variation"])
                        self.sizing_funct_rate = self.__class__.sizing_funct_rate(service, version, mode, path + ["sizing_funct_rate"])
                        self.parallel_remeshing = self.__class__.parallel_remeshing(service, version, mode, path + ["parallel_remeshing"])
                        self.remeshing_after_moving = self.__class__.remeshing_after_moving(service, version, mode, path + ["remeshing_after_moving"])
                        super().__init__(service, version, mode, path)
                    class unified_remeshing(TUIMethod):
                        """
                        Enable/disable unified remeshing.
                        """
                    class retain_size_distribution(TUIMethod):
                        """
                        Enable/disable retaining of size distribution.
                        """
                    class poly_remeshing(TUIMethod):
                        """
                        Enable/disable poly remeshing.
                        """
                    class remeshing_methods(TUIMethod):
                        """
                        Enable/disable remeshing methods.
                        """
                    class zone_remeshing(TUIMethod):
                        """
                        Enable/disable cell zone remeshing method.
                        """
                    class length_min(TUIMethod):
                        """
                        Set the length threshold below which cells will be remeshed.
                        """
                    class length_max(TUIMethod):
                        """
                        Set the length threshold above which cells will be remeshed.
                        """
                    class cell_skew_max(TUIMethod):
                        """
                        Set the cell skewness threshold above which cells will be remeshed.
                        """
                    class face_skew_max(TUIMethod):
                        """
                        Set the face skewness threshold above which faces will be remeshed.
                        """
                    class size_remesh_interval(TUIMethod):
                        """
                        Set the interval (in time steps) when remeshing based on size is done.
                        """
                    class sizing_function(TUIMethod):
                        """
                        Enable/disable sizing function to control size based remeshing.
                        """
                    class sizing_funct_defaults(TUIMethod):
                        """
                        Set sizing function defaults.
                        """
                    class sizing_funct_resolution(TUIMethod):
                        """
                        Set the sizing function resolution with respect to shortest boundary.
                        """
                    class sizing_funct_variation(TUIMethod):
                        """
                        Set the maximum sizing function increase/decrease in the interior.
                        """
                    class sizing_funct_rate(TUIMethod):
                        """
                        Determine how far from the boundary the increase/decrease happens.
                        """
                    class parallel_remeshing(TUIMethod):
                        """
                        Enable/disable parallel remeshing for zone remeshing.
                        """
                    class remeshing_after_moving(TUIMethod):
                        """
                        Enable/disable optional remeshing after mesh motion to meet skewness threshold.
                        Steady state dynamic mesh only.
                        """

                    class prism_controls(TUIMenu):
                        """
                        Specify optional prism controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Add a new object.
                            """
                        class edit(TUIMethod):
                            """
                            Edit an object.
                            """
                        class delete(TUIMethod):
                            """
                            Delete an object.
                            """
                        class list(TUIMethod):
                            """
                            List objects.
                            """
                        class list_properties(TUIMethod):
                            """
                            List properties of an object.
                            """

                    class sizing_controls(TUIMenu):
                        """
                        Specify optional sizing controls.
                        """
                        def __init__(self, service, version, mode, path):
                            self.add = self.__class__.add(service, version, mode, path + ["add"])
                            self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                            super().__init__(service, version, mode, path)
                        class add(TUIMethod):
                            """
                            Add a new object.
                            """
                        class edit(TUIMethod):
                            """
                            Edit an object.
                            """
                        class delete(TUIMethod):
                            """
                            Delete an object.
                            """
                        class list(TUIMethod):
                            """
                            List objects.
                            """
                        class list_properties(TUIMethod):
                            """
                            List properties of an object.
                            """

                    class prism_layer_parameters(TUIMenu):
                        """
                        Enter the dynamic mesh prism remeshing menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.first_height = self.__class__.first_height(service, version, mode, path + ["first_height"])
                            self.growth_rate = self.__class__.growth_rate(service, version, mode, path + ["growth_rate"])
                            self.number_of_layers = self.__class__.number_of_layers(service, version, mode, path + ["number_of_layers"])
                            super().__init__(service, version, mode, path)
                        class first_height(TUIMethod):
                            """
                            Set first cell height in the prism layer.
                            """
                        class growth_rate(TUIMethod):
                            """
                            Set the geometric growth rate of the prism layer.
                            """
                        class number_of_layers(TUIMethod):
                            """
                            Set the number of elements in the prism layer.
                            """

                class in_cylinder_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.starting_crank_angle = self.__class__.starting_crank_angle(service, version, mode, path + ["starting_crank_angle"])
                        self.crank_angle_step = self.__class__.crank_angle_step(service, version, mode, path + ["crank_angle_step"])
                        self.crank_period = self.__class__.crank_period(service, version, mode, path + ["crank_period"])
                        self.max_crank_angle_step = self.__class__.max_crank_angle_step(service, version, mode, path + ["max_crank_angle_step"])
                        self.piston_data = self.__class__.piston_data(service, version, mode, path + ["piston_data"])
                        self.piston_stroke_cutoff = self.__class__.piston_stroke_cutoff(service, version, mode, path + ["piston_stroke_cutoff"])
                        self.minimum_lift = self.__class__.minimum_lift(service, version, mode, path + ["minimum_lift"])
                        self.print_plot_lift = self.__class__.print_plot_lift(service, version, mode, path + ["print_plot_lift"])
                        self.modify_lift = self.__class__.modify_lift(service, version, mode, path + ["modify_lift"])
                        self.position_starting_mesh = self.__class__.position_starting_mesh(service, version, mode, path + ["position_starting_mesh"])
                        super().__init__(service, version, mode, path)
                    class starting_crank_angle(TUIMethod):
                        """
                        Specify the starting crank angle.
                        """
                    class crank_angle_step(TUIMethod):
                        """
                        Specify the crank angle step size.
                        """
                    class crank_period(TUIMethod):
                        """
                        Specify the crank period.
                        """
                    class max_crank_angle_step(TUIMethod):
                        """
                        Specify the maximum crank angle step size.
                        """
                    class piston_data(TUIMethod):
                        """
                        Specify the crank radius, connecting rod length, and piston pin offset.
                        """
                    class piston_stroke_cutoff(TUIMethod):
                        """
                        Specify the cut off point for in-cylinder piston.
                        """
                    class minimum_lift(TUIMethod):
                        """
                        Specify the minimum lift for in-cylinder valves.
                        """
                    class print_plot_lift(TUIMethod):
                        """
                        Print or plot valve lift curve.
                        """
                    class modify_lift(TUIMethod):
                        """
                        Modify the lift curve (shift or scale).
                        """
                    class position_starting_mesh(TUIMethod):
                        """
                        Move mesh from top dead center to starting crank angle.
                        """

                class implicit_update_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh implicit update menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.update_interval = self.__class__.update_interval(service, version, mode, path + ["update_interval"])
                        self.motion_relaxation = self.__class__.motion_relaxation(service, version, mode, path + ["motion_relaxation"])
                        self.residual_criteria = self.__class__.residual_criteria(service, version, mode, path + ["residual_criteria"])
                        super().__init__(service, version, mode, path)
                    class update_interval(TUIMethod):
                        """
                        Specify update interval of implicit update.
                        """
                    class motion_relaxation(TUIMethod):
                        """
                        Specify motion relaxation of implicit update.
                        """
                    class residual_criteria(TUIMethod):
                        """
                        Specify residual criteria of implicit update.
                        """

                class six_dof_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh six-dof menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.create_properties = self.__class__.create_properties(service, version, mode, path + ["create_properties"])
                        self.delete_properties = self.__class__.delete_properties(service, version, mode, path + ["delete_properties"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        self.x_component_of_gravity = self.__class__.x_component_of_gravity(service, version, mode, path + ["x_component_of_gravity"])
                        self.y_component_of_gravity = self.__class__.y_component_of_gravity(service, version, mode, path + ["y_component_of_gravity"])
                        self.z_component_of_gravity = self.__class__.z_component_of_gravity(service, version, mode, path + ["z_component_of_gravity"])
                        self.second_order = self.__class__.second_order(service, version, mode, path + ["second_order"])
                        self.motion_history = self.__class__.motion_history(service, version, mode, path + ["motion_history"])
                        self.motion_history_file_name = self.__class__.motion_history_file_name(service, version, mode, path + ["motion_history_file_name"])
                        super().__init__(service, version, mode, path)
                    class create_properties(TUIMethod):
                        """
                        Create a set of Six DOF Properties.
                        """
                    class delete_properties(TUIMethod):
                        """
                        Delete a set of Six DOF Properties.
                        """
                    class list_properties(TUIMethod):
                        """
                        List Six DOF Properties.
                        """
                    class x_component_of_gravity(TUIMethod):
                        """
                        Specify x-component-of-gravity.
                        """
                    class y_component_of_gravity(TUIMethod):
                        """
                        Specify y-component-of-gravity.
                        """
                    class z_component_of_gravity(TUIMethod):
                        """
                        Specify z-component-of-gravity.
                        """
                    class second_order(TUIMethod):
                        """
                        Enable/disable second order six DOF solver.
                        """
                    class motion_history(TUIMethod):
                        """
                        Enable/disable writing position/orientation of six DOF zones to file.
                        """
                    class motion_history_file_name(TUIMethod):
                        """
                        Location of six DOF motion history file.
                        """

                class periodic_displacement_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh periodic displacement menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.list_displacements = self.__class__.list_displacements(service, version, mode, path + ["list_displacements"])
                        self.create_displacement = self.__class__.create_displacement(service, version, mode, path + ["create_displacement"])
                        self.edit_displacement = self.__class__.edit_displacement(service, version, mode, path + ["edit_displacement"])
                        self.copy_displacement = self.__class__.copy_displacement(service, version, mode, path + ["copy_displacement"])
                        self.delete_displacement = self.__class__.delete_displacement(service, version, mode, path + ["delete_displacement"])
                        self.delete_all_displacements = self.__class__.delete_all_displacements(service, version, mode, path + ["delete_all_displacements"])
                        self.create_group = self.__class__.create_group(service, version, mode, path + ["create_group"])
                        self.list_groups = self.__class__.list_groups(service, version, mode, path + ["list_groups"])
                        self.edit_group = self.__class__.edit_group(service, version, mode, path + ["edit_group"])
                        self.delete_group = self.__class__.delete_group(service, version, mode, path + ["delete_group"])
                        self.delete_all_groups = self.__class__.delete_all_groups(service, version, mode, path + ["delete_all_groups"])
                        self.set_active_displacement = self.__class__.set_active_displacement(service, version, mode, path + ["set_active_displacement"])
                        super().__init__(service, version, mode, path)
                    class list_displacements(TUIMethod):
                        """
                        List Periodic Displacements.
                        """
                    class create_displacement(TUIMethod):
                        """
                        Create Periodic Displacement.
                        """
                    class edit_displacement(TUIMethod):
                        """
                        Edit Periodic Displacement.
                        """
                    class copy_displacement(TUIMethod):
                        """
                        Copy Periodic Displacement.
                        """
                    class delete_displacement(TUIMethod):
                        """
                        Delete Periodic Displacement.
                        """
                    class delete_all_displacements(TUIMethod):
                        """
                        Delete All Periodic Displacements.
                        """
                    class create_group(TUIMethod):
                        """
                        Create Periodic Displacement Group.
                        """
                    class list_groups(TUIMethod):
                        """
                        List Periodic Displacement Groups.
                        """
                    class edit_group(TUIMethod):
                        """
                        Edit Periodic Displacement Group.
                        """
                    class delete_group(TUIMethod):
                        """
                        Delete Periodic Displacement Group.
                        """
                    class delete_all_groups(TUIMethod):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                    class set_active_displacement(TUIMethod):
                        """
                        Set Active Periodic Displacement in Group.
                        """

                class contact_parameters(TUIMenu):
                    """
                    Enter the dynamic mesh contact detection menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.flow_control_parameters = self.__class__.flow_control_parameters(service, version, mode, path + ["flow_control_parameters"])
                        self.contact_face_zones = self.__class__.contact_face_zones(service, version, mode, path + ["contact_face_zones"])
                        self.contact_udf = self.__class__.contact_udf(service, version, mode, path + ["contact_udf"])
                        self.contact_threshold = self.__class__.contact_threshold(service, version, mode, path + ["contact_threshold"])
                        self.update_contact_marks = self.__class__.update_contact_marks(service, version, mode, path + ["update_contact_marks"])
                        self.flow_control = self.__class__.flow_control(service, version, mode, path + ["flow_control"])
                        self.contact_method = self.__class__.contact_method(service, version, mode, path + ["contact_method"])
                        self.render_contact_cells = self.__class__.render_contact_cells(service, version, mode, path + ["render_contact_cells"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class contact_face_zones(TUIMethod):
                        """
                        Select face zones involved in contact detection.
                        """
                    class contact_udf(TUIMethod):
                        """
                        Select UDF to be invoked when contact is detected.
                        """
                    class contact_threshold(TUIMethod):
                        """
                        Specify threshold distance for contact detection.
                        """
                    class update_contact_marks(TUIMethod):
                        """
                        Update which cells are marked in order to block flow in the contact region.
                        """
                    class flow_control(TUIMethod):
                        """
                        Enable/disable flow control.
                        """
                    class contact_method(TUIMethod):
                        """
                        Select the method used for flow control in the contact region.
                        """
                    class render_contact_cells(TUIMethod):
                        """
                        Set the option to include contact-cells in post-processing.
                        """
                    class verbosity(TUIMethod):
                        """
                        Set the verbosity for contact-detection.
                        """

                    class flow_control_parameters(TUIMenu):
                        """
                        Enter the flow control menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                            self.create_flow_control_zone = self.__class__.create_flow_control_zone(service, version, mode, path + ["create_flow_control_zone"])
                            self.delete_flow_control_zone = self.__class__.delete_flow_control_zone(service, version, mode, path + ["delete_flow_control_zone"])
                            super().__init__(service, version, mode, path)
                        class solution_stabilization(TUIMethod):
                            """
                            Enable/disable the performance of additional iterations per time step and
                            the application of solution controls to improve the stability of the solver.
                            """
                        class create_flow_control_zone(TUIMethod):
                            """
                            Create a flow control zone.
                            """
                        class delete_flow_control_zone(TUIMethod):
                            """
                            Delete a flow control zone.
                            """

            class events(TUIMenu):
                """
                Enter the dynamic mesh events menu.
                """
                def __init__(self, service, version, mode, path):
                    self.import_event_file = self.__class__.import_event_file(service, version, mode, path + ["import_event_file"])
                    self.export_event_file = self.__class__.export_event_file(service, version, mode, path + ["export_event_file"])
                    super().__init__(service, version, mode, path)
                class import_event_file(TUIMethod):
                    """
                    Import dynamic mesh event file.
                    """
                class export_event_file(TUIMethod):
                    """
                    Export dynamic mesh events to file.
                    """

            class zones(TUIMenu):
                """
                Enter the dynamic mesh zones menu.
                """
                def __init__(self, service, version, mode, path):
                    self.create = self.__class__.create(service, version, mode, path + ["create"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    self.insert_boundary_layer = self.__class__.insert_boundary_layer(service, version, mode, path + ["insert_boundary_layer"])
                    self.remove_boundary_layer = self.__class__.remove_boundary_layer(service, version, mode, path + ["remove_boundary_layer"])
                    self.insert_interior_layer = self.__class__.insert_interior_layer(service, version, mode, path + ["insert_interior_layer"])
                    self.remove_interior_layer = self.__class__.remove_interior_layer(service, version, mode, path + ["remove_interior_layer"])
                    super().__init__(service, version, mode, path)
                class create(TUIMethod):
                    """
                    Create dynamic zone.
                    """
                class delete(TUIMethod):
                    """
                    Delete dynamic zone.
                    """
                class list(TUIMethod):
                    """
                    List dynamic zones.
                    """
                class insert_boundary_layer(TUIMethod):
                    """
                    Insert new cell zone.
                    """
                class remove_boundary_layer(TUIMethod):
                    """
                    Remove cell zone.
                    """
                class insert_interior_layer(TUIMethod):
                    """
                    Insert new layer cell zone at specified location.
                    """
                class remove_interior_layer(TUIMethod):
                    """
                    Remove interior layer cell zone.
                    """

            class actions(TUIMenu):
                """
                Enter the dynamic mesh actions menu.
                """
                def __init__(self, service, version, mode, path):
                    self.remesh_cell_zone = self.__class__.remesh_cell_zone(service, version, mode, path + ["remesh_cell_zone"])
                    super().__init__(service, version, mode, path)
                class remesh_cell_zone(TUIMethod):
                    """
                    Manually remesh cell zone with option to remesh adjacent dynamic face zones.
                    """

            class transient_settings(TUIMenu):
                """
                Enter the dynamic mesh transient settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.allow_second_order = self.__class__.allow_second_order(service, version, mode, path + ["allow_second_order"])
                    super().__init__(service, version, mode, path)
                class verbosity(TUIMethod):
                    """
                    Enable/disable transient scheme verbosity for dynamic mesh cases.
                    """
                class allow_second_order(TUIMethod):
                    """
                    Enable/disable 2nd order transient scheme for dynamic mesh cases.
                    """

        class expert(TUIMenu):
            """
            Enter expert setup menu.
            """
            def __init__(self, service, version, mode, path):
                self.spectral = self.__class__.spectral(service, version, mode, path + ["spectral"])
                self.beta_feature_access = self.__class__.beta_feature_access(service, version, mode, path + ["beta_feature_access"])
                self.enable_mesh_morpher_optimizer = self.__class__.enable_mesh_morpher_optimizer(service, version, mode, path + ["enable_mesh_morpher_optimizer"])
                self.heterogeneous_stiff_chemistry = self.__class__.heterogeneous_stiff_chemistry(service, version, mode, path + ["heterogeneous_stiff_chemistry"])
                self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                super().__init__(service, version, mode, path)
            class beta_feature_access(TUIMethod):
                """
                Enable access to beta features in the interface.
                """
            class enable_mesh_morpher_optimizer(TUIMethod):
                """
                Enable use of mesh morpher/optimizer.
                """
            class heterogeneous_stiff_chemistry(TUIMethod):
                """
                Set heterogeneous stiff-chemistry solver.
                """
            class stiff_chemistry(TUIMethod):
                """
                Set solver options for stiff-chemistry solutions.
                """

            class spectral(TUIMenu):
                """
                Enter the Spectral menu.
                """
                def __init__(self, service, version, mode, path):
                    self.calculate_fourier_coefficients = self.__class__.calculate_fourier_coefficients(service, version, mode, path + ["calculate_fourier_coefficients"])
                    self.delete_fourier_coefficients = self.__class__.delete_fourier_coefficients(service, version, mode, path + ["delete_fourier_coefficients"])
                    self.calculate_harmonic_exports = self.__class__.calculate_harmonic_exports(service, version, mode, path + ["calculate_harmonic_exports"])
                    self.delete_harmonic_exports = self.__class__.delete_harmonic_exports(service, version, mode, path + ["delete_harmonic_exports"])
                    super().__init__(service, version, mode, path)
                class calculate_fourier_coefficients(TUIMethod):
                    """
                    Calculates Fourier coefficient data.
                    """
                class delete_fourier_coefficients(TUIMethod):
                    """
                    Deletes Fourier coefficient data.
                    """
                class calculate_harmonic_exports(TUIMethod):
                    """
                    Calculates Harmonic Export data.
                    """
                class delete_harmonic_exports(TUIMethod):
                    """
                    Deletes Harmonic Export data.
                    """

        class gap_model(TUIMenu):
            """
            Enter the narrow-gaps menu.
            """
            def __init__(self, service, version, mode, path):
                self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.list_gap_regions = self.__class__.list_gap_regions(service, version, mode, path + ["list_gap_regions"])
                self.list_gap_face_zones = self.__class__.list_gap_face_zones(service, version, mode, path + ["list_gap_face_zones"])
                self.list_gap_cell_zones = self.__class__.list_gap_cell_zones(service, version, mode, path + ["list_gap_cell_zones"])
                self.render_gap_regions = self.__class__.render_gap_regions(service, version, mode, path + ["render_gap_regions"])
                super().__init__(service, version, mode, path)
            class enable(TUIMethod):
                """
                Enable/Disable gap model.
                """
            class create(TUIMethod):
                """
                Create a gap object.
                """
            class edit(TUIMethod):
                """
                Edit an exiting gap object.
                """
            class delete(TUIMethod):
                """
                Delete an exiting gap object.
                """
            class delete_all(TUIMethod):
                """
                Delete all of the exiting gap objects.
                """
            class list_gap_regions(TUIMethod):
                """
                List gap regions.
                """
            class list_gap_face_zones(TUIMethod):
                """
                List name of the gap face zones that can be used for gaps creation.
                """
            class list_gap_cell_zones(TUIMethod):
                """
                List name of the gap cells zones that can be used as exclided cell zones in gaps creation.
                """
            class render_gap_regions(TUIMethod):
                """
                Update gap regions for postprocessing.
                """

            class advanced_options(TUIMenu):
                """
                Show options.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.alternative_marking = self.__class__.alternative_marking(service, version, mode, path + ["alternative_marking"])
                    self.cell_check_distance_factor = self.__class__.cell_check_distance_factor(service, version, mode, path + ["cell_check_distance_factor"])
                    self.flow_blocking_stabilization_parameters = self.__class__.flow_blocking_stabilization_parameters(service, version, mode, path + ["flow_blocking_stabilization_parameters"])
                    self.update_gap_regions = self.__class__.update_gap_regions(service, version, mode, path + ["update_gap_regions"])
                    self.clear_gap_regions = self.__class__.clear_gap_regions(service, version, mode, path + ["clear_gap_regions"])
                    self.precise_gap_marking = self.__class__.precise_gap_marking(service, version, mode, path + ["precise_gap_marking"])
                    self.render_flow_modeling_gaps = self.__class__.render_flow_modeling_gaps(service, version, mode, path + ["render_flow_modeling_gaps"])
                    self.reduce_gap_regions = self.__class__.reduce_gap_regions(service, version, mode, path + ["reduce_gap_regions"])
                    self.fill_data_in_gap_regions = self.__class__.fill_data_in_gap_regions(service, version, mode, path + ["fill_data_in_gap_regions"])
                    self.enhanced_data_interpolation = self.__class__.enhanced_data_interpolation(service, version, mode, path + ["enhanced_data_interpolation"])
                    self.sponge_layer = self.__class__.sponge_layer(service, version, mode, path + ["sponge_layer"])
                    self.solution_stabilization = self.__class__.solution_stabilization(service, version, mode, path + ["solution_stabilization"])
                    self.include_coupled_walls = self.__class__.include_coupled_walls(service, version, mode, path + ["include_coupled_walls"])
                    self.check_cfl_condition = self.__class__.check_cfl_condition(service, version, mode, path + ["check_cfl_condition"])
                    self.extend_gap_regions = self.__class__.extend_gap_regions(service, version, mode, path + ["extend_gap_regions"])
                    self.revert_controls_to_default = self.__class__.revert_controls_to_default(service, version, mode, path + ["revert_controls_to_default"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    self.render_gap_interface = self.__class__.render_gap_interface(service, version, mode, path + ["render_gap_interface"])
                    super().__init__(service, version, mode, path)
                class expert(TUIMethod):
                    """
                    Enable expert options for gap model.
                    """
                class alternative_marking(TUIMethod):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                class cell_check_distance_factor(TUIMethod):
                    """
                    Enter value of the cell distance factor.
                    """
                class flow_blocking_stabilization_parameters(TUIMethod):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                class update_gap_regions(TUIMethod):
                    """
                    Update gap regions and gap model solution information.
                    """
                class clear_gap_regions(TUIMethod):
                    """
                    Clear gap model solution information and marks.
                    """
                class precise_gap_marking(TUIMethod):
                    """
                    Mark cells in gap regions using more accurate search algorithm.
                    """
                class render_flow_modeling_gaps(TUIMethod):
                    """
                    Render solution inside flow modeling gap cells.
                    """
                class reduce_gap_regions(TUIMethod):
                    """
                    Using a more restrictive algorithm for marking cells in gap regions.
                    """
                class fill_data_in_gap_regions(TUIMethod):
                    """
                    Interpolate solution data into the whole gap regions.
                    """
                class enhanced_data_interpolation(TUIMethod):
                    """
                    Use enhanced data interpolation for updating information in gap regions.
                    """
                class sponge_layer(TUIMethod):
                    """
                    Set advanced settings for gap sponge layer.
                    """
                class solution_stabilization(TUIMethod):
                    """
                    Set solution stabilization level for gap model.
                    """
                class include_coupled_walls(TUIMethod):
                    """
                    Include coupled walls in gap face zones.
                    """
                class check_cfl_condition(TUIMethod):
                    """
                    Check time step size for better convergence.
                    """
                class extend_gap_regions(TUIMethod):
                    """
                    Extend gap regions for better convergence.
                    """
                class revert_controls_to_default(TUIMethod):
                    """
                    Revert gap stabilization and any related solver settings to default.
                    """
                class verbosity(TUIMethod):
                    """
                    Set the verbosity for gap model.
                    """
                class render_gap_interface(TUIMethod):
                    """
                    Render gap interface.
                    """

        class materials(TUIMenu):
            """
            Enter the materials menu.
            """
            def __init__(self, service, version, mode, path):
                self.data_base = self.__class__.data_base(service, version, mode, path + ["data_base"])
                self.change_create = self.__class__.change_create(service, version, mode, path + ["change_create"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.copy_by_formula = self.__class__.copy_by_formula(service, version, mode, path + ["copy_by_formula"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class change_create(TUIMethod):
                """
                Change the properties of a locally-stored material or create a new material.
                """
            class copy(TUIMethod):
                """
                Copy a material from the database.
                """
            class copy_by_formula(TUIMethod):
                """
                Copy a material from the database by formula.
                """
            class delete(TUIMethod):
                """
                Delete a material from local storage.
                """
            class list_materials(TUIMethod):
                """
                List all locally-stored materials.
                """
            class list_properties(TUIMethod):
                """
                List the properties of a locally-stored material.
                """

            class data_base(TUIMenu):
                """
                Enter the database menu.
                """
                def __init__(self, service, version, mode, path):
                    self.database_type = self.__class__.database_type(service, version, mode, path + ["database_type"])
                    self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                    self.list_materials = self.__class__.list_materials(service, version, mode, path + ["list_materials"])
                    self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                    self.new = self.__class__.new(service, version, mode, path + ["new"])
                    self.save = self.__class__.save(service, version, mode, path + ["save"])
                    super().__init__(service, version, mode, path)
                class database_type(TUIMethod):
                    """
                    Set the database type.
                    """
                class edit(TUIMethod):
                    """
                    Edit a material.
                    """
                class list_materials(TUIMethod):
                    """
                    List all materials in the database.
                    """
                class list_properties(TUIMethod):
                    """
                    List the properties of a material in the database.
                    """
                class new(TUIMethod):
                    """
                    Define a new material.
                    """
                class save(TUIMethod):
                    """
                    Save user-defined database.
                    """

        class mesh_interfaces(TUIMenu):
            """
            Enter the mesh-interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(service, version, mode, path + ["non_conformal_interface_numerics"])
                self.mapped_interface_options = self.__class__.mapped_interface_options(service, version, mode, path + ["mapped_interface_options"])
                self.auto_options = self.__class__.auto_options(service, version, mode, path + ["auto_options"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.make_periodic = self.__class__.make_periodic(service, version, mode, path + ["make_periodic"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.enforce_continuity_after_bc = self.__class__.enforce_continuity_after_bc(service, version, mode, path + ["enforce_continuity_after_bc"])
                self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                self.enable_si_with_nodes = self.__class__.enable_si_with_nodes(service, version, mode, path + ["enable_si_with_nodes"])
                self.enforce_coupled_wall_between_solids = self.__class__.enforce_coupled_wall_between_solids(service, version, mode, path + ["enforce_coupled_wall_between_solids"])
                self.improve_quality = self.__class__.improve_quality(service, version, mode, path + ["improve_quality"])
                self.one_to_one_pairing = self.__class__.one_to_one_pairing(service, version, mode, path + ["one_to_one_pairing"])
                self.auto_pairing = self.__class__.auto_pairing(service, version, mode, path + ["auto_pairing"])
                self.enable_visualization_of_interfaces = self.__class__.enable_visualization_of_interfaces(service, version, mode, path + ["enable_visualization_of_interfaces"])
                self.transfer_motion_across_interfaces = self.__class__.transfer_motion_across_interfaces(service, version, mode, path + ["transfer_motion_across_interfaces"])
                self.non_overlapping_zone_name = self.__class__.non_overlapping_zone_name(service, version, mode, path + ["non_overlapping_zone_name"])
                self.remove_left_handed_interface_faces = self.__class__.remove_left_handed_interface_faces(service, version, mode, path + ["remove_left_handed_interface_faces"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create a mesh interface.
                """
            class turbo_create(TUIMethod):
                """
                Create a general turbo interface.
                """
            class edit(TUIMethod):
                """
                Edit a mesh interface.
                """
            class delete(TUIMethod):
                """
                Delete a mesh interface.
                """
            class display(TUIMethod):
                """
                Display specified mesh interface zone.
                """
            class list(TUIMethod):
                """
                List all mesh-interfaces.
                """
            class make_periodic(TUIMethod):
                """
                Make interface zones periodic.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                Make interface zones phase lagged.
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                Convert periodic interface to phase lagged.
                """
            class delete_all(TUIMethod):
                """
                Delete all mesh interfaces.
                """
            class enforce_continuity_after_bc(TUIMethod):
                """
                Across the interface, enforces continuity over boundary condition.
                """
            class verbosity(TUIMethod):
                """
                Set mesh interface verbosity.
                """
            class enable_si_with_nodes(TUIMethod):
                """
                Enable sliding interfaces with nodes.
                """
            class enforce_coupled_wall_between_solids(TUIMethod):
                """
                Create coupled wall interface between solids.
                """
            class improve_quality(TUIMethod):
                """
                Improve mesh interface quality.
                """
            class one_to_one_pairing(TUIMethod):
                """
                Use the default one-to-one interface creation method?.
                """
            class auto_pairing(TUIMethod):
                """
                Automatically pair and create mesh interfaces for some or all interface zones.
                """
            class enable_visualization_of_interfaces(TUIMethod):
                """
                Display facets on mesh interfaces.
                """
            class transfer_motion_across_interfaces(TUIMethod):
                """
                Transfer motion from one side of the interface to the other when only one side undergoes user-defined or system-coupling motion.
                """
            class non_overlapping_zone_name(TUIMethod):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
            class remove_left_handed_interface_faces(TUIMethod):
                """
                Remove left-handed faces during mesh interface creation.
                """

            class non_conformal_interface_numerics(TUIMenu):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, service, version, mode, path):
                    self.change_numerics = self.__class__.change_numerics(service, version, mode, path + ["change_numerics"])
                    super().__init__(service, version, mode, path)
                class change_numerics(TUIMethod):
                    """
                    Enable modified non-conformal interface numerics.
                    """

            class mapped_interface_options(TUIMenu):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.solution_controls = self.__class__.solution_controls(service, version, mode, path + ["solution_controls"])
                    self.tolerance = self.__class__.tolerance(service, version, mode, path + ["tolerance"])
                    self.convert_to_mapped_interface = self.__class__.convert_to_mapped_interface(service, version, mode, path + ["convert_to_mapped_interface"])
                    super().__init__(service, version, mode, path)
                class solution_controls(TUIMethod):
                    """
                    Specification of mapped frequency and under-relaxation factor for mapped interfaces.
                    """
                class tolerance(TUIMethod):
                    """
                    Specification of mapped interface tolerance.
                    """
                class convert_to_mapped_interface(TUIMethod):
                    """
                    Convert non-conformal mesh interface to mapped mesh interfaces.
                    """

            class auto_options(TUIMenu):
                """
                Enter auto-options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.proximity_tolerance = self.__class__.proximity_tolerance(service, version, mode, path + ["proximity_tolerance"])
                    self.naming_option = self.__class__.naming_option(service, version, mode, path + ["naming_option"])
                    self.set_default_name_prefix = self.__class__.set_default_name_prefix(service, version, mode, path + ["set_default_name_prefix"])
                    self.set_one_to_one_pairing_tolerance = self.__class__.set_one_to_one_pairing_tolerance(service, version, mode, path + ["set_one_to_one_pairing_tolerance"])
                    self.pairing_between_different_cell_zones_only = self.__class__.pairing_between_different_cell_zones_only(service, version, mode, path + ["pairing_between_different_cell_zones_only"])
                    self.pairing_between_interface_zones_only = self.__class__.pairing_between_interface_zones_only(service, version, mode, path + ["pairing_between_interface_zones_only"])
                    self.keep_empty_interface = self.__class__.keep_empty_interface(service, version, mode, path + ["keep_empty_interface"])
                    super().__init__(service, version, mode, path)
                class proximity_tolerance(TUIMethod):
                    """
                    Specification of auto pairing tolerance.
                    """
                class naming_option(TUIMethod):
                    """
                    Specify whether or not to include an informative suffix to the mesh interface name.
                    """
                class set_default_name_prefix(TUIMethod):
                    """
                    Specification of auto pairing default name prefix.
                    """
                class set_one_to_one_pairing_tolerance(TUIMethod):
                    """
                    Enable/disable one-to-one auto pairing tolerance.
                    """
                class pairing_between_different_cell_zones_only(TUIMethod):
                    """
                    Pairing between interface zones from different cell zones only.
                    """
                class pairing_between_interface_zones_only(TUIMethod):
                    """
                    Pairing between interface zones only.
                    """
                class keep_empty_interface(TUIMethod):
                    """
                    Keep empty interfaces during one-to-one mesh interface creation.
                    """

        class mixing_planes(TUIMenu):
            """
            Enter the mixing planes menu.
            """
            def __init__(self, service, version, mode, path):
                self.set = self.__class__.set(service, version, mode, path + ["set"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create a mixing plane.
                """
            class delete(TUIMethod):
                """
                Delete a mixing plane.
                """
            class list(TUIMethod):
                """
                List defined mixing plane(s).
                """

            class set(TUIMenu):
                """
                Enter the mixing plane set menu.
                """
                def __init__(self, service, version, mode, path):
                    self.conserve_swirl = self.__class__.conserve_swirl(service, version, mode, path + ["conserve_swirl"])
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(service, version, mode, path + ["conserve_total_enthalpy"])
                    self.under_relaxation = self.__class__.under_relaxation(service, version, mode, path + ["under_relaxation"])
                    self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                    self.fix_pressure_level = self.__class__.fix_pressure_level(service, version, mode, path + ["fix_pressure_level"])
                    super().__init__(service, version, mode, path)
                class under_relaxation(TUIMethod):
                    """
                    Set mixing plane under-relaxation factor.
                    """
                class averaging_method(TUIMethod):
                    """
                    Set mixing plane profile averaging method.
                    """
                class fix_pressure_level(TUIMethod):
                    """
                    Set fix pressure level using define/reference-pressure-location.
                    """

                class conserve_swirl(TUIMenu):
                    """
                    Enter the mixing plane conserve-swirl menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.report_swirl_integration = self.__class__.report_swirl_integration(service, version, mode, path + ["report_swirl_integration"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable/disable swirl conservation in mixing plane.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enable/disable verbosity in swirl conservation calculations.
                        """
                    class report_swirl_integration(TUIMethod):
                        """
                        Report swirl integration (torque) on inflow and outflow zones.
                        """

                class conserve_total_enthalpy(TUIMenu):
                    """
                    Enter the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable/disable total enthalpy conservation in mixing plane.
                        """
                    class verbosity(TUIMethod):
                        """
                        Enable/disable verbosity in total-enthalpy conservation calculations.
                        """

        class models(TUIMenu):
            """
            Enter the models menu to configure the solver.
            """
            def __init__(self, service, version, mode, path):
                self.acoustics = self.__class__.acoustics(service, version, mode, path + ["acoustics"])
                self.optics = self.__class__.optics(service, version, mode, path + ["optics"])
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(service, version, mode, path + ["eulerian_wallfilm"])
                self.dpm = self.__class__.dpm(service, version, mode, path + ["dpm"])
                self.shell_conduction = self.__class__.shell_conduction(service, version, mode, path + ["shell_conduction"])
                self.system_coupling_settings = self.__class__.system_coupling_settings(service, version, mode, path + ["system_coupling_settings"])
                self.cht = self.__class__.cht(service, version, mode, path + ["cht"])
                self.two_temperature = self.__class__.two_temperature(service, version, mode, path + ["two_temperature"])
                self.multiphase = self.__class__.multiphase(service, version, mode, path + ["multiphase"])
                self.nox_parameters = self.__class__.nox_parameters(service, version, mode, path + ["nox_parameters"])
                self.soot_parameters = self.__class__.soot_parameters(service, version, mode, path + ["soot_parameters"])
                self.radiation = self.__class__.radiation(service, version, mode, path + ["radiation"])
                self.solver = self.__class__.solver(service, version, mode, path + ["solver"])
                self.species = self.__class__.species(service, version, mode, path + ["species"])
                self.viscous = self.__class__.viscous(service, version, mode, path + ["viscous"])
                self.structure = self.__class__.structure(service, version, mode, path + ["structure"])
                self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                self.electrolysis_setup = self.__class__.electrolysis_setup(service, version, mode, path + ["electrolysis_setup"])
                self.addon_module = self.__class__.addon_module(service, version, mode, path + ["addon_module"])
                self.axisymmetric = self.__class__.axisymmetric(service, version, mode, path + ["axisymmetric"])
                self.solidification_melting = self.__class__.solidification_melting(service, version, mode, path + ["solidification_melting"])
                self.crevice_model = self.__class__.crevice_model(service, version, mode, path + ["crevice_model"])
                self.crevice_model_controls = self.__class__.crevice_model_controls(service, version, mode, path + ["crevice_model_controls"])
                self.energy = self.__class__.energy(service, version, mode, path + ["energy"])
                self.noniterative_time_advance = self.__class__.noniterative_time_advance(service, version, mode, path + ["noniterative_time_advance"])
                self.nox = self.__class__.nox(service, version, mode, path + ["nox"])
                self.soot = self.__class__.soot(service, version, mode, path + ["soot"])
                self.steady = self.__class__.steady(service, version, mode, path + ["steady"])
                self.swirl = self.__class__.swirl(service, version, mode, path + ["swirl"])
                self.unsteady_1st_order = self.__class__.unsteady_1st_order(service, version, mode, path + ["unsteady_1st_order"])
                self.frozen_flux = self.__class__.frozen_flux(service, version, mode, path + ["frozen_flux"])
                self.unsteady_2nd_order = self.__class__.unsteady_2nd_order(service, version, mode, path + ["unsteady_2nd_order"])
                self.unsteady_2nd_order_bounded = self.__class__.unsteady_2nd_order_bounded(service, version, mode, path + ["unsteady_2nd_order_bounded"])
                self.unsteady_global_time = self.__class__.unsteady_global_time(service, version, mode, path + ["unsteady_global_time"])
                self.unsteady_structure_newmark = self.__class__.unsteady_structure_newmark(service, version, mode, path + ["unsteady_structure_newmark"])
                self.unsteady_structure_euler = self.__class__.unsteady_structure_euler(service, version, mode, path + ["unsteady_structure_euler"])
                self.battery_model = self.__class__.battery_model(service, version, mode, path + ["battery_model"])
                self.ablation = self.__class__.ablation(service, version, mode, path + ["ablation"])
                self.potential_and_li_ion_battery = self.__class__.potential_and_li_ion_battery(service, version, mode, path + ["potential_and_li_ion_battery"])
                super().__init__(service, version, mode, path)
            class addon_module(TUIMethod):
                """
                Load addon module.
                """
            class axisymmetric(TUIMethod):
                """
                Enable/disable the axisymmetric model.
                """
            class solidification_melting(TUIMethod):
                """
                Enable/disable the solidification and melting model.
                """
            class crevice_model(TUIMethod):
                """
                Enable/disable the crevice model.
                """
            class crevice_model_controls(TUIMethod):
                """
                Enter the crevice model controls menu.
                """
            class energy(TUIMethod):
                """
                Enable/disable the energy model.
                """
            class noniterative_time_advance(TUIMethod):
                """
                Enable/disable the noniterative time advancement scheme.
                """
            class nox(TUIMethod):
                """
                Enable/disable the NOx model.
                """
            class soot(TUIMethod):
                """
                Enable/disable the soot model.
                """
            class steady(TUIMethod):
                """
                Enable/disable the steady solution model.
                """
            class swirl(TUIMethod):
                """
                Enable/disable axisymmetric swirl velocity.
                """
            class unsteady_1st_order(TUIMethod):
                """
                Enable/disable first-order unsteady solution model.
                """
            class frozen_flux(TUIMethod):
                """
                Enable/disable frozen flux formulation for transient flows.
                """
            class unsteady_2nd_order(TUIMethod):
                """
                Enable/disable the second-order unsteady solution model.
                """
            class unsteady_2nd_order_bounded(TUIMethod):
                """
                Enable/disable bounded second-order unsteady formulation.
                """
            class unsteady_global_time(TUIMethod):
                """
                Enable/disable the unsteady global-time-step solution model.
                """
            class unsteady_structure_newmark(TUIMethod):
                """
                Enable/disable Newmark unsteady solution model.
                """
            class unsteady_structure_euler(TUIMethod):
                """
                Enable/disable Backward Euler unsteady solution model.
                """
            class battery_model(TUIMethod):
                """
                Enter battery model menu.
                """
            class ablation(TUIMethod):
                """
                Enable/disable ablation model.
                """
            class potential_and_li_ion_battery(TUIMethod):
                """
                Enable/disable the electric-potential model.
                """

            class acoustics(TUIMenu):
                """
                Enter the acoustics model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.far_field_parameters = self.__class__.far_field_parameters(service, version, mode, path + ["far_field_parameters"])
                    self.wave_equation_options = self.__class__.wave_equation_options(service, version, mode, path + ["wave_equation_options"])
                    self.sources_fft = self.__class__.sources_fft(service, version, mode, path + ["sources_fft"])
                    self.sponge_layers = self.__class__.sponge_layers(service, version, mode, path + ["sponge_layers"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.ffowcs_williams = self.__class__.ffowcs_williams(service, version, mode, path + ["ffowcs_williams"])
                    self.broad_band_noise = self.__class__.broad_band_noise(service, version, mode, path + ["broad_band_noise"])
                    self.modal_analysis = self.__class__.modal_analysis(service, version, mode, path + ["modal_analysis"])
                    self.wave_equation = self.__class__.wave_equation(service, version, mode, path + ["wave_equation"])
                    self.receivers = self.__class__.receivers(service, version, mode, path + ["receivers"])
                    self.export_source_data = self.__class__.export_source_data(service, version, mode, path + ["export_source_data"])
                    self.export_source_data_cgns = self.__class__.export_source_data_cgns(service, version, mode, path + ["export_source_data_cgns"])
                    self.sources = self.__class__.sources(service, version, mode, path + ["sources"])
                    self.read_compute_write = self.__class__.read_compute_write(service, version, mode, path + ["read_compute_write"])
                    self.write_acoustic_signals = self.__class__.write_acoustic_signals(service, version, mode, path + ["write_acoustic_signals"])
                    self.compute_write = self.__class__.compute_write(service, version, mode, path + ["compute_write"])
                    self.write_centroid_info = self.__class__.write_centroid_info(service, version, mode, path + ["write_centroid_info"])
                    self.acoustic_modal_analysis = self.__class__.acoustic_modal_analysis(service, version, mode, path + ["acoustic_modal_analysis"])
                    self.export_volumetric_sources = self.__class__.export_volumetric_sources(service, version, mode, path + ["export_volumetric_sources"])
                    self.export_volumetric_sources_cgns = self.__class__.export_volumetric_sources_cgns(service, version, mode, path + ["export_volumetric_sources_cgns"])
                    self.display_flow_time = self.__class__.display_flow_time(service, version, mode, path + ["display_flow_time"])
                    self.cylindrical_export = self.__class__.cylindrical_export(service, version, mode, path + ["cylindrical_export"])
                    self.auto_prune = self.__class__.auto_prune(service, version, mode, path + ["auto_prune"])
                    self.moving_receiver = self.__class__.moving_receiver(service, version, mode, path + ["moving_receiver"])
                    self.convective_effects = self.__class__.convective_effects(service, version, mode, path + ["convective_effects"])
                    self.display_frequencies = self.__class__.display_frequencies(service, version, mode, path + ["display_frequencies"])
                    super().__init__(service, version, mode, path)
                class off(TUIMethod):
                    """
                    Enable/disable the acoustics model.
                    """
                class ffowcs_williams(TUIMethod):
                    """
                    Enable/disable the Ffowcs-Williams-and-Hawkings model.
                    """
                class broad_band_noise(TUIMethod):
                    """
                    Enable/disable the broadband noise model.
                    """
                class modal_analysis(TUIMethod):
                    """
                    Enable/disable the modal analysis model.
                    """
                class wave_equation(TUIMethod):
                    """
                    Enable/disable the wave equation model.
                    """
                class receivers(TUIMethod):
                    """
                    Set acoustic receivers.
                    """
                class export_source_data(TUIMethod):
                    """
                    Enable export acoustic source data in ASD format during the wave equation model run.
                    """
                class export_source_data_cgns(TUIMethod):
                    """
                    Export acoustic source data in CGNS format.
                    """
                class sources(TUIMethod):
                    """
                    Set acoustic sources.
                    """
                class read_compute_write(TUIMethod):
                    """
                    Read acoustic source data files and compute sound pressure.
                    """
                class write_acoustic_signals(TUIMethod):
                    """
                    Write on-the-fly sound pressure.
                    """
                class compute_write(TUIMethod):
                    """
                    Compute sound pressure.
                    """
                class write_centroid_info(TUIMethod):
                    """
                    Write centroid info.
                    """
                class acoustic_modal_analysis(TUIMethod):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                class export_volumetric_sources(TUIMethod):
                    """
                    Enable/disable the export of fluid zones.
                    """
                class export_volumetric_sources_cgns(TUIMethod):
                    """
                    Enable/disable the export of fluid zones.
                    """
                class display_flow_time(TUIMethod):
                    """
                    Enable/disable the display of flow time during read-and-compute.
                    """
                class cylindrical_export(TUIMethod):
                    """
                    Enable/disable the export data in cylindrical coordinates.
                    """
                class auto_prune(TUIMethod):
                    """
                    Enable/disable auto prune of the receiver signal(s) during read-and-compute.
                    """
                class moving_receiver(TUIMethod):
                    """
                    Enable/disable moving receiver option.
                    """
                class convective_effects(TUIMethod):
                    """
                    Enable/disable convective effects option.
                    """
                class display_frequencies(TUIMethod):
                    """
                    Display resonance frequencies.
                    """

                class far_field_parameters(TUIMenu):
                    """
                    Enter the far field parameters menu for the wave equation model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.far_field_density = self.__class__.far_field_density(service, version, mode, path + ["far_field_density"])
                        self.far_field_sound_speed = self.__class__.far_field_sound_speed(service, version, mode, path + ["far_field_sound_speed"])
                        super().__init__(service, version, mode, path)
                    class far_field_density(TUIMethod):
                        """
                        Specify far field density.
                        """
                    class far_field_sound_speed(TUIMethod):
                        """
                        Specify far field speed of sound.
                        """

                class wave_equation_options(TUIMenu):
                    """
                    Enter the options menu for the wave equation model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.basic_shapes = self.__class__.basic_shapes(service, version, mode, path + ["basic_shapes"])
                        self.remote_receivers_options = self.__class__.remote_receivers_options(service, version, mode, path + ["remote_receivers_options"])
                        self.time_filter_source = self.__class__.time_filter_source(service, version, mode, path + ["time_filter_source"])
                        self.sponge_layer_factor = self.__class__.sponge_layer_factor(service, version, mode, path + ["sponge_layer_factor"])
                        self.sponge_layer_base_level = self.__class__.sponge_layer_base_level(service, version, mode, path + ["sponge_layer_base_level"])
                        self.source_mask_udf = self.__class__.source_mask_udf(service, version, mode, path + ["source_mask_udf"])
                        self.sponge_layer_udf = self.__class__.sponge_layer_udf(service, version, mode, path + ["sponge_layer_udf"])
                        self.remote_receivers = self.__class__.remote_receivers(service, version, mode, path + ["remote_receivers"])
                        super().__init__(service, version, mode, path)
                    class time_filter_source(TUIMethod):
                        """
                        Activate time-filtering of sound sources.
                        """
                    class sponge_layer_factor(TUIMethod):
                        """
                        Specify artificial viscosity factor for sponge layer.
                        """
                    class sponge_layer_base_level(TUIMethod):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                    class source_mask_udf(TUIMethod):
                        """
                        Select user-defined function for sound source masking.
                        """
                    class sponge_layer_udf(TUIMethod):
                        """
                        Select user-defined function for sponge layer.
                        """
                    class remote_receivers(TUIMethod):
                        """
                        Activate the Kirchhoff's integral method for remote receivers.
                        """

                    class basic_shapes(TUIMenu):
                        """
                        Enter the basic shapes menu to build source mask and sponge layer
                        geometry shapes using cell registers.
                        """
                        def __init__(self, service, version, mode, path):
                            self.list_region_registers = self.__class__.list_region_registers(service, version, mode, path + ["list_region_registers"])
                            self.list_source_mask_shapes = self.__class__.list_source_mask_shapes(service, version, mode, path + ["list_source_mask_shapes"])
                            self.list_sponge_layer_shapes = self.__class__.list_sponge_layer_shapes(service, version, mode, path + ["list_sponge_layer_shapes"])
                            self.add_source_mask_shape = self.__class__.add_source_mask_shape(service, version, mode, path + ["add_source_mask_shape"])
                            self.add_sponge_layer_shape = self.__class__.add_sponge_layer_shape(service, version, mode, path + ["add_sponge_layer_shape"])
                            self.remove_source_mask_shape = self.__class__.remove_source_mask_shape(service, version, mode, path + ["remove_source_mask_shape"])
                            self.remove_sponge_layer_shape = self.__class__.remove_sponge_layer_shape(service, version, mode, path + ["remove_sponge_layer_shape"])
                            super().__init__(service, version, mode, path)
                        class list_region_registers(TUIMethod):
                            """
                            List all available region registers (hex/cylinder/sphere).
                            """
                        class list_source_mask_shapes(TUIMethod):
                            """
                            List all active source mask registers.
                            """
                        class list_sponge_layer_shapes(TUIMethod):
                            """
                            List all active sponge layer registers.
                            """
                        class add_source_mask_shape(TUIMethod):
                            """
                            Add a region register for the source mask.
                            """
                        class add_sponge_layer_shape(TUIMethod):
                            """
                            Add a region register for the sponge layer.
                            """
                        class remove_source_mask_shape(TUIMethod):
                            """
                            Remove a region register from the source mask.
                            """
                        class remove_sponge_layer_shape(TUIMethod):
                            """
                            Remove a region register from the sponge layer.
                            """

                    class remote_receivers_options(TUIMenu):
                        """
                        Enter the menu to set up the Kirchhoff's integral method and output its results.
                        """
                        def __init__(self, service, version, mode, path):
                            self.integration_surface = self.__class__.integration_surface(service, version, mode, path + ["integration_surface"])
                            self.write_signals = self.__class__.write_signals(service, version, mode, path + ["write_signals"])
                            super().__init__(service, version, mode, path)
                        class integration_surface(TUIMethod):
                            """
                            Select Kirchhoff's integration surface.
                            """
                        class write_signals(TUIMethod):
                            """
                            Write signals calculated at receiver locations.
                            """

                class sources_fft(TUIMenu):
                    """
                    Enter the acoustic sources FFT menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.fft_surface_variables = self.__class__.fft_surface_variables(service, version, mode, path + ["fft_surface_variables"])
                        self.read_asd_files = self.__class__.read_asd_files(service, version, mode, path + ["read_asd_files"])
                        self.compute_fft_fields = self.__class__.compute_fft_fields(service, version, mode, path + ["compute_fft_fields"])
                        self.write_cgns_files = self.__class__.write_cgns_files(service, version, mode, path + ["write_cgns_files"])
                        self.clean_up_storage_area = self.__class__.clean_up_storage_area(service, version, mode, path + ["clean_up_storage_area"])
                        super().__init__(service, version, mode, path)
                    class read_asd_files(TUIMethod):
                        """
                        Read ASD files.
                        """
                    class compute_fft_fields(TUIMethod):
                        """
                        Compute FFT fields.
                        """
                    class write_cgns_files(TUIMethod):
                        """
                        Write CGNS files.
                        """
                    class clean_up_storage_area(TUIMethod):
                        """
                        Clean up storage area.
                        """

                    class fft_surface_variables(TUIMenu):
                        """
                        Enter the FFT surface variables menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create_octave_bands = self.__class__.create_octave_bands(service, version, mode, path + ["create_octave_bands"])
                            self.create_third_bands = self.__class__.create_third_bands(service, version, mode, path + ["create_third_bands"])
                            self.create_constant_width_bands = self.__class__.create_constant_width_bands(service, version, mode, path + ["create_constant_width_bands"])
                            self.create_set_of_modes = self.__class__.create_set_of_modes(service, version, mode, path + ["create_set_of_modes"])
                            self.remove_variables = self.__class__.remove_variables(service, version, mode, path + ["remove_variables"])
                            super().__init__(service, version, mode, path)
                        class create_octave_bands(TUIMethod):
                            """
                            Create octave bands.
                            """
                        class create_third_bands(TUIMethod):
                            """
                            Create third bands.
                            """
                        class create_constant_width_bands(TUIMethod):
                            """
                            Create constant-width bands.
                            """
                        class create_set_of_modes(TUIMethod):
                            """
                            Create set of modes.
                            """
                        class remove_variables(TUIMethod):
                            """
                            Remove variables.
                            """

                class sponge_layers(TUIMenu):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, service, version, mode, path):
                        self.activate = self.__class__.activate(service, version, mode, path + ["activate"])
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.deactivate = self.__class__.deactivate(service, version, mode, path + ["deactivate"])
                        self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.list_active = self.__class__.list_active(service, version, mode, path + ["list_active"])
                        self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                        super().__init__(service, version, mode, path)
                    class activate(TUIMethod):
                        """
                        Activate a sponge object.
                        """
                    class add(TUIMethod):
                        """
                        Add a new sponge layer definition.
                        """
                    class deactivate(TUIMethod):
                        """
                        Deactivate a sponge layer definition.
                        """
                    class edit(TUIMethod):
                        """
                        Edit a sponge layer definition.
                        """
                    class delete(TUIMethod):
                        """
                        Delete a sponge layer definition.
                        """
                    class list(TUIMethod):
                        """
                        List the names of the sponge layer definitions.
                        """
                    class list_active(TUIMethod):
                        """
                        List the names of the active sponge layer definitions.
                        """
                    class list_properties(TUIMethod):
                        """
                        List the properties of a sponge layer definition.
                        """

            class optics(TUIMenu):
                """
                Enter the optics model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.add_beam = self.__class__.add_beam(service, version, mode, path + ["add_beam"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable/disable optics model.
                    """
                class add_beam(TUIMethod):
                    """
                    Add optical beam grid.
                    """

                class set(TUIMenu):
                    """
                    Enter the set menu for optics model.
                    """
                    def __init__(self, service, version, mode, path):
                        self.sampling = self.__class__.sampling(service, version, mode, path + ["sampling"])
                        self.index_of_refraction = self.__class__.index_of_refraction(service, version, mode, path + ["index_of_refraction"])
                        self.running_average = self.__class__.running_average(service, version, mode, path + ["running_average"])
                        super().__init__(service, version, mode, path)
                    class sampling(TUIMethod):
                        """
                        Specify when the fluid density field is sampled.
                        """
                    class index_of_refraction(TUIMethod):
                        """
                        Specify the model parameters of index of refraction.
                        """
                    class running_average(TUIMethod):
                        """
                        Setup the running average of the collected density field.
                        """

            class eulerian_wallfilm(TUIMenu):
                """
                Enter the Eulerian wall film model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.coupled_solution = self.__class__.coupled_solution(service, version, mode, path + ["coupled_solution"])
                    self.implicit_options = self.__class__.implicit_options(service, version, mode, path + ["implicit_options"])
                    self.enable_wallfilm_model = self.__class__.enable_wallfilm_model(service, version, mode, path + ["enable_wallfilm_model"])
                    self.initialize_wallfilm_model = self.__class__.initialize_wallfilm_model(service, version, mode, path + ["initialize_wallfilm_model"])
                    self.solve_wallfilm_equation = self.__class__.solve_wallfilm_equation(service, version, mode, path + ["solve_wallfilm_equation"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.film_material = self.__class__.film_material(service, version, mode, path + ["film_material"])
                    self.solution_options = self.__class__.solution_options(service, version, mode, path + ["solution_options"])
                    super().__init__(service, version, mode, path)
                class enable_wallfilm_model(TUIMethod):
                    """
                    Enable Eulerian wall film model.
                    """
                class initialize_wallfilm_model(TUIMethod):
                    """
                    Initialize Eulerian wall film model.
                    """
                class solve_wallfilm_equation(TUIMethod):
                    """
                    Activate Eulerian wall film equations.
                    """
                class model_options(TUIMethod):
                    """
                    Set Eulerian wall film model options.
                    """
                class film_material(TUIMethod):
                    """
                    Set film material and properties.
                    """
                class solution_options(TUIMethod):
                    """
                    Set Eulerian wall film model solution options.
                    """

                class coupled_solution(TUIMenu):
                    """
                    Enter Eulerian wall film coupled solution menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_coupled_solution = self.__class__.enable_coupled_solution(service, version, mode, path + ["enable_coupled_solution"])
                        self.enable_curvature_smoothing = self.__class__.enable_curvature_smoothing(service, version, mode, path + ["enable_curvature_smoothing"])
                        super().__init__(service, version, mode, path)
                    class enable_coupled_solution(TUIMethod):
                        """
                        Enable Eulerian wall film coupled solution.
                        """
                    class enable_curvature_smoothing(TUIMethod):
                        """
                        Enable Eulerian wall film curvature smoothing.
                        """

                class implicit_options(TUIMenu):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, service, version, mode, path):
                        self.new_implicit_scheme = self.__class__.new_implicit_scheme(service, version, mode, path + ["new_implicit_scheme"])
                        self.relative_error_residual = self.__class__.relative_error_residual(service, version, mode, path + ["relative_error_residual"])
                        super().__init__(service, version, mode, path)
                    class new_implicit_scheme(TUIMethod):
                        """
                        Enable alternative implicit scheme.
                        """
                    class relative_error_residual(TUIMethod):
                        """
                        Enable relative error residual.
                        """

            class dpm(TUIMenu):
                """
                Enter the dispersed phase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.collisions = self.__class__.collisions(service, version, mode, path + ["collisions"])
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(service, version, mode, path + ["erosion_dynamic_mesh"])
                    self.interaction = self.__class__.interaction(service, version, mode, path + ["interaction"])
                    self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                    self.options = self.__class__.options(service, version, mode, path + ["options"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.splash_options = self.__class__.splash_options(service, version, mode, path + ["splash_options"])
                    self.stripping_options = self.__class__.stripping_options(service, version, mode, path + ["stripping_options"])
                    self.clear_particles_from_domain = self.__class__.clear_particles_from_domain(service, version, mode, path + ["clear_particles_from_domain"])
                    self.fill_injection_material_sources = self.__class__.fill_injection_material_sources(service, version, mode, path + ["fill_injection_material_sources"])
                    self.injections = self.__class__.injections(service, version, mode, path + ["injections"])
                    self.unsteady_tracking = self.__class__.unsteady_tracking(service, version, mode, path + ["unsteady_tracking"])
                    self.spray_model = self.__class__.spray_model(service, version, mode, path + ["spray_model"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    super().__init__(service, version, mode, path)
                class clear_particles_from_domain(TUIMethod):
                    """
                    Remove/keep all particles currently in the domain.
                    """
                class fill_injection_material_sources(TUIMethod):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                class injections(TUIMethod):
                    """
                    Enter the injections menu.
                    """
                class unsteady_tracking(TUIMethod):
                    """
                    Enable/disable unsteady particle tracking.
                    """
                class spray_model(TUIMethod):
                    """
                    Enter the spray model menu.
                    """
                class user_defined(TUIMethod):
                    """
                    Set DPM user-defined functions.
                    """

                class collisions(TUIMenu):
                    """
                    Enter the DEM collisions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.collision_partners = self.__class__.collision_partners(service, version, mode, path + ["collision_partners"])
                        self.collision_pair_settings = self.__class__.collision_pair_settings(service, version, mode, path + ["collision_pair_settings"])
                        self.list_all_pair_settings = self.__class__.list_all_pair_settings(service, version, mode, path + ["list_all_pair_settings"])
                        self.dem_collisions = self.__class__.dem_collisions(service, version, mode, path + ["dem_collisions"])
                        self.collision_mesh = self.__class__.collision_mesh(service, version, mode, path + ["collision_mesh"])
                        self.max_particle_velocity = self.__class__.max_particle_velocity(service, version, mode, path + ["max_particle_velocity"])
                        super().__init__(service, version, mode, path)
                    class collision_pair_settings(TUIMethod):
                        """
                        Supply settings for collisions to a pair of collision partners.
                        """
                    class list_all_pair_settings(TUIMethod):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                    class dem_collisions(TUIMethod):
                        """
                        Enable/disable the DEM collision model.
                        """
                    class collision_mesh(TUIMethod):
                        """
                        Input for the collision mesh.
                        """
                    class max_particle_velocity(TUIMethod):
                        """
                        Set the maximum particle velocity that may arise from collisions.
                        """

                    class collision_partners(TUIMenu):
                        """
                        Manage collision partners.
                        """
                        def __init__(self, service, version, mode, path):
                            self.create = self.__class__.create(service, version, mode, path + ["create"])
                            self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                            self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                            self.rename = self.__class__.rename(service, version, mode, path + ["rename"])
                            self.list = self.__class__.list(service, version, mode, path + ["list"])
                            super().__init__(service, version, mode, path)
                        class create(TUIMethod):
                            """
                            Create a collision partner.
                            """
                        class delete(TUIMethod):
                            """
                            Delete a collision partner.
                            """
                        class copy(TUIMethod):
                            """
                            Copy a collision partner.
                            """
                        class rename(TUIMethod):
                            """
                            Rename a collision partner.
                            """
                        class list(TUIMethod):
                            """
                            Lists all known collision partners.
                            """

                class erosion_dynamic_mesh(TUIMenu):
                    """
                    Enter the erosion-dynamic mesh interactions menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.general_parameters = self.__class__.general_parameters(service, version, mode, path + ["general_parameters"])
                        self.run_parameters = self.__class__.run_parameters(service, version, mode, path + ["run_parameters"])
                        self.enable_erosion_dynamic_mesh_coupling = self.__class__.enable_erosion_dynamic_mesh_coupling(service, version, mode, path + ["enable_erosion_dynamic_mesh_coupling"])
                        self.run_simulation = self.__class__.run_simulation(service, version, mode, path + ["run_simulation"])
                        super().__init__(service, version, mode, path)
                    class enable_erosion_dynamic_mesh_coupling(TUIMethod):
                        """
                        Enable mesh deformation due to wall erosion.
                        """
                    class run_simulation(TUIMethod):
                        """
                        Perform coupled erosion-dynamic mesh simulation.
                        """

                    class general_parameters(TUIMenu):
                        """
                        Enter the erosion-dynamic mesh setup menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.erosion_settings = self.__class__.erosion_settings(service, version, mode, path + ["erosion_settings"])
                            self.dynamic_mesh_settings = self.__class__.dynamic_mesh_settings(service, version, mode, path + ["dynamic_mesh_settings"])
                            self.participating_walls = self.__class__.participating_walls(service, version, mode, path + ["participating_walls"])
                            super().__init__(service, version, mode, path)
                        class erosion_settings(TUIMethod):
                            """
                            Set erosion modelling specific settings.
                            """
                        class dynamic_mesh_settings(TUIMethod):
                            """
                            Perform dynamic mesh related setup.
                            """
                        class participating_walls(TUIMethod):
                            """
                            Specify all participating walls.
                            """

                    class run_parameters(TUIMenu):
                        """
                        Enter the erosion-dynamic mesh run menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.mesh_motion_time_step = self.__class__.mesh_motion_time_step(service, version, mode, path + ["mesh_motion_time_step"])
                            self.simulation_termination = self.__class__.simulation_termination(service, version, mode, path + ["simulation_termination"])
                            self.flow_simulation_control = self.__class__.flow_simulation_control(service, version, mode, path + ["flow_simulation_control"])
                            self.autosave_files = self.__class__.autosave_files(service, version, mode, path + ["autosave_files"])
                            self.autosave_graphics = self.__class__.autosave_graphics(service, version, mode, path + ["autosave_graphics"])
                            super().__init__(service, version, mode, path)
                        class mesh_motion_time_step(TUIMethod):
                            """
                            Set the mesh motion time stepping parameters and method.
                            """
                        class simulation_termination(TUIMethod):
                            """
                            Set total time of erosion.
                            """
                        class flow_simulation_control(TUIMethod):
                            """
                            Set number of iterations per flow simulation step.
                            """
                        class autosave_files(TUIMethod):
                            """
                            Set the iteration increment to save data files.
                            """
                        class autosave_graphics(TUIMethod):
                            """
                            Set the iteration increment to save graphics files.
                            """

                class interaction(TUIMenu):
                    """
                    Enter the interaction menu to set parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, service, version, mode, path):
                        self.choice_of_eulerian_phase_for_interaction = self.__class__.choice_of_eulerian_phase_for_interaction(service, version, mode, path + ["choice_of_eulerian_phase_for_interaction"])
                        self.coupled_calculations = self.__class__.coupled_calculations(service, version, mode, path + ["coupled_calculations"])
                        self.dpm_iteration_interval = self.__class__.dpm_iteration_interval(service, version, mode, path + ["dpm_iteration_interval"])
                        self.underrelaxation_factor = self.__class__.underrelaxation_factor(service, version, mode, path + ["underrelaxation_factor"])
                        self.implicit_momentum_coupling = self.__class__.implicit_momentum_coupling(service, version, mode, path + ["implicit_momentum_coupling"])
                        self.implicit_source_term_coupling = self.__class__.implicit_source_term_coupling(service, version, mode, path + ["implicit_source_term_coupling"])
                        self.linearized_dpm_source_terms = self.__class__.linearized_dpm_source_terms(service, version, mode, path + ["linearized_dpm_source_terms"])
                        self.replace_dpm_mass_source_by_mixture_fraction = self.__class__.replace_dpm_mass_source_by_mixture_fraction(service, version, mode, path + ["replace_dpm_mass_source_by_mixture_fraction"])
                        self.linearized_dpm_mixture_fraction_source_terms = self.__class__.linearized_dpm_mixture_fraction_source_terms(service, version, mode, path + ["linearized_dpm_mixture_fraction_source_terms"])
                        self.linearized_dpm_species_source_terms = self.__class__.linearized_dpm_species_source_terms(service, version, mode, path + ["linearized_dpm_species_source_terms"])
                        self.keep_linearized_dpm_source_terms_constant = self.__class__.keep_linearized_dpm_source_terms_constant(service, version, mode, path + ["keep_linearized_dpm_source_terms_constant"])
                        self.linearized_dpm_source_terms_limiter = self.__class__.linearized_dpm_source_terms_limiter(service, version, mode, path + ["linearized_dpm_source_terms_limiter"])
                        self.update_dpm_sources_every_flow_iteration = self.__class__.update_dpm_sources_every_flow_iteration(service, version, mode, path + ["update_dpm_sources_every_flow_iteration"])
                        self.linear_growth_of_dpm_source_term = self.__class__.linear_growth_of_dpm_source_term(service, version, mode, path + ["linear_growth_of_dpm_source_term"])
                        self.reset_sources_at_timestep = self.__class__.reset_sources_at_timestep(service, version, mode, path + ["reset_sources_at_timestep"])
                        self.enable_flow_blocking_by_particles = self.__class__.enable_flow_blocking_by_particles(service, version, mode, path + ["enable_flow_blocking_by_particles"])
                        self.enable_source_scaling_due_to_flow_blocking = self.__class__.enable_source_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_source_scaling_due_to_flow_blocking"])
                        self.enable_drag_scaling_due_to_flow_blocking = self.__class__.enable_drag_scaling_due_to_flow_blocking(service, version, mode, path + ["enable_drag_scaling_due_to_flow_blocking"])
                        self.max_vf_allowed_for_blocking = self.__class__.max_vf_allowed_for_blocking(service, version, mode, path + ["max_vf_allowed_for_blocking"])
                        self.min_vf_threshold_for_dpm_src_scaling = self.__class__.min_vf_threshold_for_dpm_src_scaling(service, version, mode, path + ["min_vf_threshold_for_dpm_src_scaling"])
                        self.ddpm_iad_particle = self.__class__.ddpm_iad_particle(service, version, mode, path + ["ddpm_iad_particle"])
                        self.ddpm_energy_coupling_via_source_term = self.__class__.ddpm_energy_coupling_via_source_term(service, version, mode, path + ["ddpm_energy_coupling_via_source_term"])
                        self.ddpm_enhanced_inter_phase_exchange = self.__class__.ddpm_enhanced_inter_phase_exchange(service, version, mode, path + ["ddpm_enhanced_inter_phase_exchange"])
                        super().__init__(service, version, mode, path)
                    class choice_of_eulerian_phase_for_interaction(TUIMethod):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                    class coupled_calculations(TUIMethod):
                        """
                        Enable/disable coupling of continuous and discrete phase calculations.
                        """
                    class dpm_iteration_interval(TUIMethod):
                        """
                        Set the number of continuous phase iterations per DPM iteration.
                        """
                    class underrelaxation_factor(TUIMethod):
                        """
                        Set the under-relaxation factor.
                        """
                    class implicit_momentum_coupling(TUIMethod):
                        """
                        Enable/disable implicit treatment for the DPM momentum source terms.
                        """
                    class implicit_source_term_coupling(TUIMethod):
                        """
                        Enable/disable implicit treatment for all DPM source terms.
                        """
                    class linearized_dpm_source_terms(TUIMethod):
                        """
                        Perform a linearization of all DPM source terms to increase numerical robustness.
                        """
                    class replace_dpm_mass_source_by_mixture_fraction(TUIMethod):
                        """
                        Recalculate the mixture fraction source terms as function of the primary mixture fraction?.
                        """
                    class linearized_dpm_mixture_fraction_source_terms(TUIMethod):
                        """
                        Perform a linearization of mixture fraction source terms.
                        """
                    class linearized_dpm_species_source_terms(TUIMethod):
                        """
                        Perform linearization of species source terms.
                        """
                    class keep_linearized_dpm_source_terms_constant(TUIMethod):
                        """
                        Keep linearized DPM source terms constant until the next DPM Update.
                        """
                    class linearized_dpm_source_terms_limiter(TUIMethod):
                        """
                        Relative limit for DPM source linear coefficient with respect to fluid linear Ap coefficient.
                        """
                    class update_dpm_sources_every_flow_iteration(TUIMethod):
                        """
                        Enable/disable the update of DPM source terms every flow iteration.
                        (if not, the terms will be updated every DPM iteration).
                        """
                    class linear_growth_of_dpm_source_term(TUIMethod):
                        """
                        Enable/disable the linear growth of DPM source terms every DPM iteration.
                        .
                        """
                    class reset_sources_at_timestep(TUIMethod):
                        """
                        Enable/disable flush of DPM source terms at beginning of every time step.
                        """
                    class enable_flow_blocking_by_particles(TUIMethod):
                        """
                        Enable/disable inclusion of DPM volume fraction in continuous flow.
                        """
                    class enable_source_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                    class enable_drag_scaling_due_to_flow_blocking(TUIMethod):
                        """
                        Enable/disable scaling of DPM drag coefficient due to inclusion of DPM volume fraction in continuous flow.
                        """
                    class max_vf_allowed_for_blocking(TUIMethod):
                        """
                        Maximum DPM volume fraction used in continuous flow.
                        """
                    class min_vf_threshold_for_dpm_src_scaling(TUIMethod):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                    class ddpm_iad_particle(TUIMethod):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                    class ddpm_energy_coupling_via_source_term(TUIMethod):
                        """
                        Energy coupling in DDPM established via source term.
                        """
                    class ddpm_enhanced_inter_phase_exchange(TUIMethod):
                        """
                        Enhanced Eulerian inter-phase exchange.
                        """

                class numerics(TUIMenu):
                    """
                    Enter the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(service, version, mode, path + ["high_resolution_tracking"])
                        self.coupled_heat_mass_update = self.__class__.coupled_heat_mass_update(service, version, mode, path + ["coupled_heat_mass_update"])
                        self.minimum_liquid_fraction = self.__class__.minimum_liquid_fraction(service, version, mode, path + ["minimum_liquid_fraction"])
                        self.underrelax_film_height = self.__class__.underrelax_film_height(service, version, mode, path + ["underrelax_film_height"])
                        self.vaporization_limiting_factors = self.__class__.vaporization_limiting_factors(service, version, mode, path + ["vaporization_limiting_factors"])
                        self.tracking_parameters = self.__class__.tracking_parameters(service, version, mode, path + ["tracking_parameters"])
                        self.tracking_scheme = self.__class__.tracking_scheme(service, version, mode, path + ["tracking_scheme"])
                        self.tracking_statistics = self.__class__.tracking_statistics(service, version, mode, path + ["tracking_statistics"])
                        self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                        self.error_control = self.__class__.error_control(service, version, mode, path + ["error_control"])
                        self.automated_scheme_selection = self.__class__.automated_scheme_selection(service, version, mode, path + ["automated_scheme_selection"])
                        self.drag_law = self.__class__.drag_law(service, version, mode, path + ["drag_law"])
                        self.enable_node_based_averaging = self.__class__.enable_node_based_averaging(service, version, mode, path + ["enable_node_based_averaging"])
                        self.average_source_terms = self.__class__.average_source_terms(service, version, mode, path + ["average_source_terms"])
                        self.average_DDPM_variables = self.__class__.average_DDPM_variables(service, version, mode, path + ["average_DDPM_variables"])
                        self.average_each_step = self.__class__.average_each_step(service, version, mode, path + ["average_each_step"])
                        self.average_kernel = self.__class__.average_kernel(service, version, mode, path + ["average_kernel"])
                        self.gaussian_factor = self.__class__.gaussian_factor(service, version, mode, path + ["gaussian_factor"])
                        self.mppic_settings = self.__class__.mppic_settings(service, version, mode, path + ["mppic_settings"])
                        self.enhanced_packing_limit_numerics = self.__class__.enhanced_packing_limit_numerics(service, version, mode, path + ["enhanced_packing_limit_numerics"])
                        super().__init__(service, version, mode, path)
                    class coupled_heat_mass_update(TUIMethod):
                        """
                        Enable/disable coupled heat and mass update.
                        """
                    class minimum_liquid_fraction(TUIMethod):
                        """
                        Evaporate droplet completely when the remaining mass is below this fraction of initial mass.
                        """
                    class underrelax_film_height(TUIMethod):
                        """
                        Define underrelaxation factor for film height.
                        """
                    class vaporization_limiting_factors(TUIMethod):
                        """
                        Set Vaporization Fractional Change Limits.
                        """
                    class tracking_parameters(TUIMethod):
                        """
                        Set parameters for the (initial) tracking step length.
                        """
                    class tracking_scheme(TUIMethod):
                        """
                        Specify a tracking scheme.
                        """
                    class tracking_statistics(TUIMethod):
                        """
                        Control the format of the one-line tracking statistics printed after every DPM tracking pass.
                        """
                    class verbosity(TUIMethod):
                        """
                        Adjust the DPM tracker's verbosity level.
                        """
                    class error_control(TUIMethod):
                        """
                        Set the adapt integration step length based on a maximum error.
                        """
                    class automated_scheme_selection(TUIMethod):
                        """
                        Enable/disable the adaptation of integration step length based on a maximum error.
                        """
                    class drag_law(TUIMethod):
                        """
                        Set the drag law.
                        """
                    class enable_node_based_averaging(TUIMethod):
                        """
                        Enable node based averaging of DPM variables.
                        """
                    class average_source_terms(TUIMethod):
                        """
                        Average DPM source terms on nodes.
                        """
                    class average_DDPM_variables(TUIMethod):
                        """
                        Average DDPM specific variables like volume fractions and velocities on nodes.
                        """
                    class average_each_step(TUIMethod):
                        """
                        Do the averaging after each integration step for higher accuracy at a higher cost.
                        """
                    class average_kernel(TUIMethod):
                        """
                        Specify a kernel for the averaging.
                        """
                    class gaussian_factor(TUIMethod):
                        """
                        Set a factor for the gaussian kernel for node-based averaging.~%Large values give small size, small values give large size of kernel.
                        """
                    class mppic_settings(TUIMethod):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                    class enhanced_packing_limit_numerics(TUIMethod):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """

                    class high_resolution_tracking(TUIMenu):
                        """
                        Enter the high resolution tracking menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(service, version, mode, path + ["barycentric_interpolation"])
                            self.particle_relocation = self.__class__.particle_relocation(service, version, mode, path + ["particle_relocation"])
                            self.enable_high_resolution_tracking = self.__class__.enable_high_resolution_tracking(service, version, mode, path + ["enable_high_resolution_tracking"])
                            self.enable_barycentric_intersections = self.__class__.enable_barycentric_intersections(service, version, mode, path + ["enable_barycentric_intersections"])
                            self.use_barycentric_sampling = self.__class__.use_barycentric_sampling(service, version, mode, path + ["use_barycentric_sampling"])
                            self.use_velocity_based_error_control = self.__class__.use_velocity_based_error_control(service, version, mode, path + ["use_velocity_based_error_control"])
                            self.use_quad_face_centroid = self.__class__.use_quad_face_centroid(service, version, mode, path + ["use_quad_face_centroid"])
                            self.check_subtet_validity = self.__class__.check_subtet_validity(service, version, mode, path + ["check_subtet_validity"])
                            self.always_use_face_centroid_with_periodics = self.__class__.always_use_face_centroid_with_periodics(service, version, mode, path + ["always_use_face_centroid_with_periodics"])
                            self.boundary_layer_tracking = self.__class__.boundary_layer_tracking(service, version, mode, path + ["boundary_layer_tracking"])
                            self.sliding_interface_crossover_fraction = self.__class__.sliding_interface_crossover_fraction(service, version, mode, path + ["sliding_interface_crossover_fraction"])
                            self.project_wall_film_particles_to_film = self.__class__.project_wall_film_particles_to_film(service, version, mode, path + ["project_wall_film_particles_to_film"])
                            self.use_particle_timestep_for_intersection_tolerance = self.__class__.use_particle_timestep_for_intersection_tolerance(service, version, mode, path + ["use_particle_timestep_for_intersection_tolerance"])
                            self.enable_automatic_intersection_tolerance = self.__class__.enable_automatic_intersection_tolerance(service, version, mode, path + ["enable_automatic_intersection_tolerance"])
                            self.set_film_spreading_parameter = self.__class__.set_film_spreading_parameter(service, version, mode, path + ["set_film_spreading_parameter"])
                            self.set_subtet_intersection_tolerance = self.__class__.set_subtet_intersection_tolerance(service, version, mode, path + ["set_subtet_intersection_tolerance"])
                            super().__init__(service, version, mode, path)
                        class enable_high_resolution_tracking(TUIMethod):
                            """
                            Enable high resolution tracking.
                            """
                        class enable_barycentric_intersections(TUIMethod):
                            """
                            Use barycentric coordinates for intersection calculations.
                            """
                        class use_barycentric_sampling(TUIMethod):
                            """
                            Use barycentric coordinates when sampling at planes.
                            """
                        class use_velocity_based_error_control(TUIMethod):
                            """
                            Use adaptive time stepping based upon the particle velocity.
                            """
                        class use_quad_face_centroid(TUIMethod):
                            """
                            Use quad face centroids when creating subtets.
                            """
                        class check_subtet_validity(TUIMethod):
                            """
                            Test for inverted subtets due to warped cells.
                            """
                        class always_use_face_centroid_with_periodics(TUIMethod):
                            """
                            Use quad face centroids when creating subtets if the case contains periodic boundaries.
                            """
                        class boundary_layer_tracking(TUIMethod):
                            """
                            Adjust the particle timestep to account for high aspect ratio cells.
                            """
                        class sliding_interface_crossover_fraction(TUIMethod):
                            """
                            Move the particle a fraction of the distance to the subtet center when crossing a sliding interface.
                            """
                        class project_wall_film_particles_to_film(TUIMethod):
                            """
                            Project existing particles to film to track using high resolution tracking?.
                            """
                        class use_particle_timestep_for_intersection_tolerance(TUIMethod):
                            """
                            Use the particle timestep for the axisymmetric subtet intersection tolerance.
                            """
                        class enable_automatic_intersection_tolerance(TUIMethod):
                            """
                            Enable automatic scaling of subtet intersection tolerance.
                            """
                        class set_film_spreading_parameter(TUIMethod):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                        class set_subtet_intersection_tolerance(TUIMethod):
                            """
                            Set the tolerance for subtet intersection calculations.
                            """

                        class barycentric_interpolation(TUIMenu):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.interpolate_flow_solution_gradients = self.__class__.interpolate_flow_solution_gradients(service, version, mode, path + ["interpolate_flow_solution_gradients"])
                                self.interpolate_temperature = self.__class__.interpolate_temperature(service, version, mode, path + ["interpolate_temperature"])
                                self.interpolate_flow_density = self.__class__.interpolate_flow_density(service, version, mode, path + ["interpolate_flow_density"])
                                self.interpolate_flow_cp = self.__class__.interpolate_flow_cp(service, version, mode, path + ["interpolate_flow_cp"])
                                self.interpolate_flow_viscosity = self.__class__.interpolate_flow_viscosity(service, version, mode, path + ["interpolate_flow_viscosity"])
                                self.interpolate_wallfilm_properties = self.__class__.interpolate_wallfilm_properties(service, version, mode, path + ["interpolate_wallfilm_properties"])
                                self.precompute_pdf_species = self.__class__.precompute_pdf_species(service, version, mode, path + ["precompute_pdf_species"])
                                self.zero_nodal_velocity_on_walls = self.__class__.zero_nodal_velocity_on_walls(service, version, mode, path + ["zero_nodal_velocity_on_walls"])
                                self.enable_transient_variable_interpolation = self.__class__.enable_transient_variable_interpolation(service, version, mode, path + ["enable_transient_variable_interpolation"])
                                self.nodal_reconstruction_frequency = self.__class__.nodal_reconstruction_frequency(service, version, mode, path + ["nodal_reconstruction_frequency"])
                                self.user_interpolation_function = self.__class__.user_interpolation_function(service, version, mode, path + ["user_interpolation_function"])
                                super().__init__(service, version, mode, path)
                            class interpolate_flow_solution_gradients(TUIMethod):
                                """
                                Enable interpolation of flow solution gradients.
                                """
                            class interpolate_temperature(TUIMethod):
                                """
                                Enable interpolation of temperature to the particle position.
                                """
                            class interpolate_flow_density(TUIMethod):
                                """
                                Enable interpolation of flow density to the particle position.
                                """
                            class interpolate_flow_cp(TUIMethod):
                                """
                                Enable interpolation of flow specific heat to the particle position.
                                """
                            class interpolate_flow_viscosity(TUIMethod):
                                """
                                Enable interpolation of flow viscosity to the particle position.
                                """
                            class interpolate_wallfilm_properties(TUIMethod):
                                """
                                Enable interpolation of wallfilm properties to the particle position.
                                """
                            class precompute_pdf_species(TUIMethod):
                                """
                                Precompute cell values of PDF species mass fractions prior to particle tracking.
                                """
                            class zero_nodal_velocity_on_walls(TUIMethod):
                                """
                                Set the nodal velocity on all walls to zero.
                                """
                            class enable_transient_variable_interpolation(TUIMethod):
                                """
                                Enable transient variable interpolation.
                                """
                            class nodal_reconstruction_frequency(TUIMethod):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                            class user_interpolation_function(TUIMethod):
                                """
                                Enter user interpolation function.
                                """

                        class particle_relocation(TUIMenu):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, service, version, mode, path):
                                self.wallfilm_relocation_tolerance_scale_factor = self.__class__.wallfilm_relocation_tolerance_scale_factor(service, version, mode, path + ["wallfilm_relocation_tolerance_scale_factor"])
                                self.use_legacy_particle_location_method = self.__class__.use_legacy_particle_location_method(service, version, mode, path + ["use_legacy_particle_location_method"])
                                self.load_legacy_particles = self.__class__.load_legacy_particles(service, version, mode, path + ["load_legacy_particles"])
                                self.enhanced_cell_relocation_method = self.__class__.enhanced_cell_relocation_method(service, version, mode, path + ["enhanced_cell_relocation_method"])
                                self.overset_relocation_robustness_level = self.__class__.overset_relocation_robustness_level(service, version, mode, path + ["overset_relocation_robustness_level"])
                                self.enhanced_wallfilm_location_method = self.__class__.enhanced_wallfilm_location_method(service, version, mode, path + ["enhanced_wallfilm_location_method"])
                                super().__init__(service, version, mode, path)
                            class wallfilm_relocation_tolerance_scale_factor(TUIMethod):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """
                            class use_legacy_particle_location_method(TUIMethod):
                                """
                                Enable legacy method of locating particles in cells.
                                """
                            class load_legacy_particles(TUIMethod):
                                """
                                Load particles that were tracked without high-resolution tracking enabled.
                                """
                            class enhanced_cell_relocation_method(TUIMethod):
                                """
                                Enable enhanced method of locating particles in cells.
                                """
                            class overset_relocation_robustness_level(TUIMethod):
                                """
                                Set the robustness level for particle relocation in overset meshes.
                                """
                            class enhanced_wallfilm_location_method(TUIMethod):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """

                class options(TUIMenu):
                    """
                    Enter the options menu to set optional DPM models.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enable_contour_plots = self.__class__.enable_contour_plots(service, version, mode, path + ["enable_contour_plots"])
                        self.ensemble_average = self.__class__.ensemble_average(service, version, mode, path + ["ensemble_average"])
                        self.particle_radiation = self.__class__.particle_radiation(service, version, mode, path + ["particle_radiation"])
                        self.track_in_absolute_frame = self.__class__.track_in_absolute_frame(service, version, mode, path + ["track_in_absolute_frame"])
                        self.thermophoretic_force = self.__class__.thermophoretic_force(service, version, mode, path + ["thermophoretic_force"])
                        self.convective_film_heat_transfer = self.__class__.convective_film_heat_transfer(service, version, mode, path + ["convective_film_heat_transfer"])
                        self.saffman_lift_force = self.__class__.saffman_lift_force(service, version, mode, path + ["saffman_lift_force"])
                        self.pressure_gradient_force = self.__class__.pressure_gradient_force(service, version, mode, path + ["pressure_gradient_force"])
                        self.virtual_mass_force = self.__class__.virtual_mass_force(service, version, mode, path + ["virtual_mass_force"])
                        self.two_way_coupling = self.__class__.two_way_coupling(service, version, mode, path + ["two_way_coupling"])
                        self.remove_wall_film_temperature_limiter = self.__class__.remove_wall_film_temperature_limiter(service, version, mode, path + ["remove_wall_film_temperature_limiter"])
                        self.maximum_udf_species = self.__class__.maximum_udf_species(service, version, mode, path + ["maximum_udf_species"])
                        self.brownian_motion = self.__class__.brownian_motion(service, version, mode, path + ["brownian_motion"])
                        self.stagger_spatially_standard_injections = self.__class__.stagger_spatially_standard_injections(service, version, mode, path + ["stagger_spatially_standard_injections"])
                        self.stagger_spatially_atomizer_injections = self.__class__.stagger_spatially_atomizer_injections(service, version, mode, path + ["stagger_spatially_atomizer_injections"])
                        self.stagger_temporally = self.__class__.stagger_temporally(service, version, mode, path + ["stagger_temporally"])
                        self.staggering_factor = self.__class__.staggering_factor(service, version, mode, path + ["staggering_factor"])
                        self.stagger_radius = self.__class__.stagger_radius(service, version, mode, path + ["stagger_radius"])
                        self.uniform_mass_distribution_for_injections = self.__class__.uniform_mass_distribution_for_injections(service, version, mode, path + ["uniform_mass_distribution_for_injections"])
                        self.use_absolute_pressure_for_vaporization = self.__class__.use_absolute_pressure_for_vaporization(service, version, mode, path + ["use_absolute_pressure_for_vaporization"])
                        self.vaporization_options = self.__class__.vaporization_options(service, version, mode, path + ["vaporization_options"])
                        self.vaporization_heat_transfer_averaging = self.__class__.vaporization_heat_transfer_averaging(service, version, mode, path + ["vaporization_heat_transfer_averaging"])
                        self.allow_supercritical_pressure_vaporization = self.__class__.allow_supercritical_pressure_vaporization(service, version, mode, path + ["allow_supercritical_pressure_vaporization"])
                        self.treat_multicomponent_saturation_temperature_failure = self.__class__.treat_multicomponent_saturation_temperature_failure(service, version, mode, path + ["treat_multicomponent_saturation_temperature_failure"])
                        self.set_thermolysis_limit = self.__class__.set_thermolysis_limit(service, version, mode, path + ["set_thermolysis_limit"])
                        self.lowest_volatiles_mass_fraction = self.__class__.lowest_volatiles_mass_fraction(service, version, mode, path + ["lowest_volatiles_mass_fraction"])
                        self.erosion_accretion = self.__class__.erosion_accretion(service, version, mode, path + ["erosion_accretion"])
                        self.init_erosion_accretion_rate = self.__class__.init_erosion_accretion_rate(service, version, mode, path + ["init_erosion_accretion_rate"])
                        self.step_report_sig_figures = self.__class__.step_report_sig_figures(service, version, mode, path + ["step_report_sig_figures"])
                        self.include_lwf_particles_in_dpm_concentration = self.__class__.include_lwf_particles_in_dpm_concentration(service, version, mode, path + ["include_lwf_particles_in_dpm_concentration"])
                        self.current_positions_in_sample_file_format = self.__class__.current_positions_in_sample_file_format(service, version, mode, path + ["current_positions_in_sample_file_format"])
                        self.scr_urea_deposition_risk_analysis = self.__class__.scr_urea_deposition_risk_analysis(service, version, mode, path + ["scr_urea_deposition_risk_analysis"])
                        super().__init__(service, version, mode, path)
                    class enable_contour_plots(TUIMethod):
                        """
                        Enable contour and vector plots of particle data.
                        """
                    class ensemble_average(TUIMethod):
                        """
                        Set ensemble average cloud properties.
                        """
                    class particle_radiation(TUIMethod):
                        """
                        Enable/disable particle radiation.
                        """
                    class track_in_absolute_frame(TUIMethod):
                        """
                        Enable/disable tracking in absolute frame.
                        """
                    class thermophoretic_force(TUIMethod):
                        """
                        Enable/disable thermophoretic force.
                        """
                    class convective_film_heat_transfer(TUIMethod):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                    class saffman_lift_force(TUIMethod):
                        """
                        Enable/disable Saffman lift force.
                        """
                    class pressure_gradient_force(TUIMethod):
                        """
                        Enable/disable pressure gradient force.
                        """
                    class virtual_mass_force(TUIMethod):
                        """
                        Enable/disable virtual mass force.
                        """
                    class two_way_coupling(TUIMethod):
                        """
                        Enable/disable calculation of DPM sources in TKE equation.
                        """
                    class remove_wall_film_temperature_limiter(TUIMethod):
                        """
                        Remove the wall film temperature limiter.
                        """
                    class maximum_udf_species(TUIMethod):
                        """
                        Maximum number of species that can interact with particles in the DPM UDFs.
                        """
                    class brownian_motion(TUIMethod):
                        """
                        Enable/disable Brownian motion of particles.
                        """
                    class stagger_spatially_standard_injections(TUIMethod):
                        """
                        Spatially stagger non-atomizer injections?.
                        """
                    class stagger_spatially_atomizer_injections(TUIMethod):
                        """
                        Spatially stagger atomizer injections?.
                        """
                    class stagger_temporally(TUIMethod):
                        """
                        Stagger transient parcels for their first time step?.
                        """
                    class staggering_factor(TUIMethod):
                        """
                        Set the staggering factor between 0 and 1 to control the amount of staggering.
                        """
                    class stagger_radius(TUIMethod):
                        """
                        Provide a stagger radius for non atomizer injections.
                        """
                    class uniform_mass_distribution_for_injections(TUIMethod):
                        """
                        A uniform mass distribution will be enabled for all solid cone and atomizer injections.
                        """
                    class use_absolute_pressure_for_vaporization(TUIMethod):
                        """
                        Enable/disable using Absolute Pressure for Vaporization.
                        """
                    class vaporization_options(TUIMethod):
                        """
                        Set Vaporization options.
                        """
                    class vaporization_heat_transfer_averaging(TUIMethod):
                        """
                        Enable/disable correction for Vaporization heat transfer.
                        """
                    class allow_supercritical_pressure_vaporization(TUIMethod):
                        """
                        Skip the pressure dependent boiling point calculation to allow supercritical pressure conditions for vaporization.
                        """
                    class treat_multicomponent_saturation_temperature_failure(TUIMethod):
                        """
                        Dump multicomponent particle mass if the saturation temperature cannot be determined.
                        """
                    class set_thermolysis_limit(TUIMethod):
                        """
                        Set the thermolysis limit.
                        """
                    class lowest_volatiles_mass_fraction(TUIMethod):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                    class erosion_accretion(TUIMethod):
                        """
                        Enable/disable erosion/accretion.
                        """
                    class init_erosion_accretion_rate(TUIMethod):
                        """
                        Initialize erosion/accretion rates with Zero.
                        """
                    class step_report_sig_figures(TUIMethod):
                        """
                        Set significant figures in the step-by-step report.
                        """
                    class include_lwf_particles_in_dpm_concentration(TUIMethod):
                        """
                        Include LWF particle mass in DPM Concentration.
                        """
                    class current_positions_in_sample_file_format(TUIMethod):
                        """
                        Write the current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                    class scr_urea_deposition_risk_analysis(TUIMethod):
                        """
                        Options to activate and configure the SCR urea deposition risk analysis.
                        """

                class parallel(TUIMenu):
                    """
                    Enter the parallel menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.enable_workpile = self.__class__.enable_workpile(service, version, mode, path + ["enable_workpile"])
                        self.n_threads = self.__class__.n_threads(service, version, mode, path + ["n_threads"])
                        self.report = self.__class__.report(service, version, mode, path + ["report"])
                        self.use_shared_memory = self.__class__.use_shared_memory(service, version, mode, path + ["use_shared_memory"])
                        self.use_message_passing = self.__class__.use_message_passing(service, version, mode, path + ["use_message_passing"])
                        self.use_hybrid = self.__class__.use_hybrid(service, version, mode, path + ["use_hybrid"])
                        self.fix_source_term_accumulation_order = self.__class__.fix_source_term_accumulation_order(service, version, mode, path + ["fix_source_term_accumulation_order"])
                        self.hybrid_2domain = self.__class__.hybrid_2domain(service, version, mode, path + ["hybrid_2domain"])
                        self.hybrid_workpile = self.__class__.hybrid_workpile(service, version, mode, path + ["hybrid_workpile"])
                        self.hybrid_collision_model = self.__class__.hybrid_collision_model(service, version, mode, path + ["hybrid_collision_model"])
                        self.hybrid_collision_unidirectional = self.__class__.hybrid_collision_unidirectional(service, version, mode, path + ["hybrid_collision_unidirectional"])
                        self.hybrid_collision_variant = self.__class__.hybrid_collision_variant(service, version, mode, path + ["hybrid_collision_variant"])
                        super().__init__(service, version, mode, path)
                    class enable_workpile(TUIMethod):
                        """
                        Enable/disable the particle workpile algorithm.
                        """
                    class n_threads(TUIMethod):
                        """
                        Set the number of processors to use for DPM.
                        """
                    class report(TUIMethod):
                        """
                        Print particle workpile statistics.
                        """
                    class use_shared_memory(TUIMethod):
                        """
                        Set DPM parallel-mode to shared memory.
                        """
                    class use_message_passing(TUIMethod):
                        """
                        Set DPM parallel-mode to message passing.
                        """
                    class use_hybrid(TUIMethod):
                        """
                        Set DPM parallel-mode to hybrid.
                        """
                    class fix_source_term_accumulation_order(TUIMethod):
                        """
                        Enforce deterministic order of source term accumulation.
                        """
                    class hybrid_2domain(TUIMethod):
                        """
                        Use DPM domain to simulate particles.
                        """
                    class hybrid_workpile(TUIMethod):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                    class hybrid_collision_model(TUIMethod):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_unidirectional(TUIMethod):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                    class hybrid_collision_variant(TUIMethod):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """

                    class expert(TUIMenu):
                        """
                        Enter the menu to set expert DPM parallel options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.partition_method_hybrid_2domain = self.__class__.partition_method_hybrid_2domain(service, version, mode, path + ["partition_method_hybrid_2domain"])
                            super().__init__(service, version, mode, path)
                        class partition_method_hybrid_2domain(TUIMethod):
                            """
                            Set DPM Domain partition method.
                            """

                class splash_options(TUIMenu):
                    """
                    Enter the splash options menu to set optional parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.orourke_splash_fraction = self.__class__.orourke_splash_fraction(service, version, mode, path + ["orourke_splash_fraction"])
                        self.splash_pdf_limiting = self.__class__.splash_pdf_limiting(service, version, mode, path + ["splash_pdf_limiting"])
                        super().__init__(service, version, mode, path)
                    class orourke_splash_fraction(TUIMethod):
                        """
                        Select splash fraction method.
                        """
                    class splash_pdf_limiting(TUIMethod):
                        """
                        Select splash pdf limiting method.
                        """

                class stripping_options(TUIMenu):
                    """
                    Enter the stripping options menu to set optional parameters.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mass_coefficient = self.__class__.mass_coefficient(service, version, mode, path + ["mass_coefficient"])
                        self.diameter_coefficient = self.__class__.diameter_coefficient(service, version, mode, path + ["diameter_coefficient"])
                        super().__init__(service, version, mode, path)
                    class mass_coefficient(TUIMethod):
                        """
                        Set the stripping mass coefficient.
                        """
                    class diameter_coefficient(TUIMethod):
                        """
                        Set the stripping diameter coefficient.
                        """

            class shell_conduction(TUIMenu):
                """
                Enter the shell conduction model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.multi_layer_shell = self.__class__.multi_layer_shell(service, version, mode, path + ["multi_layer_shell"])
                    self.enhanced_encapsulation = self.__class__.enhanced_encapsulation(service, version, mode, path + ["enhanced_encapsulation"])
                    self.read_csv = self.__class__.read_csv(service, version, mode, path + ["read_csv"])
                    self.write_csv = self.__class__.write_csv(service, version, mode, path + ["write_csv"])
                    self.settings = self.__class__.settings(service, version, mode, path + ["settings"])
                    self.save_shell_zones = self.__class__.save_shell_zones(service, version, mode, path + ["save_shell_zones"])
                    super().__init__(service, version, mode, path)
                class multi_layer_shell(TUIMethod):
                    """
                    Enable/disable multi layer shell conduction model.
                    """
                class enhanced_encapsulation(TUIMethod):
                    """
                    Enable/disable enhanced encapsulation for shell conduction and S2S models. This is not applicable if coupled sliding interface walls exists.
                    """
                class read_csv(TUIMethod):
                    """
                    Read shell conduction settings from a csv file.
                    """
                class write_csv(TUIMethod):
                    """
                    Write shell conduction settings to a csv file.
                    """
                class settings(TUIMethod):
                    """
                    Enter Multi-layer Shell Conduction data.
                    """
                class save_shell_zones(TUIMethod):
                    """
                    Enable/Disable saving shell zones to case file.
                    """

            class system_coupling_settings(TUIMenu):
                """
                Enter the system coupling model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.htc = self.__class__.htc(service, version, mode, path + ["htc"])
                    self.use_face_or_element_based_data_transfer = self.__class__.use_face_or_element_based_data_transfer(service, version, mode, path + ["use_face_or_element_based_data_transfer"])
                    self.update_rigid_body_mesh_motion_before_mesh_transfer = self.__class__.update_rigid_body_mesh_motion_before_mesh_transfer(service, version, mode, path + ["update_rigid_body_mesh_motion_before_mesh_transfer"])
                    self.specify_system_coupling_volumetric_cell_zones = self.__class__.specify_system_coupling_volumetric_cell_zones(service, version, mode, path + ["specify_system_coupling_volumetric_cell_zones"])
                    super().__init__(service, version, mode, path)
                class use_face_or_element_based_data_transfer(TUIMethod):
                    """
                    Enable/disable face based data transfer.
                    """
                class update_rigid_body_mesh_motion_before_mesh_transfer(TUIMethod):
                    """
                    SC Enable/disable mesh motion.
                    """
                class specify_system_coupling_volumetric_cell_zones(TUIMethod):
                    """
                    Enable/disable volumetric cell zones.
                    """

                class htc(TUIMenu):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.unsteady_statistics = self.__class__.unsteady_statistics(service, version, mode, path + ["unsteady_statistics"])
                        self.htc_calculation_method = self.__class__.htc_calculation_method(service, version, mode, path + ["htc_calculation_method"])
                        super().__init__(service, version, mode, path)

                    class unsteady_statistics(TUIMenu):
                        """
                        Enter the unsteady statistics menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.sc_enable_sub_stepping_option_per_coupling_step = self.__class__.sc_enable_sub_stepping_option_per_coupling_step(service, version, mode, path + ["sc_enable_sub_stepping_option_per_coupling_step"])
                            super().__init__(service, version, mode, path)
                        class sc_enable_sub_stepping_option_per_coupling_step(TUIMethod):
                            """
                            Enable/disable sub stepping option per coupling step.
                            """

                    class htc_calculation_method(TUIMenu):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.use_tref_in_htc_calculation = self.__class__.use_tref_in_htc_calculation(service, version, mode, path + ["use_tref_in_htc_calculation"])
                            self.use_yplus_based_htc_calculation = self.__class__.use_yplus_based_htc_calculation(service, version, mode, path + ["use_yplus_based_htc_calculation"])
                            self.use_wall_function_based_htc = self.__class__.use_wall_function_based_htc(service, version, mode, path + ["use_wall_function_based_htc"])
                            super().__init__(service, version, mode, path)
                        class use_tref_in_htc_calculation(TUIMethod):
                            """
                            Enable/disable tref in htc computation.
                            """
                        class use_yplus_based_htc_calculation(TUIMethod):
                            """
                            Enable/disable yplus in htc computation.
                            """
                        class use_wall_function_based_htc(TUIMethod):
                            """
                            Enable/disable wall function based htc computation.
                            """

            class cht(TUIMenu):
                """
                Enter the mapped interface model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(service, version, mode, path + ["explicit_time_averaged_coupling"])
                    self.read_mi_type_wall = self.__class__.read_mi_type_wall(service, version, mode, path + ["read_mi_type_wall"])
                    self.write_mi_type_wall = self.__class__.write_mi_type_wall(service, version, mode, path + ["write_mi_type_wall"])
                    self.implicit_coupling = self.__class__.implicit_coupling(service, version, mode, path + ["implicit_coupling"])
                    super().__init__(service, version, mode, path)
                class read_mi_type_wall(TUIMethod):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                class write_mi_type_wall(TUIMethod):
                    """
                    Write mapped interface settings to a scv file.
                    """
                class implicit_coupling(TUIMethod):
                    """
                    Enable/disable implicit coupling for mapped interface.
                    """

                class explicit_time_averaged_coupling(TUIMenu):
                    """
                    Enter the explcit time averaged thermal coupling menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.conformal_coupled_walls = self.__class__.conformal_coupled_walls(service, version, mode, path + ["conformal_coupled_walls"])
                        self.mapped_interfaces = self.__class__.mapped_interfaces(service, version, mode, path + ["mapped_interfaces"])
                        self.coupling_controls = self.__class__.coupling_controls(service, version, mode, path + ["coupling_controls"])
                        self.fuse_explicit_cht_zones = self.__class__.fuse_explicit_cht_zones(service, version, mode, path + ["fuse_explicit_cht_zones"])
                        super().__init__(service, version, mode, path)
                    class conformal_coupled_walls(TUIMethod):
                        """
                        Select fluid-solid coupled walls (without shell) for explicit coupling using time averaged thermal variables.
                        """
                    class mapped_interfaces(TUIMethod):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """
                    class coupling_controls(TUIMethod):
                        """
                        Specify explcit coupling controls.
                        """
                    class fuse_explicit_cht_zones(TUIMethod):
                        """
                        Fuse slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """

            class two_temperature(TUIMenu):
                """
                Define two-temperature model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                    self.robustness_enhancement = self.__class__.robustness_enhancement(service, version, mode, path + ["robustness_enhancement"])
                    self.nasa9_enhancement = self.__class__.nasa9_enhancement(service, version, mode, path + ["nasa9_enhancement"])
                    self.set_verbosity = self.__class__.set_verbosity(service, version, mode, path + ["set_verbosity"])
                    super().__init__(service, version, mode, path)
                class enable(TUIMethod):
                    """
                    Enable/disable the two-temperature model.
                    """
                class robustness_enhancement(TUIMethod):
                    """
                    Apply robustness enhancements in the two-temperature model.
                    """
                class nasa9_enhancement(TUIMethod):
                    """
                    Apply nasa9 robustness enhancements in the two-temperature model.
                    """
                class set_verbosity(TUIMethod):
                    """
                    Set two-temperature model verbosity option.
                    """

            class multiphase(TUIMenu):
                """
                Define multiphase model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.phases = self.__class__.phases(service, version, mode, path + ["phases"])
                    self.wet_steam = self.__class__.wet_steam(service, version, mode, path + ["wet_steam"])
                    self.population_balance = self.__class__.population_balance(service, version, mode, path + ["population_balance"])
                    self.explicit_expert_options = self.__class__.explicit_expert_options(service, version, mode, path + ["explicit_expert_options"])
                    self.model = self.__class__.model(service, version, mode, path + ["model"])
                    self.number_of_phases = self.__class__.number_of_phases(service, version, mode, path + ["number_of_phases"])
                    self.regime_transition_modeling = self.__class__.regime_transition_modeling(service, version, mode, path + ["regime_transition_modeling"])
                    self.eulerian_parameters = self.__class__.eulerian_parameters(service, version, mode, path + ["eulerian_parameters"])
                    self.volume_fraction_parameters = self.__class__.volume_fraction_parameters(service, version, mode, path + ["volume_fraction_parameters"])
                    self.boiling_model_options = self.__class__.boiling_model_options(service, version, mode, path + ["boiling_model_options"])
                    self.mixture_parameters = self.__class__.mixture_parameters(service, version, mode, path + ["mixture_parameters"])
                    self.body_force_formulation = self.__class__.body_force_formulation(service, version, mode, path + ["body_force_formulation"])
                    self.coupled_level_set = self.__class__.coupled_level_set(service, version, mode, path + ["coupled_level_set"])
                    self.vof_sub_models = self.__class__.vof_sub_models(service, version, mode, path + ["vof_sub_models"])
                    self.interface_modeling_options = self.__class__.interface_modeling_options(service, version, mode, path + ["interface_modeling_options"])
                    self.expert_options = self.__class__.expert_options(service, version, mode, path + ["expert_options"])
                    super().__init__(service, version, mode, path)
                class model(TUIMethod):
                    """
                    Specify multiphase model.
                    """
                class number_of_phases(TUIMethod):
                    """
                    Specify the number of phases.
                    """
                class regime_transition_modeling(TUIMethod):
                    """
                    Regime-transition-modeling-options.
                    """
                class eulerian_parameters(TUIMethod):
                    """
                    Eulerian parameters.
                    """
                class volume_fraction_parameters(TUIMethod):
                    """
                    Volume fraction parameters.
                    """
                class boiling_model_options(TUIMethod):
                    """
                    Boiling model options.
                    """
                class mixture_parameters(TUIMethod):
                    """
                    Mixture parameters.
                    """
                class body_force_formulation(TUIMethod):
                    """
                    Body force formulation.
                    """
                class coupled_level_set(TUIMethod):
                    """
                    Coupled level set.
                    """
                class vof_sub_models(TUIMethod):
                    """
                    VOF sub-models.
                    """
                class interface_modeling_options(TUIMethod):
                    """
                    Interface Modeling Options.
                    """
                class expert_options(TUIMethod):
                    """
                    Expert Options.
                    """

                class phases(TUIMenu):
                    """
                    Enter the phases menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set_domain_properties = self.__class__.set_domain_properties(service, version, mode, path + ["set_domain_properties"])
                        self.iac_expert = self.__class__.iac_expert(service, version, mode, path + ["iac_expert"])
                        super().__init__(service, version, mode, path)

                    class set_domain_properties(TUIMenu):
                        """
                        Enter the menu to set domain properties.
                        """
                        def __init__(self, service, version, mode, path):
                            self.interaction_domain = self.__class__.interaction_domain(service, version, mode, path + ["interaction_domain"])
                            self.change_phases_names = self.__class__.change_phases_names(service, version, mode, path + ["change_phases_names"])
                            self.phase_domains = self.__class__.phase_domains(service, version, mode, path + ["phase_domains"])
                            super().__init__(service, version, mode, path)
                        class change_phases_names(TUIMethod):
                            """
                            Change names for all defined phases?.
                            """
                        class phase_domains(TUIMethod):
                            """
                            Enter the menu to select a specific phase domain.
                            """

                        class interaction_domain(TUIMenu):
                            """
                            Enter the menu to set the interaction domain properties.
                            """
                            def __init__(self, service, version, mode, path):
                                self.forces = self.__class__.forces(service, version, mode, path + ["forces"])
                                self.heat_mass_reactions = self.__class__.heat_mass_reactions(service, version, mode, path + ["heat_mass_reactions"])
                                self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                self.numerics = self.__class__.numerics(service, version, mode, path + ["numerics"])
                                super().__init__(service, version, mode, path)

                            class forces(TUIMenu):
                                """
                                Enter the menu to set interfacial forces related models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class heat_mass_reactions(TUIMenu):
                                """
                                Enter the menu to set heat, mass-transfer, or reaction related models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class interfacial_area(TUIMenu):
                                """
                                Enter the menu to set interfacial area models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class model_transition(TUIMenu):
                                """
                                Enter the menu to set model transition mechanisms.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                            class numerics(TUIMenu):
                                """
                                Enter the menu to set numerics models.
                                """
                                def __init__(self, service, version, mode, path):
                                    self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                    self.interphase_discretization = self.__class__.interphase_discretization(service, version, mode, path + ["interphase_discretization"])
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(service, version, mode, path + ["interphase_viscous_dissipation"])
                                    self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                    self.surface_tension = self.__class__.surface_tension(service, version, mode, path + ["surface_tension"])
                                    self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                    self.drag = self.__class__.drag(service, version, mode, path + ["drag"])
                                    self.heat_coeff = self.__class__.heat_coeff(service, version, mode, path + ["heat_coeff"])
                                    self.interfacial_area = self.__class__.interfacial_area(service, version, mode, path + ["interfacial_area"])
                                    self.mass_transfer = self.__class__.mass_transfer(service, version, mode, path + ["mass_transfer"])
                                    self.model_transition = self.__class__.model_transition(service, version, mode, path + ["model_transition"])
                                    self.reactions = self.__class__.reactions(service, version, mode, path + ["reactions"])
                                    self.restitution = self.__class__.restitution(service, version, mode, path + ["restitution"])
                                    self.slip_velocity = self.__class__.slip_velocity(service, version, mode, path + ["slip_velocity"])
                                    self.turbulence_interaction = self.__class__.turbulence_interaction(service, version, mode, path + ["turbulence_interaction"])
                                    self.turbulent_dispersion = self.__class__.turbulent_dispersion(service, version, mode, path + ["turbulent_dispersion"])
                                    self.wall_lubrication = self.__class__.wall_lubrication(service, version, mode, path + ["wall_lubrication"])
                                    super().__init__(service, version, mode, path)
                                class drag(TUIMethod):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                class heat_coeff(TUIMethod):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                class interfacial_area(TUIMethod):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                class mass_transfer(TUIMethod):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                class model_transition(TUIMethod):
                                    """
                                    Set the model transition mechanism.
                                    """
                                class reactions(TUIMethod):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                class restitution(TUIMethod):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                class slip_velocity(TUIMethod):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                class turbulence_interaction(TUIMethod):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                class turbulent_dispersion(TUIMethod):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                class wall_lubrication(TUIMethod):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """

                                class cavitation(TUIMenu):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_discretization(TUIMenu):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class interphase_viscous_dissipation(TUIMenu):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class lift(TUIMenu):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class surface_tension(TUIMenu):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                                class virtual_mass(TUIMenu):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, service, version, mode, path):
                                        self.cavitation = self.__class__.cavitation(service, version, mode, path + ["cavitation"])
                                        self.interphase_discr = self.__class__.interphase_discr(service, version, mode, path + ["interphase_discr"])
                                        self.interphase_visc_disp = self.__class__.interphase_visc_disp(service, version, mode, path + ["interphase_visc_disp"])
                                        self.jump_adhesion = self.__class__.jump_adhesion(service, version, mode, path + ["jump_adhesion"])
                                        self.lift = self.__class__.lift(service, version, mode, path + ["lift"])
                                        self.lift_montoya = self.__class__.lift_montoya(service, version, mode, path + ["lift_montoya"])
                                        self.lift_shaver_podowski = self.__class__.lift_shaver_podowski(service, version, mode, path + ["lift_shaver_podowski"])
                                        self.sfc_model_type = self.__class__.sfc_model_type(service, version, mode, path + ["sfc_model_type"])
                                        self.sfc_modeling = self.__class__.sfc_modeling(service, version, mode, path + ["sfc_modeling"])
                                        self.sfc_tension_coeff = self.__class__.sfc_tension_coeff(service, version, mode, path + ["sfc_tension_coeff"])
                                        self.slope_limiter = self.__class__.slope_limiter(service, version, mode, path + ["slope_limiter"])
                                        self.virtual_mass = self.__class__.virtual_mass(service, version, mode, path + ["virtual_mass"])
                                        self.visc_disp_factor = self.__class__.visc_disp_factor(service, version, mode, path + ["visc_disp_factor"])
                                        self.vmass_coeff = self.__class__.vmass_coeff(service, version, mode, path + ["vmass_coeff"])
                                        self.vmass_implicit_options = self.__class__.vmass_implicit_options(service, version, mode, path + ["vmass_implicit_options"])
                                        self.vmass_implicit = self.__class__.vmass_implicit(service, version, mode, path + ["vmass_implicit"])
                                        self.wall_adhesion = self.__class__.wall_adhesion(service, version, mode, path + ["wall_adhesion"])
                                        super().__init__(service, version, mode, path)
                                    class cavitation(TUIMethod):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                    class interphase_discr(TUIMethod):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                    class interphase_visc_disp(TUIMethod):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                    class jump_adhesion(TUIMethod):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                    class lift(TUIMethod):
                                        """
                                        .
                                        """
                                    class lift_montoya(TUIMethod):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                    class lift_shaver_podowski(TUIMethod):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                    class sfc_model_type(TUIMethod):
                                        """
                                        Select the surface tension model.
                                        """
                                    class sfc_modeling(TUIMethod):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                    class sfc_tension_coeff(TUIMethod):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                    class slope_limiter(TUIMethod):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                    class virtual_mass(TUIMethod):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                    class visc_disp_factor(TUIMethod):
                                        """
                                        Set the dissipation intensity.
                                        """
                                    class vmass_coeff(TUIMethod):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                    class vmass_implicit_options(TUIMethod):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                    class vmass_implicit(TUIMethod):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                    class wall_adhesion(TUIMethod):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """

                    class iac_expert(TUIMenu):
                        """
                        Enter the IAC expert setting menu.
                        """
                        def __init__(self, service, version, mode, path):
                            self.ishii_kim_model = self.__class__.ishii_kim_model(service, version, mode, path + ["ishii_kim_model"])
                            self.hibiki_ishii_model = self.__class__.hibiki_ishii_model(service, version, mode, path + ["hibiki_ishii_model"])
                            self.yao_morel_model = self.__class__.yao_morel_model(service, version, mode, path + ["yao_morel_model"])
                            self.iac_pseudo_time_step = self.__class__.iac_pseudo_time_step(service, version, mode, path + ["iac_pseudo_time_step"])
                            super().__init__(service, version, mode, path)
                        class ishii_kim_model(TUIMethod):
                            """
                            Set ik model coefficients.
                            """
                        class hibiki_ishii_model(TUIMethod):
                            """
                            Set hi model coefficients.
                            """
                        class yao_morel_model(TUIMethod):
                            """
                            Set ym model coefficients.
                            """
                        class iac_pseudo_time_step(TUIMethod):
                            """
                            Set iac pseudo-time.
                            """

                class wet_steam(TUIMenu):
                    """
                    Enter the wet steam model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.set = self.__class__.set(service, version, mode, path + ["set"])
                        self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                        self.compile_user_defined_wetsteam_functions = self.__class__.compile_user_defined_wetsteam_functions(service, version, mode, path + ["compile_user_defined_wetsteam_functions"])
                        self.load_unload_user_defined_wetsteam_library = self.__class__.load_unload_user_defined_wetsteam_library(service, version, mode, path + ["load_unload_user_defined_wetsteam_library"])
                        super().__init__(service, version, mode, path)
                    class enable(TUIMethod):
                        """
                        Enable/disable the wet steam model.
                        """
                    class compile_user_defined_wetsteam_functions(TUIMethod):
                        """
                        Compile user-defined wet steam library.
                        """
                    class load_unload_user_defined_wetsteam_library(TUIMethod):
                        """
                        Load or unload user-defined wet steam library.
                        """

                    class set(TUIMenu):
                        """
                        Enter the set menu for setting wet steam model options.
                        """
                        def __init__(self, service, version, mode, path):
                            self.max_liquid_mass_fraction = self.__class__.max_liquid_mass_fraction(service, version, mode, path + ["max_liquid_mass_fraction"])
                            self.droplet_growth_rate = self.__class__.droplet_growth_rate(service, version, mode, path + ["droplet_growth_rate"])
                            self.virial_equation = self.__class__.virial_equation(service, version, mode, path + ["virial_equation"])
                            self.rgp_tables = self.__class__.rgp_tables(service, version, mode, path + ["rgp_tables"])
                            self.stagnation_conditions = self.__class__.stagnation_conditions(service, version, mode, path + ["stagnation_conditions"])
                            super().__init__(service, version, mode, path)
                        class max_liquid_mass_fraction(TUIMethod):
                            """
                            Set the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                        class droplet_growth_rate(TUIMethod):
                            """
                            Select the formula to model the droplet growth rate.
                            """
                        class virial_equation(TUIMethod):
                            """
                            Select the formulation of the virial equation of state and associated equations for thermodynamic properties of steam.
                            """
                        class rgp_tables(TUIMethod):
                            """
                            Select which properties to use: build-in or from RGP tables.
                            """
                        class stagnation_conditions(TUIMethod):
                            """
                            If the gas phase is selected, zero wetness is assumed when evaluating total or static values of pressure and temperature.
                            """

                class population_balance(TUIMenu):
                    """
                    Enter the population balance model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.phenomena = self.__class__.phenomena(service, version, mode, path + ["phenomena"])
                        self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                        self.model = self.__class__.model(service, version, mode, path + ["model"])
                        self.include_expansion = self.__class__.include_expansion(service, version, mode, path + ["include_expansion"])
                        self.size_calculator = self.__class__.size_calculator(service, version, mode, path + ["size_calculator"])
                        super().__init__(service, version, mode, path)
                    class model(TUIMethod):
                        """
                        Select the population balance model.
                        """
                    class include_expansion(TUIMethod):
                        """
                        Set expansion.
                        """
                    class size_calculator(TUIMethod):
                        """
                        Calculate fluid particle diameters using different methods.
                        """

                    class phenomena(TUIMenu):
                        """
                        Enter the phenomena menu for population balance.
                        """
                        def __init__(self, service, version, mode, path):
                            self.nucleation = self.__class__.nucleation(service, version, mode, path + ["nucleation"])
                            self.growth = self.__class__.growth(service, version, mode, path + ["growth"])
                            self.aggregation = self.__class__.aggregation(service, version, mode, path + ["aggregation"])
                            self.breakage = self.__class__.breakage(service, version, mode, path + ["breakage"])
                            self.aggregation_factor = self.__class__.aggregation_factor(service, version, mode, path + ["aggregation_factor"])
                            self.breakage_factor = self.__class__.breakage_factor(service, version, mode, path + ["breakage_factor"])
                            self.breakage_aggregation_vof_cutoff = self.__class__.breakage_aggregation_vof_cutoff(service, version, mode, path + ["breakage_aggregation_vof_cutoff"])
                            super().__init__(service, version, mode, path)
                        class nucleation(TUIMethod):
                            """
                            Set the nucleantion rate.
                            """
                        class growth(TUIMethod):
                            """
                            Set the growth rate.
                            """
                        class aggregation(TUIMethod):
                            """
                            Set the aggregation kernel.
                            """
                        class breakage(TUIMethod):
                            """
                            Set the breakage kernel.
                            """
                        class aggregation_factor(TUIMethod):
                            """
                            Set a factor which controls the intensity of the selected aggregation kernel.
                            """
                        class breakage_factor(TUIMethod):
                            """
                            Set a factor which controls the intensity of the selected breakage kernel.
                            """
                        class breakage_aggregation_vof_cutoff(TUIMethod):
                            """
                            Control vof cut-off for breakage and aggregation.
                            """

                    class expert(TUIMenu):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, service, version, mode, path):
                            self.qmom = self.__class__.qmom(service, version, mode, path + ["qmom"])
                            super().__init__(service, version, mode, path)

                        class qmom(TUIMenu):
                            """
                            .
                            """
                            def __init__(self, service, version, mode, path):
                                self.retain_qmom_sources_for_low_vof = self.__class__.retain_qmom_sources_for_low_vof(service, version, mode, path + ["retain_qmom_sources_for_low_vof"])
                                self.realizable_moments = self.__class__.realizable_moments(service, version, mode, path + ["realizable_moments"])
                                self.print_realizable_moment_warning = self.__class__.print_realizable_moment_warning(service, version, mode, path + ["print_realizable_moment_warning"])
                                self.inversion_algorithm = self.__class__.inversion_algorithm(service, version, mode, path + ["inversion_algorithm"])
                                super().__init__(service, version, mode, path)
                            class retain_qmom_sources_for_low_vof(TUIMethod):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """
                            class realizable_moments(TUIMethod):
                                """
                                Set the population balance model.
                                """
                            class print_realizable_moment_warning(TUIMethod):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                            class inversion_algorithm(TUIMethod):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """

                class explicit_expert_options(TUIMenu):
                    """
                    Expert options for explicit formulation.
                    """
                    def __init__(self, service, version, mode, path):
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(service, version, mode, path + ["volume_fraction_filtering"])
                        self.sub_time_step_method = self.__class__.sub_time_step_method(service, version, mode, path + ["sub_time_step_method"])
                        self.solve_vof_every_iter = self.__class__.solve_vof_every_iter(service, version, mode, path + ["solve_vof_every_iter"])
                        super().__init__(service, version, mode, path)
                    class sub_time_step_method(TUIMethod):
                        """
                        Select sub-time step method for the time integration in explicit formulation.
                        """
                    class solve_vof_every_iter(TUIMethod):
                        """
                        Solve volume fraction equation every iteration for explicit formulation.
                        """

                    class volume_fraction_filtering(TUIMenu):
                        """
                        Advanced volume fraction filtering controls for explicit formulation.
                        """
                        def __init__(self, service, version, mode, path):
                            self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                            self.filtering_options = self.__class__.filtering_options(service, version, mode, path + ["filtering_options"])
                            self.vol_frac_cutoff = self.__class__.vol_frac_cutoff(service, version, mode, path + ["vol_frac_cutoff"])
                            super().__init__(service, version, mode, path)
                        class enable(TUIMethod):
                            """
                            Enable volume fraction filtering treatment.
                            """
                        class filtering_options(TUIMethod):
                            """
                            Select volume fraction filtering method.
                            """
                        class vol_frac_cutoff(TUIMethod):
                            """
                            Enter node-averaged volume fraction cutoff.
                            """

            class nox_parameters(TUIMenu):
                """
                Enter the NOx parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.nox_chemistry = self.__class__.nox_chemistry(service, version, mode, path + ["nox_chemistry"])
                    self.nox_turbulence_interaction = self.__class__.nox_turbulence_interaction(service, version, mode, path + ["nox_turbulence_interaction"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.nox_expert = self.__class__.nox_expert(service, version, mode, path + ["nox_expert"])
                    super().__init__(service, version, mode, path)
                class nox_chemistry(TUIMethod):
                    """
                    Select NOx chemistry model.
                    """
                class nox_turbulence_interaction(TUIMethod):
                    """
                    Set NOx-turbulence interaction model.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                class nox_expert(TUIMethod):
                    """
                    Select additional nox equations.
                    """

            class soot_parameters(TUIMenu):
                """
                Enter the soot parameters menu.
                """
                def __init__(self, service, version, mode, path):
                    self.soot_model_parameters = self.__class__.soot_model_parameters(service, version, mode, path + ["soot_model_parameters"])
                    self.soot_process_parameters = self.__class__.soot_process_parameters(service, version, mode, path + ["soot_process_parameters"])
                    self.soot_radiation_interaction = self.__class__.soot_radiation_interaction(service, version, mode, path + ["soot_radiation_interaction"])
                    self.soot_turbulence_interaction = self.__class__.soot_turbulence_interaction(service, version, mode, path + ["soot_turbulence_interaction"])
                    self.modify_schmidt_number = self.__class__.modify_schmidt_number(service, version, mode, path + ["modify_schmidt_number"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.soot_model_udfs = self.__class__.soot_model_udfs(service, version, mode, path + ["soot_model_udfs"])
                    super().__init__(service, version, mode, path)
                class soot_model_parameters(TUIMethod):
                    """
                    Enter the soot model parameters menu.
                    """
                class soot_process_parameters(TUIMethod):
                    """
                    Set soot process parameters.
                    """
                class soot_radiation_interaction(TUIMethod):
                    """
                    Enable/disable the soot-radiation interaction model.
                    """
                class soot_turbulence_interaction(TUIMethod):
                    """
                    Set Soot-turbulence interaction model.
                    """
                class modify_schmidt_number(TUIMethod):
                    """
                    Change Turbulent Schmidt Number for Soot/Nuclei Equations.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                class soot_model_udfs(TUIMethod):
                    """
                    User defined functions for soot model.
                    """

            class radiation(TUIMenu):
                """
                Enter the radiation models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.s2s_parameters = self.__class__.s2s_parameters(service, version, mode, path + ["s2s_parameters"])
                    self.dtrm_parameters = self.__class__.dtrm_parameters(service, version, mode, path + ["dtrm_parameters"])
                    self.solar_parameters = self.__class__.solar_parameters(service, version, mode, path + ["solar_parameters"])
                    self.discrete_ordinates = self.__class__.discrete_ordinates(service, version, mode, path + ["discrete_ordinates"])
                    self.do_acceleration = self.__class__.do_acceleration(service, version, mode, path + ["do_acceleration"])
                    self.non_gray_model_parameters = self.__class__.non_gray_model_parameters(service, version, mode, path + ["non_gray_model_parameters"])
                    self.montecarlo = self.__class__.montecarlo(service, version, mode, path + ["montecarlo"])
                    self.target_cells_per_volume_cluster = self.__class__.target_cells_per_volume_cluster(service, version, mode, path + ["target_cells_per_volume_cluster"])
                    self.s2s = self.__class__.s2s(service, version, mode, path + ["s2s"])
                    self.discrete_transfer = self.__class__.discrete_transfer(service, version, mode, path + ["discrete_transfer"])
                    self.p1 = self.__class__.p1(service, version, mode, path + ["p1"])
                    self.radiation_model_parameters = self.__class__.radiation_model_parameters(service, version, mode, path + ["radiation_model_parameters"])
                    self.radiation_iteration_parameters = self.__class__.radiation_iteration_parameters(service, version, mode, path + ["radiation_iteration_parameters"])
                    self.mc_model_parameters = self.__class__.mc_model_parameters(service, version, mode, path + ["mc_model_parameters"])
                    self.mc_under_relaxation = self.__class__.mc_under_relaxation(service, version, mode, path + ["mc_under_relaxation"])
                    self.rosseland = self.__class__.rosseland(service, version, mode, path + ["rosseland"])
                    self.solar = self.__class__.solar(service, version, mode, path + ["solar"])
                    self.solar_irradiation = self.__class__.solar_irradiation(service, version, mode, path + ["solar_irradiation"])
                    self.solar_calculator = self.__class__.solar_calculator(service, version, mode, path + ["solar_calculator"])
                    self.apply_full_solar_irradiation = self.__class__.apply_full_solar_irradiation(service, version, mode, path + ["apply_full_solar_irradiation"])
                    self.wsggm_cell_based = self.__class__.wsggm_cell_based(service, version, mode, path + ["wsggm_cell_based"])
                    self.fast_second_order_discrete_ordinate = self.__class__.fast_second_order_discrete_ordinate(service, version, mode, path + ["fast_second_order_discrete_ordinate"])
                    self.do_coupling = self.__class__.do_coupling(service, version, mode, path + ["do_coupling"])
                    self.solution_method_for_do_coupling = self.__class__.solution_method_for_do_coupling(service, version, mode, path + ["solution_method_for_do_coupling"])
                    self.beta_radiation_features = self.__class__.beta_radiation_features(service, version, mode, path + ["beta_radiation_features"])
                    self.method_partially_specular_wall = self.__class__.method_partially_specular_wall(service, version, mode, path + ["method_partially_specular_wall"])
                    self.blending_factor = self.__class__.blending_factor(service, version, mode, path + ["blending_factor"])
                    super().__init__(service, version, mode, path)
                class discrete_ordinates(TUIMethod):
                    """
                    Enable/disable the discrete ordinates radiation model.
                    """
                class do_acceleration(TUIMethod):
                    """
                    Enable/disable acceleration of computation of DO model.
                    """
                class non_gray_model_parameters(TUIMethod):
                    """
                    Set parameters for non-gray model.
                    """
                class montecarlo(TUIMethod):
                    """
                    Enable/disable the Monte Carlo radiation model.
                    """
                class target_cells_per_volume_cluster(TUIMethod):
                    """
                    Enter cells per volume cluster for Monte Carlo radiation model.
                    """
                class s2s(TUIMethod):
                    """
                    Enable/disable the S2S radiation model.
                    """
                class discrete_transfer(TUIMethod):
                    """
                    Enable/disable discrete the transfer radiation model.
                    """
                class p1(TUIMethod):
                    """
                    Enable/disable the P1 radiation model.
                    """
                class radiation_model_parameters(TUIMethod):
                    """
                    Set parameters for radiation models.
                    """
                class radiation_iteration_parameters(TUIMethod):
                    """
                    Set iteration parameters for radiation models.
                    """
                class mc_model_parameters(TUIMethod):
                    """
                    Set parameters for montecarlo radiation model.
                    """
                class mc_under_relaxation(TUIMethod):
                    """
                    Set under-relaxation factor for montecarlo radiation sources used in the energy equation.
                    """
                class rosseland(TUIMethod):
                    """
                    Enable/disable the Rosseland radiation model.
                    """
                class solar(TUIMethod):
                    """
                    Enable/disable the solar model.
                    """
                class solar_irradiation(TUIMethod):
                    """
                    Enable/disable the Solar irradiation model.
                    """
                class solar_calculator(TUIMethod):
                    """
                    Calculate sun direction and intensity.
                    """
                class apply_full_solar_irradiation(TUIMethod):
                    """
                    Enable/disable application of solar irradiation to first band with DO model.
                    """
                class wsggm_cell_based(TUIMethod):
                    """
                    Enable/disable WSGGM cell based method.
                    """
                class fast_second_order_discrete_ordinate(TUIMethod):
                    """
                    Enable/disable the fast-second-order option for Discrete Ordinate Model.
                    """
                class do_coupling(TUIMethod):
                    """
                    Enabled DO Energy Coupling.
                    """
                class solution_method_for_do_coupling(TUIMethod):
                    """
                    Enable the solution method for DO/Energy  Coupling.
                    """
                class beta_radiation_features(TUIMethod):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                class method_partially_specular_wall(TUIMethod):
                    """
                    Set method for partially specular wall with discrete ordinate model.
                    """
                class blending_factor(TUIMethod):
                    """
                    Set numeric option for Discrete Ordinate model.
                    """

                class s2s_parameters(TUIMenu):
                    """
                    Enter the S2S parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.compute_vf_only = self.__class__.compute_vf_only(service, version, mode, path + ["compute_vf_only"])
                        self.compute_write_vf = self.__class__.compute_write_vf(service, version, mode, path + ["compute_write_vf"])
                        self.compute_vf_accelerated = self.__class__.compute_vf_accelerated(service, version, mode, path + ["compute_vf_accelerated"])
                        self.compute_clusters_and_vf_accelerated = self.__class__.compute_clusters_and_vf_accelerated(service, version, mode, path + ["compute_clusters_and_vf_accelerated"])
                        self.non_participating_boundary_zones_temperature = self.__class__.non_participating_boundary_zones_temperature(service, version, mode, path + ["non_participating_boundary_zones_temperature"])
                        self.read_vf_file = self.__class__.read_vf_file(service, version, mode, path + ["read_vf_file"])
                        self.set_vf_parameters = self.__class__.set_vf_parameters(service, version, mode, path + ["set_vf_parameters"])
                        self.split_angle = self.__class__.split_angle(service, version, mode, path + ["split_angle"])
                        self.set_global_faces_per_surface_cluster = self.__class__.set_global_faces_per_surface_cluster(service, version, mode, path + ["set_global_faces_per_surface_cluster"])
                        self.print_thread_clusters = self.__class__.print_thread_clusters(service, version, mode, path + ["print_thread_clusters"])
                        self.print_zonewise_radiation = self.__class__.print_zonewise_radiation(service, version, mode, path + ["print_zonewise_radiation"])
                        self.use_old_cluster_algorithm = self.__class__.use_old_cluster_algorithm(service, version, mode, path + ["use_old_cluster_algorithm"])
                        self.use_new_cluster_algorithm = self.__class__.use_new_cluster_algorithm(service, version, mode, path + ["use_new_cluster_algorithm"])
                        self.compute_fpsc_values = self.__class__.compute_fpsc_values(service, version, mode, path + ["compute_fpsc_values"])
                        self.enable_mesh_interface_clustering = self.__class__.enable_mesh_interface_clustering(service, version, mode, path + ["enable_mesh_interface_clustering"])
                        super().__init__(service, version, mode, path)
                    class compute_vf_only(TUIMethod):
                        """
                        Compute/write view factors only.
                        """
                    class compute_write_vf(TUIMethod):
                        """
                        Compute/write surface clusters and view factors for S2S radiation model.
                        """
                    class compute_vf_accelerated(TUIMethod):
                        """
                        Compute/Write view factors from existing surface clusters.
                        """
                    class compute_clusters_and_vf_accelerated(TUIMethod):
                        """
                        Compute/Write surface cluster first and then view factors.
                        """
                    class non_participating_boundary_zones_temperature(TUIMethod):
                        """
                        Set temperature for the non-participating boundary zones.
                        """
                    class read_vf_file(TUIMethod):
                        """
                        Read an S2S file.
                        """
                    class set_vf_parameters(TUIMethod):
                        """
                        Set the parameters needed for the view factor calculations.
                        """
                    class split_angle(TUIMethod):
                        """
                        Set the split angle for the clustering algorithm.
                        """
                    class set_global_faces_per_surface_cluster(TUIMethod):
                        """
                        Set global value of faces per surface cluster for all boundary zones.
                        """
                    class print_thread_clusters(TUIMethod):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                    class print_zonewise_radiation(TUIMethod):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                    class use_old_cluster_algorithm(TUIMethod):
                        """
                        Use the old surface clustering algorithm.
                        """
                    class use_new_cluster_algorithm(TUIMethod):
                        """
                        Use the new surface clustering algorithm.
                        """
                    class compute_fpsc_values(TUIMethod):
                        """
                        Compute only fpsc values based on current settings.
                        """
                    class enable_mesh_interface_clustering(TUIMethod):
                        """
                        Enable clustering on mesh interfaces?.
                        """

                class dtrm_parameters(TUIMenu):
                    """
                    Enter the DTRM parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                        self.make_globs = self.__class__.make_globs(service, version, mode, path + ["make_globs"])
                        self.ray_trace = self.__class__.ray_trace(service, version, mode, path + ["ray_trace"])
                        self.check_ray_file = self.__class__.check_ray_file(service, version, mode, path + ["check_ray_file"])
                        super().__init__(service, version, mode, path)
                    class controls(TUIMethod):
                        """
                        Set DTRM solution controls.
                        """
                    class make_globs(TUIMethod):
                        """
                        Make globs (coarser mesh) for radiation.
                        """
                    class ray_trace(TUIMethod):
                        """
                        Create DTRM rays for radiation.
                        """
                    class check_ray_file(TUIMethod):
                        """
                        Read DTRM rays file.
                        """

                class solar_parameters(TUIMenu):
                    """
                    Enter the solar parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.autosave_solar_data = self.__class__.autosave_solar_data(service, version, mode, path + ["autosave_solar_data"])
                        self.autoread_solar_data = self.__class__.autoread_solar_data(service, version, mode, path + ["autoread_solar_data"])
                        self.sun_direction_vector = self.__class__.sun_direction_vector(service, version, mode, path + ["sun_direction_vector"])
                        self.illumination_parameters = self.__class__.illumination_parameters(service, version, mode, path + ["illumination_parameters"])
                        self.iteration_parameters = self.__class__.iteration_parameters(service, version, mode, path + ["iteration_parameters"])
                        self.quad_tree_parameters = self.__class__.quad_tree_parameters(service, version, mode, path + ["quad_tree_parameters"])
                        self.ground_reflectivity = self.__class__.ground_reflectivity(service, version, mode, path + ["ground_reflectivity"])
                        self.scattering_fraction = self.__class__.scattering_fraction(service, version, mode, path + ["scattering_fraction"])
                        self.sol_on_demand = self.__class__.sol_on_demand(service, version, mode, path + ["sol_on_demand"])
                        self.sol_camera_pos = self.__class__.sol_camera_pos(service, version, mode, path + ["sol_camera_pos"])
                        self.sol_adjacent_fluidcells = self.__class__.sol_adjacent_fluidcells(service, version, mode, path + ["sol_adjacent_fluidcells"])
                        self.use_direction_from_sol_calc = self.__class__.use_direction_from_sol_calc(service, version, mode, path + ["use_direction_from_sol_calc"])
                        self.solar_thread_control = self.__class__.solar_thread_control(service, version, mode, path + ["solar_thread_control"])
                        super().__init__(service, version, mode, path)
                    class autosave_solar_data(TUIMethod):
                        """
                        Set autosave solar data parameters.
                        """
                    class autoread_solar_data(TUIMethod):
                        """
                        Set autoread solar data parameters.
                        """
                    class sun_direction_vector(TUIMethod):
                        """
                        Set sun direction vector.
                        """
                    class illumination_parameters(TUIMethod):
                        """
                        Set illumination parameters.
                        """
                    class iteration_parameters(TUIMethod):
                        """
                        Set update parameters.
                        """
                    class quad_tree_parameters(TUIMethod):
                        """
                        Set quad-tree refinement parameters.
                        """
                    class ground_reflectivity(TUIMethod):
                        """
                        Set ground reflectivity parameters.
                        """
                    class scattering_fraction(TUIMethod):
                        """
                        Set scattering fraction parameters.
                        """
                    class sol_on_demand(TUIMethod):
                        """
                        Enable  solar load on demand.
                        """
                    class sol_camera_pos(TUIMethod):
                        """
                        Set camera position based on sun direction vector.
                        """
                    class sol_adjacent_fluidcells(TUIMethod):
                        """
                        Enable solar load for adjacent fluid cells.
                        """
                    class use_direction_from_sol_calc(TUIMethod):
                        """
                        Set direction computed from solar calculator.
                        """
                    class solar_thread_control(TUIMethod):
                        """
                        Solar thread control.
                        """

            class solver(TUIMenu):
                """
                Enter the menu to select the solver.
                """
                def __init__(self, service, version, mode, path):
                    self.pressure_based = self.__class__.pressure_based(service, version, mode, path + ["pressure_based"])
                    self.density_based_explicit = self.__class__.density_based_explicit(service, version, mode, path + ["density_based_explicit"])
                    self.density_based_implicit = self.__class__.density_based_implicit(service, version, mode, path + ["density_based_implicit"])
                    self.adjust_solver_defaults_based_on_setup = self.__class__.adjust_solver_defaults_based_on_setup(service, version, mode, path + ["adjust_solver_defaults_based_on_setup"])
                    super().__init__(service, version, mode, path)
                class pressure_based(TUIMethod):
                    """
                    Enable/disable the segregated solver.
                    """
                class density_based_explicit(TUIMethod):
                    """
                    Enable/disable the coupled-explicit solver.
                    """
                class density_based_implicit(TUIMethod):
                    """
                    Enable/disable the coupled-implicit solver.
                    """
                class adjust_solver_defaults_based_on_setup(TUIMethod):
                    """
                    Enable/disable adjustment of solver defaults based on setup.
                    """

            class species(TUIMenu):
                """
                Enter the species models menu.
                """
                def __init__(self, service, version, mode, path):
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(service, version, mode, path + ["CHEMKIN_CFD_parameters"])
                    self.off = self.__class__.off(service, version, mode, path + ["off"])
                    self.species_transport = self.__class__.species_transport(service, version, mode, path + ["species_transport"])
                    self.non_premixed_combustion = self.__class__.non_premixed_combustion(service, version, mode, path + ["non_premixed_combustion"])
                    self.premixed_combustion = self.__class__.premixed_combustion(service, version, mode, path + ["premixed_combustion"])
                    self.partially_premixed_combustion = self.__class__.partially_premixed_combustion(service, version, mode, path + ["partially_premixed_combustion"])
                    self.premixed_model = self.__class__.premixed_model(service, version, mode, path + ["premixed_model"])
                    self.pdf_transport = self.__class__.pdf_transport(service, version, mode, path + ["pdf_transport"])
                    self.save_gradients = self.__class__.save_gradients(service, version, mode, path + ["save_gradients"])
                    self.liquid_energy_diffusion = self.__class__.liquid_energy_diffusion(service, version, mode, path + ["liquid_energy_diffusion"])
                    self.volumetric_reactions = self.__class__.volumetric_reactions(service, version, mode, path + ["volumetric_reactions"])
                    self.species_transport_expert = self.__class__.species_transport_expert(service, version, mode, path + ["species_transport_expert"])
                    self.coal_calculator = self.__class__.coal_calculator(service, version, mode, path + ["coal_calculator"])
                    self.mixing_model = self.__class__.mixing_model(service, version, mode, path + ["mixing_model"])
                    self.stiff_chemistry = self.__class__.stiff_chemistry(service, version, mode, path + ["stiff_chemistry"])
                    self.liquid_micro_mixing = self.__class__.liquid_micro_mixing(service, version, mode, path + ["liquid_micro_mixing"])
                    self.epdf_energy = self.__class__.epdf_energy(service, version, mode, path + ["epdf_energy"])
                    self.integration_parameters = self.__class__.integration_parameters(service, version, mode, path + ["integration_parameters"])
                    self.clear_isat_table = self.__class__.clear_isat_table(service, version, mode, path + ["clear_isat_table"])
                    self.pdf_transport_expert = self.__class__.pdf_transport_expert(service, version, mode, path + ["pdf_transport_expert"])
                    self.set_turb_chem_interaction = self.__class__.set_turb_chem_interaction(service, version, mode, path + ["set_turb_chem_interaction"])
                    self.spark_model = self.__class__.spark_model(service, version, mode, path + ["spark_model"])
                    self.ignition_model = self.__class__.ignition_model(service, version, mode, path + ["ignition_model"])
                    self.ignition_model_controls = self.__class__.ignition_model_controls(service, version, mode, path + ["ignition_model_controls"])
                    self.inert_transport_model = self.__class__.inert_transport_model(service, version, mode, path + ["inert_transport_model"])
                    self.inert_transport_controls = self.__class__.inert_transport_controls(service, version, mode, path + ["inert_transport_controls"])
                    self.particle_surface_reactions = self.__class__.particle_surface_reactions(service, version, mode, path + ["particle_surface_reactions"])
                    self.wall_surface_reactions = self.__class__.wall_surface_reactions(service, version, mode, path + ["wall_surface_reactions"])
                    self.heat_of_surface_reactions = self.__class__.heat_of_surface_reactions(service, version, mode, path + ["heat_of_surface_reactions"])
                    self.mass_deposition_source = self.__class__.mass_deposition_source(service, version, mode, path + ["mass_deposition_source"])
                    self.electro_chemical_surface_reactions = self.__class__.electro_chemical_surface_reactions(service, version, mode, path + ["electro_chemical_surface_reactions"])
                    self.species_migration = self.__class__.species_migration(service, version, mode, path + ["species_migration"])
                    self.reaction_diffusion_balance = self.__class__.reaction_diffusion_balance(service, version, mode, path + ["reaction_diffusion_balance"])
                    self.surf_reaction_aggressiveness_factor = self.__class__.surf_reaction_aggressiveness_factor(service, version, mode, path + ["surf_reaction_aggressiveness_factor"])
                    self.surf_reaction_netm_params = self.__class__.surf_reaction_netm_params(service, version, mode, path + ["surf_reaction_netm_params"])
                    self.inlet_diffusion = self.__class__.inlet_diffusion(service, version, mode, path + ["inlet_diffusion"])
                    self.diffusion_energy_source = self.__class__.diffusion_energy_source(service, version, mode, path + ["diffusion_energy_source"])
                    self.multicomponent_diffusion = self.__class__.multicomponent_diffusion(service, version, mode, path + ["multicomponent_diffusion"])
                    self.thermal_diffusion = self.__class__.thermal_diffusion(service, version, mode, path + ["thermal_diffusion"])
                    self.CHEMKIN_CFD = self.__class__.CHEMKIN_CFD(service, version, mode, path + ["CHEMKIN_CFD"])
                    self.non_premixed_combustion_parameters = self.__class__.non_premixed_combustion_parameters(service, version, mode, path + ["non_premixed_combustion_parameters"])
                    self.partially_premixed_combustion_parameters = self.__class__.partially_premixed_combustion_parameters(service, version, mode, path + ["partially_premixed_combustion_parameters"])
                    self.partially_premixed_properties = self.__class__.partially_premixed_properties(service, version, mode, path + ["partially_premixed_properties"])
                    self.re_calc_par_premix_props = self.__class__.re_calc_par_premix_props(service, version, mode, path + ["re_calc_par_premix_props"])
                    self.full_tabulation = self.__class__.full_tabulation(service, version, mode, path + ["full_tabulation"])
                    self.init_unsteady_flamelet_prob = self.__class__.init_unsteady_flamelet_prob(service, version, mode, path + ["init_unsteady_flamelet_prob"])
                    self.import_flamelet_for_restart = self.__class__.import_flamelet_for_restart(service, version, mode, path + ["import_flamelet_for_restart"])
                    self.non_premixed_combustion_expert = self.__class__.non_premixed_combustion_expert(service, version, mode, path + ["non_premixed_combustion_expert"])
                    self.partially_premixed_combustion_expert = self.__class__.partially_premixed_combustion_expert(service, version, mode, path + ["partially_premixed_combustion_expert"])
                    self.partially_premixed_combustion_grids = self.__class__.partially_premixed_combustion_grids(service, version, mode, path + ["partially_premixed_combustion_grids"])
                    self.flamelet_expert = self.__class__.flamelet_expert(service, version, mode, path + ["flamelet_expert"])
                    self.combustion_expert = self.__class__.combustion_expert(service, version, mode, path + ["combustion_expert"])
                    self.set_premixed_combustion = self.__class__.set_premixed_combustion(service, version, mode, path + ["set_premixed_combustion"])
                    self.set_multi_regime_fgm = self.__class__.set_multi_regime_fgm(service, version, mode, path + ["set_multi_regime_fgm"])
                    self.relax_to_equil = self.__class__.relax_to_equil(service, version, mode, path + ["relax_to_equil"])
                    self.thickened_flame_model = self.__class__.thickened_flame_model(service, version, mode, path + ["thickened_flame_model"])
                    self.decoupled_detailed_chemistry = self.__class__.decoupled_detailed_chemistry(service, version, mode, path + ["decoupled_detailed_chemistry"])
                    self.reactor_network_model = self.__class__.reactor_network_model(service, version, mode, path + ["reactor_network_model"])
                    self.reacting_channel_model = self.__class__.reacting_channel_model(service, version, mode, path + ["reacting_channel_model"])
                    self.reacting_channel_model_options = self.__class__.reacting_channel_model_options(service, version, mode, path + ["reacting_channel_model_options"])
                    self.combustion_numerics = self.__class__.combustion_numerics(service, version, mode, path + ["combustion_numerics"])
                    super().__init__(service, version, mode, path)
                class off(TUIMethod):
                    """
                    Enable/disable solution of species models.
                    """
                class species_transport(TUIMethod):
                    """
                    Enable/disable the species transport model.
                    """
                class non_premixed_combustion(TUIMethod):
                    """
                    Enable/disable the non-premixed combustion model.
                    """
                class premixed_combustion(TUIMethod):
                    """
                    Enable/disable the premixed combustion model.
                    """
                class partially_premixed_combustion(TUIMethod):
                    """
                    Enable/disable partially premixed combustion model.
                    """
                class premixed_model(TUIMethod):
                    """
                    Set premixed combustion model.
                    """
                class pdf_transport(TUIMethod):
                    """
                    Enable/disable the composition PDF transport combustion model.
                    """
                class save_gradients(TUIMethod):
                    """
                    Enable/disable storage of species mass fraction gradients.
                    """
                class liquid_energy_diffusion(TUIMethod):
                    """
                    Enable/disable energy diffusion for liquid regime.
                    """
                class volumetric_reactions(TUIMethod):
                    """
                    Enable/disable volumetric reactions.
                    """
                class species_transport_expert(TUIMethod):
                    """
                    Set species transport expert options.
                    """
                class coal_calculator(TUIMethod):
                    """
                    Set up coal modeling inputs.
                    """
                class mixing_model(TUIMethod):
                    """
                    Set PDF transport mixing model.
                    """
                class stiff_chemistry(TUIMethod):
                    """
                    Enable/disable stiff chemistry option.
                    """
                class liquid_micro_mixing(TUIMethod):
                    """
                    Enable/disable liquid micro mixing option.
                    """
                class epdf_energy(TUIMethod):
                    """
                    Enable/disable EPDF energy  option.
                    """
                class integration_parameters(TUIMethod):
                    """
                    Set ISAT parameters.
                    """
                class clear_isat_table(TUIMethod):
                    """
                    Clear the ISAT table.
                    """
                class pdf_transport_expert(TUIMethod):
                    """
                    Enable/disable PDF transport expert user.
                    """
                class set_turb_chem_interaction(TUIMethod):
                    """
                    Set Eddy-Dissipation Concept model constants.
                    """
                class spark_model(TUIMethod):
                    """
                    Set spark model parameters.
                    """
                class ignition_model(TUIMethod):
                    """
                    Enable/disable the ignition model.
                    """
                class ignition_model_controls(TUIMethod):
                    """
                    Set ignition model parameters.
                    """
                class inert_transport_model(TUIMethod):
                    """
                    Enable/disable the inert transport model.
                    """
                class inert_transport_controls(TUIMethod):
                    """
                    Set inert transport model parameters.
                    """
                class particle_surface_reactions(TUIMethod):
                    """
                    Enable/disable particle surface reactions.
                    """
                class wall_surface_reactions(TUIMethod):
                    """
                    Enable/disable wall surface reactions.
                    """
                class heat_of_surface_reactions(TUIMethod):
                    """
                    Enable/disable heat of surface reactions.
                    """
                class mass_deposition_source(TUIMethod):
                    """
                    Enable/disable mass deposition source due to surface reactions.
                    """
                class electro_chemical_surface_reactions(TUIMethod):
                    """
                    Enable/disable electrochemical surface reactions.
                    """
                class species_migration(TUIMethod):
                    """
                    Enable/disable ion species migration in electric field.
                    """
                class reaction_diffusion_balance(TUIMethod):
                    """
                    Enable/disable reaction diffusion balance at reacting surface for surface reactions.
                    """
                class surf_reaction_aggressiveness_factor(TUIMethod):
                    """
                    Set the surface reaction aggressiveness factor.
                    """
                class surf_reaction_netm_params(TUIMethod):
                    """
                    Set the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                class inlet_diffusion(TUIMethod):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                class diffusion_energy_source(TUIMethod):
                    """
                    Enable/disable diffusion energy source.
                    """
                class multicomponent_diffusion(TUIMethod):
                    """
                    Enable/disable multicomponent diffusion.
                    """
                class thermal_diffusion(TUIMethod):
                    """
                    Enable/disable thermal diffusion.
                    """
                class CHEMKIN_CFD(TUIMethod):
                    """
                    Enable/disable CHEMKIN-CFD.
                    """
                class non_premixed_combustion_parameters(TUIMethod):
                    """
                    Set PDF parameters.
                    """
                class partially_premixed_combustion_parameters(TUIMethod):
                    """
                    Set PDF parameters.
                    """
                class partially_premixed_properties(TUIMethod):
                    """
                    Set/Change partially premixed mixture properties.
                    """
                class re_calc_par_premix_props(TUIMethod):
                    """
                    Re-calculate partially-premixed properties.
                    """
                class full_tabulation(TUIMethod):
                    """
                    Enable/disable building of a full 2 mixture fraction table.
                    """
                class init_unsteady_flamelet_prob(TUIMethod):
                    """
                    Initialize Unsteady Flamelet Probability.
                    """
                class import_flamelet_for_restart(TUIMethod):
                    """
                    Import Flamelet File for Restart.
                    """
                class non_premixed_combustion_expert(TUIMethod):
                    """
                    Set PDF expert parameters.
                    """
                class partially_premixed_combustion_expert(TUIMethod):
                    """
                    Set PDF expert parameters.
                    """
                class partially_premixed_combustion_grids(TUIMethod):
                    """
                    Set user specified grid parameters for PDF and flamelet.
                    """
                class flamelet_expert(TUIMethod):
                    """
                    Set flamelet expert parameters.
                    """
                class combustion_expert(TUIMethod):
                    """
                    Set combustion expert parameters.
                    """
                class set_premixed_combustion(TUIMethod):
                    """
                    Set premixed combustion parameters.
                    """
                class set_multi_regime_fgm(TUIMethod):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                class relax_to_equil(TUIMethod):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                class thickened_flame_model(TUIMethod):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                class decoupled_detailed_chemistry(TUIMethod):
                    """
                    Enable/disable the Decoupled Detailed Chemistry model.
                    """
                class reactor_network_model(TUIMethod):
                    """
                    Enable/disable the Reactor Network model.
                    """
                class reacting_channel_model(TUIMethod):
                    """
                    Enable/Disable the Reacting Channel Model.
                    """
                class reacting_channel_model_options(TUIMethod):
                    """
                    Set Reacting Channel Model parameters.
                    """
                class combustion_numerics(TUIMethod):
                    """
                    Set combustion numerics options.
                    """

                class CHEMKIN_CFD_parameters(TUIMenu):
                    """
                    Enter the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.basic_options = self.__class__.basic_options(service, version, mode, path + ["basic_options"])
                        self.advanced_options = self.__class__.advanced_options(service, version, mode, path + ["advanced_options"])
                        self.add_cell_monitor = self.__class__.add_cell_monitor(service, version, mode, path + ["add_cell_monitor"])
                        self.list_cell_monitors = self.__class__.list_cell_monitors(service, version, mode, path + ["list_cell_monitors"])
                        self.delete_cell_monitors = self.__class__.delete_cell_monitors(service, version, mode, path + ["delete_cell_monitors"])
                        super().__init__(service, version, mode, path)
                    class basic_options(TUIMethod):
                        """
                        Set basic parameter options.
                        """
                    class advanced_options(TUIMethod):
                        """
                        Set advanced parameter options.
                        """
                    class add_cell_monitor(TUIMethod):
                        """
                        Add a monitor cell for debug output.
                        """
                    class list_cell_monitors(TUIMethod):
                        """
                        List cell monitors.
                        """
                    class delete_cell_monitors(TUIMethod):
                        """
                        Delete cell monitors.
                        """

            class viscous(TUIMenu):
                """
                Enter the viscous model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.near_wall_treatment = self.__class__.near_wall_treatment(service, version, mode, path + ["near_wall_treatment"])
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(service, version, mode, path + ["multiphase_turbulence"])
                    self.turbulence_expert = self.__class__.turbulence_expert(service, version, mode, path + ["turbulence_expert"])
                    self.geko_options = self.__class__.geko_options(service, version, mode, path + ["geko_options"])
                    self.transition_model_options = self.__class__.transition_model_options(service, version, mode, path + ["transition_model_options"])
                    self.inviscid = self.__class__.inviscid(service, version, mode, path + ["inviscid"])
                    self.laminar = self.__class__.laminar(service, version, mode, path + ["laminar"])
                    self.low_pressure_boundary_slip = self.__class__.low_pressure_boundary_slip(service, version, mode, path + ["low_pressure_boundary_slip"])
                    self.mixing_length = self.__class__.mixing_length(service, version, mode, path + ["mixing_length"])
                    self.zero_equation_hvac = self.__class__.zero_equation_hvac(service, version, mode, path + ["zero_equation_hvac"])
                    self.spalart_allmaras = self.__class__.spalart_allmaras(service, version, mode, path + ["spalart_allmaras"])
                    self.ke1e = self.__class__.ke1e(service, version, mode, path + ["ke1e"])
                    self.sa_enhanced_wall_treatment = self.__class__.sa_enhanced_wall_treatment(service, version, mode, path + ["sa_enhanced_wall_treatment"])
                    self.sa_alternate_prod = self.__class__.sa_alternate_prod(service, version, mode, path + ["sa_alternate_prod"])
                    self.sa_damping = self.__class__.sa_damping(service, version, mode, path + ["sa_damping"])
                    self.ke_standard = self.__class__.ke_standard(service, version, mode, path + ["ke_standard"])
                    self.ke_easm = self.__class__.ke_easm(service, version, mode, path + ["ke_easm"])
                    self.ke_realizable = self.__class__.ke_realizable(service, version, mode, path + ["ke_realizable"])
                    self.ke_rng = self.__class__.ke_rng(service, version, mode, path + ["ke_rng"])
                    self.rng_differential_visc = self.__class__.rng_differential_visc(service, version, mode, path + ["rng_differential_visc"])
                    self.rng_swirl_model = self.__class__.rng_swirl_model(service, version, mode, path + ["rng_swirl_model"])
                    self.kw_standard = self.__class__.kw_standard(service, version, mode, path + ["kw_standard"])
                    self.kw_easm = self.__class__.kw_easm(service, version, mode, path + ["kw_easm"])
                    self.kw_bsl = self.__class__.kw_bsl(service, version, mode, path + ["kw_bsl"])
                    self.kw_geko = self.__class__.kw_geko(service, version, mode, path + ["kw_geko"])
                    self.kw_sst = self.__class__.kw_sst(service, version, mode, path + ["kw_sst"])
                    self.kw_wj_bsl_earsm = self.__class__.kw_wj_bsl_earsm(service, version, mode, path + ["kw_wj_bsl_earsm"])
                    self.kw_low_re_correction = self.__class__.kw_low_re_correction(service, version, mode, path + ["kw_low_re_correction"])
                    self.kw_shear_correction = self.__class__.kw_shear_correction(service, version, mode, path + ["kw_shear_correction"])
                    self.turb_compressibility = self.__class__.turb_compressibility(service, version, mode, path + ["turb_compressibility"])
                    self.k_kl_w = self.__class__.k_kl_w(service, version, mode, path + ["k_kl_w"])
                    self.transition_sst = self.__class__.transition_sst(service, version, mode, path + ["transition_sst"])
                    self.v2f = self.__class__.v2f(service, version, mode, path + ["v2f"])
                    self.reynolds_stress_model = self.__class__.reynolds_stress_model(service, version, mode, path + ["reynolds_stress_model"])
                    self.rsm_solve_tke = self.__class__.rsm_solve_tke(service, version, mode, path + ["rsm_solve_tke"])
                    self.rsm_wall_echo = self.__class__.rsm_wall_echo(service, version, mode, path + ["rsm_wall_echo"])
                    self.rsm_linear_pressure_strain = self.__class__.rsm_linear_pressure_strain(service, version, mode, path + ["rsm_linear_pressure_strain"])
                    self.rsm_ssg_pressure_strain = self.__class__.rsm_ssg_pressure_strain(service, version, mode, path + ["rsm_ssg_pressure_strain"])
                    self.rsm_omega_based = self.__class__.rsm_omega_based(service, version, mode, path + ["rsm_omega_based"])
                    self.rsm_bsl_based = self.__class__.rsm_bsl_based(service, version, mode, path + ["rsm_bsl_based"])
                    self.sas = self.__class__.sas(service, version, mode, path + ["sas"])
                    self.detached_eddy_simulation = self.__class__.detached_eddy_simulation(service, version, mode, path + ["detached_eddy_simulation"])
                    self.des_limiter_option = self.__class__.des_limiter_option(service, version, mode, path + ["des_limiter_option"])
                    self.large_eddy_simulation = self.__class__.large_eddy_simulation(service, version, mode, path + ["large_eddy_simulation"])
                    self.les_subgrid_smagorinsky = self.__class__.les_subgrid_smagorinsky(service, version, mode, path + ["les_subgrid_smagorinsky"])
                    self.les_dynamic_energy_flux = self.__class__.les_dynamic_energy_flux(service, version, mode, path + ["les_dynamic_energy_flux"])
                    self.les_dynamic_scalar_flux = self.__class__.les_dynamic_scalar_flux(service, version, mode, path + ["les_dynamic_scalar_flux"])
                    self.les_subgrid_dynamic_fvar = self.__class__.les_subgrid_dynamic_fvar(service, version, mode, path + ["les_subgrid_dynamic_fvar"])
                    self.les_subgrid_rng = self.__class__.les_subgrid_rng(service, version, mode, path + ["les_subgrid_rng"])
                    self.les_subgrid_wale = self.__class__.les_subgrid_wale(service, version, mode, path + ["les_subgrid_wale"])
                    self.les_subgrid_wmles = self.__class__.les_subgrid_wmles(service, version, mode, path + ["les_subgrid_wmles"])
                    self.les_subgrid_wmles_s_minus_omega = self.__class__.les_subgrid_wmles_s_minus_omega(service, version, mode, path + ["les_subgrid_wmles_s_minus_omega"])
                    self.les_subgrid_tke = self.__class__.les_subgrid_tke(service, version, mode, path + ["les_subgrid_tke"])
                    self.turb_buoyancy_effects = self.__class__.turb_buoyancy_effects(service, version, mode, path + ["turb_buoyancy_effects"])
                    self.curvature_correction = self.__class__.curvature_correction(service, version, mode, path + ["curvature_correction"])
                    self.curvature_correction_ccurv = self.__class__.curvature_correction_ccurv(service, version, mode, path + ["curvature_correction_ccurv"])
                    self.corner_flow_correction = self.__class__.corner_flow_correction(service, version, mode, path + ["corner_flow_correction"])
                    self.corner_flow_correction_ccorner = self.__class__.corner_flow_correction_ccorner(service, version, mode, path + ["corner_flow_correction_ccorner"])
                    self.rsm_or_earsm_geko_option = self.__class__.rsm_or_earsm_geko_option(service, version, mode, path + ["rsm_or_earsm_geko_option"])
                    self.add_transition_model = self.__class__.add_transition_model(service, version, mode, path + ["add_transition_model"])
                    self.user_defined = self.__class__.user_defined(service, version, mode, path + ["user_defined"])
                    self.user_defined_transition = self.__class__.user_defined_transition(service, version, mode, path + ["user_defined_transition"])
                    self.trans_sst_roughness_correlation = self.__class__.trans_sst_roughness_correlation(service, version, mode, path + ["trans_sst_roughness_correlation"])
                    super().__init__(service, version, mode, path)
                class inviscid(TUIMethod):
                    """
                    Enable/disable the inviscid flow model.
                    """
                class laminar(TUIMethod):
                    """
                    Enable/disable the laminar flow model.
                    """
                class low_pressure_boundary_slip(TUIMethod):
                    """
                    Enable/disable the slip boundary formulation for low-pressure gas systems.
                    """
                class mixing_length(TUIMethod):
                    """
                    Enable/disable the mixing-length (algebraic) turbulence model.
                    """
                class zero_equation_hvac(TUIMethod):
                    """
                    Enable/disable the zero-equation HVAC turbulence model.
                    """
                class spalart_allmaras(TUIMethod):
                    """
                    Enable/disable the Spalart-Allmaras turbulence model.
                    """
                class ke1e(TUIMethod):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                class sa_enhanced_wall_treatment(TUIMethod):
                    """
                    Enable/disable the enhanced wall treatment for the Spalart-Allmaras model.
                    If disabled, no smooth blending between the viscous sublayer and the
                    log-law formulation is employed, as was done in versions previous to Fluent14.
                    """
                class sa_alternate_prod(TUIMethod):
                    """
                    Enable/disable strain/vorticity production in Spalart-Allmaras model.
                    """
                class sa_damping(TUIMethod):
                    """
                    Enable/disable the full low-Reynolds number form of Spalart-Allmaras model.
                    """
                class ke_standard(TUIMethod):
                    """
                    Enable/disable the standard k-epsilon turbulence model.
                    """
                class ke_easm(TUIMethod):
                    """
                    Enable/disable the EASM k-epsilon turbulence model.
                    """
                class ke_realizable(TUIMethod):
                    """
                    Enable/disable the realizable k-epsilon turbulence model.
                    """
                class ke_rng(TUIMethod):
                    """
                    Enable/disable the RNG k-epsilon turbulence model.
                    """
                class rng_differential_visc(TUIMethod):
                    """
                    Enable/disable the differential-viscosity model.
                    """
                class rng_swirl_model(TUIMethod):
                    """
                    Enable/disable swirl corrections for rng-model.
                    """
                class kw_standard(TUIMethod):
                    """
                    Enable/disable the standard k-omega turbulence model.
                    """
                class kw_easm(TUIMethod):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                class kw_bsl(TUIMethod):
                    """
                    Enable/disable the BSL k-omega turbulence model.
                    """
                class kw_geko(TUIMethod):
                    """
                    Enable/disable the GEKO turbulence model.
                    """
                class kw_sst(TUIMethod):
                    """
                    Enable/disable the SST k-omega turbulence model.
                    """
                class kw_wj_bsl_earsm(TUIMethod):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                class kw_low_re_correction(TUIMethod):
                    """
                    Enable/disable the k-omega low Re option.
                    """
                class kw_shear_correction(TUIMethod):
                    """
                    Enable/disable the k-omega shear-flow correction option.
                    """
                class turb_compressibility(TUIMethod):
                    """
                    Enable/disable the compressibility correction option.
                    """
                class k_kl_w(TUIMethod):
                    """
                    Enable/disable the k-kl-omega turbulence model.
                    """
                class transition_sst(TUIMethod):
                    """
                    Enable/disable the transition SST turbulence model.
                    """
                class v2f(TUIMethod):
                    """
                    Enable/disable the V2F turbulence model.
                    """
                class reynolds_stress_model(TUIMethod):
                    """
                    Enable/disable the RSM turbulence model.
                    """
                class rsm_solve_tke(TUIMethod):
                    """
                    Enable/disable the solution of T.K.E. in RSM model.
                    """
                class rsm_wall_echo(TUIMethod):
                    """
                    Enable/disable wall-echo effects in RSM model.
                    """
                class rsm_linear_pressure_strain(TUIMethod):
                    """
                    Enable/disable the linear pressure-strain model in RSM.
                    """
                class rsm_ssg_pressure_strain(TUIMethod):
                    """
                    Enable/disable the quadratic pressure-strain model in RSM.
                    """
                class rsm_omega_based(TUIMethod):
                    """
                    Enable/disable the Stress-omega model.
                    """
                class rsm_bsl_based(TUIMethod):
                    """
                    Enable/disable the Stress-BSL model.
                    """
                class sas(TUIMethod):
                    """
                    Enable/disable the SAS turbulence model.
                    """
                class detached_eddy_simulation(TUIMethod):
                    """
                    Enable/disable detached eddy simulation.
                    """
                class des_limiter_option(TUIMethod):
                    """
                    Select DES limiter option.
                    """
                class large_eddy_simulation(TUIMethod):
                    """
                    Enable/disable large eddy simulation.
                    """
                class les_subgrid_smagorinsky(TUIMethod):
                    """
                    Enable/disable the Smagorinsky-Lilly subgrid-scale model.
                    """
                class les_dynamic_energy_flux(TUIMethod):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                class les_dynamic_scalar_flux(TUIMethod):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                class les_subgrid_dynamic_fvar(TUIMethod):
                    """
                    Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                    """
                class les_subgrid_rng(TUIMethod):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                class les_subgrid_wale(TUIMethod):
                    """
                    Enable/disable the WALE subgrid-scale model.
                    """
                class les_subgrid_wmles(TUIMethod):
                    """
                    Enable/disable the WMLES subgrid-scale model.
                    """
                class les_subgrid_wmles_s_minus_omega(TUIMethod):
                    """
                    Enable/disable the WMLES S-Omega subgrid-scale model.
                    """
                class les_subgrid_tke(TUIMethod):
                    """
                    Enable/disable the kinetic energy transport subgrid-scale model.
                    """
                class turb_buoyancy_effects(TUIMethod):
                    """
                    Select buoyancy effects on turbulence.
                    """
                class curvature_correction(TUIMethod):
                    """
                    Enable/disable the curvature correction.
                    """
                class curvature_correction_ccurv(TUIMethod):
                    """
                    Set the curvature correction coefficient CCURV.
                    """
                class corner_flow_correction(TUIMethod):
                    """
                    Enable/disable the corner flow correction.
                    """
                class corner_flow_correction_ccorner(TUIMethod):
                    """
                    Set the corner flow correction coefficient CCORNER.
                    """
                class rsm_or_earsm_geko_option(TUIMethod):
                    """
                    Enable/disable the GEKO option for RSM or EARSM.
                    """
                class add_transition_model(TUIMethod):
                    """
                    Enable/disable a transition model to account for transitional effects.
                    """
                class user_defined(TUIMethod):
                    """
                    Select user-defined functions to define the turbulent viscosity and the turbulent Prandtl and Schmidt numbers.
                    """
                class user_defined_transition(TUIMethod):
                    """
                    Set user-defined transition correlations.
                    """
                class trans_sst_roughness_correlation(TUIMethod):
                    """
                    Enable/disable the Transition-SST roughness correlation option.
                    """

                class near_wall_treatment(TUIMenu):
                    """
                    Enter the near wall treatment menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.non_equilibrium_wall_fn = self.__class__.non_equilibrium_wall_fn(service, version, mode, path + ["non_equilibrium_wall_fn"])
                        self.enhanced_wall_treatment = self.__class__.enhanced_wall_treatment(service, version, mode, path + ["enhanced_wall_treatment"])
                        self.menter_lechner = self.__class__.menter_lechner(service, version, mode, path + ["menter_lechner"])
                        self.scalable_wall_functions = self.__class__.scalable_wall_functions(service, version, mode, path + ["scalable_wall_functions"])
                        self.user_defined_wall_functions = self.__class__.user_defined_wall_functions(service, version, mode, path + ["user_defined_wall_functions"])
                        self.werner_wengle_wall_fn = self.__class__.werner_wengle_wall_fn(service, version, mode, path + ["werner_wengle_wall_fn"])
                        self.wf_pressure_gradient_effects = self.__class__.wf_pressure_gradient_effects(service, version, mode, path + ["wf_pressure_gradient_effects"])
                        self.wf_thermal_effects = self.__class__.wf_thermal_effects(service, version, mode, path + ["wf_thermal_effects"])
                        super().__init__(service, version, mode, path)
                    class non_equilibrium_wall_fn(TUIMethod):
                        """
                        Enable/disable non-equilibrium wall functions.
                        """
                    class enhanced_wall_treatment(TUIMethod):
                        """
                        Enable/disable enhanced wall functions.
                        """
                    class menter_lechner(TUIMethod):
                        """
                        Enable/disable near wall treatment Menter-Lechner.
                        """
                    class scalable_wall_functions(TUIMethod):
                        """
                        Enable/disable scalable wall functions.
                        """
                    class user_defined_wall_functions(TUIMethod):
                        """
                        Enable user defined wall functions.
                        """
                    class werner_wengle_wall_fn(TUIMethod):
                        """
                        Enable/disable Werner-Wengle wall functions.
                        """
                    class wf_pressure_gradient_effects(TUIMethod):
                        """
                        Enable/disable wall function pressure-gradient effects.
                        """
                    class wf_thermal_effects(TUIMethod):
                        """
                        Enable/disable wall function thermal effects.
                        """

                class multiphase_turbulence(TUIMenu):
                    """
                    Enter the multiphase turbulence menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.multiphase_options = self.__class__.multiphase_options(service, version, mode, path + ["multiphase_options"])
                        self.turbulence_multiphase_models = self.__class__.turbulence_multiphase_models(service, version, mode, path + ["turbulence_multiphase_models"])
                        self.rsm_multiphase_models = self.__class__.rsm_multiphase_models(service, version, mode, path + ["rsm_multiphase_models"])
                        self.subgrid_turbulence_contribution_aiad = self.__class__.subgrid_turbulence_contribution_aiad(service, version, mode, path + ["subgrid_turbulence_contribution_aiad"])
                        super().__init__(service, version, mode, path)
                    class multiphase_options(TUIMethod):
                        """
                        Enable/disable multiphase options.
                        """
                    class turbulence_multiphase_models(TUIMethod):
                        """
                        Select the k-epsilon multiphase model.
                        """
                    class rsm_multiphase_models(TUIMethod):
                        """
                        Enable/disable the Reynolds Stress multiphase model.
                        """
                    class subgrid_turbulence_contribution_aiad(TUIMethod):
                        """
                        Enable/disable the Subgrid Turbulence Contribution for the AIAD model.
                        """

                class turbulence_expert(TUIMenu):
                    """
                    Enter the turbulence expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.low_re_ke = self.__class__.low_re_ke(service, version, mode, path + ["low_re_ke"])
                        self.low_re_ke_index = self.__class__.low_re_ke_index(service, version, mode, path + ["low_re_ke_index"])
                        self.kato_launder_model = self.__class__.kato_launder_model(service, version, mode, path + ["kato_launder_model"])
                        self.production_limiter = self.__class__.production_limiter(service, version, mode, path + ["production_limiter"])
                        self.kw_vorticity_based_production = self.__class__.kw_vorticity_based_production(service, version, mode, path + ["kw_vorticity_based_production"])
                        self.kw_add_sas = self.__class__.kw_add_sas(service, version, mode, path + ["kw_add_sas"])
                        self.kw_add_des = self.__class__.kw_add_des(service, version, mode, path + ["kw_add_des"])
                        self.turb_add_sbes_sdes = self.__class__.turb_add_sbes_sdes(service, version, mode, path + ["turb_add_sbes_sdes"])
                        self.sbes_sdes_hybrid_model = self.__class__.sbes_sdes_hybrid_model(service, version, mode, path + ["sbes_sdes_hybrid_model"])
                        self.sbes_update_interval_k_omega = self.__class__.sbes_update_interval_k_omega(service, version, mode, path + ["sbes_update_interval_k_omega"])
                        self.sbes_sgs_option = self.__class__.sbes_sgs_option(service, version, mode, path + ["sbes_sgs_option"])
                        self.sbes_les_subgrid_dynamic_fvar = self.__class__.sbes_les_subgrid_dynamic_fvar(service, version, mode, path + ["sbes_les_subgrid_dynamic_fvar"])
                        self.turbulence_damping = self.__class__.turbulence_damping(service, version, mode, path + ["turbulence_damping"])
                        self.rke_cmu_rotation_term = self.__class__.rke_cmu_rotation_term(service, version, mode, path + ["rke_cmu_rotation_term"])
                        self.turb_non_newtonian = self.__class__.turb_non_newtonian(service, version, mode, path + ["turb_non_newtonian"])
                        self.non_newtonian_modification = self.__class__.non_newtonian_modification(service, version, mode, path + ["non_newtonian_modification"])
                        self.turb_pk_compressible = self.__class__.turb_pk_compressible(service, version, mode, path + ["turb_pk_compressible"])
                        self.thermal_p_function = self.__class__.thermal_p_function(service, version, mode, path + ["thermal_p_function"])
                        self.restore_sst_v61 = self.__class__.restore_sst_v61(service, version, mode, path + ["restore_sst_v61"])
                        self.stg_set_ti_and_tvr_limiters = self.__class__.stg_set_ti_and_tvr_limiters(service, version, mode, path + ["stg_set_ti_and_tvr_limiters"])
                        super().__init__(service, version, mode, path)
                    class low_re_ke(TUIMethod):
                        """
                        Enable/disable the low-Re k-epsilon turbulence model.
                        """
                    class low_re_ke_index(TUIMethod):
                        """
                        Enable/disable the low-Re k-epsilon model version.
                        """
                    class kato_launder_model(TUIMethod):
                        """
                        Enable/disable Kato-Launder modification for production.
                        """
                    class production_limiter(TUIMethod):
                        """
                        Enable/disable the Production Limiter.
                        """
                    class kw_vorticity_based_production(TUIMethod):
                        """
                        Enable/disable vorticity based production.
                        """
                    class kw_add_sas(TUIMethod):
                        """
                        Enable/disable the SAS-mode with the current turbulence model.
                        """
                    class kw_add_des(TUIMethod):
                        """
                        Enable/disable DES-mode with the current turbulence model.
                        """
                    class turb_add_sbes_sdes(TUIMethod):
                        """
                        Enable/disable SBES / SDES with the current turbulence model.
                        """
                    class sbes_sdes_hybrid_model(TUIMethod):
                        """
                        Select the SBES / SDES hybrid model.
                        """
                    class sbes_update_interval_k_omega(TUIMethod):
                        """
                        Set an integer value how often the k and omega equations are updated in a transient SBES run.
                        """
                    class sbes_sgs_option(TUIMethod):
                        """
                        Select SBES subgrid-scale model.
                        """
                    class sbes_les_subgrid_dynamic_fvar(TUIMethod):
                        """
                        Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                        """
                    class turbulence_damping(TUIMethod):
                        """
                        Enable/disable turbulence damping and set turbulence damping parameters.
                        """
                    class rke_cmu_rotation_term(TUIMethod):
                        """
                        Enable/disable inclusion of omega in the Cmu definition.
                        """
                    class turb_non_newtonian(TUIMethod):
                        """
                        Enable/disable turbulence for non-Newtonian fluids.
                        """
                    class non_newtonian_modification(TUIMethod):
                        """
                        Enable/disable non-Newtonian modification for Lam-Bremhorst model.
                        """
                    class turb_pk_compressible(TUIMethod):
                        """
                        Enable/disable turbulent production due to compressible divergence.
                        """
                    class thermal_p_function(TUIMethod):
                        """
                        Enable/disable the Jayatilleke P function.
                        """
                    class restore_sst_v61(TUIMethod):
                        """
                        Enable/disable SST formulation of v6.1.
                        """
                    class stg_set_ti_and_tvr_limiters(TUIMethod):
                        """
                        Specify minimum Turbulence Intensity (TI) and Turbulent Viscosity Ratio (TVR)
                        to search STG scales only at inlet areas where TVR > TVR_min and TI > TI_min.
                        """

                class geko_options(TUIMenu):
                    """
                    Enter the GEKO options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.wall_distance_free = self.__class__.wall_distance_free(service, version, mode, path + ["wall_distance_free"])
                        self.csep = self.__class__.csep(service, version, mode, path + ["csep"])
                        self.cnw = self.__class__.cnw(service, version, mode, path + ["cnw"])
                        self.cmix = self.__class__.cmix(service, version, mode, path + ["cmix"])
                        self.cjet = self.__class__.cjet(service, version, mode, path + ["cjet"])
                        self.blending_function = self.__class__.blending_function(service, version, mode, path + ["blending_function"])
                        self.creal = self.__class__.creal(service, version, mode, path + ["creal"])
                        self.cnw_sub = self.__class__.cnw_sub(service, version, mode, path + ["cnw_sub"])
                        self.cjet_aux = self.__class__.cjet_aux(service, version, mode, path + ["cjet_aux"])
                        self.cbf_lam = self.__class__.cbf_lam(service, version, mode, path + ["cbf_lam"])
                        self.cbf_tur = self.__class__.cbf_tur(service, version, mode, path + ["cbf_tur"])
                        self.geko_defaults = self.__class__.geko_defaults(service, version, mode, path + ["geko_defaults"])
                        super().__init__(service, version, mode, path)
                    class wall_distance_free(TUIMethod):
                        """
                        Enable/disable wall-distance-free version of GEKO model.
                        """
                    class csep(TUIMethod):
                        """
                        Set the GEKO model coefficient CSEP.
                        """
                    class cnw(TUIMethod):
                        """
                        Set the GEKO model coefficient CNW.
                        """
                    class cmix(TUIMethod):
                        """
                        Set the GEKO model coefficient CMIX.
                        """
                    class cjet(TUIMethod):
                        """
                        Set the GEKO model coefficient CJET.
                        """
                    class blending_function(TUIMethod):
                        """
                        Set the GEKO model blending function.
                        """
                    class creal(TUIMethod):
                        """
                        Set the GEKO model coefficient CREAL.
                        """
                    class cnw_sub(TUIMethod):
                        """
                        Set the GEKO model coefficient CNW_SUB.
                        """
                    class cjet_aux(TUIMethod):
                        """
                        Set the GEKO model coefficient CJET_AUX.
                        """
                    class cbf_lam(TUIMethod):
                        """
                        Set the GEKO model coefficient CBF_LAM.
                        """
                    class cbf_tur(TUIMethod):
                        """
                        Set the GEKO model coefficient CBF_TUR.
                        """
                    class geko_defaults(TUIMethod):
                        """
                        Set GEKO options to default.
                        """

                class transition_model_options(TUIMenu):
                    """
                    Enter the transition model options menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.crossflow_transition = self.__class__.crossflow_transition(service, version, mode, path + ["crossflow_transition"])
                        self.critical_reynolds_number_correlation = self.__class__.critical_reynolds_number_correlation(service, version, mode, path + ["critical_reynolds_number_correlation"])
                        self.clambda_scale = self.__class__.clambda_scale(service, version, mode, path + ["clambda_scale"])
                        self.capg_hightu = self.__class__.capg_hightu(service, version, mode, path + ["capg_hightu"])
                        self.cfpg_hightu = self.__class__.cfpg_hightu(service, version, mode, path + ["cfpg_hightu"])
                        self.capg_lowtu = self.__class__.capg_lowtu(service, version, mode, path + ["capg_lowtu"])
                        self.cfpg_lowtu = self.__class__.cfpg_lowtu(service, version, mode, path + ["cfpg_lowtu"])
                        self.ctu_hightu = self.__class__.ctu_hightu(service, version, mode, path + ["ctu_hightu"])
                        self.ctu_lowtu = self.__class__.ctu_lowtu(service, version, mode, path + ["ctu_lowtu"])
                        self.rec_max = self.__class__.rec_max(service, version, mode, path + ["rec_max"])
                        self.rec_c1 = self.__class__.rec_c1(service, version, mode, path + ["rec_c1"])
                        self.rec_c2 = self.__class__.rec_c2(service, version, mode, path + ["rec_c2"])
                        self.cbubble_c1 = self.__class__.cbubble_c1(service, version, mode, path + ["cbubble_c1"])
                        self.cbubble_c2 = self.__class__.cbubble_c2(service, version, mode, path + ["cbubble_c2"])
                        self.rv1_switch = self.__class__.rv1_switch(service, version, mode, path + ["rv1_switch"])
                        super().__init__(service, version, mode, path)
                    class crossflow_transition(TUIMethod):
                        """
                        Enable/disable crossflow transition for the intermittency transition model.
                        """
                    class critical_reynolds_number_correlation(TUIMethod):
                        """
                        Set the critical Reynolds number correlation.
                        """
                    class clambda_scale(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                    class capg_hightu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                    class cfpg_hightu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                    class capg_lowtu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CAPG_LOWTU.
                        """
                    class cfpg_lowtu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CFPG_LOWTU.
                        """
                    class ctu_hightu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CTU_HIGHTU.
                        """
                    class ctu_lowtu(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CTU_LOWTU.
                        """
                    class rec_max(TUIMethod):
                        """
                        Set the algebraic transition model coefficient REC_MAX.
                        """
                    class rec_c1(TUIMethod):
                        """
                        Set the algebraic transition model coefficient REC_C1.
                        """
                    class rec_c2(TUIMethod):
                        """
                        Set the algebraic transition model coefficient REC_C2.
                        """
                    class cbubble_c1(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C1.
                        """
                    class cbubble_c2(TUIMethod):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C2.
                        """
                    class rv1_switch(TUIMethod):
                        """
                        Set the algebraic transition model coefficient RV1_SWITCH.
                        """

            class structure(TUIMenu):
                """
                Enter the structure model menu.
                """
                def __init__(self, service, version, mode, path):
                    self.controls = self.__class__.controls(service, version, mode, path + ["controls"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.structure_off = self.__class__.structure_off(service, version, mode, path + ["structure_off"])
                    self.linear_elasticity = self.__class__.linear_elasticity(service, version, mode, path + ["linear_elasticity"])
                    self.nonlinear_elasticity = self.__class__.nonlinear_elasticity(service, version, mode, path + ["nonlinear_elasticity"])
                    self.thermal_effects = self.__class__.thermal_effects(service, version, mode, path + ["thermal_effects"])
                    super().__init__(service, version, mode, path)
                class structure_off(TUIMethod):
                    """
                    Disable the structural model.
                    """
                class linear_elasticity(TUIMethod):
                    """
                    Enable the linear elasticity model.
                    """
                class nonlinear_elasticity(TUIMethod):
                    """
                    Enable the nonlinear elasticity model.
                    """
                class thermal_effects(TUIMethod):
                    """
                    Enable structure thermal effects.
                    """

                class controls(TUIMenu):
                    """
                    Enter the structure controls menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.numerical_damping_factor = self.__class__.numerical_damping_factor(service, version, mode, path + ["numerical_damping_factor"])
                        self.enhanced_strain = self.__class__.enhanced_strain(service, version, mode, path + ["enhanced_strain"])
                        self.unsteady_damping_rayleigh = self.__class__.unsteady_damping_rayleigh(service, version, mode, path + ["unsteady_damping_rayleigh"])
                        self.amg_stabilization = self.__class__.amg_stabilization(service, version, mode, path + ["amg_stabilization"])
                        self.max_iter = self.__class__.max_iter(service, version, mode, path + ["max_iter"])
                        super().__init__(service, version, mode, path)
                    class numerical_damping_factor(TUIMethod):
                        """
                        Set structure damping parameters.
                        """
                    class enhanced_strain(TUIMethod):
                        """
                        Enable enhanced strain element.
                        """
                    class unsteady_damping_rayleigh(TUIMethod):
                        """
                        Enable/disable Newmark unsteady solution model.
                        """
                    class amg_stabilization(TUIMethod):
                        """
                        Set the AMG stabilization method for structural solver.
                        """
                    class max_iter(TUIMethod):
                        """
                        Set the maximum number of iterations for structural solver.
                        """

                class expert(TUIMenu):
                    """
                    Enter the structure expert menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.include_pop_in_fsi_force = self.__class__.include_pop_in_fsi_force(service, version, mode, path + ["include_pop_in_fsi_force"])
                        self.steady_2way_fsi = self.__class__.steady_2way_fsi(service, version, mode, path + ["steady_2way_fsi"])
                        self.include_viscous_fsi_force = self.__class__.include_viscous_fsi_force(service, version, mode, path + ["include_viscous_fsi_force"])
                        self.explicit_fsi_force = self.__class__.explicit_fsi_force(service, version, mode, path + ["explicit_fsi_force"])
                        super().__init__(service, version, mode, path)
                    class include_pop_in_fsi_force(TUIMethod):
                        """
                        Enable inclusion of operating p into fsi force.
                        """
                    class steady_2way_fsi(TUIMethod):
                        """
                        Enable steady 2-way fsi workflow.
                        """
                    class include_viscous_fsi_force(TUIMethod):
                        """
                        Enable inclusion of viscous fsi force.
                        """
                    class explicit_fsi_force(TUIMethod):
                        """
                        Enable explicit fsi force.
                        """

            class heat_exchanger(TUIMenu):
                """
                Enter the heat exchanger menu.
                """
                def __init__(self, service, version, mode, path):
                    self.macro_model = self.__class__.macro_model(service, version, mode, path + ["macro_model"])
                    self.dual_cell_model = self.__class__.dual_cell_model(service, version, mode, path + ["dual_cell_model"])
                    super().__init__(service, version, mode, path)

                class macro_model(TUIMenu):
                    """
                    Enter the heat macro-model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.heat_exchanger_model = self.__class__.heat_exchanger_model(service, version, mode, path + ["heat_exchanger_model"])
                        self.heat_exchanger_zone = self.__class__.heat_exchanger_zone(service, version, mode, path + ["heat_exchanger_zone"])
                        self.heat_exchanger_group = self.__class__.heat_exchanger_group(service, version, mode, path + ["heat_exchanger_group"])
                        self.delete_heat_exchanger_group = self.__class__.delete_heat_exchanger_group(service, version, mode, path + ["delete_heat_exchanger_group"])
                        self.heat_exchanger_report = self.__class__.heat_exchanger_report(service, version, mode, path + ["heat_exchanger_report"])
                        self.heat_exchanger_macro_report = self.__class__.heat_exchanger_macro_report(service, version, mode, path + ["heat_exchanger_macro_report"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        super().__init__(service, version, mode, path)
                    class heat_exchanger(TUIMethod):
                        """
                        Enable/disable heat-exchanger model.
                        """
                    class heat_exchanger_model(TUIMethod):
                        """
                        Define heat-exchanger core model.
                        """
                    class heat_exchanger_zone(TUIMethod):
                        """
                        Define heat-exchanger zone.
                        """
                    class heat_exchanger_group(TUIMethod):
                        """
                        Define heat-exchanger group.
                        """
                    class delete_heat_exchanger_group(TUIMethod):
                        """
                        Delete heat-exchanger group.
                        """
                    class heat_exchanger_report(TUIMethod):
                        """
                        Report heat-exchanger information.
                        """
                    class heat_exchanger_macro_report(TUIMethod):
                        """
                        Report heat-exchanger information for all the macros.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """

                class dual_cell_model(TUIMenu):
                    """
                    Enter the dual cell model menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.heat_exchanger = self.__class__.heat_exchanger(service, version, mode, path + ["heat_exchanger"])
                        self.add_heat_exchanger = self.__class__.add_heat_exchanger(service, version, mode, path + ["add_heat_exchanger"])
                        self.modify_heat_exchanger = self.__class__.modify_heat_exchanger(service, version, mode, path + ["modify_heat_exchanger"])
                        self.delete_heat_exchanger = self.__class__.delete_heat_exchanger(service, version, mode, path + ["delete_heat_exchanger"])
                        self.plot_NTU = self.__class__.plot_NTU(service, version, mode, path + ["plot_NTU"])
                        self.write_NTU = self.__class__.write_NTU(service, version, mode, path + ["write_NTU"])
                        self.alternative_formulation = self.__class__.alternative_formulation(service, version, mode, path + ["alternative_formulation"])
                        super().__init__(service, version, mode, path)
                    class heat_exchanger(TUIMethod):
                        """
                        Enable/disable the dual cell heat-exchanger model.
                        """
                    class add_heat_exchanger(TUIMethod):
                        """
                        Add heat-exchanger.
                        """
                    class modify_heat_exchanger(TUIMethod):
                        """
                        Modify heat-exchanger.
                        """
                    class delete_heat_exchanger(TUIMethod):
                        """
                        Delete heat-exchanger.
                        """
                    class plot_NTU(TUIMethod):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class write_NTU(TUIMethod):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                    class alternative_formulation(TUIMethod):
                        """
                        Enable/disable alternative formulation for heat transfer calculations.
                        """

            class electrolysis_setup(TUIMenu):
                """
                Enter the electrolysis model setup menu.
                """
                def __init__(self, service, version, mode, path):
                    self.anode_setup = self.__class__.anode_setup(service, version, mode, path + ["anode_setup"])
                    self.cathode_setup = self.__class__.cathode_setup(service, version, mode, path + ["cathode_setup"])
                    self.membrane_setup = self.__class__.membrane_setup(service, version, mode, path + ["membrane_setup"])
                    self.model_options = self.__class__.model_options(service, version, mode, path + ["model_options"])
                    self.parameters = self.__class__.parameters(service, version, mode, path + ["parameters"])
                    self.electrical_tabs_setup = self.__class__.electrical_tabs_setup(service, version, mode, path + ["electrical_tabs_setup"])
                    super().__init__(service, version, mode, path)
                class model_options(TUIMethod):
                    """
                    Model Options.
                    """
                class parameters(TUIMethod):
                    """
                    Model Parameters.
                    """
                class electrical_tabs_setup(TUIMethod):
                    """
                    Electrical Tabs Setup.
                    """

                class anode_setup(TUIMenu):
                    """
                    Anode Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

                class cathode_setup(TUIMenu):
                    """
                    Cathode Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

                class membrane_setup(TUIMenu):
                    """
                    Membrane Setup.
                    """
                    def __init__(self, service, version, mode, path):
                        self.current_collector = self.__class__.current_collector(service, version, mode, path + ["current_collector"])
                        self.flow_channel = self.__class__.flow_channel(service, version, mode, path + ["flow_channel"])
                        self.porous_layer = self.__class__.porous_layer(service, version, mode, path + ["porous_layer"])
                        self.catalyst_layer = self.__class__.catalyst_layer(service, version, mode, path + ["catalyst_layer"])
                        self.electrolyte = self.__class__.electrolyte(service, version, mode, path + ["electrolyte"])
                        super().__init__(service, version, mode, path)
                    class current_collector(TUIMethod):
                        """
                        Set Current Collector.
                        """
                    class flow_channel(TUIMethod):
                        """
                        Set Flow Channel.
                        """
                    class porous_layer(TUIMethod):
                        """
                        Set Porous Layer.
                        """
                    class catalyst_layer(TUIMethod):
                        """
                        Set Catalyst Layer.
                        """
                    class electrolyte(TUIMethod):
                        """
                        Set Electrolyte.
                        """

        class named_expressions(TUIMenu):
            """
            Manage named expressions.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.copy = self.__class__.copy(service, version, mode, path + ["copy"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.export_to_tsv = self.__class__.export_to_tsv(service, version, mode, path + ["export_to_tsv"])
                self.import_from_tsv = self.__class__.import_from_tsv(service, version, mode, path + ["import_from_tsv"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class compute(TUIMethod):
                """
                Compute expression.
                """
            class copy(TUIMethod):
                """
                Copy expression.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class export_to_tsv(TUIMethod):
                """
                Export expressions.
                """
            class import_from_tsv(TUIMethod):
                """
                Export expressions.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """

        class operating_conditions(TUIMenu):
            """
            Enter the define operating conditions menu.
            """
            def __init__(self, service, version, mode, path):
                self.gravity = self.__class__.gravity(service, version, mode, path + ["gravity"])
                self.gravity_mrf_rotation = self.__class__.gravity_mrf_rotation(service, version, mode, path + ["gravity_mrf_rotation"])
                self.set_state = self.__class__.set_state(service, version, mode, path + ["set_state"])
                self.operating_pressure = self.__class__.operating_pressure(service, version, mode, path + ["operating_pressure"])
                self.reference_pressure_location = self.__class__.reference_pressure_location(service, version, mode, path + ["reference_pressure_location"])
                self.reference_pressure_method = self.__class__.reference_pressure_method(service, version, mode, path + ["reference_pressure_method"])
                self.used_ref_pressure_location = self.__class__.used_ref_pressure_location(service, version, mode, path + ["used_ref_pressure_location"])
                self.operating_density = self.__class__.operating_density(service, version, mode, path + ["operating_density"])
                self.use_inlet_temperature_for_operating_density = self.__class__.use_inlet_temperature_for_operating_density(service, version, mode, path + ["use_inlet_temperature_for_operating_density"])
                self.operating_temperature = self.__class__.operating_temperature(service, version, mode, path + ["operating_temperature"])
                super().__init__(service, version, mode, path)
            class gravity(TUIMethod):
                """
                Set gravitational acceleration.
                """
            class gravity_mrf_rotation(TUIMethod):
                """
                Enable/disable rotation of gravity vector in moving reference frame simulations.
                """
            class set_state(TUIMethod):
                """
                Select state for real gas EOS subcritical condition.
                """
            class operating_pressure(TUIMethod):
                """
                Set the operating pressure.
                """
            class reference_pressure_location(TUIMethod):
                """
                Set coordinates of reference pressure.
                """
            class reference_pressure_method(TUIMethod):
                """
                Choosing reference pressure type.
                """
            class used_ref_pressure_location(TUIMethod):
                """
                See the actual coordinates of reference pressure used.
                """
            class operating_density(TUIMethod):
                """
                Enable/disable use of a specified operating density.
                """
            class use_inlet_temperature_for_operating_density(TUIMethod):
                """
                Use Inlet Temperature to calculate Opearating Density.
                """
            class operating_temperature(TUIMethod):
                """
                Set the operating temperature for Boussinesq.
                """

        class overset_interfaces(TUIMenu):
            """
            Enter the overset-interfaces menu.
            """
            def __init__(self, service, version, mode, path):
                self.options = self.__class__.options(service, version, mode, path + ["options"])
                self.cut_control = self.__class__.cut_control(service, version, mode, path + ["cut_control"])
                self.adapt = self.__class__.adapt(service, version, mode, path + ["adapt"])
                self.create = self.__class__.create(service, version, mode, path + ["create"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                self.intersect = self.__class__.intersect(service, version, mode, path + ["intersect"])
                self.intersect_all = self.__class__.intersect_all(service, version, mode, path + ["intersect_all"])
                self.clear = self.__class__.clear(service, version, mode, path + ["clear"])
                self.clear_all = self.__class__.clear_all(service, version, mode, path + ["clear_all"])
                self.grid_priorities = self.__class__.grid_priorities(service, version, mode, path + ["grid_priorities"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.mark_cells = self.__class__.mark_cells(service, version, mode, path + ["mark_cells"])
                self.display_cells = self.__class__.display_cells(service, version, mode, path + ["display_cells"])
                self.mark_cell_change = self.__class__.mark_cell_change(service, version, mode, path + ["mark_cell_change"])
                self.set_mark_bounds = self.__class__.set_mark_bounds(service, version, mode, path + ["set_mark_bounds"])
                self.check = self.__class__.check(service, version, mode, path + ["check"])
                self.debug_hole_cut = self.__class__.debug_hole_cut(service, version, mode, path + ["debug_hole_cut"])
                self.fill_dci = self.__class__.fill_dci(service, version, mode, path + ["fill_dci"])
                self.free_dci = self.__class__.free_dci(service, version, mode, path + ["free_dci"])
                self.update_from_dci = self.__class__.update_from_dci(service, version, mode, path + ["update_from_dci"])
                self.write_dci_to_case = self.__class__.write_dci_to_case(service, version, mode, path + ["write_dci_to_case"])
                self.read_dci_from_case = self.__class__.read_dci_from_case(service, version, mode, path + ["read_dci_from_case"])
                self.write_dci = self.__class__.write_dci(service, version, mode, path + ["write_dci"])
                self.write_cell_types = self.__class__.write_cell_types(service, version, mode, path + ["write_cell_types"])
                self.find_bounding_cell = self.__class__.find_bounding_cell(service, version, mode, path + ["find_bounding_cell"])
                self.find_all_bounding_cells = self.__class__.find_all_bounding_cells(service, version, mode, path + ["find_all_bounding_cells"])
                super().__init__(service, version, mode, path)
            class create(TUIMethod):
                """
                Create an overset interface.
                """
            class delete(TUIMethod):
                """
                Delete an overset interface.
                """
            class delete_all(TUIMethod):
                """
                Delete all overset interfaces.
                """
            class intersect(TUIMethod):
                """
                Intersect an overset interface.
                """
            class intersect_all(TUIMethod):
                """
                Intersect all overset interfaces.
                """
            class clear(TUIMethod):
                """
                Clear an overset interface.
                """
            class clear_all(TUIMethod):
                """
                Clear all overset interfaces.
                """
            class grid_priorities(TUIMethod):
                """
                Edit grid priorities for an overset interface.
                """
            class list(TUIMethod):
                """
                List all overset interfaces.
                """
            class mark_cells(TUIMethod):
                """
                Mark overset interface related cell types.
                """
            class display_cells(TUIMethod):
                """
                Display the marked overset cells.
                """
            class mark_cell_change(TUIMethod):
                """
                Mark overset interface related cell type change.
                """
            class set_mark_bounds(TUIMethod):
                """
                Set bounds (center, radius) for overset cell marking.
                """
            class check(TUIMethod):
                """
                Check all overset interfaces.
                """
            class debug_hole_cut(TUIMethod):
                """
                Debugging tool for overset hole cutting.
                """
            class fill_dci(TUIMethod):
                """
                Fill overset domain connectivity information (DCI).
                """
            class free_dci(TUIMethod):
                """
                Free overset domain connectivity information (DCI).
                """
            class update_from_dci(TUIMethod):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
            class write_dci_to_case(TUIMethod):
                """
                Save domain connectivity information (DCI) to case file.
                """
            class read_dci_from_case(TUIMethod):
                """
                Read domain connectivity information (DCI) from case file.
                """
            class write_dci(TUIMethod):
                """
                Save domain connectivity information (DCI) to a text file.
                """
            class write_cell_types(TUIMethod):
                """
                Write overset cell types into file.
                """
            class find_bounding_cell(TUIMethod):
                """
                Find bounding cell for given cell or search point.
                """
            class find_all_bounding_cells(TUIMethod):
                """
                Find bounding cells for all cell centroids.
                """

            class options(TUIMenu):
                """
                Enter the overset interface options menu.
                """
                def __init__(self, service, version, mode, path):
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    self.render_receptor_cells = self.__class__.render_receptor_cells(service, version, mode, path + ["render_receptor_cells"])
                    self.partial_cut_faces = self.__class__.partial_cut_faces(service, version, mode, path + ["partial_cut_faces"])
                    self.auto_create = self.__class__.auto_create(service, version, mode, path + ["auto_create"])
                    self.minimize_overlap = self.__class__.minimize_overlap(service, version, mode, path + ["minimize_overlap"])
                    self.overlap_boundaries = self.__class__.overlap_boundaries(service, version, mode, path + ["overlap_boundaries"])
                    self.mesh_interfaces = self.__class__.mesh_interfaces(service, version, mode, path + ["mesh_interfaces"])
                    self.node_connected_donors = self.__class__.node_connected_donors(service, version, mode, path + ["node_connected_donors"])
                    self.donor_priority_method = self.__class__.donor_priority_method(service, version, mode, path + ["donor_priority_method"])
                    self.solve_island_removal = self.__class__.solve_island_removal(service, version, mode, path + ["solve_island_removal"])
                    self.transient_caching = self.__class__.transient_caching(service, version, mode, path + ["transient_caching"])
                    self.modified_donor_search = self.__class__.modified_donor_search(service, version, mode, path + ["modified_donor_search"])
                    self.modified_hole_cutting = self.__class__.modified_hole_cutting(service, version, mode, path + ["modified_hole_cutting"])
                    self.dead_cell_update = self.__class__.dead_cell_update(service, version, mode, path + ["dead_cell_update"])
                    self.update_before_case_write = self.__class__.update_before_case_write(service, version, mode, path + ["update_before_case_write"])
                    self.parallel = self.__class__.parallel(service, version, mode, path + ["parallel"])
                    self.verbosity = self.__class__.verbosity(service, version, mode, path + ["verbosity"])
                    super().__init__(service, version, mode, path)
                class expert(TUIMethod):
                    """
                    Enable additional overset options and tools.
                    """
                class render_receptor_cells(TUIMethod):
                    """
                    Set the option to include receptor cells in postprocessing.
                    """
                class partial_cut_faces(TUIMethod):
                    """
                    Enable enhanced hole cutting where cut faces partially overlap.
                    """
                class auto_create(TUIMethod):
                    """
                    Enable automatic creation of default overset interface.
                    """
                class minimize_overlap(TUIMethod):
                    """
                    Enable overlap minimization for overset interfaces.
                    """
                class overlap_boundaries(TUIMethod):
                    """
                    Enable overset topologies with overlap boundaries.
                    """
                class mesh_interfaces(TUIMethod):
                    """
                    Allow mesh interfaces inside overset cell zones.
                    """
                class node_connected_donors(TUIMethod):
                    """
                    Enable node or face connected donor cells.
                    """
                class donor_priority_method(TUIMethod):
                    """
                    Set method used to evaludate the cell donor priority.
                    """
                class solve_island_removal(TUIMethod):
                    """
                    Set method used to control the removal of isolated patches of solve cells.
                    """
                class transient_caching(TUIMethod):
                    """
                    Set options to control caching of entities in transient overset simulations.
                    """
                class modified_donor_search(TUIMethod):
                    """
                    Enable modified and more extensive donor search.
                    """
                class modified_hole_cutting(TUIMethod):
                    """
                    Enable modified hole cutting parameters.
                    """
                class dead_cell_update(TUIMethod):
                    """
                    Enable dead cell update in moving or dynamic mesh simulations.
                    """
                class update_before_case_write(TUIMethod):
                    """
                    Enable update of overset interfaces before writing case file (CFF format only).
                    """
                class parallel(TUIMethod):
                    """
                    Set options to control running overset in parallel.
                    """
                class verbosity(TUIMethod):
                    """
                    Set overset mesh reporting verbosity.
                    """

            class cut_control(TUIMenu):
                """
                Enter the overset hole cut control menu.
                """
                def __init__(self, service, version, mode, path):
                    self.cut_seeds = self.__class__.cut_seeds(service, version, mode, path + ["cut_seeds"])
                    self.add = self.__class__.add(service, version, mode, path + ["add"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                    self.list = self.__class__.list(service, version, mode, path + ["list"])
                    super().__init__(service, version, mode, path)
                class add(TUIMethod):
                    """
                    Add hole cut control for a boundary zone.
                    """
                class delete(TUIMethod):
                    """
                    Delete hole cut control for a boundary zone.
                    """
                class delete_all(TUIMethod):
                    """
                    Delete the hole cut controls for all boundary zones.
                    """
                class list(TUIMethod):
                    """
                    List the defined hole cut controls.
                    """

                class cut_seeds(TUIMenu):
                    """
                    Enter the overset hole cut seed menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.add = self.__class__.add(service, version, mode, path + ["add"])
                        self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                        self.delete_all = self.__class__.delete_all(service, version, mode, path + ["delete_all"])
                        self.list = self.__class__.list(service, version, mode, path + ["list"])
                        self.cut_seeds_for_all_component_zones = self.__class__.cut_seeds_for_all_component_zones(service, version, mode, path + ["cut_seeds_for_all_component_zones"])
                        super().__init__(service, version, mode, path)
                    class add(TUIMethod):
                        """
                        Add a hole cut seed.
                        """
                    class delete(TUIMethod):
                        """
                        Delete a hole cut seed.
                        """
                    class delete_all(TUIMethod):
                        """
                        Delete all hole cut seeds.
                        """
                    class list(TUIMethod):
                        """
                        List the defined hole cut seeds.
                        """
                    class cut_seeds_for_all_component_zones(TUIMethod):
                        """
                        Enable that all component zones get a cut seed.
                        """

            class adapt(TUIMenu):
                """
                Enter the overset adaption menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set = self.__class__.set(service, version, mode, path + ["set"])
                    self.mark_adaption = self.__class__.mark_adaption(service, version, mode, path + ["mark_adaption"])
                    self.adapt_mesh = self.__class__.adapt_mesh(service, version, mode, path + ["adapt_mesh"])
                    super().__init__(service, version, mode, path)
                class mark_adaption(TUIMethod):
                    """
                    Mark cells for overset orphan adaption and donor-receptor size differences.
                    """
                class adapt_mesh(TUIMethod):
                    """
                    Mark and adapt the mesh to remove orphan cells and large donor-receptor cell size differences.
                    """

                class set(TUIMenu):
                    """
                    Enter the overset adaption set menu.
                    """
                    def __init__(self, service, version, mode, path):
                        self.mark_orphans = self.__class__.mark_orphans(service, version, mode, path + ["mark_orphans"])
                        self.mark_fixed_orphans = self.__class__.mark_fixed_orphans(service, version, mode, path + ["mark_fixed_orphans"])
                        self.mark_size = self.__class__.mark_size(service, version, mode, path + ["mark_size"])
                        self.mark_gaps = self.__class__.mark_gaps(service, version, mode, path + ["mark_gaps"])
                        self.mark_coarsening = self.__class__.mark_coarsening(service, version, mode, path + ["mark_coarsening"])
                        self.anisotropic = self.__class__.anisotropic(service, version, mode, path + ["anisotropic"])
                        self.automatic = self.__class__.automatic(service, version, mode, path + ["automatic"])
                        self.length_ratio_max = self.__class__.length_ratio_max(service, version, mode, path + ["length_ratio_max"])
                        self.buffer_layers = self.__class__.buffer_layers(service, version, mode, path + ["buffer_layers"])
                        self.adaption_sweeps = self.__class__.adaption_sweeps(service, version, mode, path + ["adaption_sweeps"])
                        self.maximum_refinement_level = self.__class__.maximum_refinement_level(service, version, mode, path + ["maximum_refinement_level"])
                        super().__init__(service, version, mode, path)
                    class mark_orphans(TUIMethod):
                        """
                        Enable the option to adapt for orphan reduction.
                        """
                    class mark_fixed_orphans(TUIMethod):
                        """
                        Enable the option to adapt for orphans which were removed by accepting neighbor donors.
                        """
                    class mark_size(TUIMethod):
                        """
                        Enable the option to adapt for donor-receptor cell size differences.
                        """
                    class mark_gaps(TUIMethod):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                    class mark_coarsening(TUIMethod):
                        """
                        Enable the option to coarsen the mesh during overset adaption.
                        """
                    class anisotropic(TUIMethod):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """
                    class automatic(TUIMethod):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                    class length_ratio_max(TUIMethod):
                        """
                        Set the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                    class buffer_layers(TUIMethod):
                        """
                        Set the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                    class adaption_sweeps(TUIMethod):
                        """
                        Set the number of adaption sweeps per overset adaption.
                        """
                    class maximum_refinement_level(TUIMethod):
                        """
                        Set the maximum level of refinement in overset adaption.
                        """

        class reference_frames(TUIMenu):
            """
            Manage reference frames.
            """
            def __init__(self, service, version, mode, path):
                self.add = self.__class__.add(service, version, mode, path + ["add"])
                self.display = self.__class__.display(service, version, mode, path + ["display"])
                self.display_edit = self.__class__.display_edit(service, version, mode, path + ["display_edit"])
                self.edit = self.__class__.edit(service, version, mode, path + ["edit"])
                self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                self.hide = self.__class__.hide(service, version, mode, path + ["hide"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                self.list_properties = self.__class__.list_properties(service, version, mode, path + ["list_properties"])
                super().__init__(service, version, mode, path)
            class add(TUIMethod):
                """
                Add a new object.
                """
            class display(TUIMethod):
                """
                Display Reference Frame.
                """
            class display_edit(TUIMethod):
                """
                Display and edit reference frame from graphics.
                """
            class edit(TUIMethod):
                """
                Edit an object.
                """
            class delete(TUIMethod):
                """
                Delete an object.
                """
            class hide(TUIMethod):
                """
                Hide Reference Frame.
                """
            class list(TUIMethod):
                """
                List objects.
                """
            class list_properties(TUIMethod):
                """
                List properties of an object.
                """

        class reference_values(TUIMenu):
            """
            Reference value menu.
            """
            def __init__(self, service, version, mode, path):
                self.compute = self.__class__.compute(service, version, mode, path + ["compute"])
                self.area = self.__class__.area(service, version, mode, path + ["area"])
                self.depth = self.__class__.depth(service, version, mode, path + ["depth"])
                self.density = self.__class__.density(service, version, mode, path + ["density"])
                self.enthalpy = self.__class__.enthalpy(service, version, mode, path + ["enthalpy"])
                self.length = self.__class__.length(service, version, mode, path + ["length"])
                self.pressure = self.__class__.pressure(service, version, mode, path + ["pressure"])
                self.temperature = self.__class__.temperature(service, version, mode, path + ["temperature"])
                self.yplus = self.__class__.yplus(service, version, mode, path + ["yplus"])
                self.velocity = self.__class__.velocity(service, version, mode, path + ["velocity"])
                self.viscosity = self.__class__.viscosity(service, version, mode, path + ["viscosity"])
                self.zone = self.__class__.zone(service, version, mode, path + ["zone"])
                self.list = self.__class__.list(service, version, mode, path + ["list"])
                super().__init__(service, version, mode, path)
            class area(TUIMethod):
                """
                Set reference area for normalization.
                """
            class depth(TUIMethod):
                """
                Set reference depth for volume calculation.
                """
            class density(TUIMethod):
                """
                Set reference density for normalization.
                """
            class enthalpy(TUIMethod):
                """
                Set reference enthalpy for enthalpy damping and normalization.
                """
            class length(TUIMethod):
                """
                Set reference length for normalization.
                """
            class pressure(TUIMethod):
                """
                Set reference pressure for normalization.
                """
            class temperature(TUIMethod):
                """
                Set reference temperature for normalization.
                """
            class yplus(TUIMethod):
                """
                Set reference yplus for normalization.
                """
            class velocity(TUIMethod):
                """
                Set reference velocity for normalization.
                """
            class viscosity(TUIMethod):
                """
                Set reference viscosity for normalization.
                """
            class zone(TUIMethod):
                """
                Set reference zone.
                """
            class list(TUIMethod):
                """
                List current reference values.
                """

            class compute(TUIMenu):
                """
                Enter the compute menu.
                """
                def __init__(self, service, version, mode, path):
                    self.axis = self.__class__.axis(service, version, mode, path + ["axis"])
                    self.degassing = self.__class__.degassing(service, version, mode, path + ["degassing"])
                    self.dummy_entry = self.__class__.dummy_entry(service, version, mode, path + ["dummy_entry"])
                    self.exhaust_fan = self.__class__.exhaust_fan(service, version, mode, path + ["exhaust_fan"])
                    self.fan = self.__class__.fan(service, version, mode, path + ["fan"])
                    self.fluid = self.__class__.fluid(service, version, mode, path + ["fluid"])
                    self.geometry = self.__class__.geometry(service, version, mode, path + ["geometry"])
                    self.inlet_vent = self.__class__.inlet_vent(service, version, mode, path + ["inlet_vent"])
                    self.intake_fan = self.__class__.intake_fan(service, version, mode, path + ["intake_fan"])
                    self.interface = self.__class__.interface(service, version, mode, path + ["interface"])
                    self.interior = self.__class__.interior(service, version, mode, path + ["interior"])
                    self.mass_flow_inlet = self.__class__.mass_flow_inlet(service, version, mode, path + ["mass_flow_inlet"])
                    self.mass_flow_outlet = self.__class__.mass_flow_outlet(service, version, mode, path + ["mass_flow_outlet"])
                    self.network = self.__class__.network(service, version, mode, path + ["network"])
                    self.network_end = self.__class__.network_end(service, version, mode, path + ["network_end"])
                    self.outflow = self.__class__.outflow(service, version, mode, path + ["outflow"])
                    self.outlet_vent = self.__class__.outlet_vent(service, version, mode, path + ["outlet_vent"])
                    self.overset = self.__class__.overset(service, version, mode, path + ["overset"])
                    self.periodic = self.__class__.periodic(service, version, mode, path + ["periodic"])
                    self.porous_jump = self.__class__.porous_jump(service, version, mode, path + ["porous_jump"])
                    self.pressure_far_field = self.__class__.pressure_far_field(service, version, mode, path + ["pressure_far_field"])
                    self.pressure_inlet = self.__class__.pressure_inlet(service, version, mode, path + ["pressure_inlet"])
                    self.pressure_outlet = self.__class__.pressure_outlet(service, version, mode, path + ["pressure_outlet"])
                    self.radiator = self.__class__.radiator(service, version, mode, path + ["radiator"])
                    self.rans_les_interface = self.__class__.rans_les_interface(service, version, mode, path + ["rans_les_interface"])
                    self.recirculation_inlet = self.__class__.recirculation_inlet(service, version, mode, path + ["recirculation_inlet"])
                    self.recirculation_outlet = self.__class__.recirculation_outlet(service, version, mode, path + ["recirculation_outlet"])
                    self.shadow = self.__class__.shadow(service, version, mode, path + ["shadow"])
                    self.solid = self.__class__.solid(service, version, mode, path + ["solid"])
                    self.symmetry = self.__class__.symmetry(service, version, mode, path + ["symmetry"])
                    self.velocity_inlet = self.__class__.velocity_inlet(service, version, mode, path + ["velocity_inlet"])
                    self.wall = self.__class__.wall(service, version, mode, path + ["wall"])
                    super().__init__(service, version, mode, path)
                class axis(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class degassing(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class dummy_entry(TUIMethod):
                    """
                    .
                    """
                class exhaust_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class fluid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class geometry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class inlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class intake_fan(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class interior(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class mass_flow_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class network_end(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outflow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class outlet_vent(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class overset(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class periodic(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class porous_jump(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_far_field(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class pressure_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class radiator(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class rans_les_interface(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class recirculation_outlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class shadow(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class solid(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class symmetry(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class velocity_inlet(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """
                class wall(TUIMethod):
                    """
                    Compute reference values from a zone of this type.
                    """

        class turbo_model(TUIMenu):
            """
            Turbo features menu.
            """
            def __init__(self, service, version, mode, path):
                self.turbo_topology = self.__class__.turbo_topology(service, version, mode, path + ["turbo_topology"])
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(service, version, mode, path + ["general_turbo_interface_settings"])
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(service, version, mode, path + ["blade_flutter_harmonics"])
                self.enable_turbo_model = self.__class__.enable_turbo_model(service, version, mode, path + ["enable_turbo_model"])
                self.separate_nonoverlapping_interface_boundary = self.__class__.separate_nonoverlapping_interface_boundary(service, version, mode, path + ["separate_nonoverlapping_interface_boundary"])
                self.turbo_create = self.__class__.turbo_create(service, version, mode, path + ["turbo_create"])
                self.number_of_blades_in_row = self.__class__.number_of_blades_in_row(service, version, mode, path + ["number_of_blades_in_row"])
                self.create_turbomachine_description = self.__class__.create_turbomachine_description(service, version, mode, path + ["create_turbomachine_description"])
                self.create_phaselag_spectral_content = self.__class__.create_phaselag_spectral_content(service, version, mode, path + ["create_phaselag_spectral_content"])
                self.phaselag_extra_settings = self.__class__.phaselag_extra_settings(service, version, mode, path + ["phaselag_extra_settings"])
                self.create_graphics_spectral_content = self.__class__.create_graphics_spectral_content(service, version, mode, path + ["create_graphics_spectral_content"])
                self.graphics_extra_settings = self.__class__.graphics_extra_settings(service, version, mode, path + ["graphics_extra_settings"])
                self.delete_turbomachine_description = self.__class__.delete_turbomachine_description(service, version, mode, path + ["delete_turbomachine_description"])
                self.delete_phaselag_spectral_content = self.__class__.delete_phaselag_spectral_content(service, version, mode, path + ["delete_phaselag_spectral_content"])
                self.delete_graphics_spectral_content = self.__class__.delete_graphics_spectral_content(service, version, mode, path + ["delete_graphics_spectral_content"])
                self.list_turbomachine_description = self.__class__.list_turbomachine_description(service, version, mode, path + ["list_turbomachine_description"])
                self.list_graphics_spectral_content = self.__class__.list_graphics_spectral_content(service, version, mode, path + ["list_graphics_spectral_content"])
                self.list_phaselag_state = self.__class__.list_phaselag_state(service, version, mode, path + ["list_phaselag_state"])
                self.make_phaselag_from_boundaries = self.__class__.make_phaselag_from_boundaries(service, version, mode, path + ["make_phaselag_from_boundaries"])
                self.make_phaselag_from_periodic = self.__class__.make_phaselag_from_periodic(service, version, mode, path + ["make_phaselag_from_periodic"])
                super().__init__(service, version, mode, path)
            class enable_turbo_model(TUIMethod):
                """
                Enable/disable turbo model menu.
                """
            class separate_nonoverlapping_interface_boundary(TUIMethod):
                """
                Split a general turbo interface non-overlapping zone.
                """
            class turbo_create(TUIMethod):
                """
                Create a general turbo interface.
                """
            class number_of_blades_in_row(TUIMethod):
                """
                Define the total number of blades in blade flutter row.
                """
            class create_turbomachine_description(TUIMethod):
                """
                Define turbomachine description.
                """
            class create_phaselag_spectral_content(TUIMethod):
                """
                Define phaselag related spectral content.
                """
            class phaselag_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class create_graphics_spectral_content(TUIMethod):
                """
                Define post-processing related spectral content.
                """
            class graphics_extra_settings(TUIMethod):
                """
                Define phaselag related extra settings.
                """
            class delete_turbomachine_description(TUIMethod):
                """
                Delete turbomachine description.
                """
            class delete_phaselag_spectral_content(TUIMethod):
                """
                Delete phaselag related spectral content.
                """
            class delete_graphics_spectral_content(TUIMethod):
                """
                Delete post-processing related spectral content.
                """
            class list_turbomachine_description(TUIMethod):
                """
                List turbomachine description.
                """
            class list_graphics_spectral_content(TUIMethod):
                """
                List post-processing related spectral content.
                """
            class list_phaselag_state(TUIMethod):
                """
                List all phaselag related case settings.
                """
            class make_phaselag_from_boundaries(TUIMethod):
                """
                Make interface zones phase lagged.
                """
            class make_phaselag_from_periodic(TUIMethod):
                """
                Convert periodic interface to phase lagged.
                """

            class turbo_topology(TUIMenu):
                """
                Define turbo topology.
                """
                def __init__(self, service, version, mode, path):
                    self.define_topology = self.__class__.define_topology(service, version, mode, path + ["define_topology"])
                    self.mesh_method = self.__class__.mesh_method(service, version, mode, path + ["mesh_method"])
                    self.search_method = self.__class__.search_method(service, version, mode, path + ["search_method"])
                    self.projection_method = self.__class__.projection_method(service, version, mode, path + ["projection_method"])
                    self.delete = self.__class__.delete(service, version, mode, path + ["delete"])
                    super().__init__(service, version, mode, path)
                class define_topology(TUIMethod):
                    """
                    Define a turbo topology.
                    """
                class mesh_method(TUIMethod):
                    """
                    Set turbo structured mesh generation method.
                    """
                class search_method(TUIMethod):
                    """
                    Set search method for a topology.
                    """
                class projection_method(TUIMethod):
                    """
                    Set 2D projection method.
                    """
                class delete(TUIMethod):
                    """
                    Delete a turbo topology.
                    """

            class general_turbo_interface_settings(TUIMenu):
                """
                Set General Turbo Interface options.
                """
                def __init__(self, service, version, mode, path):
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(service, version, mode, path + ["mixing_plane_model_settings"])
                    self.pitch_scale_model_settings = self.__class__.pitch_scale_model_settings(service, version, mode, path + ["pitch_scale_model_settings"])
                    self.no_pitch_scale_model_settings = self.__class__.no_pitch_scale_model_settings(service, version, mode, path + ["no_pitch_scale_model_settings"])
                    self.expert = self.__class__.expert(service, version, mode, path + ["expert"])
                    super().__init__(service, version, mode, path)

                class mixing_plane_model_settings(TUIMenu):
                    """
                    Set the mixing plane model settings.
                    """
                    def __init__(self, service, version, mode, path):
                        self.number_of_bands = self.__class__.number_of_bands(service, version, mode, path + ["number_of_bands"])
                        self.averaging_method = self.__class__.averaging_method(service, version, mode, path + ["averaging_method"])
                        self.mixing_set_constraint = self.__class__.mixing_set_constraint(service, version, mode, path + ["mixing_set_constraint"])
                        self.bands_type = self.__class__.bands_type(service, version, mode, path + ["bands_type"])
                        self.number_of_inner_iterations = self.__class__.number_of_inner_iterations(service, version, mode, path + ["number_of_inner_iterations"])
                        self.list_mixing_planes = self.__class__.list_mixing_planes(service, version, mode, path + ["list_mixing_planes"])
                        super().__init__(service, version, mode, path)
                    class averaging_method(TUIMethod):
                        """
                        Set the averaging method for the mixing.
                        """
                    class mixing_set_constraint(TUIMethod):
                        """
                        To set the mixing of primitive or total variable approach.
                        """
                    class bands_type(TUIMethod):
                        """
                        To set the mixing plane bands type.
                        """
                    class number_of_inner_iterations(TUIMethod):
                        """
                        To set the number of iteration used for the scaling.
                        """
                    class list_mixing_planes(TUIMethod):
                        """
                        List the settings of mixing planes in the case.
                        """

                    class number_of_bands(TUIMenu):
                        """
                        Set the maximum number of bands to be used for mixing.
                        """
                        def __init__(self, service, version, mode, path):
                            self.set_specific_interface = self.__class__.set_specific_interface(service, version, mode, path + ["set_specific_interface"])
                            self.set_all_interfaces = self.__class__.set_all_interfaces(service, version, mode, path + ["set_all_interfaces"])
                            super().__init__(service, version, mode, path)
                        class set_specific_interface(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """
                        class set_all_interfaces(TUIMethod):
                            """
                            Set number of band to be used for mixing.
                            """

                class pitch_scale_model_settings(TUIMenu):
                    """
                    Set the pitch scale model settings.
                    """
                    def __init__(self, service, version, mode, path):
                        self.scale_mflux = self.__class__.scale_mflux(service, version, mode, path + ["scale_mflux"])
                        super().__init__(service, version, mode, path)
                    class scale_mflux(TUIMethod):
                        """
                        Scale mass flux to improve the conservation.
                        """

                class no_pitch_scale_model_settings(TUIMenu):
                    """
                    Set the no pitch scale model settings.
                    """
                    def __init__(self, service, version, mode, path):
                        self.scale_mflux = self.__class__.scale_mflux(service, version, mode, path + ["scale_mflux"])
                        super().__init__(service, version, mode, path)
                    class scale_mflux(TUIMethod):
                        """
                        Scale mass flux to improve the conservation.
                        """

                class expert(TUIMenu):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    def __init__(self, service, version, mode, path):
                        self.enforce_flux_scaling = self.__class__.enforce_flux_scaling(service, version, mode, path + ["enforce_flux_scaling"])
                        self.list_settings = self.__class__.list_settings(service, version, mode, path + ["list_settings"])
                        super().__init__(service, version, mode, path)
                    class enforce_flux_scaling(TUIMethod):
                        """
                        Enforce flux scaling ON/OFF at the turbo interfaces.
                        """
                    class list_settings(TUIMethod):
                        """
                        List the flux scale settings at the turbo interfaces.
                        """

            class blade_flutter_harmonics(TUIMenu):
                """
                Enter the blade flutter harmonics menu.
                """
                def __init__(self, service, version, mode, path):
                    self.enable_harmonic_postprocessing = self.__class__.enable_harmonic_postprocessing(service, version, mode, path + ["enable_harmonic_postprocessing"])
                    self.enable_harmonic_exports = self.__class__.enable_harmonic_exports(service, version, mode, path + ["enable_harmonic_exports"])
                    self.write_harmonic_exports = self.__class__.write_harmonic_exports(service, version, mode, path + ["write_harmonic_exports"])
                    self.write_aerodamping_vs_nodal_diameter = self.__class__.write_aerodamping_vs_nodal_diameter(service, version, mode, path + ["write_aerodamping_vs_nodal_diameter"])
                    super().__init__(service, version, mode, path)
                class enable_harmonic_postprocessing(TUIMethod):
                    """
                    Calculates/Deletes Postprocessing Fourier coefficients data.
                    """
                class enable_harmonic_exports(TUIMethod):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                class write_harmonic_exports(TUIMethod):
                    """
                    Writes harmonic export data.
                    """
                class write_aerodamping_vs_nodal_diameter(TUIMethod):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """

    class surface(TUIMenu):
        """
        Enter the data surface manipulation menu.
        """
        def __init__(self, service, version, mode, path):
            self.post_processing_volume = self.__class__.post_processing_volume(service, version, mode, path + ["post_processing_volume"])
            self.query = self.__class__.query(service, version, mode, path + ["query"])
            self.circle_slice = self.__class__.circle_slice(service, version, mode, path + ["circle_slice"])
            self.delete_surface = self.__class__.delete_surface(service, version, mode, path + ["delete_surface"])
            self.group_surfaces = self.__class__.group_surfaces(service, version, mode, path + ["group_surfaces"])
            self.ungroup_surface = self.__class__.ungroup_surface(service, version, mode, path + ["ungroup_surface"])
            self.iso_clip = self.__class__.iso_clip(service, version, mode, path + ["iso_clip"])
            self.iso_surface = self.__class__.iso_surface(service, version, mode, path + ["iso_surface"])
            self.expression_volume = self.__class__.expression_volume(service, version, mode, path + ["expression_volume"])
            self.multiple_iso_surfaces = self.__class__.multiple_iso_surfaces(service, version, mode, path + ["multiple_iso_surfaces"])
            self.line_slice = self.__class__.line_slice(service, version, mode, path + ["line_slice"])
            self.line_surface = self.__class__.line_surface(service, version, mode, path + ["line_surface"])
            self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
            self.mouse_line = self.__class__.mouse_line(service, version, mode, path + ["mouse_line"])
            self.mouse_plane = self.__class__.mouse_plane(service, version, mode, path + ["mouse_plane"])
            self.mouse_rake = self.__class__.mouse_rake(service, version, mode, path + ["mouse_rake"])
            self.partition_surface = self.__class__.partition_surface(service, version, mode, path + ["partition_surface"])
            self.plane = self.__class__.plane(service, version, mode, path + ["plane"])
            self.plane_surface = self.__class__.plane_surface(service, version, mode, path + ["plane_surface"])
            self.multiple_plane_surfaces = self.__class__.multiple_plane_surfaces(service, version, mode, path + ["multiple_plane_surfaces"])
            self.plane_slice = self.__class__.plane_slice(service, version, mode, path + ["plane_slice"])
            self.point_array = self.__class__.point_array(service, version, mode, path + ["point_array"])
            self.point_surface = self.__class__.point_surface(service, version, mode, path + ["point_surface"])
            self.structural_point_surface = self.__class__.structural_point_surface(service, version, mode, path + ["structural_point_surface"])
            self.quadric_slice = self.__class__.quadric_slice(service, version, mode, path + ["quadric_slice"])
            self.rake_surface = self.__class__.rake_surface(service, version, mode, path + ["rake_surface"])
            self.rename_surface = self.__class__.rename_surface(service, version, mode, path + ["rename_surface"])
            self.sphere_slice = self.__class__.sphere_slice(service, version, mode, path + ["sphere_slice"])
            self.ellipsoid_slice = self.__class__.ellipsoid_slice(service, version, mode, path + ["ellipsoid_slice"])
            self.cone_slice = self.__class__.cone_slice(service, version, mode, path + ["cone_slice"])
            self.surface_cells = self.__class__.surface_cells(service, version, mode, path + ["surface_cells"])
            self.transform_surface = self.__class__.transform_surface(service, version, mode, path + ["transform_surface"])
            self.create_imprint_surface = self.__class__.create_imprint_surface(service, version, mode, path + ["create_imprint_surface"])
            self.zone_surface = self.__class__.zone_surface(service, version, mode, path + ["zone_surface"])
            self.reset_zone_surfaces = self.__class__.reset_zone_surfaces(service, version, mode, path + ["reset_zone_surfaces"])
            self.multiple_zone_surfaces = self.__class__.multiple_zone_surfaces(service, version, mode, path + ["multiple_zone_surfaces"])
            self.edit_surface = self.__class__.edit_surface(service, version, mode, path + ["edit_surface"])
            super().__init__(service, version, mode, path)
        class circle_slice(TUIMethod):
            """
            Extracts a circular slice.
            """
        class delete_surface(TUIMethod):
            """
            Removes a defined data surface.
            """
        class group_surfaces(TUIMethod):
            """
            Group a set of surfaces.
            """
        class ungroup_surface(TUIMethod):
            """
            Ungroup the surface(if grouped).
            """
        class iso_clip(TUIMethod):
            """
            Clips a data surface (surface, curve, or point) between two isovalues.
            """
        class iso_surface(TUIMethod):
            """
            Extracts an iso-surface (surface, curve, or point) from the current data field.
            """
        class expression_volume(TUIMethod):
            """
            Create volume with boolean expression.
            """
        class multiple_iso_surfaces(TUIMethod):
            """
            Creates multiple iso-surfaces at once. Accepts zone names, lists of zone ID’s, and wildcards.
            """
        class line_slice(TUIMethod):
            """
            Extracts a linear slice in 2D, given the normal to the line and a distance from the origin.
            """
        class line_surface(TUIMethod):
            """
            Defines a “line" surface by specifying the two endpoint coordinates.
            """
        class list_surfaces(TUIMethod):
            """
            Displays the ID and name, and the number of point, curve, and surface facets of the current surfaces.
            """
        class mouse_line(TUIMethod):
            """
            Extracts a line surface that you define by using the mouse to select the endpoints.
            """
        class mouse_plane(TUIMethod):
            """
            Extracts a planar surface defined by selecting three points with the mouse.
            """
        class mouse_rake(TUIMethod):
            """
            Extracts a “rake" surface that you define by using the mouse to select the endpoints.
            """
        class partition_surface(TUIMethod):
            """
            Defines a data surface consisting of mesh faces on the partition boundary.
            """
        class plane(TUIMethod):
            """
            Create a plane given 3 points bounded by the domain.
            """
        class plane_surface(TUIMethod):
            """
            Create a plane from a coordinate plane, point and normal, or three points.
            """
        class multiple_plane_surfaces(TUIMethod):
            """
            Creates multiple planes at once. Accepts zone names, lists of zone ID’s, and wildcards.
            """
        class plane_slice(TUIMethod):
            """
            Extracts a planar slice.
            """
        class point_array(TUIMethod):
            """
            Extracts a rectangular array of data points.
            """
        class point_surface(TUIMethod):
            """
            Defines a “point" surface by specifying the coordinates.
            """
        class structural_point_surface(TUIMethod):
            """
            Defines a structural “point" surface by specifying the coordinates.
            """
        class quadric_slice(TUIMethod):
            """
            Extracts a quadric slice.
            """
        class rake_surface(TUIMethod):
            """
            Extracts a “rake" surface, given the coordinates of the endpoints.
            """
        class rename_surface(TUIMethod):
            """
            Renames a defined data surface.
            """
        class sphere_slice(TUIMethod):
            """
            Extracts a spherical slice.
            """
        class ellipsoid_slice(TUIMethod):
            """
            Extract a ellipsoid slice.
            """
        class cone_slice(TUIMethod):
            """
            Extract a cone slice.
            """
        class surface_cells(TUIMethod):
            """
            Extracts all cells intersected by a data surface.
            """
        class transform_surface(TUIMethod):
            """
            Transforms surface.
            """
        class create_imprint_surface(TUIMethod):
            """
            Imprint surface.
            """
        class zone_surface(TUIMethod):
            """
            Creates a surface of a designated zone and gives it a specified name.
            """
        class reset_zone_surfaces(TUIMethod):
            """
            Recreates missing surface zones by resetting the case surface list.
            """
        class multiple_zone_surfaces(TUIMethod):
            """
            Creates multiple data surfaces at one time. Accepts zone names, lists of zone ID’s, and wildcards.
            """
        class edit_surface(TUIMethod):
            """
            Allows you to edit any of the listed available surfaces.
            """

        class post_processing_volume(TUIMenu):
            """
            Enter post-processing volume menu.
            """
            def __init__(self, service, version, mode, path):
                self.create_from_file = self.__class__.create_from_file(service, version, mode, path + ["create_from_file"])
                self.create_octree = self.__class__.create_octree(service, version, mode, path + ["create_octree"])
                super().__init__(service, version, mode, path)
            class create_from_file(TUIMethod):
                """
                Read post-processing mesh from file.
                """
            class create_octree(TUIMethod):
                """
                Create post-processing octree mesh based on current case.
                """

        class query(TUIMenu):
            """
            Enter surface query menu.
            """
            def __init__(self, service, version, mode, path):
                self.delete_query = self.__class__.delete_query(service, version, mode, path + ["delete_query"])
                self.list_surfaces = self.__class__.list_surfaces(service, version, mode, path + ["list_surfaces"])
                self.named_surface_list = self.__class__.named_surface_list(service, version, mode, path + ["named_surface_list"])
                self.list_named_selection = self.__class__.list_named_selection(service, version, mode, path + ["list_named_selection"])
                self.list_queries = self.__class__.list_queries(service, version, mode, path + ["list_queries"])
                super().__init__(service, version, mode, path)
            class delete_query(TUIMethod):
                """
                Delete saved query.
                """
            class list_surfaces(TUIMethod):
                """
                List surfaces.
                """
            class named_surface_list(TUIMethod):
                """
                Create named list of surfaces.
                """
            class list_named_selection(TUIMethod):
                """
                List named selection of surface type.
                """
            class list_queries(TUIMethod):
                """
                List all saved queries.
                """

    class simulation_reports(TUIMenu):
        """
        Enter the simulation reports menu.
        """
        def __init__(self, service, version, mode, path):
            self.list_simulation_reports = self.__class__.list_simulation_reports(service, version, mode, path + ["list_simulation_reports"])
            self.generate_simulation_report = self.__class__.generate_simulation_report(service, version, mode, path + ["generate_simulation_report"])
            self.view_simulation_report = self.__class__.view_simulation_report(service, version, mode, path + ["view_simulation_report"])
            self.export_simulation_report_as_pdf = self.__class__.export_simulation_report_as_pdf(service, version, mode, path + ["export_simulation_report_as_pdf"])
            self.export_simulation_report_as_html = self.__class__.export_simulation_report_as_html(service, version, mode, path + ["export_simulation_report_as_html"])
            self.write_report_names_to_file = self.__class__.write_report_names_to_file(service, version, mode, path + ["write_report_names_to_file"])
            self.rename_simulation_report = self.__class__.rename_simulation_report(service, version, mode, path + ["rename_simulation_report"])
            self.duplicate_simulation_report = self.__class__.duplicate_simulation_report(service, version, mode, path + ["duplicate_simulation_report"])
            self.reset_report_to_defaults = self.__class__.reset_report_to_defaults(service, version, mode, path + ["reset_report_to_defaults"])
            self.delete_simulation_report = self.__class__.delete_simulation_report(service, version, mode, path + ["delete_simulation_report"])
            self.write_simulation_report_template_file = self.__class__.write_simulation_report_template_file(service, version, mode, path + ["write_simulation_report_template_file"])
            self.read_simulation_report_template_file = self.__class__.read_simulation_report_template_file(service, version, mode, path + ["read_simulation_report_template_file"])
            super().__init__(service, version, mode, path)
        class list_simulation_reports(TUIMethod):
            """
            List all report names.
            """
        class generate_simulation_report(TUIMethod):
            """
            Generate a new simulation report or regenerate an existing simulation report with the provided name.
            """
        class view_simulation_report(TUIMethod):
            """
            View a simulation report that has already been generated. In batch mode this will print the report's URL.
            """
        class export_simulation_report_as_pdf(TUIMethod):
            """
            Export the provided simulation report as a PDF file.
            """
        class export_simulation_report_as_html(TUIMethod):
            """
            Export the provided simulation report as HTML.
            """
        class write_report_names_to_file(TUIMethod):
            """
            Write the list of currently generated report names to a txt file.
            """
        class rename_simulation_report(TUIMethod):
            """
            Rename a report which has already been generated.
            """
        class duplicate_simulation_report(TUIMethod):
            """
            Duplicate a report and all of its settings to a new report.
            """
        class reset_report_to_defaults(TUIMethod):
            """
            Reset all report settings to default for the provided simulation report.
            """
        class delete_simulation_report(TUIMethod):
            """
            Delete the provided simulation report.
            """
        class write_simulation_report_template_file(TUIMethod):
            """
            Write a JSON template file with this case's Simulation Report settings.
            """
        class read_simulation_report_template_file(TUIMethod):
            """
            Read a JSON template file with existing Simulation Report settings.
            """

    class server(TUIMenu):
        """
        Enter the server menu.
        """
        def __init__(self, service, version, mode, path):
            self.start_server = self.__class__.start_server(service, version, mode, path + ["start_server"])
            self.start_client = self.__class__.start_client(service, version, mode, path + ["start_client"])
            self.print_server_address = self.__class__.print_server_address(service, version, mode, path + ["print_server_address"])
            self.write_or_reset_server_info = self.__class__.write_or_reset_server_info(service, version, mode, path + ["write_or_reset_server_info"])
            self.print_connected_clients = self.__class__.print_connected_clients(service, version, mode, path + ["print_connected_clients"])
            self.shutdown_server = self.__class__.shutdown_server(service, version, mode, path + ["shutdown_server"])
            super().__init__(service, version, mode, path)
        class start_server(TUIMethod):
            """
            Starts the server for the ANSYS Fluent remote visualization client.
            """
        class start_client(TUIMethod):
            """
            Start the ANSYS Fluent remote visualization client.
            """
        class print_server_address(TUIMethod):
            """
            Prints the host address and port number of the server to the console.
            """
        class write_or_reset_server_info(TUIMethod):
            """
            Allows you to create a new server_info.txt file (with any name you specify), which resets the password for connecting to this server session. It does not restart the server.
            """
        class print_connected_clients(TUIMethod):
            """
            Prints the name of the connected client and its IP address to the console.
            """
        class shutdown_server(TUIMethod):
            """
            Shuts-down the server and disconnects the connected client.
            """

    class turbo_post(TUIMenu):
        """
        Enter the turbo menu.
        """
        def __init__(self, service, version, mode, path):
            self.compute_report = self.__class__.compute_report(service, version, mode, path + ["compute_report"])
            self.write_report = self.__class__.write_report(service, version, mode, path + ["write_report"])
            self.avg_contours = self.__class__.avg_contours(service, version, mode, path + ["avg_contours"])
            self.two_d_contours = self.__class__.two_d_contours(service, version, mode, path + ["two_d_contours"])
            self.xy_plot_avg = self.__class__.xy_plot_avg(service, version, mode, path + ["xy_plot_avg"])
            self.current_topology = self.__class__.current_topology(service, version, mode, path + ["current_topology"])
            super().__init__(service, version, mode, path)
        class compute_report(TUIMethod):
            """
            Computes turbomachinery quantities.
            """
        class write_report(TUIMethod):
            """
            Writes the turbo report to file.
            """
        class avg_contours(TUIMethod):
            """
            Displays average contours.
            """
        class two_d_contours(TUIMethod):
            """
            Display 2d contours.
            """
        class xy_plot_avg(TUIMethod):
            """
            Displays average XY plots.
            """
        class current_topology(TUIMethod):
            """
            Sets the current turbo topology for global use.
            """

    class views(TUIMenu):
        """
        Enter the view manipulation menu.
        """
        def __init__(self, service, version, mode, path):
            self.camera = self.__class__.camera(service, version, mode, path + ["camera"])
            self.auto_scale = self.__class__.auto_scale(service, version, mode, path + ["auto_scale"])
            self.default_view = self.__class__.default_view(service, version, mode, path + ["default_view"])
            self.delete_view = self.__class__.delete_view(service, version, mode, path + ["delete_view"])
            self.last_view = self.__class__.last_view(service, version, mode, path + ["last_view"])
            self.next_view = self.__class__.next_view(service, version, mode, path + ["next_view"])
            self.list_views = self.__class__.list_views(service, version, mode, path + ["list_views"])
            self.restore_view = self.__class__.restore_view(service, version, mode, path + ["restore_view"])
            self.read_views = self.__class__.read_views(service, version, mode, path + ["read_views"])
            self.save_view = self.__class__.save_view(service, version, mode, path + ["save_view"])
            self.write_views = self.__class__.write_views(service, version, mode, path + ["write_views"])
            super().__init__(service, version, mode, path)
        class auto_scale(TUIMethod):
            """
            Scales and centers the current scene without changing its orientation.
            """
        class default_view(TUIMethod):
            """
            Resets view to front and center.
            """
        class delete_view(TUIMethod):
            """
            Removes a view from the list.
            """
        class last_view(TUIMethod):
            """
            Returns to the camera position before the last manipulation.
            """
        class next_view(TUIMethod):
            """
            Return to the camera position after the current position in the stack.
            """
        class list_views(TUIMethod):
            """
            Lists predefined and saved views.
            """
        class restore_view(TUIMethod):
            """
            Uses a saved view.
            """
        class read_views(TUIMethod):
            """
            Reads views from a view file.
            """
        class save_view(TUIMethod):
            """
            Saves the current view to the view list.
            """
        class write_views(TUIMethod):
            """
            Writes selected views to a view file.
            """

        class camera(TUIMenu):
            """
            Enters the camera menu to modify the current viewing parameters.
            """
            def __init__(self, service, version, mode, path):
                self.dolly_camera = self.__class__.dolly_camera(service, version, mode, path + ["dolly_camera"])
                self.field = self.__class__.field(service, version, mode, path + ["field"])
                self.orbit_camera = self.__class__.orbit_camera(service, version, mode, path + ["orbit_camera"])
                self.pan_camera = self.__class__.pan_camera(service, version, mode, path + ["pan_camera"])
                self.position = self.__class__.position(service, version, mode, path + ["position"])
                self.projection = self.__class__.projection(service, version, mode, path + ["projection"])
                self.roll_camera = self.__class__.roll_camera(service, version, mode, path + ["roll_camera"])
                self.target = self.__class__.target(service, version, mode, path + ["target"])
                self.up_vector = self.__class__.up_vector(service, version, mode, path + ["up_vector"])
                self.zoom_camera = self.__class__.zoom_camera(service, version, mode, path + ["zoom_camera"])
                super().__init__(service, version, mode, path)
            class dolly_camera(TUIMethod):
                """
                Adjusts the camera position and target.
                """
            class field(TUIMethod):
                """
                Sets the field of view (width and height).
                """
            class orbit_camera(TUIMethod):
                """
                Adjusts the camera position without modifying the target.
                """
            class pan_camera(TUIMethod):
                """
                Adjusts the camera target without modifying the position.
                """
            class position(TUIMethod):
                """
                Sets the camera position.
                """
            class projection(TUIMethod):
                """
                Set the camera projection type.
                """
            class roll_camera(TUIMethod):
                """
                Adjusts the camera up-vector.
                """
            class target(TUIMethod):
                """
                Sets the point to be the center of the camera view.
                """
            class up_vector(TUIMethod):
                """
                Sets the camera up-vector.
                """
            class zoom_camera(TUIMethod):
                """
                Adjusts the camera’s field of view. This operation is similar to dollying the camera in or out of the scene. Dollying causes objects in front to move past you. Zooming changes the perspective effect in the scene (and can be disconcerting).
                """

    class parametric_study(TUIMenu):
        """
        Enter the parametric study menu.
        """
        def __init__(self, service, version, mode, path):
            self.design_points = self.__class__.design_points(service, version, mode, path + ["design_points"])
            self.update = self.__class__.update(service, version, mode, path + ["update"])
            self.initialize = self.__class__.initialize(service, version, mode, path + ["initialize"])
            self.duplicate_study = self.__class__.duplicate_study(service, version, mode, path + ["duplicate_study"])
            self.set_as_current_study = self.__class__.set_as_current_study(service, version, mode, path + ["set_as_current_study"])
            self.rename_study = self.__class__.rename_study(service, version, mode, path + ["rename_study"])
            self.delete_study = self.__class__.delete_study(service, version, mode, path + ["delete_study"])
            self.list_studies = self.__class__.list_studies(service, version, mode, path + ["list_studies"])
            self.use_base_data = self.__class__.use_base_data(service, version, mode, path + ["use_base_data"])
            self.export_design_table = self.__class__.export_design_table(service, version, mode, path + ["export_design_table"])
            self.import_design_table = self.__class__.import_design_table(service, version, mode, path + ["import_design_table"])
            self.case_settings_changed = self.__class__.case_settings_changed(service, version, mode, path + ["case_settings_changed"])
            super().__init__(service, version, mode, path)
        class initialize(TUIMethod):
            """
            Start Parametric Study.
            """
        class duplicate_study(TUIMethod):
            """
            Duplicate Parametric Study.
            """
        class set_as_current_study(TUIMethod):
            """
            Set As Current Study.
            """
        class rename_study(TUIMethod):
            """
            Rename Study.
            """
        class delete_study(TUIMethod):
            """
            Delete Study.
            """
        class list_studies(TUIMethod):
            """
            List Studies.
            """
        class use_base_data(TUIMethod):
            """
            Use Base Data.
            """
        class export_design_table(TUIMethod):
            """
            Export Design Point Table.
            """
        class import_design_table(TUIMethod):
            """
            Import Design Point Table.
            """
        class case_settings_changed(TUIMethod):
            """
            Check if case settings are changed.
            """

        class design_points(TUIMenu):
            """
            Enter the design points menu.
            """
            def __init__(self, service, version, mode, path):
                self.add_design_point = self.__class__.add_design_point(service, version, mode, path + ["add_design_point"])
                self.get_current_design_point = self.__class__.get_current_design_point(service, version, mode, path + ["get_current_design_point"])
                self.load_case_data_for_current_dp = self.__class__.load_case_data_for_current_dp(service, version, mode, path + ["load_case_data_for_current_dp"])
                self.set_as_current = self.__class__.set_as_current(service, version, mode, path + ["set_as_current"])
                self.get_input_parameters_of_dp = self.__class__.get_input_parameters_of_dp(service, version, mode, path + ["get_input_parameters_of_dp"])
                self.set_input_parameters_of_dp = self.__class__.set_input_parameters_of_dp(service, version, mode, path + ["set_input_parameters_of_dp"])
                self.get_output_parameters_of_dp = self.__class__.get_output_parameters_of_dp(service, version, mode, path + ["get_output_parameters_of_dp"])
                self.set_write_data = self.__class__.set_write_data(service, version, mode, path + ["set_write_data"])
                self.get_write_data = self.__class__.get_write_data(service, version, mode, path + ["get_write_data"])
                self.set_capture_simulation_report_data = self.__class__.set_capture_simulation_report_data(service, version, mode, path + ["set_capture_simulation_report_data"])
                self.get_capture_simulation_report_data = self.__class__.get_capture_simulation_report_data(service, version, mode, path + ["get_capture_simulation_report_data"])
                self.delete_design_point = self.__class__.delete_design_point(service, version, mode, path + ["delete_design_point"])
                self.duplicate_design_point = self.__class__.duplicate_design_point(service, version, mode, path + ["duplicate_design_point"])
                self.save_journals = self.__class__.save_journals(service, version, mode, path + ["save_journals"])
                self.clear_generated_data = self.__class__.clear_generated_data(service, version, mode, path + ["clear_generated_data"])
                self.refresh_status = self.__class__.refresh_status(service, version, mode, path + ["refresh_status"])
                self.abort_concurrent_design_point_update = self.__class__.abort_concurrent_design_point_update(service, version, mode, path + ["abort_concurrent_design_point_update"])
                self.abort_all_concurrent_design_point_updates = self.__class__.abort_all_concurrent_design_point_updates(service, version, mode, path + ["abort_all_concurrent_design_point_updates"])
                super().__init__(service, version, mode, path)
            class add_design_point(TUIMethod):
                """
                Add new design point.
                """
            class get_current_design_point(TUIMethod):
                """
                Get Name of Current Design Point.
                """
            class load_case_data_for_current_dp(TUIMethod):
                """
                Loads relevant case/data file for current design point.
                """
            class set_as_current(TUIMethod):
                """
                Set current design point.
                """
            class get_input_parameters_of_dp(TUIMethod):
                """
                Get Input Parameter Values of Current Design Point.
                """
            class set_input_parameters_of_dp(TUIMethod):
                """
                Set Input Parameter Values of Design Point.
                """
            class get_output_parameters_of_dp(TUIMethod):
                """
                Get Output Parameter Values of Design Point.
                """
            class set_write_data(TUIMethod):
                """
                Set WriteData option for Design Point.
                """
            class get_write_data(TUIMethod):
                """
                Get WriteData option for Design Point.
                """
            class set_capture_simulation_report_data(TUIMethod):
                """
                Set Capture Simulation Report Data option for Design Point.
                """
            class get_capture_simulation_report_data(TUIMethod):
                """
                Get Capture Simulation Report Data option for Design Point.
                """
            class delete_design_point(TUIMethod):
                """
                Delete Design Point.
                """
            class duplicate_design_point(TUIMethod):
                """
                Duplicate Design Point.
                """
            class save_journals(TUIMethod):
                """
                Save Journals.
                """
            class clear_generated_data(TUIMethod):
                """
                Clear Generated Data.
                """
            class refresh_status(TUIMethod):
                """
                Refresh Status.
                """
            class abort_concurrent_design_point_update(TUIMethod):
                """
                Interrupt Design Point.
                """
            class abort_all_concurrent_design_point_updates(TUIMethod):
                """
                Interrupt Design Points.
                """

        class update(TUIMenu):
            """
            Enter the update menu.
            """
            def __init__(self, service, version, mode, path):
                self.concurrent_settings = self.__class__.concurrent_settings(service, version, mode, path + ["concurrent_settings"])
                self.set_update_method = self.__class__.set_update_method(service, version, mode, path + ["set_update_method"])
                self.get_update_method = self.__class__.get_update_method(service, version, mode, path + ["get_update_method"])
                self.update_current = self.__class__.update_current(service, version, mode, path + ["update_current"])
                self.update_all = self.__class__.update_all(service, version, mode, path + ["update_all"])
                self.update_selected_design_points = self.__class__.update_selected_design_points(service, version, mode, path + ["update_selected_design_points"])
                self.get_number_of_concurrent_dps = self.__class__.get_number_of_concurrent_dps(service, version, mode, path + ["get_number_of_concurrent_dps"])
                self.set_number_of_concurrent_dps = self.__class__.set_number_of_concurrent_dps(service, version, mode, path + ["set_number_of_concurrent_dps"])
                self.get_number_of_cores_per_dp = self.__class__.get_number_of_cores_per_dp(service, version, mode, path + ["get_number_of_cores_per_dp"])
                self.set_number_of_cores_per_dp = self.__class__.set_number_of_cores_per_dp(service, version, mode, path + ["set_number_of_cores_per_dp"])
                super().__init__(service, version, mode, path)
            class set_update_method(TUIMethod):
                """
                Set update method.
                """
            class get_update_method(TUIMethod):
                """
                Get update method.
                """
            class update_current(TUIMethod):
                """
                Update Current Design Point.
                """
            class update_all(TUIMethod):
                """
                Update All Design Points.
                """
            class update_selected_design_points(TUIMethod):
                """
                Update Selected Design Points.
                """
            class get_number_of_concurrent_dps(TUIMethod):
                """
                Get Number of Concurrent Design Points.
                """
            class set_number_of_concurrent_dps(TUIMethod):
                """
                Set Number of Concurrent Design Points.
                """
            class get_number_of_cores_per_dp(TUIMethod):
                """
                Get Number of Cores per Design Point.
                """
            class set_number_of_cores_per_dp(TUIMethod):
                """
                Set Number of Cores per Design Point.
                """

            class concurrent_settings(TUIMenu):
                """
                Enter the Concurrent Settings menu.
                """
                def __init__(self, service, version, mode, path):
                    self.set_license_type = self.__class__.set_license_type(service, version, mode, path + ["set_license_type"])
                    self.get_license_type = self.__class__.get_license_type(service, version, mode, path + ["get_license_type"])
                    self.get_optislang_license_type = self.__class__.get_optislang_license_type(service, version, mode, path + ["get_optislang_license_type"])
                    self.set_optislang_license_type = self.__class__.set_optislang_license_type(service, version, mode, path + ["set_optislang_license_type"])
                    self.get_optislang_license_count = self.__class__.get_optislang_license_count(service, version, mode, path + ["get_optislang_license_count"])
                    self.set_optislang_license_count = self.__class__.set_optislang_license_count(service, version, mode, path + ["set_optislang_license_count"])
                    super().__init__(service, version, mode, path)
                class set_license_type(TUIMethod):
                    """
                    Set License Type.
                    """
                class get_license_type(TUIMethod):
                    """
                    Get License Type.
                    """
                class get_optislang_license_type(TUIMethod):
                    """
                    Get optiSLang License Type.
                    """
                class set_optislang_license_type(TUIMethod):
                    """
                    Set optiSLang License Type.
                    """
                class get_optislang_license_count(TUIMethod):
                    """
                    Get optiSLang License Count.
                    """
                class set_optislang_license_count(TUIMethod):
                    """
                    Set optiSLang License Count.
                    """

    class turbo_workflow(TUIMenu):
        """
        Enter the turbo workflow menu.
        """
        def __init__(self, service, version, mode, path):
            self.workflow = self.__class__.workflow(service, version, mode, path + ["workflow"])
            super().__init__(service, version, mode, path)

        class workflow(TUIMenu):
            """
            Enter the workflow menu.
            """
            def __init__(self, service, version, mode, path):
                self.enable = self.__class__.enable(service, version, mode, path + ["enable"])
                self.reset = self.__class__.reset(service, version, mode, path + ["reset"])
                self.disable = self.__class__.disable(service, version, mode, path + ["disable"])
                super().__init__(service, version, mode, path)
            class enable(TUIMethod):
                """
                Enable the workflow.
                """
            class reset(TUIMethod):
                """
                Reset the workflow.
                """
            class disable(TUIMethod):
                """
                Disable the workflow.
                """
