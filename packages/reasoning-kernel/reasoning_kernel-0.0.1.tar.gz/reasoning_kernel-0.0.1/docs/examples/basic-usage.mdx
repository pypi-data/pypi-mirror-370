---
title: "Basic Usage Examples"
description: "Learn the Reasoning Kernel through practical examples, from simple scenarios to complex reasoning applications using MSA and thinking exploration."
---

## Introduction

This guide provides hands-on examples to help you understand and use the Reasoning Kernel effectively. We'll start with simple scenarios and progressively build to more complex applications.

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket-launch" href="#quick-start-examples">
    Simple examples to get you started immediately
  </Card>
  <Card title="Business Applications" icon="building-office" href="#business-applications">
    Real-world business reasoning scenarios
  </Card>
  <Card title="Scientific Reasoning" icon="flask" href="#scientific-reasoning">
    Research and discovery applications
  </Card>
  <Card title="Advanced Patterns" icon="puzzle-piece" href="#advanced-reasoning-patterns">
    Complex reasoning with MSA and exploration
  </Card>
</CardGroup>

## Quick Start Examples

### Example 1: Simple Decision Analysis

Let's start with a basic business decision scenario:

<Tabs>
  <Tab title="Python SDK">
    ```python simple_decision.py
    import asyncio
    from reasoning_kernel import ReasoningKernel
    
    async def simple_decision_example():
        # Initialize the kernel
        kernel = ReasoningKernel()
        
        # Define the scenario
        scenario = """
        A small restaurant owner must decide whether to expand their 
        delivery service. Current facts:
        - Monthly revenue: $45,000
        - Delivery would cost $8,000/month to operate
        - Estimated additional revenue: $12,000-18,000/month
        - Competition: 3 other restaurants offer delivery
        - Customer survey: 68% interested in delivery option
        
        Should they expand their delivery service?
        """
        
        # Execute reasoning
        result = await kernel.reason(scenario)
        
        # Display results
        print("=== Decision Analysis ===")
        print(f"Recommendation: {result.reasoning_result}")
        print(f"Confidence: {result.confidence:.2f}")
        
        if result.reasoning_trace:
            print("\n=== Reasoning Steps ===")
            for i, step in enumerate(result.reasoning_trace, 1):
                print(f"{i}. {step}")
        
        return result
    
    # Run the example
    if __name__ == "__main__":
        result = asyncio.run(simple_decision_example())
    ```
    
    **Expected Output:**
    ```
    === Decision Analysis ===
    Recommendation: Expand delivery service. The financial analysis shows 
    positive ROI with break-even at 67% of estimated demand. Customer 
    interest (68%) exceeds break-even threshold, providing safety margin.
    Confidence: 0.84
    
    === Reasoning Steps ===
    1. Calculate net revenue range: $4,000-10,000/month
    2. Assess customer demand vs. required utilization
    3. Evaluate competitive positioning and market share
    4. Consider implementation risks and mitigation strategies
    ```
  </Tab>
  
  <Tab title="REST API">
    ```bash curl
    curl -X POST "https://api.reasoning-kernel.com/v1/reasoning" \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "scenario": "A small restaurant owner must decide whether to expand their delivery service. Current facts: - Monthly revenue: $45,000 - Delivery would cost $8,000/month to operate - Estimated additional revenue: $12,000-18,000/month - Competition: 3 other restaurants offer delivery - Customer survey: 68% interested in delivery option. Should they expand their delivery service?",
        "config": {
          "confidence_threshold": 0.8
        }
      }'
    ```
    
    **Response:**
    ```json
    {
      "success": true,
      "reasoning_result": "Expand delivery service. The financial analysis shows positive ROI with break-even at 67% of estimated demand. Customer interest (68%) exceeds break-even threshold, providing safety margin.",
      "confidence": 0.84,
      "reasoning_trace": [
        "Calculate net revenue range: $4,000-10,000/month",
        "Assess customer demand vs. required utilization", 
        "Evaluate competitive positioning and market share",
        "Consider implementation risks and mitigation strategies"
      ],
      "execution_time": 8.42
    }
    ```
  </Tab>
  
  <Tab title="JavaScript SDK">
    ```javascript simple_decision.js
    import { ReasoningKernel } from '@reasoning-kernel/sdk';
    
    async function simpleDecisionExample() {
      // Initialize the kernel
      const kernel = new ReasoningKernel({
        apiKey: process.env.REASONING_KERNEL_API_KEY
      });
      
      // Define the scenario
      const scenario = `
        A small restaurant owner must decide whether to expand their 
        delivery service. Current facts:
        - Monthly revenue: $45,000
        - Delivery would cost $8,000/month to operate
        - Estimated additional revenue: $12,000-18,000/month
        - Competition: 3 other restaurants offer delivery
        - Customer survey: 68% interested in delivery option
        
        Should they expand their delivery service?
      `;
      
      try {
        // Execute reasoning
        const result = await kernel.reason(scenario);
        
        console.log('=== Decision Analysis ===');
        console.log(`Recommendation: ${result.reasoning_result}`);
        console.log(`Confidence: ${result.confidence.toFixed(2)}`);
        
        if (result.reasoning_trace) {
          console.log('\n=== Reasoning Steps ===');
          result.reasoning_trace.forEach((step, i) => {
            console.log(`${i + 1}. ${step}`);
          });
        }
        
        return result;
      } catch (error) {
        console.error('Reasoning failed:', error.message);
      }
    }
    
    // Run the example
    simpleDecisionExample();
    ```
  </Tab>
</Tabs>

### Example 2: Risk Assessment

Analyze a more complex risk scenario:

```python risk_assessment.py
from reasoning_kernel import ReasoningKernel, MSAConfig

async def risk_assessment_example():
    # Configure for enhanced risk analysis
    config = MSAConfig(
        enable_uncertainty_quantification=True,
        include_confidence_intervals=True,
        reasoning_depth="detailed"
    )
    
    kernel = ReasoningKernel(config=config)
    
    scenario = """
    A technology startup is considering expanding to European markets.
    Context:
    - Current ARR: $2.4M in North America
    - EU expansion estimated cost: $800K initial + $200K/month
    - GDPR compliance required (estimated $150K)
    - Market research: 2.3M potential customers in target regions
    - Conversion rate assumption: 0.8-1.5% based on NA data
    - Competition: 5 established players, 3 well-funded startups
    - Team: Would need to hire 8-12 people in Europe
    - Timeline: 12-18 months to break even
    
    Assess the risks and recommend whether to proceed.
    """
    
    result = await kernel.reason(
        scenario=scenario,
        include_risk_breakdown=True,
        timeout=60
    )
    
    print("=== Risk Assessment ===")
    print(f"Recommendation: {result.reasoning_result}")
    print(f"Overall Confidence: {result.confidence:.2f}")
    
    if hasattr(result, 'risk_breakdown'):
        print("\n=== Risk Analysis ===")
        for risk_category, assessment in result.risk_breakdown.items():
            print(f"{risk_category}: {assessment['level']} (p={assessment['probability']:.2f})")
    
    if hasattr(result, 'uncertainty_bounds'):
        print("\n=== Uncertainty Bounds ===")
        for metric, bounds in result.uncertainty_bounds.items():
            print(f"{metric}: {bounds['low']:.2f} - {bounds['high']:.2f}")

# Run the example
asyncio.run(risk_assessment_example())
```

**Sample Output:**
```
=== Risk Assessment ===
Recommendation: Proceed with caution. Implement phased expansion starting 
with one market (Germany or UK) to validate assumptions before full rollout.
Overall Confidence: 0.71

=== Risk Analysis ===
Market Risk: Medium (p=0.45)
Financial Risk: High (p=0.62)  
Operational Risk: Medium (p=0.38)
Regulatory Risk: Low (p=0.23)

=== Uncertainty Bounds ===
Break-even timeline: 14.2 - 22.7 months
Customer acquisition cost: $142 - $287
Market penetration: 0.6% - 1.8%
```

## Business Applications

### Example 3: Supply Chain Optimization

Complex multi-factor optimization scenario:

<Tabs>
  <Tab title="Problem Setup">
    ```python supply_chain.py
    from reasoning_kernel import ReasoningKernel
    from reasoning_kernel.agents import OptimizationAgent
    
    async def supply_chain_optimization():
        kernel = ReasoningKernel()
        
        scenario = """
        Global electronics manufacturer facing supply chain disruption:
        
        Current Situation:
        - Primary semiconductor supplier in Taiwan affected by earthquake
        - 40% of supply disrupted for 6-8 weeks
        - Current inventory: 3.2 weeks at normal production
        - Alternative suppliers available but 15-30% higher cost
        - Customer demand stable with key orders due in 4-6 weeks
        
        Options:
        1. Reduce production 40% using current inventory + remaining supply
        2. Switch to alternative suppliers for shortfall
        3. Mixed approach: partial production cut + some alternative sourcing
        4. Rush order premium components (50% cost increase, 2-week delivery)
        
        Constraints:
        - Customer satisfaction critical (Apple, Samsung contracts)
        - Q2 earnings guidance already set
        - Alternative suppliers need 2-week qualification
        - Union contract limits production cuts to 25% without negotiation
        
        Optimize the response strategy considering financial, operational, 
        and relationship impacts.
        """
        
        result = await kernel.reason_with_optimization(
            scenario=scenario,
            optimization_objectives=[
                "minimize_cost",
                "maximize_customer_satisfaction", 
                "minimize_operational_disruption"
            ],
            constraints=[
                "union_contract_limits",
                "supplier_qualification_time",
                "earnings_guidance"
            ]
        )
        
        return result
    ```
  </Tab>
  
  <Tab title="Advanced Analysis">
    ```python supply_chain_advanced.py
    async def advanced_supply_chain_analysis():
        # Use full MSA pipeline with thinking exploration
        kernel = ReasoningKernel(
            enable_thinking_exploration=True,
            enable_scenario_analysis=True
        )
        
        # The system will automatically detect this as a complex 
        # multi-objective optimization requiring thinking exploration
        result = await kernel.reason_with_exploration(
            scenario=scenario,
            exploration_mode="adaptive"
        )
        
        print("=== Optimization Results ===")
        print(f"Recommended Strategy: {result.recommended_strategy}")
        print(f"Confidence: {result.confidence:.2f}")
        
        if result.exploration_triggered:
            print(f"\nExploration triggered: {result.exploration_reasons}")
            print(f"Scenarios analyzed: {result.scenarios_considered}")
        
        if hasattr(result, 'pareto_frontier'):
            print("\n=== Trade-off Analysis ===")
            for solution in result.pareto_frontier[:3]:  # Top 3 solutions
                print(f"Cost Impact: {solution.cost_impact}")
                print(f"Customer Satisfaction: {solution.customer_impact}")
                print(f"Operational Disruption: {solution.operational_impact}")
                print("---")
        
        return result
    ```
  </Tab>
  
  <Tab title="Results Analysis">
    **Sample Output:**
    ```
    === Optimization Results ===
    Recommended Strategy: Mixed approach with strategic component rush orders
    - Immediate: Rush order 15% of critical components (2-week delivery)
    - Week 1-2: Qualify alternative suppliers for remaining 25% shortfall
    - Week 3+: Gradual transition to alternative suppliers
    - Production: Maintain 90% capacity through strategic scheduling
    Confidence: 0.78
    
    Exploration triggered: ['novel_constraint_combination', 'multi_objective_optimization']
    Scenarios analyzed: 12
    
    === Trade-off Analysis ===
    Cost Impact: +$2.4M (5.2% above normal)
    Customer Satisfaction: 94% (minimal order delays)
    Operational Disruption: Low (no production cuts)
    ---
    Cost Impact: +$1.1M (2.4% above normal)  
    Customer Satisfaction: 87% (some delays acceptable)
    Operational Disruption: Medium (15% production cut)
    ---
    Cost Impact: +$0.3M (0.7% above normal)
    Customer Satisfaction: 72% (significant delays)
    Operational Disruption: High (35% production cut)
    ```
  </Tab>
</Tabs>

### Example 4: Market Entry Strategy

Strategic planning with uncertainty:

```python market_entry.py
from reasoning_kernel import ReasoningKernel
from reasoning_kernel.config import StrategyConfig

async def market_entry_strategy():
    # Configure for strategic planning
    config = StrategyConfig(
        planning_horizon="24_months",
        uncertainty_modeling=True,
        scenario_planning=True,
        competitive_analysis=True
    )
    
    kernel = ReasoningKernel(config=config)
    
    scenario = """
    SaaS company (CRM software) considering expansion to Latin America:
    
    Company Profile:
    - Current markets: US, Canada (established), UK (growing)
    - ARR: $12M, growing 35% YoY
    - Team: 45 people, mostly engineering and sales
    - Funding: $8M Series A, 18 months runway
    
    Latin America Opportunity:
    - Addressable market: ~$180M (Brazil 40%, Mexico 25%, rest 35%)
    - Local competition: 2 major players, multiple smaller ones
    - Pricing pressure: 30-40% lower than US market
    - Localization needs: Portuguese, Spanish, local tax integration
    - Sales model: Direct sales challenging, partner channel preferred
    
    Entry Options:
    1. Full localization + direct sales team (Brazil focus)
    2. English product + partner channel (multi-country)
    3. Acquisition of local competitor ($2-4M range)
    4. Strategic partnership with existing platform
    
    Considerations:
    - Limited resources (funding runway)
    - Founder has no LatAm experience
    - Product-market fit strong in English-speaking markets
    - Investors expect international expansion
    
    Develop a market entry strategy with risk mitigation.
    """
    
    result = await kernel.develop_strategy(
        scenario=scenario,
        strategic_frameworks=[
            "market_entry_analysis",
            "resource_constraint_optimization", 
            "risk_mitigation_planning"
        ]
    )
    
    print("=== Market Entry Strategy ===")
    print(f"Recommended Approach: {result.strategy.primary_recommendation}")
    print(f"Confidence: {result.confidence:.2f}")
    print(f"Timeline: {result.strategy.timeline}")
    
    print("\n=== Phased Implementation ===")
    for phase in result.strategy.phases:
        print(f"Phase {phase.number}: {phase.description}")
        print(f"  Duration: {phase.duration}")
        print(f"  Investment: {phase.investment}")
        print(f"  Key Milestones: {', '.join(phase.milestones)}")
    
    print("\n=== Risk Mitigation ===")
    for risk in result.strategy.risk_mitigations:
        print(f"Risk: {risk.description}")
        print(f"Mitigation: {risk.mitigation_strategy}")
        print(f"Monitoring: {risk.monitoring_metrics}")

# Execute the strategy development
asyncio.run(market_entry_strategy())
```

## Scientific Reasoning

### Example 5: Research Hypothesis Generation

Scientific discovery and hypothesis formation:

<Tabs>
  <Tab title="Experimental Design">
    ```python research_hypothesis.py
    from reasoning_kernel import ReasoningKernel
    from reasoning_kernel.research import ScientificReasoningConfig
    
    async def research_hypothesis_generation():
        # Configure for scientific reasoning
        config = ScientificReasoningConfig(
            evidence_threshold=0.95,
            hypothesis_generation=True,
            experimental_design=True,
            causal_inference=True
        )
        
        kernel = ReasoningKernel(config=config)
        
        scenario = """
        Research Observation:
        A materials science lab discovered an unexpected phenomenon:
        
        Experimental Setup:
        - Testing new polymer composite for aerospace applications
        - Standard tensile strength tests at various temperatures
        - Expected: Strength decreases linearly with temperature
        - Observed: Strength increases 15-20% at 180-220Â°C range
        
        Additional Observations:
        - Effect reproducible across 15 test samples
        - Only occurs with specific catalyst (Cat-X47)
        - Microscopy shows unusual crystal formation at high temp
        - Effect reversible when cooled and reheated
        - Similar polymers without Cat-X47 show expected behavior
        
        Background:
        - Cat-X47 contains rare earth elements (neodymium, terbium)
        - Polymer backbone: polyetheretherketone (PEEK) derivative
        - Literature: No similar phenomena reported
        - Team expertise: Polymer chemistry, not rare earth physics
        
        Generate hypotheses to explain this phenomenon and design 
        experiments to test them.
        """
        
        result = await kernel.reason_scientifically(
            scenario=scenario,
            generate_hypotheses=True,
            design_experiments=True,
            literature_context=True
        )
        
        return result
    ```
  </Tab>
  
  <Tab title="Hypothesis Analysis">
    ```python hypothesis_analysis.py
    async def analyze_hypotheses():
        result = await research_hypothesis_generation()
        
        print("=== Generated Hypotheses ===")
        for i, hypothesis in enumerate(result.hypotheses, 1):
            print(f"\n{i}. {hypothesis.description}")
            print(f"   Mechanism: {hypothesis.proposed_mechanism}")
            print(f"   Testability: {hypothesis.testability_score:.2f}")
            print(f"   Novelty: {hypothesis.novelty_score:.2f}")
            print(f"   Predictions: {', '.join(hypothesis.testable_predictions)}")
        
        print("\n=== Experimental Design ===")
        for experiment in result.experimental_design:
            print(f"\nExperiment: {experiment.title}")
            print(f"Objective: {experiment.objective}")
            print(f"Method: {experiment.methodology}")
            print(f"Variables: {experiment.variables}")
            print(f"Expected Results: {experiment.expected_outcomes}")
            print(f"Required Resources: {experiment.resource_requirements}")
        
        print("\n=== Research Priority ===")
        print(f"Highest Priority: {result.research_priority.top_hypothesis}")
        print(f"Rationale: {result.research_priority.rationale}")
        print(f"Expected Timeline: {result.research_priority.timeline}")
    
    # Run the analysis
    asyncio.run(analyze_hypotheses())
    ```
  </Tab>
  
  <Tab title="Sample Output">
    **Expected Results:**
    ```
    === Generated Hypotheses ===
    
    1. Thermally-Activated Crosslinking Enhancement
       Mechanism: Rare earth elements catalyze additional crosslinking at high temperatures
       Testability: 0.89
       Novelty: 0.67
       Predictions: DSC shows endothermic transition, increased crosslink density
    
    2. Crystal Phase Transition in Catalyst
       Mechanism: Cat-X47 undergoes reversible phase transition creating reinforcing nanostructures
       Testability: 0.95
       Novelty: 0.82
       Predictions: XRD pattern changes, optical properties shift
    
    3. Magnetic Field Effects from Rare Earth
       Mechanism: Neodymium creates local magnetic fields affecting polymer chain alignment
       Testability: 0.73
       Novelty: 0.91
       Predictions: External magnetic field modulates effect, NMR shows changes
    
    === Experimental Design ===
    
    Experiment: Temperature-Resolved X-Ray Diffraction
    Objective: Test crystal phase transition hypothesis
    Method: In-situ XRD during heating cycle 150-250Â°C
    Variables: Temperature, Cat-X47 concentration, heating rate
    Expected Results: Phase transition peaks at 180Â°C, reversible on cooling
    Required Resources: High-temp XRD stage, 2 weeks analysis time
    
    === Research Priority ===
    Highest Priority: Crystal Phase Transition in Catalyst
    Rationale: Highest novelty with excellent testability, clear experimental path
    Expected Timeline: 6-8 weeks for definitive results
    ```
  </Tab>
</Tabs>

### Example 6: Medical Diagnosis Reasoning

Complex diagnostic reasoning with uncertainty:

```python medical_diagnosis.py
from reasoning_kernel import ReasoningKernel
from reasoning_kernel.medical import DiagnosticConfig

async def medical_diagnosis_reasoning():
    # Configure for medical reasoning
    config = DiagnosticConfig(
        differential_diagnosis=True,
        evidence_weighting=True,
        uncertainty_quantification=True,
        treatment_recommendations=False  # Diagnosis only
    )
    
    kernel = ReasoningKernel(config=config)
    
    scenario = """
    Patient Case for Diagnostic Reasoning:
    
    Patient: 34-year-old female software engineer
    
    Chief Complaint:
    - Fatigue and weakness progressing over 3 months
    - Initially attributed to work stress
    
    History of Present Illness:
    - Gradual onset fatigue, now severe enough to affect work
    - Weakness more prominent in legs than arms
    - Occasional muscle cramps, especially at night
    - No fever, weight loss, or appetite changes
    - Sleep quality poor despite feeling exhausted
    
    Physical Exam:
    - Vital signs normal
    - Muscle strength: 4/5 in legs, 5/5 in arms
    - Deep tendon reflexes: diminished in legs
    - No muscle atrophy visible
    - Coordination and sensation intact
    
    Laboratory Results:
    - CBC: Normal except mild anemia (Hgb 10.8)
    - Chemistry: Creatine kinase elevated (450 U/L, normal <200)
    - Thyroid function: Normal
    - Vitamin B12: Low normal (250 pg/mL)
    - Vitamin D: Deficient (18 ng/mL)
    
    Additional Context:
    - Family history: Mother has rheumatoid arthritis
    - Medications: Oral contraceptives only
    - Recent travel: None
    - Diet: Vegetarian for 2 years
    
    Generate differential diagnosis with reasoning.
    """
    
    result = await kernel.diagnose(
        scenario=scenario,
        include_probability_estimates=True,
        include_reasoning_chain=True
    )
    
    print("=== Differential Diagnosis ===")
    for diagnosis in result.differential_diagnoses:
        print(f"\n{diagnosis.condition}")
        print(f"  Probability: {diagnosis.probability:.2f}")
        print(f"  Supporting Evidence: {', '.join(diagnosis.supporting_evidence)}")
        print(f"  Contradicting Evidence: {', '.join(diagnosis.contradicting_evidence)}")
        print(f"  Next Steps: {', '.join(diagnosis.recommended_tests)}")
    
    print("\n=== Reasoning Chain ===")
    for step in result.reasoning_steps:
        print(f"â€¢ {step}")
    
    print("\n=== Recommended Investigations ===")
    for test in result.recommended_investigations:
        print(f"{test.name}: {test.rationale}")

# Execute medical reasoning
asyncio.run(medical_diagnosis_reasoning())
```

## Advanced Reasoning Patterns

### Example 7: Multi-Agent Reasoning

Complex scenarios requiring multiple reasoning perspectives:

<Tabs>
  <Tab title="Agent Coordination">
    ```python multi_agent_reasoning.py
    from reasoning_kernel import ReasoningKernel
    from reasoning_kernel.agents import (
        AnalyticalAgent,
        CreativeAgent, 
        SkepticalAgent,
        SynthesisAgent
    )
    
    async def multi_agent_reasoning_example():
        kernel = ReasoningKernel()
        
        # Initialize different reasoning agents
        analytical_agent = AnalyticalAgent(kernel)
        creative_agent = CreativeAgent(kernel)
        skeptical_agent = SkepticalAgent(kernel)
        synthesis_agent = SynthesisAgent(kernel)
        
        scenario = """
        Climate Tech Startup Dilemma:
        
        A startup has developed a new carbon capture technology that 
        could revolutionize industrial CO2 removal. However, they face 
        several critical decisions:
        
        Technical:
        - Technology works at lab scale (99.2% capture efficiency)
        - Scaling to industrial level unproven
        - Energy requirements: 30% less than current tech
        - Patent protection: Strong in US, pending in EU/China
        
        Business:
        - Funding: $50M needed for commercial prototype
        - Interest from 3 major oil companies for partnerships
        - Government incentives: $10M tax credits available
        - Timeline pressure: 2 competitors with similar tech
        
        Ethical Considerations:
        - Oil company partnerships could improve impact but hurt ESG image
        - Technology could enable continued fossil fuel use vs. transition
        - Regulatory risk if carbon credits system changes
        
        Strategic Question: How should they proceed with 
        commercialization while balancing technical, business, 
        and ethical considerations?
        """
        
        # Each agent analyzes from their perspective
        analytical_result = await analytical_agent.analyze(
            scenario, 
            focus="data_driven_analysis"
        )
        
        creative_result = await creative_agent.analyze(
            scenario,
            focus="innovative_solutions"
        )
        
        skeptical_result = await skeptical_agent.analyze(
            scenario,
            focus="risk_assessment"
        )
        
        # Synthesis agent combines perspectives
        synthesis_result = await synthesis_agent.synthesize_perspectives([
            analytical_result,
            creative_result, 
            skeptical_result
        ])
        
        return {
            "analytical": analytical_result,
            "creative": creative_result,
            "skeptical": skeptical_result,
            "synthesis": synthesis_result
        }
    ```
  </Tab>
  
  <Tab title="Perspective Analysis">
    ```python perspective_analysis.py
    async def analyze_multi_agent_results():
        results = await multi_agent_reasoning_example()
        
        print("=== ANALYTICAL PERSPECTIVE ===")
        print(f"Focus: {results['analytical'].focus_area}")
        print(f"Recommendation: {results['analytical'].recommendation}")
        print(f"Key Metrics: {results['analytical'].key_metrics}")
        print(f"Confidence: {results['analytical'].confidence:.2f}")
        
        print("\n=== CREATIVE PERSPECTIVE ===")
        print(f"Novel Approaches: {len(results['creative'].novel_approaches)}")
        for approach in results['creative'].novel_approaches:
            print(f"  â€¢ {approach.description}")
            print(f"    Innovation Score: {approach.innovation_score:.2f}")
        
        print("\n=== SKEPTICAL PERSPECTIVE ===")
        print("Risk Assessment:")
        for risk in results['skeptical'].identified_risks:
            print(f"  â€¢ {risk.description} (Impact: {risk.impact_level})")
            print(f"    Mitigation: {risk.mitigation_strategy}")
        
        print("\n=== SYNTHESIZED RECOMMENDATION ===")
        synthesis = results['synthesis']
        print(f"Balanced Strategy: {synthesis.balanced_recommendation}")
        print(f"Consensus Areas: {', '.join(synthesis.consensus_points)}")
        print(f"Trade-offs Identified: {len(synthesis.trade_offs)}")
        
        for trade_off in synthesis.trade_offs:
            print(f"  {trade_off.description}")
            print(f"    Recommended Resolution: {trade_off.resolution}")
    
    # Run the multi-perspective analysis
    asyncio.run(analyze_multi_agent_results())
    ```
  </Tab>
  
  <Tab title="Sample Output">
    **Multi-Agent Analysis Results:**
    ```
    === ANALYTICAL PERSPECTIVE ===
    Focus: Quantitative risk-return analysis
    Recommendation: Pursue oil company partnerships with structured ESG safeguards
    Key Metrics: NPV $89M over 10 years, IRR 34%, payback 4.2 years
    Confidence: 0.82
    
    === CREATIVE PERSPECTIVE ===
    Novel Approaches: 4
      â€¢ Create independent foundation to manage climate impact
        Innovation Score: 0.91
      â€¢ Develop modular licensing model for broader adoption
        Innovation Score: 0.85
      â€¢ Partner with cities for urban deployment pilots
        Innovation Score: 0.78
      â€¢ Build coalition of climate tech companies for shared advocacy
        Innovation Score: 0.73
    
    === SKEPTICAL PERSPECTIVE ===
    Risk Assessment:
      â€¢ Technology scaling risk (Impact: High)
        Mitigation: Phased development with interim milestones
      â€¢ Regulatory capture by oil industry (Impact: Medium)
        Mitigation: Maintain independence through governance structure
      â€¢ Market timing risk (Impact: High)
        Mitigation: Accelerated development timeline, early market signals
    
    === SYNTHESIZED RECOMMENDATION ===
    Balanced Strategy: Hybrid approach combining partnerships with independence
    Consensus Areas: Need for additional funding, importance of scaling success, market timing urgency
    Trade-offs Identified: 3
      Partner funding vs. independence: Create separate entity for partnerships
      Speed vs. control: License technology while maintaining core IP
      ESG image vs. practical impact: Transparent impact measurement and reporting
    ```
  </Tab>
</Tabs>

### Example 8: Real-Time Adaptive Reasoning

Dynamic reasoning that adapts based on incoming information:

```python adaptive_reasoning.py
from reasoning_kernel import ReasoningKernel, AdaptiveConfig
from reasoning_kernel.streaming import ReasoningStream

async def adaptive_reasoning_example():
    # Configure for real-time adaptation
    config = AdaptiveConfig(
        update_threshold=0.1,        # Update reasoning when confidence drops 10%
        streaming_enabled=True,
        adaptation_sensitivity="high"
    )
    
    kernel = ReasoningKernel(config=config)
    
    initial_scenario = """
    Emergency Response Coordination:
    
    Situation: Major earthquake (7.2 magnitude) struck metropolitan area
    Initial Information (T+15 minutes):
    - Epicenter: 25km northwest of city center
    - Population affected: ~2.3 million
    - Initial damage reports: Multiple building collapses
    - Infrastructure: Power grid 60% down, major highways blocked
    - Emergency services: Fire stations 3 and 7 non-responsive
    
    Available Resources:
    - Emergency response teams: 12 units available
    - Medical facilities: 4 hospitals operational, 2 major trauma centers
    - Search and rescue: 3 teams with specialized equipment
    - Temporary shelters: Convention center, 2 schools available
    
    Coordinate initial emergency response priorities.
    """
    
    # Start adaptive reasoning stream
    reasoning_stream = ReasoningStream(kernel)
    
    print("=== INITIAL RESPONSE PLAN ===")
    initial_plan = await reasoning_stream.start_reasoning(initial_scenario)
    print(f"Priority Actions: {initial_plan.priority_actions}")
    print(f"Resource Allocation: {initial_plan.resource_allocation}")
    print(f"Confidence: {initial_plan.confidence:.2f}")
    
    # Simulate incoming information updates
    updates = [
        {
            "timestamp": "T+30min",
            "info": "Hospital St. Mary's reports structural damage, evacuating patients",
            "impact": "high"
        },
        {
            "timestamp": "T+45min", 
            "info": "Gas leak detected in downtown area, evacuation zone expanded",
            "impact": "high"
        },
        {
            "timestamp": "T+60min",
            "info": "Additional search and rescue teams arriving from neighboring counties (5 teams)",
            "impact": "medium"
        }
    ]
    
    for update in updates:
        print(f"\n=== UPDATE: {update['timestamp']} ===")
        print(f"New Information: {update['info']}")
        
        # System automatically adapts reasoning
        adapted_plan = await reasoning_stream.update_reasoning(update['info'])
        
        if adapted_plan.plan_changed:
            print("ðŸ”„ Plan Updated")
            print(f"Changes: {adapted_plan.changes_made}")
            print(f"New Priorities: {adapted_plan.updated_priorities}")
            print(f"Confidence: {adapted_plan.confidence:.2f}")
        else:
            print("âœ… Plan Confirmed")
            print(f"Confidence: {adapted_plan.confidence:.2f}")
    
    # Get final comprehensive plan
    final_plan = await reasoning_stream.get_final_plan()
    return final_plan

# Execute adaptive reasoning
asyncio.run(adaptive_reasoning_example())
```

## Best Practices

Based on these examples, here are key best practices for using the Reasoning Kernel:

<AccordionGroup>
  <Accordion title="Scenario Design" icon="pencil">
    **Provide Rich Context**: Include relevant facts, constraints, and objectives
    
    **Be Specific**: Quantify information when possible (numbers, percentages, timelines)
    
    **Include Uncertainties**: Mention what's unknown or uncertain
    
    **Set Clear Objectives**: Define what decision or analysis is needed
  </Accordion>
  
  <Accordion title="Configuration Choices" icon="cog">
    **Match Config to Use Case**: Use appropriate config for scientific, business, or creative reasoning
    
    **Set Appropriate Thresholds**: Adjust confidence thresholds based on decision importance
    
    **Enable Features Selectively**: Use MSA, exploration, or multi-agent reasoning when beneficial
    
    **Consider Performance**: Balance capability with response time requirements
  </Accordion>
  
  <Accordion title="Result Interpretation" icon="chart-bar">
    **Check Confidence Scores**: Lower confidence may indicate need for more information
    
    **Review Reasoning Traces**: Understand how conclusions were reached
    
    **Consider Uncertainties**: Factor in confidence intervals and risk assessments
    
    **Validate Assumptions**: Verify that the system's assumptions match reality
  </Accordion>
  
  <Accordion title="Iterative Improvement" icon="arrow-path">
    **Start Simple**: Begin with basic scenarios before adding complexity
    
    **Refine Incrementally**: Use results to improve scenario descriptions
    
    **Learn from Patterns**: Notice what types of problems work best
    
    **Build on Success**: Use successful reasoning patterns as templates
  </Accordion>
</AccordionGroup>

## Next Steps

Ready to explore more advanced capabilities?

<CardGroup cols={2}>
  <Card title="MSA Pipeline Guide" icon="brain" href="/examples/msa-pipeline">
    Deep dive into Model Synthesis Architecture examples
  </Card>
  <Card title="Thinking Exploration" icon="lightbulb" href="/examples/thinking-exploration">
    Learn to use the thinking exploration framework
  </Card>
  <Card title="Advanced Scenarios" icon="rocket-launch" href="/examples/advanced-scenarios">
    Complex multi-stage reasoning applications
  </Card>
  <Card title="Production Patterns" icon="server" href="/guides/production-patterns">
    Patterns for production reasoning applications
  </Card>
</CardGroup>

<Tip>
**Experiment and Learn**: The Reasoning Kernel works best when you experiment with different approaches. Start with these examples and adapt them to your specific use cases.
</Tip>
