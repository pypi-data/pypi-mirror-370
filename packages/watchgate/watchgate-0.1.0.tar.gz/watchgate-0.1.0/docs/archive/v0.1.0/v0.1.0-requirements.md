# Watchgate v0.1.0 Requirements Document
 
*Version: 3.0*  
*Target: Initial Release - 🔄 IN PROGRESS - Security Plugin Suite Development*

> **Parent Document:** [Watchgate Requirements Overview](../../overview.md)  
> **Related Documents:** [Implementation Plan](v0.1.0-implementation-plan.md) | [Test Plan](v0.1.0-test-plan.md)

## Project Overview

Watchgate is an open-source Model Context Protocol (MCP) security proxy that provides basic message forwarding, simple access control, and request auditing for MCP client-server communications. This focused v0.1.0 release proves the core concept with minimal complexity.

## v0.1.0 Scope

### Core Value Proposition
**"Gain visibility and control over your MCP tool interactions"** - Enable developers to monitor and control which tools their MCP clients can access, with transparent auditing of all interactions for debugging and security purposes.

### Target Users
- Developers deploying AI agents who need oversight of tool usage
- Teams requiring controlled access to MCP server capabilities
- Security-conscious developers wanting transparency in AI tool interactions

## Plugin Architecture Design Philosophy

### v0.1.0 Plugin Strategy
Watchgate v0.1.0 establishes a **plugin-first architecture** while maintaining simplicity for initial users:

**Benefits of Plugin Architecture**:
- **Extensibility**: Developers can create custom security policies and auditing formats without modifying core code
- **Modularity**: Clean separation between core proxy logic and policy/auditing implementations
- **Testability**: Plugins can be tested independently and swapped for different environments
- **Extensibility**: Advanced features can be added as plugins without breaking existing deployments
- **Community Growth**: Third-party developers can contribute specialized plugins for different use cases

**v0.1.0 Implementation Strategy**:
- Ship with **default plugins** that provide the basic tool allowlist/blocklist and file auditing functionality
- Establish **plugin interfaces** that define clear contracts for security and auditing plugins
- Support **plugin configuration** through the existing YAML configuration system
- Maintain **backwards compatibility** so users can start simple and add complexity over time

This approach allows v0.1.0 to deliver immediate value with simple defaults while laying the foundation for sophisticated extensibility.

## Functional Requirements

### 1. MCP Gateway Server *(Requirement FR-1 / Component A + B.4)*
**Priority**: Critical  
**Description**: Core proxy functionality to intercept and forward MCP communications

*📋 Related Documents: [Implementation Plan](v0.1.0-implementation-plan.md) | [Test Plan](v0.1.0-test-plan.md)*

**v0.1.0 Requirements**: ✅ **COMPLETED**
- ✅ Accept MCP client connections (JSON-RPC over stdio only)
- ✅ Forward requests to single upstream MCP server
- ✅ Maintain protocol compatibility with MCP specification
- ✅ Handle basic connection lifecycle (initialization, requests, cleanup)
- ✅ Simple message forwarding with basic error handling
- ✅ Enhanced message forwarding with sender context for plugins

**Implementation Status**: ✅ **COMPLETED** in `watchgate/proxy/stdio_server.py`
- **StdioServer**: Complete proxy server with plugin integration
- **Custom WriteProtocol**: Asyncio stream handling for MCP communication
- **Plugin Pipeline**: Security and auditing plugin orchestration
- **Upstream Forwarding**: Full MCP server communication established
- **Enhanced Message Support**: Full sender context and notification support
- **Test Coverage**: 55 integration tests with 90% coverage

**Technical Details**: ✅ **IMPLEMENTED**
```python
# Complete implementation in watchgate/proxy/stdio_server.py
class StdioServer:
    """Production proxy server with plugin integration and stdio transport"""
    
    async def start(self):
        """✅ Initialize proxy server with stdio transport and plugin system"""
        
    async def handle_client_request(self, request: MCPRequest) -> MCPResponse:
        """✅ Process client request through complete plugin pipeline"""
        # ✅ Security plugin validation
        # ✅ Auditing plugin logging
        # ✅ Upstream server forwarding
        # ✅ Response processing and logging
```

### 2. Plugin-Based Auditing System *(Requirement FR-2 / Component B.1 + B.3)*
**Priority**: High  
**Description**: Extensible plugin architecture for auditing with default implementation

**v0.1.0 Plugin Architecture Requirements**:
- **Pluggable Auditing Engine**: Define plugin interface for custom auditing formats and destinations
- **Default Auditing Plugin**: Ship with basic file-based auditing implementation 
- **Plugin Discovery**: Automatic loading and registration of auditing plugins
- **Configuration Integration**: YAML configuration support for plugin parameters

**Default Auditing Plugin (v0.1.0)**:
- Log all MCP method calls to a simple text file
- Include timestamps and basic request information
- Simple, human-readable format (not JSON)
- Basic log rotation (by size)

**Default Log Format**:
```
YYYY-MM-DD HH:MM:SS - REQUEST: tools/call - read_file
YYYY-MM-DD HH:MM:SS - RESPONSE: success
YYYY-MM-DD HH:MM:SS - REQUEST: tools/call - run_terminal
YYYY-MM-DD HH:MM:SS - BLOCKED: tool not allowed
```

### 3. Security Plugin Suite *(Requirement FR-3 / Component F)*  
**Priority**: High  
**Description**: Comprehensive security plugin suite providing specialized protection for different MCP communication aspects

**v0.1.0 Security Plugin Suite**:

#### 3.1. PII Content Filter Plugin
**Status**: ✅ **COMPLETED**
**Purpose**: Detects and filters personally identifiable information across all MCP communications using proven pattern-matching techniques.

**Key Features**:
- **Detection modes**: block, redact, audit_only
- **Configurable PII types**: SSN, credit cards, emails, phone numbers, IP addresses via regex patterns
- **International format support**: Configurable detection for region-specific PII formats (international phone numbers, national IDs, etc.)
- **Granular format control**: Enable/disable specific formats within each PII type (e.g., US vs international phone formats)
- **Custom regex patterns**: Organization-specific PII detection patterns
- **Tool and path exemptions**: Bypass PII filtering for trusted sources
- **Audit integration**: Uses PolicyDecision.reason and metadata fields to provide plugin decision information to auditing plugins

**Technical Approach**:
- **Regex-based detection**: Well-established patterns for common PII types
- **Pattern library**: Pre-configured regex patterns for standard PII formats across multiple regions
- **Format-specific detection**: Configurable pattern sets for US, EU, UK, and international PII formats
- **Performance optimized**: Designed for real-time processing with minimal latency
- **Modular pattern system**: Enable/disable specific format detection within each PII type

#### 3.2. Secrets Filter Plugin
**Status**: ✅ **COMPLETED**  
**Purpose**: Identifies and blocks well-known secrets, tokens, and credentials across all MCP communications using established pattern-matching and entropy analysis techniques.

**Key Features**:
- **Detection modes**: block, redact, audit_only
- **High-confidence secret detection**: Focus on unambiguous patterns with minimal false positives
- **Conservative entropy analysis**: Conservative high-threshold entropy detection for unknown secrets
- **Configurable secret types**: Enable/disable specific secret types individually
- **Custom secret patterns**: Organization-specific credential detection patterns
- **Allowlist support**: Testing scenario patterns and development environment exceptions
- **Tool and path exemptions**: Bypass secret filtering for trusted sources
- **Audit integration**: Uses PolicyDecision.reason and metadata fields to provide plugin decision information to auditing plugins

**Technical Approach**:
- **High-confidence regex patterns**: Focus on secret formats with unique, unambiguous identifiers
- **Conservative detection strategy**: Prioritize avoiding false positives over comprehensive coverage
- **Optional entropy analysis**: Disabled by default, high thresholds when enabled to minimize noise
- **Performance optimized**: Designed for real-time processing with minimal latency impact
- **Modular detection system**: Enable/disable specific secret type detection based on organizational risk tolerance

**Secret Types and Detection Methods** (High-Confidence Only):
- **AWS Access Keys**: AKIA-prefixed access keys with specific format validation
- **GitHub Tokens**: Platform-specific prefixes (ghp_, gho_, ghu_, ghs_, ghr_) designed to be unambiguous
- **Google API Keys**: AIza-prefixed keys with length validation
- **JWT Tokens**: Standard JWT three-part structure with base64url encoding
- **SSH Private Keys**: PEM format headers (-----BEGIN [TYPE] PRIVATE KEY-----)
- **Custom Organization Patterns**: User-defined patterns for internal credential formats

**Configuration Examples**:
```yaml
plugins:
  security:
    - policy: "basic_secrets_filter"
      enabled: true
      priority: 10
      config:
        action: "block"  # or "redact" or "audit_only"
        detection_types:
          aws_access_keys:
            enabled: true
          github_tokens:
            enabled: true
          google_api_keys:
            enabled: true
          jwt_tokens:
            enabled: true
          ssh_private_keys:
            enabled: true
          # Higher false positive risk - disabled by default
          aws_secret_keys:
            enabled: false  # 40-char base64 pattern has false positive risk
        entropy_detection:
          enabled: true   # Enabled by default with conservative thresholds
          min_entropy: 5.5  # Higher threshold for fewer false positives
          min_length: 32
          max_length: 200
        custom_patterns:
          - name: "company_api_key"
            pattern: "COMP-[A-Za-z0-9]{32}"
            enabled: true
          - name: "internal_token"
            pattern: "INT_[A-Z0-9]{24}"
            enabled: true
        allowlist:
          patterns: 
            - "test_key_*"
            - "demo_token_*"
            - "sample_secret_*"
            - "placeholder_*"
            - "example_*"
        exemptions:
          tools: ["development_tool", "testing_framework"]
          paths: ["test/*", "examples/*", "demo/*", "docs/*"]
```

**Integration Architecture**:
- Uses PolicyDecision architecture for consistent audit integration
- Provides structured metadata for detailed secret detection logging
- Maintains compatibility with existing plugin priority and execution order
- Supports modified_response field for redacted content in redact mode

#### 3.3. Prompt Injection Defense Plugin
**Status**: 🔄 **PLACEHOLDER - TO BE IMPLEMENTED**  
**Purpose**: Detects and blocks basic prompt injection techniques across all MCP communications using proven pattern-matching approaches.

**Key Features**:
- **Detection modes**: block, redact, audit_only
- **High-confidence injection detection**: Delimiter injection, basic role manipulation, context breaking keywords
- **Two sensitivity levels**: standard, strict detection sensitivity to balance security and usability
- **Pattern-based detection**: Proven regex patterns for reliable injection detection
- **Custom injection patterns**: Organization-specific injection patterns via regex
- **Tool exemptions**: Bypass injection filtering for trusted tools
- **Audit integration**: Uses PolicyDecision.reason and metadata fields to provide plugin decision information to auditing plugins

**Technical Approach**:
- **Pattern-based detection**: Focused regex patterns for high-confidence injection techniques
- **Delimiter injection detection**: Recognition of prompt delimiters, escape sequences, and context-breaking characters
- **Basic role manipulation detection**: Detection of simple system role changes and privilege escalation attempts
- **Performance optimized**: Designed for real-time processing with <50ms prompt analysis time
- **Simplified detection system**: Enable/disable specific injection detection categories with global sensitivity control

**Injection Detection Categories**:
- **Delimiter Injection**: Triple quotes, markdown code blocks, XML/HTML tags, role delimiters
- **Basic Role Manipulation**: System role changes, administrator impersonation attempts
- **Context Breaking**: Instruction negation, context reset attempts using keyword detection

**Sensitivity Levels and Behavior**:
- **Standard**: Balanced sensitivity (targets >85% detection rate), production-ready with <5% false positive rate
- **Strict**: Higher sensitivity (targets >90% detection rate), security-critical environments with <10% false positive rate

**Configuration Examples**:
```yaml
plugins:
  security:
    - policy: "basic_prompt_injection_defense"
      enabled: true
      priority: 10
      config:
        action: "block"  # or "redact" or "audit_only"
        sensitivity: "standard"  # standard, strict
        detection_methods:
          delimiter_injection:
            enabled: true
          role_manipulation:
            enabled: true
          context_breaking:
            enabled: true
        custom_patterns:
          - name: "org_specific_injection"
            pattern: "OVERRIDE\\s+SYSTEM\\s+MODE"
            enabled: true
        exemptions:
          tools: ["trusted_tool", "development_assistant"]
```

**Integration Architecture**:
- Uses PolicyDecision architecture for consistent audit integration
- Provides structured metadata for injection attempt logging
- Maintains compatibility with existing plugin priority and execution order
- Supports modified_response field for sanitized prompts in redact mode

#### 3.4. Filesystem Server Security Plugin
**Status**: 🔄 **IN DEVELOPMENT**  
**Purpose**: Provides specialized security controls for the `modelcontextprotocol/servers/src/filesystem` MCP server, offering fine-grained path-based access control and file operation restrictions that extend beyond generic resource control capabilities.

**Key Features**:
- **Path-based access control with tool-specific permissions**: Glob pattern matching for paths with granular tool permissions (read vs write vs admin operations)
- **Blocked path patterns for sensitive files**: Protection for environment files, secrets directories, and configuration files containing credentials
- **Tool-specific path permissions matrix**: Different filesystem tools can have different access levels to the same paths
- **Integration with existing security architecture**: Leverages established pathspec pattern matching system and PolicyDecision architecture
- **Comprehensive configuration validation**: Validates filesystem tool names against known MCP server capabilities and provides clear error messages for invalid configurations

**Technical Approach**:
- **Pathspec-based pattern matching**: Utilizes existing pathspec library integration with gitwildmatch patterns supporting *, ?, [range], and ** glob operators
- **Tool permission matrix validation**: Validates filesystem tool access against configured path permissions before request forwarding
- **Pattern compilation optimization**: Pre-compiles glob patterns during plugin initialization for efficient runtime matching
- **Configuration validation**: Comprehensive validation of tool names against known filesystem server capabilities and path pattern syntax verification

**Security Benefits**:
- **Prevents unauthorized file access**: Granular control beyond generic resource filtering, specific to filesystem operations
- **Tool-aware path permissions**: Different permission levels for read operations (read_file, list_directory) vs write operations (write_file, create_directory) vs administrative operations (move_file)
- **Comprehensive audit trail**: Integration with existing PolicyDecision architecture provides detailed filesystem operation logging for compliance and security monitoring
- **Robust error handling**: Clear validation errors and fallback security posture for misconfigured permissions

**Configuration Examples**:
```yaml
plugins:
  security:
    - policy: "filesystem_server_security"
      enabled: true
      priority: 20
      config:
        # Path-based access control with tool permissions
        path_permissions:
          - paths: 
              - "public/**/*"         # Allow all files in public directory
              - "docs/**/*.md"        # Allow markdown files in docs
              - "src/**/*.{py,js,ts}" # Allow source code files
              - "config/**/*.yaml"    # Allow configuration files
            tools:
              - "read_file"
              - "list_directory" 
              - "search_files"
              - "get_file_info"
          
          - paths:
              - "tmp/**/*"            # Temp directory
              - "output/**/*"         # Output directory  
              - "logs/**/*.log"       # Log files
            tools:
              - "read_file"
              - "write_file"
              - "create_directory"
              - "list_directory"
          
          - paths:
              - "!**/*.env"           # Block environment files
              - "!**/secrets/**"      # Block secrets directory
              - "!tmp/sensitive/**"   # Block sensitive temp files
            tools: []                 # No tools allowed on blocked paths
```

**Integration Architecture**:
- **Uses PolicyDecision for consistent audit integration**: Provides structured metadata for filesystem operation logging with details like requested path, tool used, and access decision
- **Compatibility with plugin priority system**: Designed to work alongside other security plugins with configurable execution order
- **Metadata structure for filesystem operation logging**: Includes filesystem-specific fields like file_path, operation_type, tool_name, and permission_level in audit records
- **Replaces generic resource control for filesystem servers**: Provides specialized filesystem security that supersedes generic pattern matching

#### 3.5. Git Server Security Plugin
**Status**: 🔄 **PLACEHOLDER - TO BE IMPLEMENTED**  
**Purpose**: Offers tailored security for `modelcontextprotocol/servers/src/git` including repository access control and branch protection.

**Key Features**:
- **Repository and path-based access control**: Fine-grained repository permissions
- **Branch protection**: main, master, production, release branch protection
- **Content security**: Credential scanning in commit content
- **Operation limits**: diff size, log entry limits
- **Tool-specific repository permissions**: Per-tool repository access control
- **Audit integration**: Uses existing PolicyDecision architecture for Git operation logging

**Plugin Architecture Requirements**:
- **Pluggable Security Engine**: Define plugin interface for custom security policies
- **Plugin Discovery**: Automatic loading and registration of security plugins
- **Configuration Integration**: YAML configuration support for plugin parameters
- **Priority-Based Execution**: Security plugins execute in configurable priority order

**Plugin-Based Configuration (v0.1.0)**:
```yaml
# watchgate.yml
upstream:
  command: "python my_mcp_server" # or ["python", "my_mcp_server.py"]

# Plugin configuration with security plugin suite
plugins:
  security:
    - policy: "basic_pii_filter"
      enabled: true
      priority: 5
      config:
        mode: "redact"  # or "block" or "audit_only"
        pii_types:
          ssn:
            enabled: true
            formats: ["us"]  # US Social Security Numbers
          credit_card:
            enabled: true  # Detects all major credit card formats using Luhn validation
          email:
            enabled: true
            formats: ["standard"]  # RFC 5322 compliant
          phone:
            enabled: true
            formats: ["us", "international", "uk", "eu"]  # Regional phone formats
          ip_address:
            enabled: true
            formats: ["ipv4", "ipv6"]  # IP address types
          national_id:
            enabled: false
            formats: ["uk_ni", "canadian_sin"]  # International ID numbers
        custom_patterns:
          - name: "employee_id"
            pattern: "EMP-\\d{6}"
            enabled: true
        exemptions:
          tools: ["trusted_tool"]
          paths: ["test/data/*"]
        # Audit integration: Plugin decision information included in PolicyDecision
    
    - policy: "basic_secrets_filter"
      enabled: true
      priority: 10
      config:
        action: "block"  # or "redact" or "audit_only"
        detection_types: 
          aws_keys: true
          github_tokens: true
          api_keys: true
        entropy_detection:
          enabled: true
          min_entropy: 4.5
        # Audit integration: Plugin decision information included in PolicyDecision
    
    - policy: "basic_prompt_injection_defense"
      enabled: true
      priority: 15
      config:
        action: "block"  # or "audit_only"
        detection_methods: ["delimiter_injection", "role_manipulation"]
        sensitivity: "medium"
        # Audit integration: Injection attempt details included in PolicyDecision for auditing
  
  auditing:
    - policy: "file_auditing"
      enabled: true
      config:
        file: "watchgate.log"
        max_size_mb: 10
        format: "simple"
        mode: "all_events"  # Logs both allowed and blocked requests with detailed reasons
```

**Audit Integration Architecture**:
All security plugins use the existing `PolicyDecision` mechanism for audit integration:
- **Reason field**: Contains human-readable detection information (e.g., "PII detected: SSN (confidence: 0.95) - audit_only mode enabled")
- **Metadata field**: Contains structured detection data for programmatic processing by auditing plugins
- **No plugin-to-plugin communication**: Security and auditing plugins remain decoupled through the PolicyDecision interface
- **Standard audit flow**: Existing auditing plugins automatically receive and log security plugin decisions

### 4. Plugin-Aware Configuration *(Requirement FR-4 / Component B.5)*
**Priority**: Critical  
**Description**: YAML configuration supporting plugin architecture with backwards compatibility

**v0.1.0 Requirements**:
- YAML configuration file format with plugin sections
- Configure upstream server command
- Configure default security and auditing plugins
- Plugin-specific configuration parameters
- Backwards compatibility with simple flat configuration
- Basic validation with simple error messages

### 5. Enhanced Message Type System *(Requirement FR-5 / Component C)*
**Priority**: Critical  
**Description**: Enhanced MCP message types with sender metadata for improved plugin context and JSON-RPC 2.0 compliance

*📋 Related Documents: [Implementation Plan](v0.1.0-implementation-plan.md) | [Test Plan](v0.1.0-test-plan.md)*

**v0.1.0 Requirements**: ✅ **COMPLETED**
- ✅ MessageSender enum for distinguishing CLIENT vs SERVER message origins
- ✅ Optional sender metadata on MCPRequest and MCPResponse types
- ✅ MCPNotification message type for JSON-RPC 2.0 notification support
- ✅ Plugin interface updates to leverage sender context information
- ✅ Backward compatibility with existing message usage patterns

**Implementation Status**: ✅ **COMPLETED** - All message enhancements implemented
- **MessageSender Enum**: Define CLIENT and SERVER values for message origin tracking
- **SenderContext Structure**: Enhanced metadata structure for extensible context information
- **MCPNotification Type**: Support for JSON-RPC notifications (messages without id)
- **Plugin Interface Updates**: Enhanced interfaces with sender context and original request access
- **SecurityPlugin.check_response()**: Takes both original request and response parameters
- **Test Coverage**: Comprehensive test suite for all enhanced message types (37 additional tests)

**Technical Details**: 🔄 **DESIGN FINALIZED**
```python
# Implementation required in watchgate/protocol/messages.py
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Union, Dict, Any

class MessageSender(Enum):
    """Enum for identifying message sender type"""
    CLIENT = "client"  # Messages from MCP client to proxy
    SERVER = "server"  # Messages from proxy to MCP server

@dataclass
class SenderContext:
    """Enhanced sender context with extensible metadata"""
    sender: MessageSender
    connection_id: Optional[str] = None
    # Future extensibility for auth context, rate limiting, etc.

@dataclass
class MCPRequest:
    """Enhanced MCP request with optional sender context"""
    jsonrpc: str
    method: str
    id: Union[str, int]
    params: Optional[Dict[str, Any]] = None
    sender_context: Optional[SenderContext] = None  # Enhanced field

@dataclass
class MCPNotification:
    """New: JSON-RPC 2.0 notification support (no id field)"""
    jsonrpc: str
    method: str
    params: Optional[Dict[str, Any]] = None
    sender_context: Optional[SenderContext] = None
``` 
class MCPNotification:
    """✅ MCP notification message (JSON-RPC without id)"""
    jsonrpc: str
    method: str
    params: Optional[Dict[str, Any]] = None
    sender: Optional[MessageSender] = None  # ✅ New field
```

**Design Rationale**:
- **Plugin Context**: Plugins can distinguish between client requests and server sampling requests
- **Type Safety**: Structured approach prevents raw JSON manipulation errors
- **Future Extensibility**: Supports potential sampling methods (createMessage/completePrompt)
- **JSON-RPC 2.0 Compliance**: Full notification support per specification
- **Minimal Breaking Changes**: Optional sender property with sensible defaults

### 6. Command Line Interface *(Requirement FR-6 / Component B.3)*
**Priority**: High  
**Description**: User-friendly CLI for starting and configuring the proxy server

*📋 Related Documents: [Implementation Plan](v0.1.0-implementation-plan.md) | [Test Plan](v0.1.0-test-plan.md)*

**v0.1.0 Requirements**: ✅ **COMPLETED**
- ✅ Accept configuration file path via command line argument
- ✅ Support verbose logging mode for debugging
- ✅ Display version information
- ✅ Provide helpful usage examples and error messages
- ✅ Graceful handling of keyboard interrupts (Ctrl+C)
- ✅ Proper exit codes for different error conditions

**Implementation Status**: ✅ **COMPLETED** in `watchgate/main.py`
- **Argument Parsing**: Complete argparse implementation with config file path, verbose mode, and version display
- **Logging Configuration**: Structured logging setup with configurable verbosity levels
- **Error Handling**: Comprehensive error handling for configuration, file not found, and runtime errors
- **Async Integration**: Full integration with asyncio-based proxy server
- **User Experience**: Clear help text, examples, and graceful shutdown handling

**Technical Details**: ✅ **IMPLEMENTED**
```python
# Complete implementation in watchgate/main.py
def main():
    """✅ Full-featured CLI with argparse, logging, and error handling"""
    parser = argparse.ArgumentParser(
        description="Watchgate MCP Gateway Server - Monitor and control AI tool usage",
        epilog="Examples: watchgate --config watchgate.yaml --verbose"
    )
    # ✅ Configuration file argument with default
    # ✅ Verbose logging flag
    # ✅ Version display
    # ✅ Help text with usage examples

async def run_proxy(config_path: Path, verbose: bool = False):
    """✅ Async proxy runner with comprehensive error handling"""
    # ✅ Structured logging configuration
    # ✅ Configuration loading with validation
    # ✅ Proxy lifecycle management
    # ✅ Error handling with appropriate exit codes
```

**CLI Usage Examples**:
```bash
# Start with default configuration
watchgate

# Start with custom configuration file
watchgate --config /path/to/config.yaml

# Start with verbose debug logging
watchgate --config watchgate.yaml --verbose

# Display version information
watchgate --version

# Display help and usage examples
watchgate --help
```



### 8. Logging Configuration System *(Requirement FR-8 / Component E)*
**Priority**: High  
**Description**: File-based logging configuration with flexible output destinations and log management

*📋 Related Documents: [Implementation Plan](v0.1.0-implementation-plan.md) | [Test Plan](v0.1.0-test-plan.md)*

**v0.1.0 Requirements**: ✅ **COMPLETED**
- ✅ YAML-based logging configuration integrated with main configuration file
- ✅ Multiple output destinations: console (stderr), file, or both simultaneously  
- ✅ Configurable log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- ✅ Automatic log rotation based on file size with configurable backup retention
- ✅ Custom log message formatting with timestamp and component identification
- ✅ Runtime log level override via `--verbose` command-line flag
- ✅ Graceful error handling with fallback to console logging
- ✅ Complete backward compatibility with existing command-line behavior

**Implementation Status**: ✅ **COMPLETED**
- **Configuration Schema**: Pydantic validation for logging settings in `watchgate/config/models.py`
- **Setup Function**: `setup_logging_from_config()` in `watchgate/main.py` with multiple handler support
- **File Management**: Automatic directory creation and log rotation using Python's `RotatingFileHandler`
- **Integration**: Seamless integration with existing configuration loader and CLI argument parsing
- **Error Recovery**: Automatic fallback to stderr logging when file operations fail

**Configuration Example**:
```yaml
# Optional logging section in watchgate.yaml
logging:
  level: "INFO"                                    # Log level control
  handlers: ["stderr", "file"]                     # Output destinations
  file_path: "logs/watchgate.log"                 # Log file location
  max_file_size_mb: 10                             # Rotation threshold
  backup_count: 5                                  # Number of backup files
  format: "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
  date_format: "%Y-%m-%d %H:%M:%S"
```

**Key Features**:
- **Backward Compatibility**: Existing configurations without logging section continue working unchanged
- **Flexible Output**: Support for console-only, file-only, or combined logging
- **Performance Optimized**: Efficient code paths for common configurations
- **Production Ready**: Log rotation prevents disk space issues in long-running deployments
- **Development Friendly**: Verbose flag override enables temporary debugging without config changes

## Technical Requirements

### 1. Technology Stack
**Language**: Python 3.11+  
**Key Dependencies**:
- `asyncio` - Basic async networking
- `PyYAML` - Configuration parsing
- `pytest` - Testing framework
- Built-in `auditing` - Simple file auditing

### 2. Plugin-Based Architecture
```
┌─────────────┐    ┌───────────────────────────┐    ┌─────────────┐
│ MCP Client  │───▶│      Watchgate Proxy     │───▶│ MCP Server  │
│ (Claude,    │    │ ┌───────────────────────┐ │    │ (Tools)     │
│  etc.)      │    │ │   Plugin Manager      │ │    │             │
│             │    │ │ ┌──────────┬─────────┐│ │    │             │
└─────────────┘    │ │ │ Security │ Auditing││ │    └─────────────┘
                   │ │ │ Plugins  │ Plugins ││ │
                   │ │ └──────────┴─────────┘│ │
                   │ └───────────────────────┘ │
                   └───────────────────────────┘
                                 │
                                 ▼
                      ┌─────────────────────┐
                      │  Auditing Outputs   │
                      │ (Files, Databases,  │
                      │  APIs, etc.)        │
                      └─────────────────────┘
```

### 3. Core Components (Plugin Architecture)
```python
# Plugin-based project structure for v0.1.0
watchgate/
├── __init__.py
├── proxy/
│   ├── __init__.py
│   └── server.py          # Main proxy server
├── plugins/               # 🆕 Plugin architecture
│   ├── __init__.py
│   ├── manager.py         # Plugin discovery and loading
│   ├── interfaces.py      # Plugin interface definitions
│   ├── security/          # Security plugin implementations
│   │   ├── __init__.py
│   │   └── tool_allowlist.py  # Default tool allowlist/blocklist
│   └── auditing/           # Auditing plugin implementations
│       ├── __init__.py
│       └── file_auditing.py    # Default file-based auditing
├── config/               # ✅ Already implemented
│   ├── __init__.py
│   ├── models.py         # Extended for plugin configuration
│   └── loader.py         
├── protocol/             # ✅ Already implemented
│   ├── __init__.py
│   ├── messages.py
│   ├── validation.py
│   └── errors.py
└── transport/            # ✅ Already implemented
    ├── __init__.py
    ├── base.py
    └── stdio.py
```

### 4. Plugin Architecture Requirements *(Requirement TR-4)*
**Priority**: High  
**Description**: Define plugin system for extensible security and auditing

**v0.1.0 Plugin System Requirements**:
- **Plugin Interfaces**: Define abstract base classes for security and auditing plugins
- **Plugin Discovery**: Direct file path loading based on configuration
- **Plugin Manager**: Central orchestration of plugin lifecycle and communication
- **Default Plugins**: Ship with working security policy and auditing implementations
- **Plugin Configuration**: YAML-based path configuration system for plugin parameters

**Plugin Interface Definition**:
```python
# Security Plugin Interface
class SecurityPlugin(ABC):
    @abstractmethod
    async def check_request(self, request: MCPRequest) -> PolicyDecision:
        """Check if request should be allowed, blocked, or modified"""
        pass

# Auditing Plugin Interface  
class AuditingPlugin(ABC):
    @abstractmethod
    async def log_request(self, request: MCPRequest, decision: PolicyDecision) -> None:
        """Log request with policy decision"""
        pass
    
    @abstractmethod
    async def log_response(self, response: MCPResponse) -> None:
        """Log response from upstream server"""
        pass
```

**Plugin Examples** (to illustrate extensibility potential):
```python
# Example: Enterprise LDAP Security Plugin
class LDAPSecurityPlugin(SecurityPlugin):
    """Authenticate users against LDAP and apply role-based policies"""
    
# Example: Database Auditing Plugin
class DatabaseAuditingPlugin(AuditingPlugin):
    """Store structured audit logs in PostgreSQL with rich metadata"""
    
# Example: Slack Notification Plugin
class SlackNotificationPlugin(AuditingPlugin):
    """Send alerts to Slack when suspicious activity is detected"""
```

### 5. Enhanced Message Type System *(Requirement TR-5 / Component C)*
**Priority**: Critical  
**Description**: Core message type enhancements required for plugin architecture and JSON-RPC 2.0 compliance

**v0.1.0 Message System Requirements**: ✅ **COMPLETED**
- ✅ **MessageSender Enum**: Define CLIENT and SERVER values for message origin tracking
- ✅ **Enhanced Message Types**: Add optional sender metadata to MCPRequest and MCPResponse
- ✅ **Notification Support**: Implement MCPNotification for JSON-RPC 2.0 notification messages
- ✅ **Plugin Integration**: Update plugin interfaces to utilize sender context information
- ✅ **Test-Driven Implementation**: Comprehensive test coverage using TDD methodology

**Message Type Implementation Requirements**:
```python
# ✅ COMPLETED - Enhanced message type implementation for v0.1.0
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Union, Dict, Any

class MessageSender(Enum):
    """✅ IMPLEMENTED: Message sender identification enum"""
    CLIENT = "client"    # Messages originating from MCP client
    SERVER = "server"    # Messages originating from MCP server

@dataclass
class MCPRequest:
    """✅ IMPLEMENTED: MCP request with sender context"""
    jsonrpc: str
    method: str
    id: Union[str, int]
    params: Optional[Dict[str, Any]] = None
    sender_context: Optional[SenderContext] = None  # ✅ IMPLEMENTED

@dataclass
class MCPNotification:
    """✅ IMPLEMENTED: JSON-RPC 2.0 notification support"""
    jsonrpc: str
    method: str
    params: Optional[Dict[str, Any]] = None
    sender_context: Optional[SenderContext] = None  # ✅ IMPLEMENTED
```

**Plugin Interface Updates**: ✅ **COMPLETED**
```python
# ✅ COMPLETED - Enhanced plugin interfaces with sender context
class SecurityPlugin(ABC):
    @abstractmethod
    async def check_request(self, request: MCPRequest) -> PolicyDecision:
        """✅ IMPLEMENTED: Access to request.sender_context for context-aware policies"""
        pass
    
    @abstractmethod
    async def check_response(self, request: MCPRequest, response: MCPResponse) -> PolicyDecision:
        """✅ IMPLEMENTED: Takes both original request and response for full security context"""
        pass
    
    @abstractmethod
    async def check_notification(self, notification: MCPNotification) -> PolicyDecision:
        """✅ IMPLEMENTED: Security check for JSON-RPC 2.0 notifications"""
        pass

class AuditingPlugin(ABC):
    @abstractmethod
    async def log_request(self, request: MCPRequest) -> None:
        """✅ IMPLEMENTED: Access to request.sender_context for context-aware logging"""
        pass
    
    @abstractmethod
    async def log_response(self, request: MCPRequest, response: MCPResponse) -> None:
        """✅ IMPLEMENTED: Access to both request and response with sender context"""
        pass
    
    @abstractmethod
    async def log_notification(self, notification: MCPNotification) -> None:
        """✅ IMPLEMENTED: Logging for JSON-RPC 2.0 notifications"""
        pass
```
    @abstractmethod
    async def log_request(self, request: MCPRequest, decision: PolicyDecision, sender_context: Optional[MessageSender] = None) -> None:
        """✅ IMPLEMENTED: Access to request.sender for detailed audit trails"""
        pass
    
    @abstractmethod
    async def log_response(self, request: MCPRequest, response: MCPResponse, decision: PolicyDecision, sender_context: Optional[MessageSender] = None) -> None:
        """✅ IMPLEMENTED: Log response with original request context and sender context"""
        pass
    
    @abstractmethod
    async def log_notification(self, notification: MCPNotification, decision: PolicyDecision) -> None:
        """✅ IMPLEMENTED: Log notification with policy decision"""
        pass
```

**Test-Driven Development Requirements**: ✅ **COMPLETED**
- ✅ **Red Phase**: Write failing tests for MessageSender enum, enhanced message types, and MCPNotification
- ✅ **Green Phase**: Implement minimal code to make tests pass
- ✅ **Refactor Phase**: Improve code quality while maintaining test coverage
- ✅ **Coverage Target**: >90% test coverage for all message type enhancements achieved



### 7. Logging Configuration System *(Requirement TR-7 / Component E)*
**Priority**: High  
**Description**: Technical implementation requirements for flexible logging configuration system

**v0.1.0 Logging System Requirements**: ✅ **COMPLETED**
- ✅ **Configuration Schema**: Pydantic validation schemas for logging settings with dataclass conversion
- ✅ **Handler Architecture**: Support for multiple simultaneous output destinations (stderr, file)
- ✅ **File Management**: Automatic directory creation and log rotation using Python's `RotatingFileHandler`
- ✅ **Format Customization**: Python logging format strings with timestamp and component identification
- ✅ **Runtime Override**: Command-line verbose flag integration with config-based log levels
- ✅ **Error Recovery**: Graceful fallback to stderr logging when file operations fail

**Technical Implementation Details**:
```python
# Configuration integration in watchgate/config/models.py
@dataclass
class LoggingConfig:
    level: str = "INFO"
    handlers: List[str] = field(default_factory=lambda: ["stderr"])
    file_path: Optional[Path] = None
    max_file_size_mb: int = 10
    backup_count: int = 5
    format: str = "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    date_format: str = "%Y-%m-%d %H:%M:%S"

# Setup function in watchgate/main.py
def setup_logging_from_config(logging_config: Optional[LoggingConfig], verbose: bool = False) -> None:
    """Configure Python logging based on config file and runtime flags"""
    # Implementation includes handler setup, format configuration, and error handling
```

**Integration Points**:
- **ConfigLoader**: Extended to parse optional logging sections from YAML configuration
- **Main Application**: Startup sequence modified to configure logging before other operations
- **CLI Interface**: Verbose flag overrides configured log level to DEBUG for troubleshooting
- **Error Handling**: Enhanced to support logging configuration errors with clear messages

**Performance Considerations**:
- **Optimized Code Paths**: Use `logging.basicConfig()` for simple stderr-only configurations
- **Lazy Handler Setup**: Manual handler configuration only when file logging or combined output required
- **Rotation Efficiency**: Large default file sizes to minimize rotation overhead in production

### 7. Basic Performance Requirements
- Handle basic MCP communication without noticeable lag
- Start up in reasonable time (< 5 seconds)
- Don't crash on common error conditions
- Simple memory usage (no optimization required)
- Plugin loading adds minimal startup overhead

### 6. Minimal Deployment
- Run as a Python script with `python -m watchgate`
- Single configuration file
- Log to current directory by default
- No special installation requirements beyond Python + dependencies

## Non-Functional Requirements

### 1. Simplicity
- Easy to understand codebase
- Minimal configuration options
- Clear error messages for common issues
- Simple deployment (just run it)

### 2. Reliability
- Basic error handling to prevent crashes
- Restart upstream server if it fails
- Log errors for debugging
- Graceful shutdown

### 3. Usability
- Work out of the box with minimal configuration
- Simple YAML configuration file
- Clear log output for troubleshooting
- Obvious behavior (no surprises)

## Quality Requirements

### 1. Testing - Enhanced for Message Types ✅ **COMPLETED**
- Unit test coverage >80% for new components
- Integration test with a real MCP server
- Basic error condition testing
- Simple smoke tests
- ✅ **Completed**: Test-driven development for message type enhancements (FR-5)
- ✅ **Completed**: Message type validation and sender context testing
- ✅ **Completed**: MCPNotification support testing

### 2. Documentation
- README with quick start guide
- Configuration file examples
- Basic troubleshooting guide

### 3. Code Quality
- Type hints for new code
- Consistent style with existing codebase
- Clear variable and function names
- Basic error handling

## Success Criteria

### v0.1.0 Success Metrics - ✅ **COMPLETED**
1. **Functional**: Proxy successfully forwards basic MCP operations ✅ **DONE**
2. **Plugin Architecture**: Security and auditing plugins work through defined interfaces ✅ **DONE**
3. **Default Plugins**: Tool allowlist/blocklist and file auditing work correctly ✅ **DONE**
4. **Plugin Configuration**: YAML configuration supports plugin parameters ✅ **DONE**
5. **Extensibility**: Clear interfaces allow developers to create custom plugins ✅ **DONE**
6. **Usability**: Developer can configure and run in <5 minutes ✅ **DONE**
7. **Stability**: Runs without crashing for basic usage scenarios ✅ **DONE**
8. ✅ **COMPLETED**: Enhanced message types with sender metadata (FR-5)
9. ✅ **COMPLETED**: MCPNotification support for JSON-RPC 2.0 compliance
10. ✅ **COMPLETED**: Plugin interfaces enhanced with sender context
11. ✅ **COMPLETED**: Test-driven development implementation of message enhancements

### v0.1.0 Release Blockers
**All items have been completed for v0.1.0 release:**

1. **MessageSender Enum Implementation** (FR-5, TR-5) ✅ **COMPLETED**
   - ✅ Define CLIENT and SERVER values
   - ✅ Integrate with existing message types

2. **Enhanced Message Types** (FR-5, TR-5) ✅ **COMPLETED**
   - ✅ Add optional sender metadata to MCPRequest and MCPResponse
   - ✅ Maintain backward compatibility

3. **MCPNotification Support** (FR-5, TR-5) ✅ **COMPLETED**
   - ✅ Implement JSON-RPC 2.0 notification message type
   - ✅ Support messages without id field

4. **Plugin Interface Updates** (FR-5) ✅ **COMPLETED**
   - ✅ Enhanced SecurityPlugin with sender context access
   - ✅ Enhanced AuditingPlugin with sender context access

5. **Test Coverage Implementation** (TR-5) ✅ **COMPLETED**
   - ✅ Test-driven development for all message enhancements
   - ✅ Achieve >90% coverage for new message functionality

### Current v0.1.0 Status: ✅ **COMPLETED**
**Completion**: 100% (All core functionality and message enhancements complete)
**Release Status**: ✅ Ready for release
**Quality Gate**: All requirements met and thoroughly tested

### Post-v0.1.0 Indicators
- Users can successfully intercept MCP communications
- Basic tool blocking works as expected
- Log files provide useful debugging information
- Configuration is straightforward and documented
- Developers can create custom security and auditing plugins
- Plugin system provides clear extension points for functionality

## Explicitly Out of Scope for v0.1.0

### Plugin System Limitations (v0.1.0)
The plugin architecture in v0.1.0 focuses on establishing the foundation with basic functionality:

**Plugin Features Included**:
- Basic plugin interfaces for security and auditing
- Simple plugin discovery and loading
- Default security policy plugin (tool allowlist/blocklist)
- Default file auditing plugin
- YAML configuration for plugin parameters

**Advanced Plugin Features**:
- Plugin hot-reloading and dynamic updates
- Plugin dependency management and versioning
- Plugin packaging and distribution system
- Plugin security sandboxing and isolation
- Plugin performance monitoring and metrics
- Third-party plugin marketplace or registry
- Plugin API documentation and SDK
- Cross-plugin communication and event system

### Other Advanced Features
- Advanced policy engine (resource paths, content filtering)
- Structured logging formats (JSON, database storage)
- Comprehensive CLI tools
- HTTP transport support
- Performance optimization
- Production deployment features
- Advanced error handling and recovery
- Hot configuration reload
- Multi-client support
- Enterprise authentication and authorization

## Development Phases

## Development Phases - Updated Status

### Phase 1: Core Proxy Components ✅ **COMPLETED**
- ✅ Protocol foundation (COMPLETED)
- ✅ Transport layer (COMPLETED) 
- ✅ Configuration management (COMPLETED)
- ✅ Simple proxy server implementation (COMPLETED)
- ✅ Basic message forwarding (COMPLETED)

### Phase 2: Policy and Auditing ✅ **COMPLETED**
- ✅ Simple tool allowlist/blocklist implementation (COMPLETED)
- ✅ Basic file auditing implementation (COMPLETED)
- ✅ Policy integration with proxy server (COMPLETED)

### Phase 3: Integration and Testing ✅ **COMPLETED**
- ✅ End-to-end integration testing (COMPLETED)
- ✅ Basic documentation (COMPLETED)
- ✅ Simple deployment testing (COMPLETED)

## Implementation Status

### Component Implementation Progress

#### ✅ Component A: Foundation Components - **COMPLETED**
**Status**: ✅ Complete (Core foundation established)  
**Completed Components**:
- ✅ **Protocol Foundation**: Basic message types, validation, error handling (90% test coverage)
- ✅ **Transport Layer**: Stdio transport with subprocess management (90% test coverage)
- ✅ **Configuration Management**: YAML loading with validation (90% test coverage)

#### ✅ Component B.1-B.6: Plugin System - **COMPLETED**
**Status**: ✅ Complete (Plugin architecture fully implemented)  
**Completed Components**:
- ✅ **Plugin Interfaces**: Abstract base classes for security and auditing plugins (14 tests)
- ✅ **Plugin Manager**: Dynamic loading, orchestration, and error isolation (30 tests)
- ✅ **Default Security Plugin**: Tool allowlist/blocklist implementation (31 tests, 100% coverage)
- ✅ **Default Auditing Plugin**: File-based auditing implementation (40 tests, 95% coverage)
- ✅ **Core Proxy Server**: Message forwarding with plugin integration (55 tests, 90% coverage)
- ✅ **Configuration Extension**: YAML-based plugin configuration (37 tests, 95% coverage)
- ✅ **End-to-End Integration**: Complete request/response flow validation

#### ✅ Component C: Enhanced Message Types - **COMPLETED**
**Status**: ✅ **COMPLETED** - All v0.1.0 requirements successfully implemented  
**Completed Components**:
- ✅ **MessageSender Enum**: CLIENT/SERVER origin tracking (FR-5, TR-5)
- ✅ **Enhanced MCPRequest**: Sender metadata integration (FR-5, TR-5)
- ✅ **Enhanced MCPResponse**: Sender metadata integration (FR-5, TR-5)  
- ✅ **MCPNotification**: JSON-RPC 2.0 notification support (FR-5, TR-5)
- ✅ **Plugin Interface Updates**: Sender context utilization (FR-5)
- ✅ **Test Suite**: TDD implementation and validation (TR-5, 37 tests passing)



### Overall Project Status
**Current Phase**: ✅ **COMPLETED** - All phases including Enhanced Message Types complete  
**Overall Progress**: 100% complete (All components implemented and tested)  
**Quality Status**: ✅ **COMPLETED** (All v0.1.0 requirements met)  
**Schedule Status**: ✅ **READY FOR RELEASE** (All components complete and tested)

## v0.1.0 Release Status Summary

### ✅ v0.1.0 COMPLETED - All Requirements Met

Watchgate v0.1.0 is **COMPLETED** and ready for release with all critical message type enhancements implemented:

**Completed Implementation (100%)**:
- ✅ **Complete Plugin System**: All plugin interfaces, manager, discovery, and configuration implemented
- ✅ **Default Plugins**: Security (tool allowlist/blocklist) and auditing (file-based auditing) plugins shipped
- ✅ **YAML Configuration**: Full plugin configuration system with path-based discovery
- ✅ **Basic Proxy Functionality**: Core message forwarding and plugin orchestration working
- ✅ **Enhanced Message Types**: MessageSender enum and sender metadata implemented (FR-5, TR-5)
- ✅ **JSON-RPC 2.0 Compliance**: MCPNotification support implemented (FR-5, TR-5)
- ✅ **Plugin Context Enhancement**: Sender-aware plugin interfaces implemented (FR-5)
- ✅ **Test-Driven Implementation**: Comprehensive test suite for message enhancements complete (TR-5)

**Quality Achievements (All Components)**:
- **370/370 tests Passing**: 100% test success rate for all components including message enhancements
- **>90% Test Coverage**: Achieved on all plugin components and message types
- **Robust Error Handling**: Plugin failures isolated, proxy remains stable
- **Performance**: <100ms plugin system latency confirmed

### Release Readiness Assessment
- **Core Functionality**: ✅ Ready (Plugin-based proxy architecture complete)
- **Message Enhancement (FR-5)**: ✅ **COMPLETED** (All requirements implemented and tested)
- **Documentation**: ✅ Updated to reflect completion status
- **Test Coverage**: ✅ Enhanced for message types with 37 additional tests (TR-5)

**Bottom Line**: v0.1.0 release is **READY FOR RELEASE** with all enhanced message types (FR-5, TR-5) implemented using test-driven development methodology.

**Quality Achievements**:
- **370/370 tests Passing**: 100% test success rate across all components including message enhancements
- **>90% Test Coverage**: Exceeded quality targets on all plugin components and message types
- **Robust Error Handling**: Plugin failures isolated, proxy remains stable
- **Performance**: <100ms plugin system latency confirmed

**Production Ready**:
- **Complete Documentation**: Plugin development guide and configuration examples
- **Backwards Compatible**: Simple configuration works alongside advanced plugin features  
- **Extensible Foundation**: Ready for community plugin development and advanced features
- **Enhanced Message Support**: Full JSON-RPC 2.0 compliance with notification support

The v0.1.0 plugin-based architecture provides immediate value with default plugins while establishing a solid foundation for extensibility and community growth.

## Success Indicators for v0.1.0 Release

**Technical**:
- [x] **Foundation**: Protocol, transport, and config systems complete and tested (✅ 370 tests passing)
- [x] **Plugin Architecture**: Plugin system foundation complete and tested (✅ 44 tests passing)
- [x] **Default Plugins**: Security and auditing plugins implement basic functionality (✅ 71 tests passing)
- [x] **Core Proxy Server**: Plugin-based proxy forwards MCP messages correctly (✅ 55 tests passing)
- [x] **Plugin Integration**: End-to-end plugin workflow functions as designed (✅ 37 configuration tests passing)
- [x] **Enhanced Messages**: MessageSender, MCPNotification, and sender context implemented (✅ 37 message tests passing)

**Usability**:
- [x] **Quick Start**: Developer can configure and run plugin-based proxy in <5 minutes
- [x] **Plugin Documentation**: Clear examples for plugin configuration and development
- [x] **Configuration**: YAML-based plugin configuration with path-based discovery fully implemented

**Quality**:
- [x] **Plugin Testing**: Integration tests with plugin system pass (✅ 370/370 tests)
- [x] **Stability**: Plugin failures don't crash proxy server (✅ error isolation tested)
- [x] **Code Quality**: Plugin components maintain existing quality standards (>90% coverage achieved)
- [x] **Message Type Testing**: Enhanced message types thoroughly tested (✅ 37 additional tests passing)

