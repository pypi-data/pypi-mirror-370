"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Contains the definitions for Microgrid gRPC API.

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import abc
import collections.abc
import frequenz.api.microgrid.microgrid_pb2
import google.protobuf.empty_pb2
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import grpc
import grpc.aio
import typing

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

class MicrogridStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    GetMicrogridMetadata: grpc.UnaryUnaryMultiCallable[
        google.protobuf.empty_pb2.Empty,
        frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata,
    ]
    """/ Returns the microgrid metadata
    / The metadata consists of information that describes the overall
    / microgrid, as opposed to its components,
    / e.g., the microgrid ID, location.
    """

    ListComponents: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentFilter,
        frequenz.api.microgrid.microgrid_pb2.ComponentList,
    ]
    """List components in the local microgrid, optionally filtered by a given list
    of component IDs and component categories.

    If provided, the filters for component IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
     `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

    If a filter list is empty, then that filter is not applied.
    """

    ListConnections: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ConnectionFilter,
        frequenz.api.microgrid.microgrid_pb2.ConnectionList,
    ]
    """Returns a list of the connections between components as `(start, end)`
    pairs of connection IDs, where the direction of individual connections
    is always away from the grid endpoint, i.e. aligned with the direction
    of positive current according to the passive sign convention:
    https://en.wikipedia.org/wiki/Passive_sign_convention

    The request may be filtered by `start`/`end` component(s) of individual
    connections.  If provided, the `start` and `end` filters have an `AND`
    relationship between each other, meaning that they are applied serially,
    but an `OR` relationship with other elements in the same list.
    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
    result should have all the connections where
    * each `start` component ID is either `1`, `2`, OR `3`,
     AND
    * each `end` component ID is either `4`, `5`, OR `6`.
    """

    StreamComponentData: grpc.UnaryStreamMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        frequenz.api.microgrid.microgrid_pb2.ComponentData,
    ]
    """Returns a stream containing data from a component with a given ID."""

    CanStreamData: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.wrappers_pb2.BoolValue,
    ]
    """Returns whether the component with given ID can stream data."""

    AddExclusionBounds: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        google.protobuf.timestamp_pb2.Timestamp,
    ]
    """Adds exclusion bounds for a given metric of a given component, and returns
    the UTC timestamp until which the given exclusion bounds will stay in
    effect.

    Exclusion bounds refer to the range of values that are disallowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraints
    `value <= lower` OR `upper <= value`.

    Exclusion bounds are a useful tool for enhancing the performance of a
    system. They can be used to restrict the acceptance of commands that fall
    below a certain threshold, which can help ensure the smooth functioning of
    the system.
    E.g., exclusion bounds can be set to limit the minimum charging power to a
    sufficiently high level, preventing a peak-shaver client from sending
    charge powers that are too low when a DC heater client is executing a
    charge pulse. This can significantly improve the overall performance of the
    DC heating mechanism.


    If multiple exclusion bounds have been provided bor a metric, then the
    aggregated lower and upper exclusion bounds are calculated as follows:
    lower: the minimum of all lower exclusion bounds
    upper: the maximum of all upper exclusion bounds

    It is important to note that these bounds work together with
    `system_inclusion_bounds`.

    E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
    This means that clients can only request charge commands with values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`.
    Similarly, for the system to accept a discharge command,
    clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

    The following diagram illustrates the relationship between the bounds.
    ```
      inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
                   exclusion.lower    exclusion.upper
    ```
    ---- values here are disallowed and wil be rejected
    ==== vales here are allowed and will be accepted
    """

    AddInclusionBounds: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        google.protobuf.timestamp_pb2.Timestamp,
    ]
    """Adds inclusion bounds for a given metric of a given component, and returns
    the UTC timestamp until which the given inclusion bounds will stay in
    effect.

    Inclusion bounds refer to the range of values that are allowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraint
    `lower <= value <= upper`.

    If multiple inclusion bounds have been provided bor a metric, then the
    aggregated lower and upper inclusion bounds are calculated as follows:
    lower: the maximum of all lower inclusion bounds
    upper: the minimum of all upper inclusion bounds

    It is important to note that these bounds work together with
    `system_exclusion_bounds`.

    E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
    This means that clients can only request charge commands with values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`.
    Similarly, for the system to accept a discharge command,
    clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

    The following diagram illustrates the relationship between the bounds.
    ```
      inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
                   exclusion.lower    exclusion.upper
    ```
    ---- values here are disallowed and wil be rejected
    ==== vales here are allowed and will be accepted
    """

    SetPowerActive: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the active power output of a component with a given ID, provided the
    component supports it.

    Note that the target component may have a resolution of more than 1 W.
    E.g., an inverter may have a resolution of 88 W.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Sends the discharge command to the inverter, making it deliver
     AC power.
    """

    SetPowerReactive: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the reactive power output of a component with a given ID, provided the
    component supports it.

    Note that the target component may have a resolution of more than 1 VAr.
    E.g., an inverter may have a resolution of 88 VAr.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.
    """

    Start: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Starts the component, and brings it into a state where it is immediately
    operational.

    Performs the following sequence of actions for the following component
    categories:

    * Inverter:
     * closes DC relays, if the feature is available
     * closes AC relays
     * sets power output to 0

    * Battery: Checks if DC relays are open, then
     * closes DC relays

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    HotStandby: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a hot-standby state, from which it can return
    into an operational state within at most 5 seconds.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.
    """

    ColdStandby: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a cold-standby state, from which it can
    return into an operational state within at most 2 minutes.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0, and
     * opens AC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call efffectively skips that action.
    """

    Stop: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Stops the component completely, potentially disengaging its power
    electronics controller(s).

    Performs the following sequence actions for the following component
    categories:

    * Inverter:
     * Brings component to the cold-standby state
     * opens DC relays

    * Battery: Checks if the power output is 0, then
     * opens DC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    ErrorAck: grpc.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Acknowledges any recoverable error reported by the component, and brings it
    back to the stopped or cold-standby state.
    """

class MicrogridAsyncStub:
    GetMicrogridMetadata: grpc.aio.UnaryUnaryMultiCallable[
        google.protobuf.empty_pb2.Empty,
        frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata,
    ]
    """/ Returns the microgrid metadata
    / The metadata consists of information that describes the overall
    / microgrid, as opposed to its components,
    / e.g., the microgrid ID, location.
    """

    ListComponents: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentFilter,
        frequenz.api.microgrid.microgrid_pb2.ComponentList,
    ]
    """List components in the local microgrid, optionally filtered by a given list
    of component IDs and component categories.

    If provided, the filters for component IDs and categories have an `AND`
    relationship with one another, meaning that they are applied serially,
    but the elements within a single filter list have an `OR` relationship with
    each other.
    E.g., if `ids` = [1, 2, 3], and `categories` = [
     `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
     `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
    then the results will consist of elements that
    have the IDs 1, OR 2, OR 3,
    AND
    are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
    `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

    If a filter list is empty, then that filter is not applied.
    """

    ListConnections: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ConnectionFilter,
        frequenz.api.microgrid.microgrid_pb2.ConnectionList,
    ]
    """Returns a list of the connections between components as `(start, end)`
    pairs of connection IDs, where the direction of individual connections
    is always away from the grid endpoint, i.e. aligned with the direction
    of positive current according to the passive sign convention:
    https://en.wikipedia.org/wiki/Passive_sign_convention

    The request may be filtered by `start`/`end` component(s) of individual
    connections.  If provided, the `start` and `end` filters have an `AND`
    relationship between each other, meaning that they are applied serially,
    but an `OR` relationship with other elements in the same list.
    For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
    result should have all the connections where
    * each `start` component ID is either `1`, `2`, OR `3`,
     AND
    * each `end` component ID is either `4`, `5`, OR `6`.
    """

    StreamComponentData: grpc.aio.UnaryStreamMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        frequenz.api.microgrid.microgrid_pb2.ComponentData,
    ]
    """Returns a stream containing data from a component with a given ID."""

    CanStreamData: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.wrappers_pb2.BoolValue,
    ]
    """Returns whether the component with given ID can stream data."""

    AddExclusionBounds: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        google.protobuf.timestamp_pb2.Timestamp,
    ]
    """Adds exclusion bounds for a given metric of a given component, and returns
    the UTC timestamp until which the given exclusion bounds will stay in
    effect.

    Exclusion bounds refer to the range of values that are disallowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraints
    `value <= lower` OR `upper <= value`.

    Exclusion bounds are a useful tool for enhancing the performance of a
    system. They can be used to restrict the acceptance of commands that fall
    below a certain threshold, which can help ensure the smooth functioning of
    the system.
    E.g., exclusion bounds can be set to limit the minimum charging power to a
    sufficiently high level, preventing a peak-shaver client from sending
    charge powers that are too low when a DC heater client is executing a
    charge pulse. This can significantly improve the overall performance of the
    DC heating mechanism.


    If multiple exclusion bounds have been provided bor a metric, then the
    aggregated lower and upper exclusion bounds are calculated as follows:
    lower: the minimum of all lower exclusion bounds
    upper: the maximum of all upper exclusion bounds

    It is important to note that these bounds work together with
    `system_inclusion_bounds`.

    E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
    This means that clients can only request charge commands with values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`.
    Similarly, for the system to accept a discharge command,
    clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

    The following diagram illustrates the relationship between the bounds.
    ```
      inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
                   exclusion.lower    exclusion.upper
    ```
    ---- values here are disallowed and wil be rejected
    ==== vales here are allowed and will be accepted
    """

    AddInclusionBounds: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        google.protobuf.timestamp_pb2.Timestamp,
    ]
    """Adds inclusion bounds for a given metric of a given component, and returns
    the UTC timestamp until which the given inclusion bounds will stay in
    effect.

    Inclusion bounds refer to the range of values that are allowed for the
    metric. If these bounds for a metric are [`lower`, `upper`], then this
    metric's `value` needs to comply with the constraint
    `lower <= value <= upper`.

    If multiple inclusion bounds have been provided bor a metric, then the
    aggregated lower and upper inclusion bounds are calculated as follows:
    lower: the maximum of all lower inclusion bounds
    upper: the minimum of all upper inclusion bounds

    It is important to note that these bounds work together with
    `system_exclusion_bounds`.

    E.g., for the system to accept a charge command,
    clients need to request power values within the bounds
    `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
    This means that clients can only request charge commands with values that
    are within the `system_inclusion_bounds`, but not within
    `system_exclusion_bounds`.
    Similarly, for the system to accept a discharge command,
    clients need to request power values within the bounds
    `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

    The following diagram illustrates the relationship between the bounds.
    ```
      inclusion.lower                              inclusion.upper
    <-------|============|------------------|============|--------->
                   exclusion.lower    exclusion.upper
    ```
    ---- values here are disallowed and wil be rejected
    ==== vales here are allowed and will be accepted
    """

    SetPowerActive: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the active power output of a component with a given ID, provided the
    component supports it.

    Note that the target component may have a resolution of more than 1 W.
    E.g., an inverter may have a resolution of 88 W.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Sends the discharge command to the inverter, making it deliver
     AC power.
    """

    SetPowerReactive: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the reactive power output of a component with a given ID, provided the
    component supports it.

    Note that the target component may have a resolution of more than 1 VAr.
    E.g., an inverter may have a resolution of 88 VAr.
    In such cases, the magnitude of power will be floored to the nearest
    multiple of the resolution.
    """

    Start: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Starts the component, and brings it into a state where it is immediately
    operational.

    Performs the following sequence of actions for the following component
    categories:

    * Inverter:
     * closes DC relays, if the feature is available
     * closes AC relays
     * sets power output to 0

    * Battery: Checks if DC relays are open, then
     * closes DC relays

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    HotStandby: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a hot-standby state, from which it can return
    into an operational state within at most 5 seconds.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.
    """

    ColdStandby: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Sets the given component into a cold-standby state, from which it can
    return into an operational state within at most 2 minutes.

    Performs the following sequence actions for the following component
    categories:

    * Inverter: Checks if AC and DC relays are closed, then
     * sets power to 0, and
     * opens AC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call efffectively skips that action.
    """

    Stop: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Stops the component completely, potentially disengaging its power
    electronics controller(s).

    Performs the following sequence actions for the following component
    categories:

    * Inverter:
     * Brings component to the cold-standby state
     * opens DC relays

    * Battery: Checks if the power output is 0, then
     * opens DC relays

    If any of the checks mentioned above fails, then the method call returns an
    error.

    If any of the above mentioned actions for a given component has already
    been performed, then this method call effectively skips that action.

    If a feature required to perform an action is missing, then that action is
    skipped.
    """

    ErrorAck: grpc.aio.UnaryUnaryMultiCallable[
        frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        google.protobuf.empty_pb2.Empty,
    ]
    """Acknowledges any recoverable error reported by the component, and brings it
    back to the stopped or cold-standby state.
    """

class MicrogridServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def GetMicrogridMetadata(
        self,
        request: google.protobuf.empty_pb2.Empty,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata, collections.abc.Awaitable[frequenz.api.microgrid.microgrid_pb2.MicrogridMetadata]]:
        """/ Returns the microgrid metadata
        / The metadata consists of information that describes the overall
        / microgrid, as opposed to its components,
        / e.g., the microgrid ID, location.
        """

    @abc.abstractmethod
    def ListComponents(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentFilter,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.microgrid_pb2.ComponentList, collections.abc.Awaitable[frequenz.api.microgrid.microgrid_pb2.ComponentList]]:
        """List components in the local microgrid, optionally filtered by a given list
        of component IDs and component categories.

        If provided, the filters for component IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
         `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
         `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

        If a filter list is empty, then that filter is not applied.
        """

    @abc.abstractmethod
    def ListConnections(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ConnectionFilter,
        context: _ServicerContext,
    ) -> typing.Union[frequenz.api.microgrid.microgrid_pb2.ConnectionList, collections.abc.Awaitable[frequenz.api.microgrid.microgrid_pb2.ConnectionList]]:
        """Returns a list of the connections between components as `(start, end)`
        pairs of connection IDs, where the direction of individual connections
        is always away from the grid endpoint, i.e. aligned with the direction
        of positive current according to the passive sign convention:
        https://en.wikipedia.org/wiki/Passive_sign_convention

        The request may be filtered by `start`/`end` component(s) of individual
        connections.  If provided, the `start` and `end` filters have an `AND`
        relationship between each other, meaning that they are applied serially,
        but an `OR` relationship with other elements in the same list.
        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
        result should have all the connections where
        * each `start` component ID is either `1`, `2`, OR `3`,
         AND
        * each `end` component ID is either `4`, `5`, OR `6`.
        """

    @abc.abstractmethod
    def StreamComponentData(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[frequenz.api.microgrid.microgrid_pb2.ComponentData], collections.abc.AsyncIterator[frequenz.api.microgrid.microgrid_pb2.ComponentData]]:
        """Returns a stream containing data from a component with a given ID."""

    @abc.abstractmethod
    def CanStreamData(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.wrappers_pb2.BoolValue, collections.abc.Awaitable[google.protobuf.wrappers_pb2.BoolValue]]:
        """Returns whether the component with given ID can stream data."""

    @abc.abstractmethod
    def AddExclusionBounds(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.timestamp_pb2.Timestamp, collections.abc.Awaitable[google.protobuf.timestamp_pb2.Timestamp]]:
        """Adds exclusion bounds for a given metric of a given component, and returns
        the UTC timestamp until which the given exclusion bounds will stay in
        effect.

        Exclusion bounds refer to the range of values that are disallowed for the
        metric. If these bounds for a metric are [`lower`, `upper`], then this
        metric's `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        Exclusion bounds are a useful tool for enhancing the performance of a
        system. They can be used to restrict the acceptance of commands that fall
        below a certain threshold, which can help ensure the smooth functioning of
        the system.
        E.g., exclusion bounds can be set to limit the minimum charging power to a
        sufficiently high level, preventing a peak-shaver client from sending
        charge powers that are too low when a DC heater client is executing a
        charge pulse. This can significantly improve the overall performance of the
        DC heating mechanism.


        If multiple exclusion bounds have been provided bor a metric, then the
        aggregated lower and upper exclusion bounds are calculated as follows:
        lower: the minimum of all lower exclusion bounds
        upper: the maximum of all upper exclusion bounds

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    @abc.abstractmethod
    def AddInclusionBounds(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.SetBoundsParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.timestamp_pb2.Timestamp, collections.abc.Awaitable[google.protobuf.timestamp_pb2.Timestamp]]:
        """Adds inclusion bounds for a given metric of a given component, and returns
        the UTC timestamp until which the given inclusion bounds will stay in
        effect.

        Inclusion bounds refer to the range of values that are allowed for the
        metric. If these bounds for a metric are [`lower`, `upper`], then this
        metric's `value` needs to comply with the constraint
        `lower <= value <= upper`.

        If multiple inclusion bounds have been provided bor a metric, then the
        aggregated lower and upper inclusion bounds are calculated as follows:
        lower: the maximum of all lower inclusion bounds
        upper: the minimum of all upper inclusion bounds

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
          inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
                       exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and wil be rejected
        ==== vales here are allowed and will be accepted
        """

    @abc.abstractmethod
    def SetPowerActive(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.SetPowerActiveParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sets the active power output of a component with a given ID, provided the
        component supports it.

        Note that the target component may have a resolution of more than 1 W.
        E.g., an inverter may have a resolution of 88 W.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Sends the discharge command to the inverter, making it deliver
         AC power.
        """

    @abc.abstractmethod
    def SetPowerReactive(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.SetPowerReactiveParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sets the reactive power output of a component with a given ID, provided the
        component supports it.

        Note that the target component may have a resolution of more than 1 VAr.
        E.g., an inverter may have a resolution of 88 VAr.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.
        """

    @abc.abstractmethod
    def Start(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Starts the component, and brings it into a state where it is immediately
        operational.

        Performs the following sequence of actions for the following component
        categories:

        * Inverter:
         * closes DC relays, if the feature is available
         * closes AC relays
         * sets power output to 0

        * Battery: Checks if DC relays are open, then
         * closes DC relays

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """

    @abc.abstractmethod
    def HotStandby(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sets the given component into a hot-standby state, from which it can return
        into an operational state within at most 5 seconds.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Checks if AC and DC relays are closed, then
         * sets power to 0

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.
        """

    @abc.abstractmethod
    def ColdStandby(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sets the given component into a cold-standby state, from which it can
        return into an operational state within at most 2 minutes.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Checks if AC and DC relays are closed, then
         * sets power to 0, and
         * opens AC relays

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call efffectively skips that action.
        """

    @abc.abstractmethod
    def Stop(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Stops the component completely, potentially disengaging its power
        electronics controller(s).

        Performs the following sequence actions for the following component
        categories:

        * Inverter:
         * Brings component to the cold-standby state
         * opens DC relays

        * Battery: Checks if the power output is 0, then
         * opens DC relays

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """

    @abc.abstractmethod
    def ErrorAck(
        self,
        request: frequenz.api.microgrid.microgrid_pb2.ComponentIdParam,
        context: _ServicerContext,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Acknowledges any recoverable error reported by the component, and brings it
        back to the stopped or cold-standby state.
        """

def add_MicrogridServicer_to_server(servicer: MicrogridServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
