<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PETLS: petls::Complex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PETLS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepetls.html">petls</a></li><li class="navelem"><a class="el" href="classpetls_1_1Complex.html">Complex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classpetls_1_1Complex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">petls::Complex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Complex_8hpp_source.html">Complex.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for petls::Complex:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpetls_1_1Complex.png" usemap="#petls::Complex_map" alt=""/>
  <map id="petls::Complex_map" name="petls::Complex_map">
<area href="classpetls_1_1Alpha.html" alt="petls::Alpha" shape="rect" coords="0,56,92,80"/>
<area href="classpetls_1_1Rips.html" alt="petls::Rips" shape="rect" coords="102,56,194,80"/>
<area href="classpetls_1_1dFlag.html" alt="petls::dFlag" shape="rect" coords="204,56,296,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8cd116efeb41c775846c29a7c09fa5e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a8cd116efeb41c775846c29a7c09fa5e3">Complex</a> ()</td></tr>
<tr class="separator:a8cd116efeb41c775846c29a7c09fa5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c3d07024b1b2b2843ea4f146fc9b18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ab2c3d07024b1b2b2843ea4f146fc9b18">Complex</a> (std::vector&lt; Eigen::SparseMatrix&lt; storage &gt;&gt; boundaries, std::vector&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt; filtrations)</td></tr>
<tr class="separator:ab2c3d07024b1b2b2843ea4f146fc9b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62336bf763bdbf09a50eb8acac8e807"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#aa62336bf763bdbf09a50eb8acac8e807">~Complex</a> ()</td></tr>
<tr class="separator:aa62336bf763bdbf09a50eb8acac8e807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a65ad47047f0f4703a15f42fcb2c8a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a4a65ad47047f0f4703a15f42fcb2c8a4">set_eigs_algorithm_func</a> (std::function&lt; <a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>(<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt; _eigs_algorithm_func)</td></tr>
<tr class="separator:a4a65ad47047f0f4703a15f42fcb2c8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace6ce7f6d9d9728754e010410c60cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a1ace6ce7f6d9d9728754e010410c60cc">set_eigs_algorithm_func</a> (std::string name)</td></tr>
<tr class="separator:a1ace6ce7f6d9d9728754e010410c60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678471235fe014fb3db216e50114f880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a678471235fe014fb3db216e50114f880">set_up_algorithm_func</a> (std::function&lt; void(<a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt; int &gt; *, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt; _up_algorithm_func)</td></tr>
<tr class="separator:a678471235fe014fb3db216e50114f880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee6e39d415176902ccfa9ce2205e30b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a6ee6e39d415176902ccfa9ce2205e30b">set_up_algorithm_func</a> (std::string name)</td></tr>
<tr class="separator:a6ee6e39d415176902ccfa9ce2205e30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dc94300ae8ff357c2e73a19977d9f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ad3dc94300ae8ff357c2e73a19977d9f6">set_boundaries_filtrations</a> (std::vector&lt; Eigen::SparseMatrix&lt; storage &gt;&gt; boundaries, std::vector&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt; filtrations)</td></tr>
<tr class="separator:ad3dc94300ae8ff357c2e73a19977d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81608e40257ce40d6ccb2a8fb064ed8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a81608e40257ce40d6ccb2a8fb064ed8b">set_verbose</a> (bool <a class="el" href="classpetls_1_1Complex.html#a784b891bd9bf1c68ad22d942d8d8245c">verbose</a>)</td></tr>
<tr class="separator:a81608e40257ce40d6ccb2a8fb064ed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aa6d47f79701aa182e1f551203b0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ab1aa6d47f79701aa182e1f551203b0bb">set_flipped</a> (bool <a class="el" href="classpetls_1_1Complex.html#acf05fc10d73f8dc5e9a2a1d50a9cd480">use_flipped</a>)</td></tr>
<tr class="separator:ab1aa6d47f79701aa182e1f551203b0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761ea93d4220dfced3b59e04767e6c9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a761ea93d4220dfced3b59e04767e6c9e">get_L</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;L)</td></tr>
<tr class="separator:a761ea93d4220dfced3b59e04767e6c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2484c3864671287d5518793dcff6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a6cc2484c3864671287d5518793dcff6c">get_L</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b)</td></tr>
<tr class="separator:a6cc2484c3864671287d5518793dcff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfffc8a1b210c8f650e660bb202a9dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#adfffc8a1b210c8f650e660bb202a9dc9">get_L_top_dim_flipped</a> (<a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a> &amp;L)</td></tr>
<tr class="separator:adfffc8a1b210c8f650e660bb202a9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa257917af744abb7a94a7713a05c4f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#aa257917af744abb7a94a7713a05c4f8c">get_L_top_dim_flipped</a> (<a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a)</td></tr>
<tr class="separator:aa257917af744abb7a94a7713a05c4f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791969d5e1a55e0db1bd381257062494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a791969d5e1a55e0db1bd381257062494">get_up</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;L_up)</td></tr>
<tr class="separator:a791969d5e1a55e0db1bd381257062494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e79d7991ce0602bc02997bafb584b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a49e79d7991ce0602bc02997bafb584b6">get_up</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b)</td></tr>
<tr class="separator:a49e79d7991ce0602bc02997bafb584b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b882abcabbfb35073eb33f7be9d30e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a2b882abcabbfb35073eb33f7be9d30e9">get_down</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, Eigen::SparseMatrix&lt; storage &gt; &amp;L_down)</td></tr>
<tr class="separator:a2b882abcabbfb35073eb33f7be9d30e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94f36cfa806dc9df9a2f4fef203f1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ac94f36cfa806dc9df9a2f4fef203f1d9">get_down</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a)</td></tr>
<tr class="separator:ac94f36cfa806dc9df9a2f4fef203f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75852f8c18c3496d67261f841cd31607"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a75852f8c18c3496d67261f841cd31607">nonzero_spectra</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b, <a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a> PH_basis, bool use_dummy_harmonic_basis)</td></tr>
<tr class="separator:a75852f8c18c3496d67261f841cd31607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573eb40a05d28db6271ec74615fb6a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#aa573eb40a05d28db6271ec74615fb6a6">spectra</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b)</td></tr>
<tr class="separator:aa573eb40a05d28db6271ec74615fb6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90c3fed6769bf36fd6c88465459cefd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ae90c3fed6769bf36fd6c88465459cefd">spectra</a> ()</td></tr>
<tr class="separator:ae90c3fed6769bf36fd6c88465459cefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ae478fd15f6f3ff59bc7c3862f832b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ac8ae478fd15f6f3ff59bc7c3862f832b">spectra</a> (std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt; spectra_request_list)</td></tr>
<tr class="separator:ac8ae478fd15f6f3ff59bc7c3862f832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073913eac9aeabe8b9063523e1c1e1e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a073913eac9aeabe8b9063523e1c1e1e4">spectra_allpairs</a> ()</td></tr>
<tr class="separator:a073913eac9aeabe8b9063523e1c1e1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac131d729c705f46ff3e16458335c7001"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ac131d729c705f46ff3e16458335c7001">eigenpairs</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b)</td></tr>
<tr class="separator:ac131d729c705f46ff3e16458335c7001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbea1a9ca32af5cc235e2dd1c28d872"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#acdbea1a9ca32af5cc235e2dd1c28d872">eigenpairs</a> ()</td></tr>
<tr class="separator:acdbea1a9ca32af5cc235e2dd1c28d872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460d3368941c911624f99a24d741f19"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a7460d3368941c911624f99a24d741f19">eigenpairs</a> (std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt; spectra_request_list)</td></tr>
<tr class="separator:a7460d3368941c911624f99a24d741f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ac144149db98b2245c13e95c23d12e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ae3ac144149db98b2245c13e95c23d12e">eigenvalues_summarize</a> (std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; eigenvalues)</td></tr>
<tr class="separator:ae3ac144149db98b2245c13e95c23d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3c7f99170a02f218012c2b2348dc6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a8c3c7f99170a02f218012c2b2348dc6c">store_L</a> (int dim, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> a, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> b, std::string filename)</td></tr>
<tr class="separator:a8c3c7f99170a02f218012c2b2348dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901288242ec9f4d6db57074755e0a942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a901288242ec9f4d6db57074755e0a942">print_boundaries</a> ()</td></tr>
<tr class="separator:a901288242ec9f4d6db57074755e0a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f24c27efcf718465238d3bb1586046c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a8f24c27efcf718465238d3bb1586046c">store_spectra</a> (std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&gt;&gt; <a class="el" href="classpetls_1_1Complex.html#aa573eb40a05d28db6271ec74615fb6a6">spectra</a>, std::string out_prefix)</td></tr>
<tr class="separator:a8f24c27efcf718465238d3bb1586046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e321056e2ede5b46164f1240ac0e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#acd5e321056e2ede5b46164f1240ac0e4">store_spectra_summary</a> (std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&gt;&gt; <a class="el" href="classpetls_1_1Complex.html#aa573eb40a05d28db6271ec74615fb6a6">spectra</a>, std::string out_prefix)</td></tr>
<tr class="separator:acd5e321056e2ede5b46164f1240ac0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca94422983a0ca1e2f7083f0d7466fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a5ca94422983a0ca1e2f7083f0d7466fe">time_to_csv</a> (std::string filename)</td></tr>
<tr class="separator:a5ca94422983a0ca1e2f7083f0d7466fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6e6a833a87173157c02391d13af78b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a9e6e6a833a87173157c02391d13af78b">filtration_list_to_spectra_request</a> (std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; filtrations, std::vector&lt; int &gt; dims)</td></tr>
<tr class="separator:a9e6e6a833a87173157c02391d13af78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8de6f9bffcf4efc584855bd25982752"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#ae8de6f9bffcf4efc584855bd25982752">filtration_list_to_spectra_request_allpairs</a> (std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; filtrations, std::vector&lt; int &gt; dims)</td></tr>
<tr class="separator:ae8de6f9bffcf4efc584855bd25982752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fce0a1ba9de451b677012c289aa3e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a30fce0a1ba9de451b677012c289aa3e9">get_all_filtrations</a> ()</td></tr>
<tr class="separator:a30fce0a1ba9de451b677012c289aa3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a51b323c84f7c4944c796e88538c28824"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a51b323c84f7c4944c796e88538c28824">top_dim</a></td></tr>
<tr class="memdesc:a51b323c84f7c4944c796e88538c28824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top dimension of the complex.  <a href="classpetls_1_1Complex.html#a51b323c84f7c4944c796e88538c28824">More...</a><br /></td></tr>
<tr class="separator:a51b323c84f7c4944c796e88538c28824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8eab257d6e54edc37e910921176060"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt; storage &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a0c8eab257d6e54edc37e910921176060">filtered_boundaries</a></td></tr>
<tr class="memdesc:a0c8eab257d6e54edc37e910921176060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boundary matrix assuming real (or integer) coefficients.  <a href="classpetls_1_1Complex.html#a0c8eab257d6e54edc37e910921176060">More...</a><br /></td></tr>
<tr class="separator:a0c8eab257d6e54edc37e910921176060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b891bd9bf1c68ad22d942d8d8245c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a784b891bd9bf1c68ad22d942d8d8245c">verbose</a></td></tr>
<tr class="memdesc:a784b891bd9bf1c68ad22d942d8d8245c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print progress if <a class="el" href="classpetls_1_1Complex.html#ae90c3fed6769bf36fd6c88465459cefd">spectra()</a> is called.  <a href="classpetls_1_1Complex.html#a784b891bd9bf1c68ad22d942d8d8245c">More...</a><br /></td></tr>
<tr class="separator:a784b891bd9bf1c68ad22d942d8d8245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf05fc10d73f8dc5e9a2a1d50a9cd480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#acf05fc10d73f8dc5e9a2a1d50a9cd480">use_flipped</a></td></tr>
<tr class="memdesc:acf05fc10d73f8dc5e9a2a1d50a9cd480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the top-dimensional Laplacian's eigenvalues in spectra function via the eigenvalues of the smaller of B_N B_N^T or B_N^T B_N and possible zero-padding.  <a href="classpetls_1_1Complex.html#acf05fc10d73f8dc5e9a2a1d50a9cd480">More...</a><br /></td></tr>
<tr class="separator:acf05fc10d73f8dc5e9a2a1d50a9cd480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b4983ae83f6978bd2a851cdddf89e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpetls_1_1Profile.html">Profile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a09b4983ae83f6978bd2a851cdddf89e6">profile</a></td></tr>
<tr class="memdesc:a09b4983ae83f6978bd2a851cdddf89e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiler to track time usage of various steps.  <a href="classpetls_1_1Complex.html#a09b4983ae83f6978bd2a851cdddf89e6">More...</a><br /></td></tr>
<tr class="separator:a09b4983ae83f6978bd2a851cdddf89e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8409d2c6aa6af1f987987a96000a508"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>(<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#af8409d2c6aa6af1f987987a96000a508">eigs_algorithm_func</a></td></tr>
<tr class="separator:af8409d2c6aa6af1f987987a96000a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619425ac85e02a7bcde6d2309adc9dfb"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::pair&lt; <a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt;<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a619425ac85e02a7bcde6d2309adc9dfb">eigenpairs_algorithm_func</a></td></tr>
<tr class="separator:a619425ac85e02a7bcde6d2309adc9dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aa83f406df56a1f06343eb1fc86084"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt; storage &gt; *, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#a06aa83f406df56a1f06343eb1fc86084">up_algorithm_func</a></td></tr>
<tr class="separator:a06aa83f406df56a1f06343eb1fc86084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af9c9116f42876d80cc78e5662f979bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">petls::FilteredBoundaryMatrix</a>&lt; storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpetls_1_1Complex.html#af9c9116f42876d80cc78e5662f979bfc">dummy_d0</a> ()</td></tr>
<tr class="separator:af9c9116f42876d80cc78e5662f979bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary class for computing persistent Laplacians </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">eigs_Algorithm</td><td>Algorithm wrapper class to use for computing eigenvalues of the Laplacian in the spectra family of functions. Default is a wrapper for Eigen::SelfAdjointEigenSolver. </td></tr>
    <tr><td class="paramname">up_Algorithm</td><td>Algorithm wrapper class to use for computing the up-Laplacian. Default is the Schur complement algorithm presented in Memoli, Wan, and Wang 2020. //TODO: \see up_algorithms and eigs_algorithms </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8cd116efeb41c775846c29a7c09fa5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd116efeb41c775846c29a7c09fa5e3">&#9670;&nbsp;</a></span>Complex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">petls::Complex::Complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor with no boundary maps or simplices. </p>

</div>
</div>
<a id="ab2c3d07024b1b2b2843ea4f146fc9b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c3d07024b1b2b2843ea4f146fc9b18">&#9670;&nbsp;</a></span>Complex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">petls::Complex::Complex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::SparseMatrix&lt; storage &gt;&gt;&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>filtrations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundaries</td><td>a vector of Eigen::SparseMatrix of type int. Boundaries must be sorted in order of dimension. </td></tr>
    <tr><td class="paramname">filtrations</td><td>a vector of vector of filtrations. filtrations[dim] is a list of all filtrations of simplices in dimension dim. filtrations must be sorted in order of dimension, each filtrations[i] must be sorted in order of filtration</td></tr>
  </table>
  </dd>
</dl>
<p>Primary constructor. Important Assumptions: 1) Boundary matrix has real coefficients stored as integers (but not mod 2!) 2) Boundary matrix dimensions agree with filtrations sizes 3) Length(filtrations) = Length(boundaries) + 1 </p>

</div>
</div>
<a id="aa62336bf763bdbf09a50eb8acac8e807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62336bf763bdbf09a50eb8acac8e807">&#9670;&nbsp;</a></span>~Complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">petls::Complex::~Complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9c9116f42876d80cc78e5662f979bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c9116f42876d80cc78e5662f979bfc">&#9670;&nbsp;</a></span>dummy_d0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">petls::FilteredBoundaryMatrix</a>&lt; storage &gt; petls::Complex::dummy_d0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdbea1a9ca32af5cc235e2dd1c28d872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbea1a9ca32af5cc235e2dd1c28d872">&#9670;&nbsp;</a></span>eigenpairs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt; &gt; petls::Complex::eigenpairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all eigenvalues for all combinations of dimension and successive filtration values: a=filtrations[i] and b=filtrations[i+1]. Note: the caller does not know what spectra to expect from this. <br  />
 </p><dl class="section return"><dt>Returns</dt><dd>vector of tuples (dim, a, b, eigenvalues, eigenvectors) where "eigenvalues" is a sorted vector of real, nonnegative eigenvalues and "eigenvectors" is an Eigen::MatrixXf where column i is the eigenvector for eigenvalue i </dd></dl>

</div>
</div>
<a id="ac131d729c705f46ff3e16458335c7001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac131d729c705f46ff3e16458335c7001">&#9670;&nbsp;</a></span>eigenpairs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt; petls::Complex::eigenpairs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Persistent Laplacian's eigenvalues and eigenvectors at a given dimension and filtration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration level </td></tr>
    <tr><td class="paramname">b</td><td>end filtration level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted pair of: vector of real, nonnegative eigenvalues and Eigen matrix where column i is the eigenvector for eigenvalue i </dd></dl>

</div>
</div>
<a id="a7460d3368941c911624f99a24d741f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7460d3368941c911624f99a24d741f19">&#9670;&nbsp;</a></span>eigenpairs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &gt; &gt; petls::Complex::eigenpairs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>spectra_request_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function essentially just calls eigenpairs(dim, a, b) in a loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spectra_quest_list</td><td>vector of tuples (dim, a, b) to compute the eigenvalues of L_{dim}^{a,b}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of tuples (dim, a, b, eigenvalues, eigenvalues), where eigenvalues it istelf a vector of real, nonnegative eigenvalues and "eigenvectors" is an Eigen::MatrixXf where column i is the eigenvector for eigenvalue i. </dd></dl>

</div>
</div>
<a id="ae3ac144149db98b2245c13e95c23d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ac144149db98b2245c13e95c23d12e">&#9670;&nbsp;</a></span>eigenvalues_summarize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; petls::Complex::eigenvalues_summarize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&#160;</td>
          <td class="paramname"><em>eigenvalues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to get the Betti number and least nonzero eigenvalue form a vector of eigenvalues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigenvalues</td><td>eigenvalues </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of (Betti number, least nonzero eigenvalue) </dd></dl>

</div>
</div>
<a id="a9e6e6a833a87173157c02391d13af78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6e6a833a87173157c02391d13af78b">&#9670;&nbsp;</a></span>filtration_list_to_spectra_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; &gt; petls::Complex::filtration_list_to_spectra_request </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&#160;</td>
          <td class="paramname"><em>filtrations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get tuples (dim, a, b) for all combinations of dimension and successive filtration values: a=filtrations[i], b=filtrations[i+1]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filtrations</td><td>vector of filtration values </td></tr>
    <tr><td class="paramname">dims</td><td>vector of dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuples (dim, a, b) for all combinations of dimension and successive filtration values: a=filtrations[i], b=filtrations[i+1]. </dd></dl>

</div>
</div>
<a id="ae8de6f9bffcf4efc584855bd25982752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8de6f9bffcf4efc584855bd25982752">&#9670;&nbsp;</a></span>filtration_list_to_spectra_request_allpairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; &gt; petls::Complex::filtration_list_to_spectra_request_allpairs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&#160;</td>
          <td class="paramname"><em>filtrations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get tuples (dim, a, b) for all combinations of dimension and filtrations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filtrations</td><td>vector of filtration values </td></tr>
    <tr><td class="paramname">dims</td><td>vector of dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuples (dim, a, b) for all combinations of dimension and filtration values. </dd></dl>

</div>
</div>
<a id="a30fce0a1ba9de451b677012c289aa3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fce0a1ba9de451b677012c289aa3e9">&#9670;&nbsp;</a></span>get_all_filtrations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt; petls::Complex::get_all_filtrations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all unique filtration values in the complex. </p>

</div>
</div>
<a id="ac94f36cfa806dc9df9a2f4fef203f1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94f36cfa806dc9df9a2f4fef203f1d9">&#9670;&nbsp;</a></span>get_down() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> petls::Complex::get_down </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the down persistent Laplacian (by value).</p>
<p>Warning: this does a potentially expensive copy. The primary reason this function exists is to provide reasonable python binding access to the matrix itself. If you do not need this matrix directly in python (e.g. you want its eigenvalues) it will be more efficient to compute by reference via <a class="el" href="classpetls_1_1Complex.html#a2b882abcabbfb35073eb33f7be9d30e9">get_down(int dim, filtration_type a, Eigen::SparseMatrix&lt;storage&gt; &amp;L_down)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration value \return The matrix (by value) of the down presistent Laplacian <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b882abcabbfb35073eb33f7be9d30e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b882abcabbfb35073eb33f7be9d30e9">&#9670;&nbsp;</a></span>get_down() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::get_down </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>L_down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the down persistent Laplacian (by reference). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L_down</td><td>the matrix (by reference) of the down presistent Laplacian <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc2484c3864671287d5518793dcff6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2484c3864671287d5518793dcff6c">&#9670;&nbsp;</a></span>get_L() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> petls::Complex::get_L </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Persistent Laplacian Matrix (by value).</p>
<p>Warning: this does a potentially expensive copy. The primary reason this function exists is to provide reasonable python binding access to the matrix L itself. If you do not need the persistent Laplacian matrix directly in python (e.g. you want its eigenvalues) it will be more efficient to compute by reference via <a class="el" href="classpetls_1_1Complex.html#a761ea93d4220dfced3b59e04767e6c9e">get_L(int dim, filtration_type a, filtration_type b, DenseMatrix_PL &amp;L)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramname">b</td><td>end filtration value (must be &gt;= a) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L the persistent Laplacian matrix. </dd></dl>

</div>
</div>
<a id="a761ea93d4220dfced3b59e04767e6c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761ea93d4220dfced3b59e04767e6c9e">&#9670;&nbsp;</a></span>get_L() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::get_L </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Persistent Laplacian Matrix (by reference). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>end filtration value (must be &gt;= a) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>the matrix where the persistent Laplacian will be stored (by reference). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa257917af744abb7a94a7713a05c4f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa257917af744abb7a94a7713a05c4f8c">&#9670;&nbsp;</a></span>get_L_top_dim_flipped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a> petls::Complex::get_L_top_dim_flipped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a matrix with the same nonzero eigenvalues as the top-dimensional Persistent Laplacian Matrix (by value).</p>
<p>Warning: this does a potentially expensive copy. The primary reason this function exists is to provide reasonable python binding access to the matrix itself. If you do not need this matrix directly in python (e.g. you want its eigenvalues) it will be more efficient to compute by reference via <a class="el" href="classpetls_1_1Complex.html#adfffc8a1b210c8f650e660bb202a9dc9">get_L_top_dim_flipped(filtration_type a, SparseMatrix_PL &amp;L)</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>start filtration value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix with the same nonzero eigenvalues as the top-dimensional persistent Laplacian (but not the persistent Laplacian itself). </dd></dl>

</div>
</div>
<a id="adfffc8a1b210c8f650e660bb202a9dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfffc8a1b210c8f650e660bb202a9dc9">&#9670;&nbsp;</a></span>get_L_top_dim_flipped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::get_L_top_dim_flipped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a matrix with the same nonzero eigenvalues as the top-dimensional Persistent Laplacian Matrix (by reference). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>the matrix (by reference) that has the same eigenvalues as the top-dimensional Persistent Laplacian </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49e79d7991ce0602bc02997bafb584b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e79d7991ce0602bc02997bafb584b6">&#9670;&nbsp;</a></span>get_up() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> petls::Complex::get_up </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the up persistent Laplacian (by value). The algorithm used is determined by the template parameter. See <a class="el" href="up__algorithms_8hpp.html">up_algorithms.hpp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramname">b</td><td>end filtration value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>up persistent Laplacian </dd></dl>

</div>
</div>
<a id="a791969d5e1a55e0db1bd381257062494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791969d5e1a55e0db1bd381257062494">&#9670;&nbsp;</a></span>get_up() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::get_up </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;&#160;</td>
          <td class="paramname"><em>L_up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the up persistent Laplacian (by reference). The algorithm used is determined by the template parameter. See <a class="el" href="up__algorithms_8hpp.html">up_algorithms.hpp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>end filtration value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L_up</td><td>up persistent Laplacian (by reference) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75852f8c18c3496d67261f841cd31607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75852f8c18c3496d67261f841cd31607">&#9670;&nbsp;</a></span>nonzero_spectra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; petls::Complex::nonzero_spectra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#aa0b819682f9cdac0ae1234aed46106e6">SparseMatrix_PL</a>&#160;</td>
          <td class="paramname"><em>PH_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_dummy_harmonic_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the nonzero eigenvalues of a persistent Laplacian using Schur restriction with the null space, either given by Persistent Homology representatives or by computing the null space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration level </td></tr>
    <tr><td class="paramname">b</td><td>end filtration level </td></tr>
    <tr><td class="paramname">(optional)</td><td>PH_basis Basis for the null space of the Laplacian, possibly obtained through persistent homology </td></tr>
    <tr><td class="paramname">use_dummy_harmonic_basis</td><td>Compute the null space of the Laplacian here, then do the same projected as if we had been given the null space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted vector of real, positive eigenvalues </dd></dl>

</div>
</div>
<a id="a901288242ec9f4d6db57074755e0a942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901288242ec9f4d6db57074755e0a942">&#9670;&nbsp;</a></span>print_boundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::print_boundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all boundaries and corresponding filtrations. </p>

</div>
</div>
<a id="ad3dc94300ae8ff357c2e73a19977d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dc94300ae8ff357c2e73a19977d9f6">&#9670;&nbsp;</a></span>set_boundaries_filtrations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_boundaries_filtrations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::SparseMatrix&lt; storage &gt;&gt;&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>filtrations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundaries and filtrations of a complex, particularly if the default constructor was called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundaries</td><td>a vector of Eigen::SparseMatrix of type int. Boundaries must be sorted in order of dimension. </td></tr>
    <tr><td class="paramname">filtrations</td><td>a vector of vector of filtrations. filtrations[dim] is a list of all filtrations of simplices in dimension dim. filtrations must be sorted in order of dimension, each filtrations[i] must be sorted in order of filtration. Important Assumptions: 1) Boundary matrix has real coefficients stored as integers (but not mod 2!), 2) Boundary matrix dimensions agree with filtrations sizes, 3) Length(filtrations) = Length(boundaries) + 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a65ad47047f0f4703a15f42fcb2c8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a65ad47047f0f4703a15f42fcb2c8a4">&#9670;&nbsp;</a></span>set_eigs_algorithm_func() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_eigs_algorithm_func </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>(<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>_eigs_algorithm_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ace6ce7f6d9d9728754e010410c60cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace6ce7f6d9d9728754e010410c60cc">&#9670;&nbsp;</a></span>set_eigs_algorithm_func() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_eigs_algorithm_func </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1aa6d47f79701aa182e1f551203b0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1aa6d47f79701aa182e1f551203b0bb">&#9670;&nbsp;</a></span>set_flipped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_flipped </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_flipped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set flipped </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_flipped</td><td>New setting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a678471235fe014fb3db216e50114f880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678471235fe014fb3db216e50114f880">&#9670;&nbsp;</a></span>set_up_algorithm_func() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_up_algorithm_func </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt; int &gt; *, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>_up_algorithm_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ee6e39d415176902ccfa9ce2205e30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee6e39d415176902ccfa9ce2205e30b">&#9670;&nbsp;</a></span>set_up_algorithm_func() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_up_algorithm_func </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81608e40257ce40d6ccb2a8fb064ed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81608e40257ce40d6ccb2a8fb064ed8b">&#9670;&nbsp;</a></span>set_verbose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::set_verbose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set verbose </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>New setting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90c3fed6769bf36fd6c88465459cefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90c3fed6769bf36fd6c88465459cefd">&#9670;&nbsp;</a></span>spectra() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt; petls::Complex::spectra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all eigenvalues for all combinations of dimension and successive filtration values: a=filtrations[i] and b=filtrations[i+1]. Note: the caller does not know what spectra to expect from this. <br  />
 </p><dl class="section return"><dt>Returns</dt><dd>vector of tuples (dim, a, b, eigenvalues) where "eigenvalues" is a sorted vector of real, nonnegative eigenvalues. <br  />
 </dd></dl>

</div>
</div>
<a id="aa573eb40a05d28db6271ec74615fb6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa573eb40a05d28db6271ec74615fb6a6">&#9670;&nbsp;</a></span>spectra() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; petls::Complex::spectra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Persistent Laplacian's eigenvalues at a given dimension and filtration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration level </td></tr>
    <tr><td class="paramname">b</td><td>end filtration level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted vector of real, nonnegative eigenvalues </dd></dl>

</div>
</div>
<a id="ac8ae478fd15f6f3ff59bc7c3862f832b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ae478fd15f6f3ff59bc7c3862f832b">&#9670;&nbsp;</a></span>spectra() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt; petls::Complex::spectra </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>spectra_request_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function essentially just calls spectra(dim, a, b) in a loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spectra_quest_list</td><td>vector of tuples (dim, a, b) to compute the eigenvalues of L_{dim}^{a,b}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of tuples (dim, a, b, eigenvalues), where eigenvalues it istelf a vector of real, nonnegative eigenvalues. </dd></dl>

</div>
</div>
<a id="a073913eac9aeabe8b9063523e1c1e1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073913eac9aeabe8b9063523e1c1e1e4">&#9670;&nbsp;</a></span>spectra_allpairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt; &gt; &gt; petls::Complex::spectra_allpairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all eigenvalues for all combinations of dimension and filtration values. Note: the caller does not know what spectra to expect from this. <br  />
 </p><dl class="section return"><dt>Returns</dt><dd>vector of tuples (dim, a, b, eigenvalues) where "eigenvalues" is a sorted vector of real, nonnegative eigenvalues. <br  />
 </dd></dl>

</div>
</div>
<a id="a8c3c7f99170a02f218012c2b2348dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3c7f99170a02f218012c2b2348dc6c">&#9670;&nbsp;</a></span>store_L()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::store_L </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and store a persistent Laplacian matrix in a file in matrix market format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>dimension </td></tr>
    <tr><td class="paramname">a</td><td>start filtration value </td></tr>
    <tr><td class="paramname">b</td><td>end filtration value </td></tr>
    <tr><td class="paramname">filename</td><td>file to store matrix (typically .mtx extension) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f24c27efcf718465238d3bb1586046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f24c27efcf718465238d3bb1586046c">&#9670;&nbsp;</a></span>store_spectra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::store_spectra </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>spectra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>out_prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write spectra to files.</p>
<p>for each dimension dim of the complex, files write "{out_prefix}_spectra_{dim}.txt". Each line of the file is a space-separated list of eigenvalues. Lines may be empty. Note the filtration values are not reported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spectra</td><td>tuples (dim, a, b, eigenvalues) </td></tr>
    <tr><td class="paramname">out_prefix</td><td>Eigenvalues will be written to "{out_prefix}_spectra_{dim}.txt" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd5e321056e2ede5b46164f1240ac0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5e321056e2ede5b46164f1240ac0e4">&#9670;&nbsp;</a></span>store_spectra_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::store_spectra_summary </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; int, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, std::vector&lt; <a class="el" href="typedefs_8hpp.html#ac240cc0d46f103fa1a410237a0b8853f">spectra_type</a> &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>spectra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>out_prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write spectra summary to files "{out_prefix}_spectra_summary.txt"</p>
<p>Each line is a space-separated list of filtrations, bettti numbers, and least nonzero eigenvalues: (filtration a) (filtration b) (betti 0) ... (betti top_dim) (lambda 0) ... (lambda top_dim) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spectra</td><td>tuples (dim, a, b, eigenvalues) </td></tr>
    <tr><td class="paramname">out_prefix</td><td>Eigenvalues will be written to "{out_prefix}_spectra_summary.txt" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca94422983a0ca1e2f7083f0d7466fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca94422983a0ca1e2f7083f0d7466fe">&#9670;&nbsp;</a></span>time_to_csv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void petls::Complex::time_to_csv </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the profile to a csv file. This is done automatically when <a class="el" href="classpetls_1_1Complex.html#ae90c3fed6769bf36fd6c88465459cefd">spectra()</a> is called, but it can also be done here.BDCSVDEigen </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a619425ac85e02a7bcde6d2309adc9dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619425ac85e02a7bcde6d2309adc9dfb">&#9670;&nbsp;</a></span>eigenpairs_algorithm_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::pair&lt;<a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>,<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&gt;<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&amp;)&gt; petls::Complex::eigenpairs_algorithm_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8409d2c6aa6af1f987987a96000a508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8409d2c6aa6af1f987987a96000a508">&#9670;&nbsp;</a></span>eigs_algorithm_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="typedefs_8hpp.html#a27a64e317582fd2a2dbdc95fa84b7ebd">spectra_vec</a>(<a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&amp;)&gt; petls::Complex::eigs_algorithm_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c8eab257d6e54edc37e910921176060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8eab257d6e54edc37e910921176060">&#9670;&nbsp;</a></span>filtered_boundaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt;storage&gt; &gt; petls::Complex::filtered_boundaries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boundary matrix assuming real (or integer) coefficients. </p>

</div>
</div>
<a id="a09b4983ae83f6978bd2a851cdddf89e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b4983ae83f6978bd2a851cdddf89e6">&#9670;&nbsp;</a></span>profile</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpetls_1_1Profile.html">Profile</a> petls::Complex::profile</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Profiler to track time usage of various steps. </p>

</div>
</div>
<a id="a51b323c84f7c4944c796e88538c28824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b323c84f7c4944c796e88538c28824">&#9670;&nbsp;</a></span>top_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int petls::Complex::top_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Top dimension of the complex. </p>

</div>
</div>
<a id="a06aa83f406df56a1f06343eb1fc86084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06aa83f406df56a1f06343eb1fc86084">&#9670;&nbsp;</a></span>up_algorithm_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="classpetls_1_1FilteredBoundaryMatrix.html">FilteredBoundaryMatrix</a>&lt;storage&gt;*, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#afc86493f3736a9d186d249149b2e5e22">filtration_type</a>, <a class="el" href="typedefs_8hpp.html#a260197b742c38462952d018c69ff535a">DenseMatrix_PL</a>&amp;)&gt; petls::Complex::up_algorithm_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf05fc10d73f8dc5e9a2a1d50a9cd480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf05fc10d73f8dc5e9a2a1d50a9cd480">&#9670;&nbsp;</a></span>use_flipped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool petls::Complex::use_flipped</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the top-dimensional Laplacian's eigenvalues in spectra function via the eigenvalues of the smaller of B_N B_N^T or B_N^T B_N and possible zero-padding. </p>

</div>
</div>
<a id="a784b891bd9bf1c68ad22d942d8d8245c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b891bd9bf1c68ad22d942d8d8245c">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool petls::Complex::verbose</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print progress if <a class="el" href="classpetls_1_1Complex.html#ae90c3fed6769bf36fd6c88465459cefd">spectra()</a> is called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/jones657/PersistentLaplacians/cpp/include/petls_headers/core/<a class="el" href="Complex_8hpp_source.html">Complex.hpp</a></li>
<li>/home/jones657/PersistentLaplacians/cpp/src/core/<a class="el" href="Complex_8cpp.html">Complex.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
