import textwrap
from abc import abstractmethod
from collections import OrderedDict
from collections.abc import Iterable
from enum import Enum
from typing import Optional, Union, Callable

import relationalai.early_access.builder as qb
from relationalai.early_access.builder import define, where, annotations, not_
from relationalai.early_access.builder.builder import Not
from relationalai.early_access.dsl.bindings.common import Binding, BindableAttribute, IdentifierConceptBinding, \
    SubtypeConceptBinding, BindableTable, _PrimitiveType, FilterBy, ReferentConceptBinding, _get_transform_types, \
    BindableColumn
from relationalai.early_access.dsl.codegen.helpers import reference_entity, construct_entity
from relationalai.early_access.dsl.orm.constraints import Unique
from relationalai.early_access.dsl.orm.relationships import Role
from relationalai.early_access.rel.rel_utils import DECIMAL64_SCALE, DECIMAL128_SCALE


def _get_map_madlib_and_name(name_prefix: str, value_concept: qb.Concept) -> tuple[str, str]:
    """
    Generates a name for the map based on the value concept.
    """
    name = f'{name_prefix}_row_to_{value_concept}'
    madlib = f'{name} {{row_id:RowId}} {{val:{value_concept}}}'
    return madlib, name


class GeneratedRelation(qb.Relationship):
    """
    A class representing a relation generated from a model.
    """
    def __init__(self, madlib, model, name):
        super().__init__(madlib, model=model.qb_model(), short_name=name)

    def __repr__(self):
        return f'GeneratedRelation({self._name})'


class InternallyGeneratedRelation(GeneratedRelation):
    """
    A class representing a relation generated by analyzing the model.
    """
    def __init__(self, madlib, dsl_model, name):
        super().__init__(madlib, dsl_model, name)


def _filtering_view(row, filter_by: Optional[FilterBy], column_ref=None):
    """
    Generates filtering atoms for the map if the binding has any filters, which must be simple
    filters on the attribute view of the same table.
    """
    if not filter_by:
        return where()
    if isinstance(filter_by, _PrimitiveType):
        assert column_ref is not None, 'Attribute must be provided if filter_by is a PrimitiveFilterBy'
        atoms = [_primitive_filtering_atom(column_ref, filter_by)]
    elif isinstance(filter_by, qb.Expression):
        atoms = [_expr_filtering_atom(row, filter_by)]
    elif isinstance(filter_by, Iterable):
        atoms = [_expr_filtering_atom(row, filter_expr) for filter_expr in filter_by]
    elif isinstance(filter_by, Not):
        # trivial negation is supported, either on a single column or a trivial expression
        atoms = [_negation_atom(row, filter_by)]
    else:
        raise TypeError(f'Expected a PrimitiveFilterBy, Expression, or Iterable of Expressions, got {type(filter_by)}')
    return where(*atoms)

def _primitive_filtering_atom(column_ref, condition: _PrimitiveType):
    """
    Generates a filtering atom for the map based on a primitive filter.
    """
    if isinstance(condition, Enum):
        condition = condition.name
    return where(
        column_ref == condition
    )

def _expr_from_filter(row, condition: Union[BindableColumn, qb.Expression]):
    """
    Generates a filtering atom for the map based on a condition.
    """
    if isinstance(condition, qb.Expression):
        return _expr_filtering_atom(row, condition)
    elif isinstance(condition, BindableColumn):
        return _column_filtering_atom(row, condition)
    else:
        raise TypeError(f'Expected an Expression or a BindableColumn, got {type(condition)}')

def _expr_filtering_atom(row, condition: qb.Expression):
    params = condition._params
    if len(params) != 2:
        raise ValueError(f'Expected a condition with two parameters, got {len(params)}: {condition}')
    column, value = params
    if isinstance(value, Enum):
        value = value.name
    orig = column.type().ref()
    return where(
        column(row, orig),
        qb.Expression(condition._op, orig, value)
    )

def _column_filtering_atom(row, column: BindableColumn):
    """
    Defines an expression which could be used to express `exists(val: column(row, val))` for a given column.
    """
    orig = column.type().ref()
    return where(
        column(row, orig)
    )

def _negation_atom(row, condition: Not):
    """
    Generates a negation atom based on the filter: either a column or a trivial expression.
    """
    conditions = condition._args
    return where(
        not_(
            *[_expr_from_filter(row, condition) for condition in conditions]
        )
    )


class AbstractMap(GeneratedRelation):
    """
    A class representing an abstract map.
    """
    def __init__(self, madlib, dsl_model, name):
        super().__init__(madlib, dsl_model, name)

    def row_ref(self):
        assert len(self._field_refs) == 2, 'AbstractMap must have exactly two field references'
        row_ref = self._field_refs[0]
        assert row_ref._thing._name == 'RowId', 'First field must be of type RowId'
        return row_ref

class RoleMap(AbstractMap):
    """
    A class representing a base role map relation.
    """

    def __init__(self, madlib, model, name, role, functional: bool = False):
        super().__init__(madlib, model, name)
        self._role = role

    def role(self):
        """
        Returns the role of the role map.
        """
        return self._role

    def value_player(self):
        """
        Returns the value player of the role map.
        """
        return self._role.player()

    @abstractmethod
    def column(self) -> BindableAttribute:
        """
        Returns the bindable column associated with this role map.
        """
        raise NotImplementedError("Subclasses must implement this method")

    def table(self) -> BindableTable:
        """
        Returns the table associated with the role map.
        """
        return self.column().table

    def __repr__(self):
        return f'RoleMap({self._name})'


class InlineValueMap:
    """
    A non-QB relationship class that represents an inline value map.
    """
    def __init__(self, model, binding: Binding, role, value_converter: Optional['ValueConverter']=None):
        self._binding = binding
        self._role = role
        self._value_converter = value_converter
        self._value_player = role.player()
        self._initialize()

    def _initialize(self):
        role = self._role
        if not role.player()._is_primitive():
            raise TypeError(f'Cannot construct a value map for {role}, concept is not a value type')

        table_name = self._binding.column.table.physical_name()
        concept = role.player()
        _, self._name = _get_map_madlib_and_name(table_name, concept)
        self._has_transforms = self._value_converter or self._binding.transform_with

    def __call__(self, *args, **kwargs):
        """
        Returns a QB expression that can be used in a query.
        """
        # assert that len(args) is 2, as we expect row and value variables
        if len(args) != 2:
            raise ValueError(f'Expected 2 arguments, got {len(args)}: {args}')

        row_ref, rez_val_ref = args
        _, body_atoms = self.construct_body_formula(row_ref, rez_val_ref)
        return where(*body_atoms)

    def construct_body_formula(self, row_ref, rez_val_ref):
        """
        Constructs the body formula for the value map.
        This is used to generate the head and the body of the relation.
        """
        col_val_ref = self.column().type().ref() if self._has_transforms else rez_val_ref
        filter_atoms = _filtering_view(row_ref, self._binding.filter_by, col_val_ref)
        return self._construct_body_atoms(row_ref, col_val_ref, rez_val_ref, filter_atoms)

    def _construct_body_atoms(self, row_ref, col_val_ref, rez_val_ref, filter_atoms):
        result_type = self.value_player()
        if self._has_transforms:
            transform_atoms = self._generate_transform_body(col_val_ref, rez_val_ref)
            return [row_ref, result_type(rez_val_ref)], [
                where(
                    self._binding.column(row_ref, col_val_ref),
                    transform_atoms,
                    filter_atoms
                )]
        else:
            # col_val_ref and rez_val_ref are the same handles here
            return [row_ref, result_type(col_val_ref)], [
                self._binding.column(row_ref, col_val_ref),
                filter_atoms,
            ]

    def _generate_transform_body(self, col_val_ref, rez_val_ref):
        converter = self._value_converter
        transformations = self._binding.transform_with
        if transformations:
            transformations = (transformations,) if not isinstance(transformations, tuple) else transformations

        if converter and not transformations:
            return converter(col_val_ref, rez_val_ref)
        elif transformations and not converter:
            return self._chain_transformations(col_val_ref, rez_val_ref, transformations)
        elif converter and transformations:
            conv_val_ref = converter.result_type().ref()
            transform_atoms = self._chain_transformations(conv_val_ref, rez_val_ref, transformations)
            return where(
                converter(col_val_ref, conv_val_ref),
                transform_atoms
            )
        raise ValueError("Incorrect state, cannot apply binding transformations with empty value converter(s)")

    def _chain_transformations(self, input_val_ref, output_val_ref, transformations):
        if len(transformations) == 1:
            return self._apply_transformations(input_val_ref, output_val_ref, transformations[0])
        intermediate_vars = [self._get_transform_output_type(tr) for tr in transformations[:-1]]
        all_vars = [input_val_ref, *intermediate_vars, output_val_ref]
        return where(
            *[self._apply_transformations(all_vars[idx], all_vars[idx+1], tr)
              for idx, tr in enumerate(transformations)]
        )

    @staticmethod
    def _get_transform_output_type(transformer):
        _, output_type = _get_transform_types(transformer)
        return output_type

    @staticmethod
    def _apply_transformations(input_var, output_var, transformer):
        if isinstance(transformer, qb.Relationship):
            return transformer(input_var, output_var)
        elif isinstance(transformer, Callable):
            return output_var == transformer(input_var)
        else:
            raise TypeError(f'Expected a Relationship or Callable, got {type(transformer)}')

    def value_player(self):
        """
        Returns the value player of the inline value map.
        """
        return self._value_player

    def column(self) -> BindableAttribute:
        """
        Returns the bindable column associated with this inline value map.
        """
        return self._binding.column

    def binding(self) -> Binding:
        """
        Returns the binding of the value map.
        """
        return self._binding

    def __repr__(self):
        return f'@inline ValueMap({self._name})'


class ValueMap(RoleMap):
    """
    A class representing a value map relation.
    """

    def __init__(self, model, binding: Binding, role, value_converter: Optional['ValueConverter']=None):
        # =
        # Skip QB relationship initialization if *inline* is True, as __call__ will return a QB expression
        # =
        madlib, name = self._handle_params(binding, role)
        super().__init__(madlib, model, name, role)
        self._binding = binding
        self._value_converter = value_converter
        self._inline_value_map = InlineValueMap(model, binding, role, value_converter)
        self._generate_body()

    @staticmethod
    def _handle_params(binding, role):
        if not role.player()._is_primitive():
            raise TypeError(f'Cannot construct a value map for {role}, concept is not a value type')

        table_name = binding.column.table.physical_name()
        concept = role.player()
        return _get_map_madlib_and_name(table_name, concept)

    def _generate_body(self):
        row_ref = self.row_ref()
        has_transforms = self._value_converter or self._binding.transform_with
        rez_val_ref = self.value_player().ref() if has_transforms else self.column().type().ref()

        head_vars, body_atoms = self._inline_value_map.construct_body_formula(row_ref, rez_val_ref)

        define(self(*head_vars)).where(*body_atoms)

    def column(self) -> BindableAttribute:
        return self._binding.column

    def binding(self) -> Binding:
        """
        Returns the binding of the value map.
        """
        return self._binding

    def __repr__(self):
        return f'ValueMap({self._name})'


class SimpleConstructorEntityMap(RoleMap):
    """
    A class representing an entity map relation.
    """

    def __init__(self, model, binding: Binding, role: Role, identifier_to_role_map: OrderedDict[Unique, 'RoleMap']):
        madlib, name = self._handle_params(binding, role)
        super().__init__(madlib, model, name, role)
        self._binding = binding
        self._identifier_to_role_map = identifier_to_role_map
        self._reference_role_map = list(identifier_to_role_map.items())[-1][1]  # last role map is the reference one
        self._generate_body()

    @staticmethod
    def _handle_params(binding, role):
        if role.player()._is_primitive():
            raise TypeError(f'Cannot construct an entity map for {role}, concept is not an entity type')

        table_name = binding.column.table.physical_name()
        concept = role.player()
        return _get_map_madlib_and_name(table_name, concept)

    def _generate_body(self):
        concept = self.role().player()

        row = self.row_ref()
        if not self._should_reference():
            # then create entities
            role_maps = self._identifier_to_role_map.values()
            values = [role_map.value_player().ref() for role_map in role_maps]
            where(
                *[role_map(row, value) for role_map, value in zip(role_maps, values)]
            ).define(construct_entity(concept, *values))

        # and populate the entity map, role_map is always the last one in the identifier_to_role_map
        value = self._reference_role_map.value_player().ref()
        where(
            self._reference_role_map(row, value), entity := reference_entity(concept, value),
            self._concept_population_atom(entity)
        ).define(self(row, entity))

    def _concept_population_atom(self, entity):
        """
        Generates the *optional* population atom for the entity map.
        Only used for bindings that have a FK.
        """
        if self._should_reference():
            return where(
                self.role().player()(entity)
            )
        else:
            return where()

    def _should_reference(self) -> bool:
        return self._reference_role_map.column().references_column is not None

    def binding(self) -> Binding:
        """
        Returns the binding of the entity map.
        """
        return self._binding

    def column(self) -> BindableAttribute:
        """
        Returns the bindable column associated with this entity map.
        """
        return self._binding.column

    def __repr__(self):
        return f'CtorEntityMap({self._name})'


class ReferentEntityMap(RoleMap):
    """
    A class representing a referent entity map relation.
    """

    def __init__(self, model, binding: Binding, role: Role, constructing_role_map: Union['InlineValueMap', 'RoleMap']):
        madlib, name = self._handle_params(binding, role)
        super().__init__(madlib, model, name, role)
        self._binding = binding
        self._constructing_role_map = constructing_role_map
        self._generate_body()

    @staticmethod
    def _handle_params(binding, role):
        if role.player()._is_primitive():
            raise TypeError(f'Cannot construct an entity map for {role}, concept is not an entity type')

        table_name = binding.column.table.physical_name()
        concept = role.player()
        return _get_map_madlib_and_name(f'{table_name}_ref', concept)

    def _generate_body(self):
        concept = self.role().player()

        row, value = self.row_ref(), self._constructing_role_map.value_player().ref()
        where(
            self._constructing_role_map(row, value),
            entity := reference_entity(concept, value),
            concept(entity)
        ).define(self(row, entity))

    def binding(self) -> Binding:
        """
        Returns the binding of the entity map.
        """
        return self._binding

    def column(self) -> BindableAttribute:
        """
        Returns the bindable column associated with this entity map.
        """
        return self._binding.column

    def __repr__(self):
        return f'ReferentEntityMap({self._name})'

class CompositeEntityMap(AbstractMap):
    """
    A class representing a composite entity map relation.

    Takes a sequence of EntityMaps and constructs a composite entity type.
    """

    def __init__(self, model, entity_concept: qb.Concept, *role_maps: 'Map'):
        madlib, name = self._handle_params(entity_concept, *role_maps)
        super().__init__(madlib, model, name)
        self._entity_concept = entity_concept
        self._role_maps = role_maps
        self._generate_body()

    def _handle_params(self, entity_concept: qb.Concept, *role_maps: 'Map'):
        if entity_concept._is_primitive():
            raise TypeError(f'Cannot construct a composite entity map for {entity_concept},'
                            f' concept is not an entity type')
        if len(role_maps) < 2:
            raise ValueError('CompositeEntityMap requires at least two EntityMaps')

        role_map = role_maps[0]
        table = role_map.binding().column.table
        self._table = table
        return _get_map_madlib_and_name(table.physical_name(), entity_concept)

    def _generate_body(self):
        row = self.row_ref()
        vars = [role_map.value_player().ref() for role_map in self._role_maps]

        # construct entities
        where(
            self._body_formula(row, *vars),
            entity := construct_entity(self._entity_concept, *vars),
        ).define(entity)

        # populate the entity map
        where(
            self._body_formula(row, *vars),
            entity := reference_entity(self._entity_concept, *vars),
            #
        ).define(self(row, entity))

    def _body_formula(self, row, *vars):
        return where(
            *[role_map(row, var) for role_map, var in zip(self._role_maps, vars)],
        )

    def value_player(self):
        """
        Returns the value player of the composite entity map.
        """
        return self._entity_concept

    def table(self):
        """
        Returns the table associated with the composite entity map.
        """
        return self._table

    def __repr__(self):
        return f'CompositeEntityMap({self._name})'


AbstractEntityMap = Union['SimpleConstructorEntityMap', 'ReferentEntityMap', 'CompositeEntityMap', 'UnionEntityMap']
Map = Union['ValueMap', 'InlineValueMap', 'EntitySubtypeMap', 'AbstractEntityMap']

class EntitySubtypeMap(AbstractMap):
    """
    A class representing an entity subtype map relation.
    """

    def __init__(self, model, binding: Union[IdentifierConceptBinding, SubtypeConceptBinding, ReferentConceptBinding],
                 ctor_entity_map: 'AbstractEntityMap'):
        # type of the entity subtype map is the parent type coming from the ctor_entity_map
        madlib, name = self._handle_params(binding, ctor_entity_map.value_player())
        super().__init__(madlib, model, name)
        self._binding = binding
        self._ctor_entity_map = ctor_entity_map
        self._generate_body()

    @staticmethod
    def _handle_params(binding: Union[IdentifierConceptBinding, SubtypeConceptBinding, ReferentConceptBinding],
                       result_concept: qb.Concept):
        table = binding.column.table
        entity_concept = binding.entity_type
        # check that the entity concept is a subtype of the result concept
        assert entity_concept._isa(result_concept), f"Entity concept {entity_concept} must be a subtype of result concept {result_concept}"
        name = f'{table.physical_name()}_row_to_{entity_concept}'
        madlib = f'{name} {{row_id:RowId}} {{val:{result_concept}}}'
        return madlib, name

    def _generate_body(self):
        subtype = self._binding.entity_type
        row, parent_entity = self.row_ref(), self._ctor_entity_map.value_player().ref()

        # derive subtype population
        self._generate_body_formula(row, parent_entity).define(subtype(parent_entity))

        # populate the entity subtype map
        self._generate_body_formula(row, parent_entity).define(self(row, parent_entity))

    def _generate_body_formula(self, row, parent_entity):
        filtering_atom = _filtering_view(row, self._binding.filter_by)
        return where(
            self._ctor_entity_map(row, parent_entity),
            filtering_atom
        )

    def _should_reference(self) -> bool:
        return self._role_map.column().references_column is not None

    def binding(self):
        """
        Returns the binding of the entity subtype map.
        """
        return self._binding

    def value_player(self):
        """
        Returns the subtype of the entity subtype map.
        """
        return self._binding.entity_type

    def column(self) -> BindableAttribute:
        """
        Returns the bindable column associated with this entity subtype map.
        """
        return self._binding.column

    def table(self) -> BindableTable:
        """
        Returns the table associated with the entity subtype map.
        """
        return self._binding.column.table

    def __repr__(self):
        return f'EntitySubtypeMap({self._name})'


class UnionEntityMap(AbstractMap):
    """
    A class representing a union entity map relation.
    """

    def __init__(self, model, entity_concept: qb.Concept, *entity_maps: AbstractEntityMap, generate_population: bool=False):
        madlib, name = self._handle_params(entity_concept, *entity_maps)
        super().__init__(madlib, model, name)
        self._entity_type = entity_concept
        self._entity_maps = list(entity_maps)
        self._generate_population = generate_population
        self._generate_body()

    def _handle_params(self, entity_concept: qb.Concept, *entity_maps: AbstractEntityMap):
        if len(entity_maps) == 0:
            raise ValueError('UnionEntityMap requires at least one EntityMap')
        # pick an arbitrary entity map to get the table, as they must all have the same
        table = entity_maps[0].table()
        self._table = table
        return _get_map_madlib_and_name(table.physical_name(), entity_concept)

    def _generate_body(self):
        for entity_map in self._entity_maps:
            self._generate_body_rule(entity_map)

    def _generate_body_rule(self, entity_map: AbstractEntityMap):
        row, entity = self.row_ref(), entity_map.value_player().ref()

        if self._generate_population:
            # derive type population
            where(
                entity_map(row, entity)
            ).define(self._entity_type(entity))

        # derive union entity map
        where(
            entity_map(row, entity)
        ).define(self(row, entity))

    def value_player(self):
        """
        Returns the type of the entity map.
        """
        return self._entity_type

    def table(self):
        """
        Returns the table associated with the entity map.
        """
        return self._table

    def update(self, entity_map: AbstractEntityMap):
        """
        Updates the union entity map with a new entity map.
        """
        if entity_map._id in [existing._id for existing in self._entity_maps]:
            return
        self._entity_maps.append(entity_map)
        self._generate_body_rule(entity_map)

    def __repr__(self):
        return f'UnionEntityMap({self._name})'


class ValueConverter(InternallyGeneratedRelation):
    """
    Base class for value converter relations.
    """
    def __init__(self, madlib, dsl_model, name):
        super().__init__(madlib, dsl_model, name)
        self.annotate(annotations.external)

    @abstractmethod
    def result_type(self) -> qb.Concept:
        pass

# Note: this conversion is only needed until CDC standardizes on the scale and size of the Decimal type.

class DecimalValueConverter(ValueConverter):
    """
    A class representing a decimal value converter relation.
    """

    def __init__(self, model, size_from: int, scale_from: int, type_to: qb.Concept):
        madlib, name = self._generate_madlib_and_name(size_from, scale_from, type_to)
        super().__init__(madlib, model, name)
        self._validate(type_to)
        self._size_from = size_from
        self._scale_from = scale_from
        self._type_to = type_to
        self._size_to = 64 if type_to is qb.Decimal64 else 128
        self._scale_to = DECIMAL64_SCALE if type_to is qb.Decimal64 else DECIMAL128_SCALE
        self._generate_body()

    @staticmethod
    def _validate(type_to):
        if type_to is not qb.Decimal64 and type_to is not qb.Decimal128:
            raise TypeError(f'Expected Decimal64 or Decimal128, got {type_to}')

    def result_type(self) -> qb.Concept:
        return self._type_to

    @staticmethod
    def _generate_madlib_and_name(size_from: int, scale_from: int, type_to: qb.Concept):
        name = f'value_converter_{type_to}_from_{size_from}_{scale_from}'
        madlib = f'{name} {{Decimal{size_from}}} {{{type_to}}}'
        return madlib, name

    def _generate_body(self):
        src = textwrap.dedent(f"""
        @inline
        def {self._name}(orig, rez):
            exists((t_size, t_scale, size, scale, int_val) |
                ^FixedDecimal(t_size, t_scale, int_val, orig) and
                ::std::mirror::lower(t_size, size) and
                ::std::mirror::lower(t_scale, scale) and
                decimal({self._size_to}, {self._scale_to}, int_val / (10 ^ scale), rez)
            )""")
        assert self._model is not None, "Model must be defined before defining a relation"
        self._model.define(qb.RawSource('rel', src))

    def __repr__(self):
        return f'DecimalValueConverter({self._name})'
