/**********************************************************************************
 * Copyright (c) 2021 Process Systems Engineering (AVT.SVT), RWTH Aachen University
 *
 * MAiNGO and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * @file problem_gams.h.h
 *
 * @brief This file has been automatically generated by the MAiNGO Reader Writer
 *        utility.
 *
 **********************************************************************************/

#pragma once

#include "MAiNGOmodel.h"


using Var = mc::FFVar;    // This allows us to write Var instead of mc::FFVar


/**
* @class Model
* @brief Class defining the actual model to be solved by MAiNGO 
*/
class Model_st_e27: public maingo::MAiNGOmodel {

    public:
        /**
        * @brief Default constructor 
        */
        Model_st_e27();

        /**
        * @brief Main function used to evaluate the model and construct a directed acyclic graph
        *
        * @param[in] optVars is the optimization variables vector
        */  
        maingo::EvaluationContainer evaluate(const std::vector<Var> &optVars);

        /**
        * @brief Function for getting optimization variables data
        */
        std::vector<maingo::OptimizationVariable> get_variables();

        /**
        * @brief Function for getting initial point data
        */
        std::vector<double> get_initial_point();

    private:
};


//////////////////////////////////////////////////////////////////////////
// function for providing optimization variable data to the Branch-and-Bound solver
std::vector<maingo::OptimizationVariable>
Model_st_e27::get_variables()
{

    std::vector<maingo::OptimizationVariable> variables;
    // Required: Define optimization variables by specifying lower bound, upper bound (, optionally variable type, branching priority and a name)
    // Continuous variables
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0,6), maingo::VT_CONTINUOUS, "x3"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0,5), maingo::VT_CONTINUOUS, "x4"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(-1000000000000,1000000000000), maingo::VT_CONTINUOUS, "objvar"));
    // Binary variables
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0,1), maingo::VT_BINARY, "b1"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0,1), maingo::VT_BINARY, "b2"));
    // Integer variables

    return variables;
}


//////////////////////////////////////////////////////////////////////////
// function for providing initial point data to the Branch-and-Bound solver
std::vector<double>
Model_st_e27::get_initial_point()
{

    // Here you can provide an initial point for the local search
    std::vector<double> initialPoint;
    // Continuous variables
    initialPoint.push_back(0);
    initialPoint.push_back(0);
    initialPoint.push_back(-1000000000000);
    // Binary variables
    initialPoint.push_back(0);
    initialPoint.push_back(0);
    // Integer variables

    return initialPoint;
}


//////////////////////////////////////////////////////////////////////////
// constructor for the model
Model_st_e27::Model_st_e27()
{

    // Initialize data if necessary:

}


//////////////////////////////////////////////////////////////////////////
// Evaluate the model
maingo::EvaluationContainer
Model_st_e27::evaluate(const std::vector<Var> &optVars)
{

    maingo::EvaluationContainer result; /*!< Variable holding the actual result consisting of an objective, inequalities, equalities, relaxation only inequalities and relaxation only equalities */

    // Rename  inputs
    // Continuous variables
    unsigned int cVar = 0;
    Var x3 = optVars[cVar]; cVar++;
    Var x4 = optVars[cVar]; cVar++;
    Var objvar = optVars[cVar]; cVar++;
    // Binary variables
    unsigned int bVar = cVar;
    Var b1 = optVars[bVar]; bVar++;
    Var b2 = optVars[bVar]; bVar++;
    // Integer variables
    unsigned int iVar = bVar;

    // Objective function
    #ifndef HAVE_GROWING_DATASETS
        result.objective = 2 - sqr(x3) + 4 * x3 - sqr(x4) + 2 * x4 + 2 * b1 + 2 * b2;
    #else
        result.objective_per_data.push_back(2 - sqr(x3) + 4 * x3 - sqr(x4) + 2 * x4 + 2 * b1 + 2 * b2);
    #endif


    // Inequalities (<=0)
    result.ineq.push_back( -x3 + 3 * x4  - ( 5 ), "e1" );
    result.ineq.push_back( 2 * x3 - x4  - ( 5 ), "e2" );
    result.ineq.push_back( -2 * x3 + x4 , "e3" );
    result.ineq.push_back( x3 - 3 * x4 , "e4" );
    result.ineq.push_back( -6 * b1 + x3 , "e5" );
    result.ineq.push_back( -5 * b2 + x4 , "e6" );

    // Equalities (=0)

    // Relaxation only inequalities (<=0):

    // Relaxation only equalities (=0):

    return result;
}
