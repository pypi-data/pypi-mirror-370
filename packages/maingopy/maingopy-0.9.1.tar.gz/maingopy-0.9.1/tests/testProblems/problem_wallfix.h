/**********************************************************************************
 * Copyright (c) 2021 Process Systems Engineering (AVT.SVT), RWTH Aachen University
 *
 * MAiNGO and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * @file problem_gams.h.h
 *
 * @brief This file has been automatically generated by the MAiNGO Reader Writer
 *        utility.
 *
 **********************************************************************************/

#pragma once

#include "MAiNGOmodel.h"


using Var = mc::FFVar;    // This allows us to write Var instead of mc::FFVar


/**
* @class Model
* @brief Class defining the actual model to be solved by MAiNGO 
*/
class Model_wallfix: public maingo::MAiNGOmodel {

    public:
        /**
        * @brief Default constructor 
        */
        Model_wallfix();

        /**
        * @brief Main function used to evaluate the model and construct a directed acyclic graph
        *
        * @param[in] optVars is the optimization variables vector
        */  
        maingo::EvaluationContainer evaluate(const std::vector<Var> &optVars);

        /**
        * @brief Function for getting optimization variables data
        */
        std::vector<maingo::OptimizationVariable> get_variables();

        /**
        * @brief Function for getting initial point data
        */
        std::vector<double> get_initial_point();

    private:
};


//////////////////////////////////////////////////////////////////////////
// function for providing optimization variable data to the Branch-and-Bound solver
std::vector<maingo::OptimizationVariable>
Model_wallfix::get_variables()
{

    std::vector<maingo::OptimizationVariable> variables;
    // Required: Define optimization variables by specifying lower bound, upper bound (, optionally variable type, branching priority and a name)
    // Continuous variables
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(-10000000000,10000000000), maingo::VT_CONTINUOUS, "objvar"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0.1,10000000000), maingo::VT_CONTINUOUS, "x2"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0.1,10000000000), maingo::VT_CONTINUOUS, "x3"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0.1,10000000000), maingo::VT_CONTINUOUS, "x4"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0.1,10000000000), maingo::VT_CONTINUOUS, "x5"));
    variables.push_back(maingo::OptimizationVariable(maingo::Bounds(0.1,10000000000), maingo::VT_CONTINUOUS, "x6"));
    // Binary variables
    // Integer variables

    return variables;
}


//////////////////////////////////////////////////////////////////////////
// function for providing initial point data to the Branch-and-Bound solver
std::vector<double>
Model_wallfix::get_initial_point()
{

    // Here you can provide an initial point for the local search
    std::vector<double> initialPoint;
    // Continuous variables
    initialPoint.push_back(1);
    initialPoint.push_back(1);
    initialPoint.push_back(1);
    initialPoint.push_back(1);
    initialPoint.push_back(1);
    initialPoint.push_back(1);
    // Binary variables
    // Integer variables

    return initialPoint;
}


//////////////////////////////////////////////////////////////////////////
// constructor for the model
Model_wallfix::Model_wallfix()
{

    // Initialize data if necessary:

}


//////////////////////////////////////////////////////////////////////////
// Evaluate the model
maingo::EvaluationContainer
Model_wallfix::evaluate(const std::vector<Var> &optVars)
{

   // Rename  inputs
    // Continuous variables
    Var objvar = optVars[0];
    Var x2 = optVars[1];
    Var x3 = optVars[2];
    Var x4 = optVars[3];
    Var x5 = optVars[4];
    Var x6 = optVars[5];
    // Binary variables
    // Integer variables
    maingo::EvaluationContainer result; /*!< variable holding the actual result consisting of an objective, inequalities, equalities, relaxation only inequalities and relaxation only equalities */
  
    // Objective function 
    #ifndef HAVE_GROWING_DATASETS
        result.objective = objvar;
    #else
        result.objective_per_data.push_back(objvar);
    #endif

    // Inequalities (<=0)

    // Equalities (=0)
    result.eq.push_back( objvar * x2  - ( 1 ), "e1" );
    result.eq.push_back( x3 / (pos(x4 * objvar))  - ( 4.8 ), "e2" );
    result.eq.push_back( x5 / (pos(x6 * x2))  - ( 0.98 ), "e3" );
    result.eq.push_back( x6 * x4  - ( 1 ), "e4" );
    result.eq.push_back( objvar - x2 + 1e-07 * x3 - 1e-05 * x5 , "e5" );
    result.eq.push_back( 2 * objvar - 2 * x2 + 1e-07 * x3 - 0.01 * x4 - 1e-05 * x5 + 0.01 * x6 , "e6" );

    // Relaxation only inequalities (<=0):

    // Relaxation only equalities (=0):

    return result;
}
