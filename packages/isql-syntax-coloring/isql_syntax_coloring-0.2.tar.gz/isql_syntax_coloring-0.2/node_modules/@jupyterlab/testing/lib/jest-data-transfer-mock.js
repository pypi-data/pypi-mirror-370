"use strict";
/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTransferMock = void 0;
class FileSystemEntryMock {
    constructor(options) {
        this.isFile = false;
        this.isDirectory = false;
        this.name = options.name;
    }
    getParent() {
        throw Error('Not implemented in the mock');
    }
    get filesystem() {
        throw Error('Not implemented in the mock');
    }
    get fullPath() {
        throw Error('Not implemented in the mock');
    }
}
class FileSystemDirectoryEntryMock extends FileSystemEntryMock {
    constructor(options) {
        super(options);
        this.isFile = false;
        this.isDirectory = true;
        this._files = options.files.map(spec => 'file' in spec
            ? new FileSystemFileEntryMock(spec)
            : new FileSystemDirectoryEntryMock(spec));
    }
    createReader() {
        return new FileSystemDirectoryReaderMock(this._files);
    }
    getDirectory() {
        throw Error('Not implemented in the mock');
    }
    getFile() {
        throw Error('Not implemented in the mock');
    }
}
class FileSystemFileEntryMock extends FileSystemEntryMock {
    constructor(options) {
        super(options);
        this.isFile = true;
        this.isDirectory = false;
        this._file = new File(options.file.bits, options.name);
    }
    file(successCallback) {
        successCallback(this._file);
    }
}
class FileSystemDirectoryReaderMock {
    constructor(_files) {
        this._files = _files;
        this._step = 2;
        this._index = 0;
    }
    readEntries(successCallback) {
        successCallback(this._files.slice(this._index, Math.min(this._files.length, this._index + this._step)));
        this._index += this._step;
    }
}
// https://github.com/jsdom/jsdom/issues/2913
class DataTransferItemMock {
    constructor(type, value) {
        this.type = type;
        this.value = value;
        this.kind = ['file', 'directory'].includes(type) ? type : 'string';
    }
    getAsString(callback) {
        callback(this.value);
    }
    getAsFile() {
        return null;
    }
    webkitGetAsEntry() {
        if (this.kind === 'directory') {
            return new FileSystemDirectoryEntryMock(JSON.parse(this.value));
        }
        else if (this.kind === 'file') {
            return new FileSystemFileEntryMock(JSON.parse(this.value));
        }
        return null;
    }
}
// https://github.com/jsdom/jsdom/issues/2913
class DataTransferMock {
    constructor() {
        this.dropEffect = 'none';
        this.effectAllowed = 'none';
        this.types = [];
        this._data = {};
    }
    get items() {
        return [
            ...Object.entries(this._data).map(([k, v]) => new DataTransferItemMock(k, v))
        ];
    }
    getData(format) {
        return this._data[format];
    }
    setData(format, data) {
        this._data[format] = data;
    }
    clearData() {
        this._data = {};
    }
    setDragImage(imgElement, xOffset, yOffset) {
        // no-op
    }
}
exports.DataTransferMock = DataTransferMock;
//# sourceMappingURL=jest-data-transfer-mock.js.map