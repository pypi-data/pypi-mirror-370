# coding: utf-8

"""
    Aron API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from vessl.openapi_client.api_client import ApiClient
from vessl.openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class APIV1Api(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def account_set_default_organiztion_api(self, **kwargs):  # noqa: E501
        """account_set_default_organiztion_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.account_set_default_organiztion_api(async_req=True)
        >>> result = thread.get()

        :param account_set_default_organiztion_api_input:
        :type account_set_default_organiztion_api_input: AccountSetDefaultOrganiztionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.account_set_default_organiztion_api_with_http_info(**kwargs)  # noqa: E501

    def account_set_default_organiztion_api_with_http_info(self, **kwargs):  # noqa: E501
        """account_set_default_organiztion_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.account_set_default_organiztion_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param account_set_default_organiztion_api_input:
        :type account_set_default_organiztion_api_input: AccountSetDefaultOrganiztionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'account_set_default_organiztion_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method account_set_default_organiztion_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'account_set_default_organiztion_api_input' in local_var_params:
            body_params = local_var_params['account_set_default_organiztion_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/default_organization', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def add_git_ssh_key_api(self, **kwargs):  # noqa: E501
        """add_git_ssh_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_git_ssh_key_api(async_req=True)
        >>> result = thread.get()

        :param add_git_ssh_key_api_input:
        :type add_git_ssh_key_api_input: AddGitSSHKeyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.add_git_ssh_key_api_with_http_info(**kwargs)  # noqa: E501

    def add_git_ssh_key_api_with_http_info(self, **kwargs):  # noqa: E501
        """add_git_ssh_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.add_git_ssh_key_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param add_git_ssh_key_api_input:
        :type add_git_ssh_key_api_input: AddGitSSHKeyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'add_git_ssh_key_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_git_ssh_key_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_git_ssh_key_api_input' in local_var_params:
            body_params = local_var_params['add_git_ssh_key_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/git_ssh_keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def artifact_create_artifact_locator_api(self, artifact_id, organization_name, project_name, **kwargs):  # noqa: E501
        """artifact_create_artifact_locator_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.artifact_create_artifact_locator_api(artifact_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param artifact_create_artifact_locator_api_input:
        :type artifact_create_artifact_locator_api_input: ArtifactCreateArtifactLocatorAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactArtifactCreateArtifactLocatorResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.artifact_create_artifact_locator_api_with_http_info(artifact_id, organization_name, project_name, **kwargs)  # noqa: E501

    def artifact_create_artifact_locator_api_with_http_info(self, artifact_id, organization_name, project_name, **kwargs):  # noqa: E501
        """artifact_create_artifact_locator_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.artifact_create_artifact_locator_api_with_http_info(artifact_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param artifact_create_artifact_locator_api_input:
        :type artifact_create_artifact_locator_api_input: ArtifactCreateArtifactLocatorAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactArtifactCreateArtifactLocatorResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'artifact_id',
            'organization_name',
            'project_name',
            'artifact_create_artifact_locator_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method artifact_create_artifact_locator_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'artifact_id' is set
        if self.api_client.client_side_validation and local_var_params.get('artifact_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `artifact_id` when calling `artifact_create_artifact_locator_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `artifact_create_artifact_locator_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `artifact_create_artifact_locator_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'artifact_id' in local_var_params:
            path_params['artifactID'] = local_var_params['artifact_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'artifact_create_artifact_locator_api_input' in local_var_params:
            body_params = local_var_params['artifact_create_artifact_locator_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ArtifactArtifactCreateArtifactLocatorResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/artifacts/{artifactID}/locator', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def auto_top_up_config_update_api(self, organization_name, **kwargs):  # noqa: E501
        """auto_top_up_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auto_top_up_config_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param auto_top_up_config_update_api_input:
        :type auto_top_up_config_update_api_input: AutoTopUpConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.auto_top_up_config_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def auto_top_up_config_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """auto_top_up_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.auto_top_up_config_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param auto_top_up_config_update_api_input:
        :type auto_top_up_config_update_api_input: AutoTopUpConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'auto_top_up_config_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auto_top_up_config_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `auto_top_up_config_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auto_top_up_config_update_api_input' in local_var_params:
            body_params = local_var_params['auto_top_up_config_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/auto_top_up_config_update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def bit_bucket_authorize_api(self, **kwargs):  # noqa: E501
        """bit_bucket_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bit_bucket_authorize_api(async_req=True)
        >>> result = thread.get()

        :param bit_bucket_authorize_api_input:
        :type bit_bucket_authorize_api_input: BitBucketAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.bit_bucket_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def bit_bucket_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """bit_bucket_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bit_bucket_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param bit_bucket_authorize_api_input:
        :type bit_bucket_authorize_api_input: BitBucketAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'bit_bucket_authorize_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bit_bucket_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bit_bucket_authorize_api_input' in local_var_params:
            body_params = local_var_params['bit_bucket_authorize_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/bitbucket/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def bit_bucket_config_api(self, **kwargs):  # noqa: E501
        """bit_bucket_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bit_bucket_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalBitBucketConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.bit_bucket_config_api_with_http_info(**kwargs)  # noqa: E501

    def bit_bucket_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """bit_bucket_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bit_bucket_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalBitBucketConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bit_bucket_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalBitBucketConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/bitbucket/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def change_password_api(self, **kwargs):  # noqa: E501
        """change_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_password_api(async_req=True)
        >>> result = thread.get()

        :param change_password_api_input:
        :type change_password_api_input: ChangePasswordAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_api_with_http_info(**kwargs)  # noqa: E501

    def change_password_api_with_http_info(self, **kwargs):  # noqa: E501
        """change_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.change_password_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param change_password_api_input:
        :type change_password_api_input: ChangePasswordAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'change_password_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_api_input' in local_var_params:
            body_params = local_var_params['change_password_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/change_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cli_experiment_freeze_dataset_version_api(self, dataset_id, experiment_id, **kwargs):  # noqa: E501
        """cli_experiment_freeze_dataset_version_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_experiment_freeze_dataset_version_api(dataset_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param experiment_id: (required)
        :type experiment_id: int
        :param cli_experiment_freeze_dataset_version_api_input:
        :type cli_experiment_freeze_dataset_version_api_input: CliExperimentFreezeDatasetVersionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.cli_experiment_freeze_dataset_version_api_with_http_info(dataset_id, experiment_id, **kwargs)  # noqa: E501

    def cli_experiment_freeze_dataset_version_api_with_http_info(self, dataset_id, experiment_id, **kwargs):  # noqa: E501
        """cli_experiment_freeze_dataset_version_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_experiment_freeze_dataset_version_api_with_http_info(dataset_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param experiment_id: (required)
        :type experiment_id: int
        :param cli_experiment_freeze_dataset_version_api_input:
        :type cli_experiment_freeze_dataset_version_api_input: CliExperimentFreezeDatasetVersionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'experiment_id',
            'cli_experiment_freeze_dataset_version_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cli_experiment_freeze_dataset_version_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `cli_experiment_freeze_dataset_version_api`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `cli_experiment_freeze_dataset_version_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cli_experiment_freeze_dataset_version_api_input' in local_var_params:
            body_params = local_var_params['cli_experiment_freeze_dataset_version_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}/datasets/{datasetID}/freeze', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cli_workspace_backup_create_api(self, workspace_id, **kwargs):  # noqa: E501
        """cli_workspace_backup_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_workspace_backup_create_api(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param cli_workspace_backup_create_api_input:
        :type cli_workspace_backup_create_api_input: CliWorkspaceBackupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceBackup
        """
        kwargs['_return_http_data_only'] = True
        return self.cli_workspace_backup_create_api_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def cli_workspace_backup_create_api_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """cli_workspace_backup_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cli_workspace_backup_create_api_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param cli_workspace_backup_create_api_input:
        :type cli_workspace_backup_create_api_input: CliWorkspaceBackupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceBackup, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_id',
            'cli_workspace_backup_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cli_workspace_backup_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `cli_workspace_backup_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cli_workspace_backup_create_api_input' in local_var_params:
            body_params = local_var_params['cli_workspace_backup_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceBackup",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceID}/backup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_access_delete_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_delete_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_access_delete_api_input:
        :type cluster_access_delete_api_input: ClusterAccessDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_access_delete_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_access_delete_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_delete_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_access_delete_api_input:
        :type cluster_access_delete_api_input: ClusterAccessDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_access_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_access_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_access_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_access_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_access_delete_api_input' in local_var_params:
            body_params = local_var_params['cluster_access_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/access_delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_access_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterAccessListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_access_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_access_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterAccessListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_access_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_access_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_access_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterAccessListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/access', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_access_upsert_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_upsert_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_access_upsert_api_input:
        :type cluster_access_upsert_api_input: ClusterAccessUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_access_upsert_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_access_upsert_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_access_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_access_upsert_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_access_upsert_api_input:
        :type cluster_access_upsert_api_input: ClusterAccessUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_access_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_access_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_access_upsert_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_access_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_access_upsert_api_input' in local_var_params:
            body_params = local_var_params['cluster_access_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/access_upsert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_cert_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_cert_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_cert_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterCertListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_cert_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_cert_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_cert_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_cert_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterCertListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_cert_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_cert_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_cert_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterCertListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/cert', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_cert_upload_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_cert_upload_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_cert_upload_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_cert_upload_api_input:
        :type cluster_cert_upload_api_input: ClusterCertUploadAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_cert_upload_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_cert_upload_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_cert_upload_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_cert_upload_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_cert_upload_api_input:
        :type cluster_cert_upload_api_input: ClusterCertUploadAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_cert_upload_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_cert_upload_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_cert_upload_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_cert_upload_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_cert_upload_api_input' in local_var_params:
            body_params = local_var_params['cluster_cert_upload_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/cert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_custom_endpoint_config_read_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_custom_endpoint_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_custom_endpoint_config_read_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseClusterCustomEndpointConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_custom_endpoint_config_read_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_custom_endpoint_config_read_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_custom_endpoint_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_custom_endpoint_config_read_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseClusterCustomEndpointConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_custom_endpoint_config_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_custom_endpoint_config_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_custom_endpoint_config_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseClusterCustomEndpointConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/custom_endpoint_config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_custom_endpoint_config_update_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_custom_endpoint_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_custom_endpoint_config_update_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_custom_endpoint_config_update_api_input:
        :type cluster_custom_endpoint_config_update_api_input: ClusterCustomEndpointConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseClusterCustomEndpointConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_custom_endpoint_config_update_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_custom_endpoint_config_update_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_custom_endpoint_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_custom_endpoint_config_update_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_custom_endpoint_config_update_api_input:
        :type cluster_custom_endpoint_config_update_api_input: ClusterCustomEndpointConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseClusterCustomEndpointConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_custom_endpoint_config_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_custom_endpoint_config_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_custom_endpoint_config_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_custom_endpoint_config_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_custom_endpoint_config_update_api_input' in local_var_params:
            body_params = local_var_params['cluster_custom_endpoint_config_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseClusterCustomEndpointConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/custom_endpoint_config', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_delegate_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_delegate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_delegate_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_delegate_api_input:
        :type cluster_delegate_api_input: ClusterDelegateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_delegate_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_delegate_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_delegate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_delegate_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_delegate_api_input:
        :type cluster_delegate_api_input: ClusterDelegateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_delegate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_delegate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_delegate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_delegate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_delegate_api_input' in local_var_params:
            body_params = local_var_params['cluster_delegate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/delegate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_delete_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_delete_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_delete_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_delete_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_delete_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_event_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_event_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_event_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterEventListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_event_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_event_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_event_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_event_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterEventListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_event_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_event_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_event_list_api`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 30:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `cluster_event_list_api`, must be a value less than or equal to `30`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterEventListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_ingress_class_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_ingress_class_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_ingress_class_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param custom_endpoint_type:
        :type custom_endpoint_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterIngressClassListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_ingress_class_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_ingress_class_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_ingress_class_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_ingress_class_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param custom_endpoint_type:
        :type custom_endpoint_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterIngressClassListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'custom_endpoint_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_ingress_class_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_ingress_class_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_ingress_class_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('custom_endpoint_type') is not None:  # noqa: E501
            query_params.append(('custom_endpoint_type', local_var_params['custom_endpoint_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterIngressClassListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/ingress_classes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_list_api(self, organization_name, **kwargs):  # noqa: E501
        """cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def cluster_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_metrics_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_metrics_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrometheusqueryClusterMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_metrics_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_metrics_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_metrics_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrometheusqueryClusterMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'end',
            'start'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('end') is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if local_var_params.get('start') is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PrometheusqueryClusterMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_metrics_new_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_metrics_new_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_metrics_new_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrometheusqueryNodeMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_metrics_new_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_metrics_new_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_metrics_new_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_metrics_new_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrometheusqueryNodeMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'end',
            'start'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_metrics_new_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_metrics_new_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_metrics_new_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('end') is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if local_var_params.get('start') is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PrometheusqueryNodeMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/metrics_new', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_node_cordon_api(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_cordon_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_cordon_api(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterNodeCordonResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_node_cordon_api_with_http_info(cluster_id, node_id, organization_name, **kwargs)  # noqa: E501

    def cluster_node_cordon_api_with_http_info(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_cordon_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_cordon_api_with_http_info(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterNodeCordonResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'node_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_node_cordon_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_node_cordon_api`")  # noqa: E501
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and local_var_params.get('node_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `cluster_node_cordon_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_node_cordon_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'node_id' in local_var_params:
            path_params['nodeID'] = local_var_params['node_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterNodeCordonResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/nodes/{nodeID}/cordon', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_node_detail_api(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_detail_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_detail_api(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterNodeInfoV2
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_node_detail_api_with_http_info(cluster_id, node_id, organization_name, **kwargs)  # noqa: E501

    def cluster_node_detail_api_with_http_info(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_detail_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_detail_api_with_http_info(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterNodeInfoV2, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'node_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_node_detail_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_node_detail_api`")  # noqa: E501
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and local_var_params.get('node_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `cluster_node_detail_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_node_detail_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'node_id' in local_var_params:
            path_params['nodeID'] = local_var_params['node_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelClusterNodeInfoV2",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/nodes/{nodeID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_node_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cpu:
        :type cpu: float
        :param gpu:
        :type gpu: int
        :param gpu_type:
        :type gpu_type: str
        :param memory:
        :type memory: float
        :param preset_id:
        :type preset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterNodeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_node_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_node_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cpu:
        :type cpu: float
        :param gpu:
        :type gpu: int
        :param gpu_type:
        :type gpu_type: str
        :param memory:
        :type memory: float
        :param preset_id:
        :type preset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterNodeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cpu',
            'gpu',
            'gpu_type',
            'memory',
            'preset_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_node_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_node_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_node_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cpu') is not None:  # noqa: E501
            query_params.append(('cpu', local_var_params['cpu']))  # noqa: E501
        if local_var_params.get('gpu') is not None:  # noqa: E501
            query_params.append(('gpu', local_var_params['gpu']))  # noqa: E501
        if local_var_params.get('gpu_type') is not None:  # noqa: E501
            query_params.append(('gpu_type', local_var_params['gpu_type']))  # noqa: E501
        if local_var_params.get('memory') is not None:  # noqa: E501
            query_params.append(('memory', local_var_params['memory']))  # noqa: E501
        if local_var_params.get('preset_id') is not None:  # noqa: E501
            query_params.append(('preset_id', local_var_params['preset_id']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterNodeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_node_metrics_api(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_metrics_api(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PrometheusqueryNodeMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_node_metrics_api_with_http_info(cluster_id, node_id, organization_name, **kwargs)  # noqa: E501

    def cluster_node_metrics_api_with_http_info(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_metrics_api_with_http_info(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param end:
        :type end: float
        :param start:
        :type start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PrometheusqueryNodeMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'node_id',
            'organization_name',
            'end',
            'start'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_node_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_node_metrics_api`")  # noqa: E501
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and local_var_params.get('node_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `cluster_node_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_node_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'node_id' in local_var_params:
            path_params['nodeID'] = local_var_params['node_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('end') is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if local_var_params.get('start') is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PrometheusqueryNodeMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/nodes/{nodeID}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_node_uncordon_api(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_uncordon_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_uncordon_api(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterNodeUncordonResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_node_uncordon_api_with_http_info(cluster_id, node_id, organization_name, **kwargs)  # noqa: E501

    def cluster_node_uncordon_api_with_http_info(self, cluster_id, node_id, organization_name, **kwargs):  # noqa: E501
        """cluster_node_uncordon_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_node_uncordon_api_with_http_info(cluster_id, node_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param node_id: (required)
        :type node_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterNodeUncordonResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'node_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_node_uncordon_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_node_uncordon_api`")  # noqa: E501
        # verify the required parameter 'node_id' is set
        if self.api_client.client_side_validation and local_var_params.get('node_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `node_id` when calling `cluster_node_uncordon_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_node_uncordon_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'node_id' in local_var_params:
            path_params['nodeID'] = local_var_params['node_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterNodeUncordonResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/nodes/{nodeID}/uncordon', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_quota_delete_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_delete_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_quota_delete_api_input:
        :type cluster_quota_delete_api_input: ClusterQuotaDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_quota_delete_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_quota_delete_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_delete_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_quota_delete_api_input:
        :type cluster_quota_delete_api_input: ClusterQuotaDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_quota_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_quota_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_quota_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_quota_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_quota_delete_api_input' in local_var_params:
            body_params = local_var_params['cluster_quota_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/quotas_delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_quota_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterQuotaListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_quota_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_quota_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterQuotaListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_quota_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_quota_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_quota_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterQuotaListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/quotas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_quota_upsert_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_upsert_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_quota_upsert_api_input:
        :type cluster_quota_upsert_api_input: ClusterQuotaUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_quota_upsert_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_quota_upsert_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_upsert_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_quota_upsert_api_input:
        :type cluster_quota_upsert_api_input: ClusterQuotaUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_quota_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_quota_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_quota_upsert_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_quota_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_quota_upsert_api_input' in local_var_params:
            body_params = local_var_params['cluster_quota_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/quotas_upsert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_quota_usage_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_usage_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_usage_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterQuotaUsageResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_quota_usage_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_quota_usage_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_quota_usage_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_quota_usage_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterQuotaUsageResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_quota_usage_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_quota_usage_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_quota_usage_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterQuotaUsageResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/quotas/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_read_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_read_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfoWithPermission
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_read_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_read_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_read_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfoWithPermission, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelClusterInfoWithPermission",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_update_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_update_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_update_api_input:
        :type cluster_update_api_input: ClusterUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_update_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_update_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_update_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cluster_update_api_input:
        :type cluster_update_api_input: ClusterUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cluster_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'cluster_update_api_input' in local_var_params:
            body_params = local_var_params['cluster_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_usage_report_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_usage_report_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_usage_report_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterUsageReportResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_usage_report_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_usage_report_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_usage_report_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_usage_report_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterUsageReportResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'month',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'year'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_usage_report_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_usage_report_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_usage_report_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('month') is not None:  # noqa: E501
            query_params.append(('month', local_var_params['month']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('year') is not None:  # noqa: E501
            query_params.append(('year', local_var_params['year']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterUsageReportResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/usage_report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_usage_report_raw_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_usage_report_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_usage_report_raw_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_usage_report_raw_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_usage_report_raw_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_usage_report_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_usage_report_raw_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'month',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'year'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_usage_report_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_usage_report_raw_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_usage_report_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('month') is not None:  # noqa: E501
            query_params.append(('month', local_var_params['month']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('year') is not None:  # noqa: E501
            query_params.append(('year', local_var_params['year']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/usage_report/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cluster_workload_list_with_prometheus_metric_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_workload_list_with_prometheus_metric_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_workload_list_with_prometheus_metric_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param fetch_all_workloads:
        :type fetch_all_workloads: bool
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param node_ids:
        :type node_ids: list[int]
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param workload_statuses:
        :type workload_statuses: list[str]
        :param workload_types:
        :type workload_types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterClusterWorkloadListWithPrometheusMetricResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cluster_workload_list_with_prometheus_metric_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def cluster_workload_list_with_prometheus_metric_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """cluster_workload_list_with_prometheus_metric_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cluster_workload_list_with_prometheus_metric_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param fetch_all_workloads:
        :type fetch_all_workloads: bool
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param node_ids:
        :type node_ids: list[int]
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param workload_statuses:
        :type workload_statuses: list[str]
        :param workload_types:
        :type workload_types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterClusterWorkloadListWithPrometheusMetricResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'fetch_all_workloads',
            'keyword',
            'limit',
            'node_ids',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'workload_statuses',
            'workload_types'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cluster_workload_list_with_prometheus_metric_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `cluster_workload_list_with_prometheus_metric_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cluster_workload_list_with_prometheus_metric_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('fetch_all_workloads') is not None:  # noqa: E501
            query_params.append(('fetch_all_workloads', local_var_params['fetch_all_workloads']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('node_ids') is not None:  # noqa: E501
            query_params.append(('node_ids', local_var_params['node_ids']))  # noqa: E501
            collection_formats['node_ids'] = 'multi'  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('workload_statuses') is not None:  # noqa: E501
            query_params.append(('workload_statuses', local_var_params['workload_statuses']))  # noqa: E501
            collection_formats['workload_statuses'] = 'multi'  # noqa: E501
        if local_var_params.get('workload_types') is not None:  # noqa: E501
            query_params.append(('workload_types', local_var_params['workload_types']))  # noqa: E501
            collection_formats['workload_types'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterClusterWorkloadListWithPrometheusMetricResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/workloads_v2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def cmdk_search_api(self, organization_name, keyword, **kwargs):  # noqa: E501
        """cmdk_search_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cmdk_search_api(organization_name, keyword, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param keyword: (required)
        :type keyword: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CmdkCmdkSearchResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.cmdk_search_api_with_http_info(organization_name, keyword, **kwargs)  # noqa: E501

    def cmdk_search_api_with_http_info(self, organization_name, keyword, **kwargs):  # noqa: E501
        """cmdk_search_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cmdk_search_api_with_http_info(organization_name, keyword, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param keyword: (required)
        :type keyword: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CmdkCmdkSearchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'keyword',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cmdk_search_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `cmdk_search_api`")  # noqa: E501
        # verify the required parameter 'keyword' is set
        if self.api_client.client_side_validation and local_var_params.get('keyword') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `keyword` when calling `cmdk_search_api`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 10:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `cmdk_search_api`, must be a value less than or equal to `10`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "CmdkCmdkSearchResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/cmdk/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def coupon_redeem_api(self, **kwargs):  # noqa: E501
        """coupon_redeem_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.coupon_redeem_api(async_req=True)
        >>> result = thread.get()

        :param coupon_redeem_api_input:
        :type coupon_redeem_api_input: CouponRedeemAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CouponCouponRedeemResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.coupon_redeem_api_with_http_info(**kwargs)  # noqa: E501

    def coupon_redeem_api_with_http_info(self, **kwargs):  # noqa: E501
        """coupon_redeem_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.coupon_redeem_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param coupon_redeem_api_input:
        :type coupon_redeem_api_input: CouponRedeemAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CouponCouponRedeemResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'coupon_redeem_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coupon_redeem_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'coupon_redeem_api_input' in local_var_params:
            body_params = local_var_params['coupon_redeem_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "CouponCouponRedeemResponse",
        }

        return self.api_client.call_api(
            '/api/v1/coupons/redeem', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_connectivity_api(self, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_connectivity_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_connectivity_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param agent_access_token:
        :type agent_access_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_connectivity_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def custom_cluster_connectivity_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_connectivity_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_connectivity_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param agent_access_token:
        :type agent_access_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'agent_access_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_connectivity_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `custom_cluster_connectivity_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('agent_access_token') is not None:  # noqa: E501
            query_params.append(('agent_access_token', local_var_params['agent_access_token']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/custom_cluster_connectivity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_key_api(self, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_key_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterCustomClusterKeyResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_key_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def custom_cluster_key_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_key_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterCustomClusterKeyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_key_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `custom_cluster_key_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterCustomClusterKeyResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/custom_cluster_key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def custom_cluster_node_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_node_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterCustomClusterNodeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.custom_cluster_node_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def custom_cluster_node_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """custom_cluster_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.custom_cluster_node_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterCustomClusterNodeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method custom_cluster_node_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `custom_cluster_node_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `custom_cluster_node_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterCustomClusterNodeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/custom_clusters/{clusterID}/nodes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def customer_portal_api(self, organization_name, **kwargs):  # noqa: E501
        """customer_portal_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_portal_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param customer_portal_api_input:
        :type customer_portal_api_input: CustomerPortalAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BillingCustomerPortalResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.customer_portal_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def customer_portal_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """customer_portal_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_portal_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param customer_portal_api_input:
        :type customer_portal_api_input: CustomerPortalAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BillingCustomerPortalResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'customer_portal_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_portal_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `customer_portal_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'customer_portal_api_input' in local_var_params:
            body_params = local_var_params['customer_portal_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "BillingCustomerPortalResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/billing/customer_portal', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_chart_create_api(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_create_api(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_chart_create_api_input:
        :type dashboard_chart_create_api_input: DashboardChartCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardChart
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_chart_create_api_with_http_info(dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_chart_create_api_with_http_info(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_create_api_with_http_info(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_chart_create_api_input:
        :type dashboard_chart_create_api_input: DashboardChartCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardChart, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id',
            'dashboard_chart_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_chart_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_chart_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_chart_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_chart_create_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_chart_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_chart_create_api_input' in local_var_params:
            body_params = local_var_params['dashboard_chart_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardChart",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}/charts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_chart_delete_api(self, chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_delete_api(chart_id, dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param chart_id: (required)
        :type chart_id: int
        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_chart_delete_api_with_http_info(chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_chart_delete_api_with_http_info(self, chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_delete_api_with_http_info(chart_id, dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param chart_id: (required)
        :type chart_id: int
        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'chart_id',
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_chart_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'chart_id' is set
        if self.api_client.client_side_validation and local_var_params.get('chart_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `chart_id` when calling `dashboard_chart_delete_api`")  # noqa: E501
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_chart_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_chart_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_chart_delete_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_chart_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'chart_id' in local_var_params:
            path_params['chartID'] = local_var_params['chart_id']  # noqa: E501
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}/charts/{chartID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_chart_list_api(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_list_api(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardChartListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_chart_list_api_with_http_info(dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_chart_list_api_with_http_info(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_list_api_with_http_info(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardChartListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_chart_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_chart_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_chart_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_chart_list_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_chart_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardChartListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}/charts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_chart_metrics_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_chart_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_metrics_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param field_ids:
        :type field_ids: list[int]
        :param x_axis:
        :type x_axis: str
        :param x_axis_max:
        :type x_axis_max: float
        :param x_axis_min:
        :type x_axis_min: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardChartMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_chart_metrics_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_chart_metrics_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_chart_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_metrics_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param field_ids:
        :type field_ids: list[int]
        :param x_axis:
        :type x_axis: str
        :param x_axis_max:
        :type x_axis_max: float
        :param x_axis_min:
        :type x_axis_min: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardChartMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'field_ids',
            'x_axis',
            'x_axis_max',
            'x_axis_min'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_chart_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_chart_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_chart_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_chart_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('field_ids') is not None:  # noqa: E501
            query_params.append(('field_ids', local_var_params['field_ids']))  # noqa: E501
            collection_formats['field_ids'] = 'multi'  # noqa: E501
        if local_var_params.get('x_axis') is not None:  # noqa: E501
            query_params.append(('x_axis', local_var_params['x_axis']))  # noqa: E501
        if local_var_params.get('x_axis_max') is not None:  # noqa: E501
            query_params.append(('x_axis_max', local_var_params['x_axis_max']))  # noqa: E501
        if local_var_params.get('x_axis_min') is not None:  # noqa: E501
            query_params.append(('x_axis_min', local_var_params['x_axis_min']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardChartMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/chart_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_chart_update_api(self, chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_update_api(chart_id, dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param chart_id: (required)
        :type chart_id: int
        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_chart_update_api_input:
        :type dashboard_chart_update_api_input: DashboardChartUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardChart
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_chart_update_api_with_http_info(chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_chart_update_api_with_http_info(self, chart_id, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_chart_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_chart_update_api_with_http_info(chart_id, dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param chart_id: (required)
        :type chart_id: int
        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_chart_update_api_input:
        :type dashboard_chart_update_api_input: DashboardChartUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardChart, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'chart_id',
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id',
            'dashboard_chart_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_chart_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'chart_id' is set
        if self.api_client.client_side_validation and local_var_params.get('chart_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `chart_id` when calling `dashboard_chart_update_api`")  # noqa: E501
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_chart_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_chart_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_chart_update_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_chart_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'chart_id' in local_var_params:
            path_params['chartID'] = local_var_params['chart_id']  # noqa: E501
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_chart_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_chart_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardChart",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}/charts/{chartID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_clone_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_clone_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_clone_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_clone_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_clone_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_clone_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_clone_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_clone_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_clone_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_clone_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_clone_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/clone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_copy_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_copy_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_copy_api_input:
        :type dashboard_copy_api_input: DashboardCopyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_copy_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_copy_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_copy_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_copy_api_input:
        :type dashboard_copy_api_input: DashboardCopyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_copy_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_copy_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_copy_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_copy_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_copy_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_copy_api_input' in local_var_params:
            body_params = local_var_params['dashboard_copy_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_create_api_input:
        :type dashboard_create_api_input: DashboardCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_create_api_input:
        :type dashboard_create_api_input: DashboardCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'dashboard_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_create_api_input' in local_var_params:
            body_params = local_var_params['dashboard_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_csvapi(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_csvapi(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_csvapi_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_csvapi_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_csvapi_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_csvapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_csvapi`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_csvapi`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_csvapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_default_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_default_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_default_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_default_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_default_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_default_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_default_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_default_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_default_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_default_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboard', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_delete_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_delete_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_delete_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_delete_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_delete_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_add_tags_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_add_tags_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_add_tags_api_input:
        :type dashboard_experiment_add_tags_api_input: DashboardExperimentAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_add_tags_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_add_tags_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_add_tags_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_add_tags_api_input:
        :type dashboard_experiment_add_tags_api_input: DashboardExperimentAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_add_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_add_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_add_tags_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_add_tags_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_add_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_add_tags_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_add_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_bulk_delete_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_delete_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_delete_api_input:
        :type dashboard_experiment_bulk_delete_api_input: DashboardExperimentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_bulk_delete_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_bulk_delete_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_delete_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_delete_api_input:
        :type dashboard_experiment_bulk_delete_api_input: DashboardExperimentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_bulk_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_bulk_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_bulk_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_bulk_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_bulk_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_bulk_delete_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_bulk_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_bulk_star_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_star_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_star_api_input:
        :type dashboard_experiment_bulk_star_api_input: DashboardExperimentBulkStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_bulk_star_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_bulk_star_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_star_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_star_api_input:
        :type dashboard_experiment_bulk_star_api_input: DashboardExperimentBulkStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_bulk_star_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_bulk_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_bulk_star_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_bulk_star_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_bulk_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_bulk_star_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_bulk_star_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_bulk_terminate_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_terminate_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_terminate_api_input:
        :type dashboard_experiment_bulk_terminate_api_input: DashboardExperimentBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_bulk_terminate_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_bulk_terminate_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_terminate_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_terminate_api_input:
        :type dashboard_experiment_bulk_terminate_api_input: DashboardExperimentBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_bulk_terminate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_bulk_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_bulk_terminate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_bulk_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_bulk_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_bulk_terminate_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_bulk_terminate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_bulk_unstar_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_unstar_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_unstar_api_input:
        :type dashboard_experiment_bulk_unstar_api_input: DashboardExperimentBulkUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_bulk_unstar_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_bulk_unstar_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_unstar_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_unstar_api_input:
        :type dashboard_experiment_bulk_unstar_api_input: DashboardExperimentBulkUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_bulk_unstar_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_bulk_unstar_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_bulk_unstar_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_bulk_unstar_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_bulk_unstar_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_bulk_unstar_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_bulk_unstar_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_unstar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_bulk_update_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_update_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_update_api_input:
        :type dashboard_experiment_bulk_update_api_input: DashboardExperimentBulkUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_bulk_update_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_bulk_update_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_bulk_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_bulk_update_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_bulk_update_api_input:
        :type dashboard_experiment_bulk_update_api_input: DashboardExperimentBulkUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_bulk_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_bulk_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_bulk_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_bulk_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_bulk_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_bulk_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_bulk_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_field_list_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_list_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentFieldListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_field_list_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_field_list_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_list_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentFieldListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_field_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_field_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_field_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_field_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentFieldListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/fields', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_field_update_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_update_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_field_update_api_input:
        :type dashboard_experiment_field_update_api_input: DashboardExperimentFieldUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentFieldUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_field_update_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_field_update_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_update_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_field_update_api_input:
        :type dashboard_experiment_field_update_api_input: DashboardExperimentFieldUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentFieldUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_field_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_field_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_field_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_field_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_field_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_field_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_field_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentFieldUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/fields', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_field_value_list_api(self, dashboard_id, field_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_value_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_value_list_api(dashboard_id, field_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param field_id: (required)
        :type field_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentFieldValueListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_field_value_list_api_with_http_info(dashboard_id, field_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_field_value_list_api_with_http_info(self, dashboard_id, field_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_field_value_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_field_value_list_api_with_http_info(dashboard_id, field_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param field_id: (required)
        :type field_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentFieldValueListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'field_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_field_value_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_field_value_list_api`")  # noqa: E501
        # verify the required parameter 'field_id' is set
        if self.api_client.client_side_validation and local_var_params.get('field_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `field_id` when calling `dashboard_experiment_field_value_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_field_value_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_field_value_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'field_id' in local_var_params:
            path_params['fieldID'] = local_var_params['field_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentFieldValueListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/fields/{fieldID}/values', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_filter_create_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_create_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_filter_create_api_input:
        :type dashboard_experiment_filter_create_api_input: DashboardExperimentFilterCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardExperimentFilterResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_filter_create_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_filter_create_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_create_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_filter_create_api_input:
        :type dashboard_experiment_filter_create_api_input: DashboardExperimentFilterCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardExperimentFilterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_filter_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_filter_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_filter_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_filter_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_filter_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_filter_create_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_filter_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardExperimentFilterResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/filters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_filter_delete_api(self, dashboard_id, filter_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_delete_api(dashboard_id, filter_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param filter_id: (required)
        :type filter_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_filter_delete_api_with_http_info(dashboard_id, filter_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_filter_delete_api_with_http_info(self, dashboard_id, filter_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_delete_api_with_http_info(dashboard_id, filter_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param filter_id: (required)
        :type filter_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'filter_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_filter_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_filter_delete_api`")  # noqa: E501
        # verify the required parameter 'filter_id' is set
        if self.api_client.client_side_validation and local_var_params.get('filter_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filter_id` when calling `dashboard_experiment_filter_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_filter_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_filter_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'filter_id' in local_var_params:
            path_params['filterID'] = local_var_params['filter_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/filters/{filterID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_filter_update_api(self, dashboard_id, filter_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_update_api(dashboard_id, filter_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param filter_id: (required)
        :type filter_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_filter_update_api_input:
        :type dashboard_experiment_filter_update_api_input: DashboardExperimentFilterUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardExperimentFilterResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_filter_update_api_with_http_info(dashboard_id, filter_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_filter_update_api_with_http_info(self, dashboard_id, filter_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_filter_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_filter_update_api_with_http_info(dashboard_id, filter_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param filter_id: (required)
        :type filter_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_filter_update_api_input:
        :type dashboard_experiment_filter_update_api_input: DashboardExperimentFilterUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardExperimentFilterResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'filter_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_filter_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_filter_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_filter_update_api`")  # noqa: E501
        # verify the required parameter 'filter_id' is set
        if self.api_client.client_side_validation and local_var_params.get('filter_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `filter_id` when calling `dashboard_experiment_filter_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_filter_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_filter_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'filter_id' in local_var_params:
            path_params['filterID'] = local_var_params['filter_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_filter_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_filter_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardExperimentFilterResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/filters/{filterID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_hide_plots_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_hide_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_hide_plots_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_hide_plots_api_input:
        :type dashboard_experiment_hide_plots_api_input: DashboardExperimentHidePlotsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentHidePlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_hide_plots_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_hide_plots_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_hide_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_hide_plots_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_hide_plots_api_input:
        :type dashboard_experiment_hide_plots_api_input: DashboardExperimentHidePlotsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentHidePlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_hide_plots_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_hide_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_hide_plots_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_hide_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_hide_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_hide_plots_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_hide_plots_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentHidePlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_hide_plots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_list_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_list_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_list_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_list_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_list_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_remove_tags_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_remove_tags_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_remove_tags_api_input:
        :type dashboard_experiment_remove_tags_api_input: DashboardExperimentRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_remove_tags_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_remove_tags_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_remove_tags_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_remove_tags_api_input:
        :type dashboard_experiment_remove_tags_api_input: DashboardExperimentRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_remove_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_remove_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_remove_tags_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_remove_tags_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_remove_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_remove_tags_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_remove_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_show_plots_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_show_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_show_plots_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_show_plots_api_input:
        :type dashboard_experiment_show_plots_api_input: DashboardExperimentShowPlotsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardExperimentShowPlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_show_plots_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_show_plots_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_show_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_show_plots_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_show_plots_api_input:
        :type dashboard_experiment_show_plots_api_input: DashboardExperimentShowPlotsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardExperimentShowPlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_show_plots_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_show_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_show_plots_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_show_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_show_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_show_plots_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_show_plots_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardExperimentShowPlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/experiments_show_plots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_sort_create_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_create_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_sort_create_api_input:
        :type dashboard_experiment_sort_create_api_input: DashboardExperimentSortCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardExperimentSortResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_sort_create_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_experiment_sort_create_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_create_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_experiment_sort_create_api_input:
        :type dashboard_experiment_sort_create_api_input: DashboardExperimentSortCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardExperimentSortResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_experiment_sort_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_sort_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_sort_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_sort_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_sort_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_sort_create_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_sort_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardExperimentSortResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sorts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_sort_delete_api(self, dashboard_id, organization_name, project_name, sort_id, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_delete_api(dashboard_id, organization_name, project_name, sort_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sort_id: (required)
        :type sort_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_sort_delete_api_with_http_info(dashboard_id, organization_name, project_name, sort_id, **kwargs)  # noqa: E501

    def dashboard_experiment_sort_delete_api_with_http_info(self, dashboard_id, organization_name, project_name, sort_id, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_delete_api_with_http_info(dashboard_id, organization_name, project_name, sort_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sort_id: (required)
        :type sort_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'sort_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_sort_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_sort_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_sort_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_sort_delete_api`")  # noqa: E501
        # verify the required parameter 'sort_id' is set
        if self.api_client.client_side_validation and local_var_params.get('sort_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sort_id` when calling `dashboard_experiment_sort_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sort_id' in local_var_params:
            path_params['sortID'] = local_var_params['sort_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sorts/{sortID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_experiment_sort_update_api(self, dashboard_id, organization_name, project_name, sort_id, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_update_api(dashboard_id, organization_name, project_name, sort_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sort_id: (required)
        :type sort_id: int
        :param dashboard_experiment_sort_update_api_input:
        :type dashboard_experiment_sort_update_api_input: DashboardExperimentSortUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardExperimentSortResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_experiment_sort_update_api_with_http_info(dashboard_id, organization_name, project_name, sort_id, **kwargs)  # noqa: E501

    def dashboard_experiment_sort_update_api_with_http_info(self, dashboard_id, organization_name, project_name, sort_id, **kwargs):  # noqa: E501
        """dashboard_experiment_sort_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_experiment_sort_update_api_with_http_info(dashboard_id, organization_name, project_name, sort_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sort_id: (required)
        :type sort_id: int
        :param dashboard_experiment_sort_update_api_input:
        :type dashboard_experiment_sort_update_api_input: DashboardExperimentSortUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardExperimentSortResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'sort_id',
            'dashboard_experiment_sort_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_experiment_sort_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_experiment_sort_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_experiment_sort_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_experiment_sort_update_api`")  # noqa: E501
        # verify the required parameter 'sort_id' is set
        if self.api_client.client_side_validation and local_var_params.get('sort_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sort_id` when calling `dashboard_experiment_sort_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sort_id' in local_var_params:
            path_params['sortID'] = local_var_params['sort_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_experiment_sort_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_experiment_sort_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardExperimentSortResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sorts/{sortID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardList
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_read_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_read_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_read_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_read_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_read_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_reset_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_reset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_reset_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_reset_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_reset_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_reset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_reset_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_reset_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_reset_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_reset_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_reset_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_section_create_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_section_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_create_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_section_create_api_input:
        :type dashboard_section_create_api_input: DashboardSectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardChartSection
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_section_create_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_section_create_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_section_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_create_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_section_create_api_input:
        :type dashboard_section_create_api_input: DashboardSectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardChartSection, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_section_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_section_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_section_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_section_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_section_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_section_create_api_input' in local_var_params:
            body_params = local_var_params['dashboard_section_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardChartSection",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_section_delete_api(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_section_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_delete_api(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_section_delete_api_with_http_info(dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_section_delete_api_with_http_info(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_section_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_delete_api_with_http_info(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_section_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_section_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_section_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_section_delete_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_section_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_section_update_api(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_section_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_update_api(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_section_update_api_input:
        :type dashboard_section_update_api_input: DashboardSectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DashboardDashboardSectionUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_section_update_api_with_http_info(dashboard_id, organization_name, project_name, section_id, **kwargs)  # noqa: E501

    def dashboard_section_update_api_with_http_info(self, dashboard_id, organization_name, project_name, section_id, **kwargs):  # noqa: E501
        """dashboard_section_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_section_update_api_with_http_info(dashboard_id, organization_name, project_name, section_id, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param section_id: (required)
        :type section_id: int
        :param dashboard_section_update_api_input:
        :type dashboard_section_update_api_input: DashboardSectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DashboardDashboardSectionUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'section_id',
            'dashboard_section_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_section_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_section_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_section_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_section_update_api`")  # noqa: E501
        # verify the required parameter 'section_id' is set
        if self.api_client.client_side_validation and local_var_params.get('section_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `section_id` when calling `dashboard_section_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'section_id' in local_var_params:
            path_params['sectionID'] = local_var_params['section_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_section_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_section_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DashboardDashboardSectionUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/sections/{sectionID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_star_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_star_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_star_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_star_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_star_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_star_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_star_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_status_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_status_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_status_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardStatus
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_status_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_status_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_status_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_status_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardStatus, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_status_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_status_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_status_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_status_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardStatus",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_unstar_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_unstar_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_unstar_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_unstar_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_unstar_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_unstar_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_unstar_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_unstar_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_unstar_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}/unstar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dashboard_update_api(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_update_api(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_update_api_input:
        :type dashboard_update_api_input: DashboardUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDashboardDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dashboard_update_api_with_http_info(dashboard_id, organization_name, project_name, **kwargs)  # noqa: E501

    def dashboard_update_api_with_http_info(self, dashboard_id, organization_name, project_name, **kwargs):  # noqa: E501
        """dashboard_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dashboard_update_api_with_http_info(dashboard_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param dashboard_id: (required)
        :type dashboard_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param dashboard_update_api_input:
        :type dashboard_update_api_input: DashboardUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDashboardDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dashboard_id',
            'organization_name',
            'project_name',
            'dashboard_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dashboard_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dashboard_id` when calling `dashboard_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dashboard_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `dashboard_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in local_var_params:
            path_params['dashboardID'] = local_var_params['dashboard_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_update_api_input' in local_var_params:
            body_params = local_var_params['dashboard_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDashboardDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/dashboards/{dashboardID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_delete_api(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_delete_api(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_delete_api_with_http_info(dataset_name, organization_name, **kwargs)  # noqa: E501

    def dataset_delete_api_with_http_info(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_delete_api_with_http_info(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dataset_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets/{datasetName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_list_api(self, organization_name, **kwargs):  # noqa: E501
        """dataset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param volume_claim_type:
        :type volume_claim_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def dataset_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """dataset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param volume_claim_type:
        :type volume_claim_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'volume_claim_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dataset_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('volume_claim_type') is not None:  # noqa: E501
            query_params.append(('volume_claim_type', local_var_params['volume_claim_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_read_api(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_api(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_read_api_with_http_info(dataset_name, organization_name, **kwargs)  # noqa: E501

    def dataset_read_api_with_http_info(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_api_with_http_info(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dataset_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets/{datasetName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_read_by_idapi(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_by_idapi(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_read_by_idapi_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def dataset_read_by_idapi_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_read_by_idapi_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_read_by_idapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_read_by_idapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_summary_update_api(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_summary_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_summary_update_api(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param dataset_summary_update_api_input:
        :type dataset_summary_update_api_input: DatasetSummaryUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetSummary
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_summary_update_api_with_http_info(dataset_name, organization_name, **kwargs)  # noqa: E501

    def dataset_summary_update_api_with_http_info(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_summary_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_summary_update_api_with_http_info(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param dataset_summary_update_api_input:
        :type dataset_summary_update_api_input: DatasetSummaryUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetSummary, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'organization_name',
            'dataset_summary_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_summary_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_summary_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dataset_summary_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_summary_update_api_input' in local_var_params:
            body_params = local_var_params['dataset_summary_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetSummary",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets/{datasetName}/summary', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_update_api(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_update_api(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param dataset_update_api_input:
        :type dataset_update_api_input: DatasetUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_update_api_with_http_info(dataset_name, organization_name, **kwargs)  # noqa: E501

    def dataset_update_api_with_http_info(self, dataset_name, organization_name, **kwargs):  # noqa: E501
        """dataset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_update_api_with_http_info(dataset_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param dataset_name: (required)
        :type dataset_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param dataset_update_api_input:
        :type dataset_update_api_input: DatasetUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_name',
            'organization_name',
            'dataset_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_name' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_name` when calling `dataset_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `dataset_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_name' in local_var_params:
            path_params['datasetName'] = local_var_params['dataset_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_update_api_input' in local_var_params:
            body_params = local_var_params['dataset_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets/{datasetName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_version_create_api(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_version_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_create_api(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_create_api_input:
        :type dataset_version_create_api_input: DatasetVersionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetVersionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_version_create_api_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def dataset_version_create_api_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_version_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_create_api_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_create_api_input:
        :type dataset_version_create_api_input: DatasetVersionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetVersionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'dataset_version_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_version_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_version_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_version_create_api_input' in local_var_params:
            body_params = local_var_params['dataset_version_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetVersionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_version_list_api(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_version_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_list_api(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DatasetversionDatasetVersionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_version_list_api_with_http_info(dataset_id, **kwargs)  # noqa: E501

    def dataset_version_list_api_with_http_info(self, dataset_id, **kwargs):  # noqa: E501
        """dataset_version_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_list_api_with_http_info(dataset_id, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DatasetversionDatasetVersionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_version_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_version_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DatasetversionDatasetVersionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_version_read_api(self, dataset_id, dataset_version_hash, **kwargs):  # noqa: E501
        """dataset_version_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_read_api(dataset_id, dataset_version_hash, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_hash: (required)
        :type dataset_version_hash: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetVersionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_version_read_api_with_http_info(dataset_id, dataset_version_hash, **kwargs)  # noqa: E501

    def dataset_version_read_api_with_http_info(self, dataset_id, dataset_version_hash, **kwargs):  # noqa: E501
        """dataset_version_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_read_api_with_http_info(dataset_id, dataset_version_hash, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_hash: (required)
        :type dataset_version_hash: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetVersionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'dataset_version_hash'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_version_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_version_read_api`")  # noqa: E501
        # verify the required parameter 'dataset_version_hash' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_version_hash') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_version_hash` when calling `dataset_version_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501
        if 'dataset_version_hash' in local_var_params:
            path_params['datasetVersionHash'] = local_var_params['dataset_version_hash']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetVersionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}/versions/{datasetVersionHash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def dataset_version_update_api(self, dataset_id, dataset_version_hash, **kwargs):  # noqa: E501
        """dataset_version_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_update_api(dataset_id, dataset_version_hash, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_hash: (required)
        :type dataset_version_hash: str
        :param dataset_version_update_api_input:
        :type dataset_version_update_api_input: DatasetVersionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetVersionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.dataset_version_update_api_with_http_info(dataset_id, dataset_version_hash, **kwargs)  # noqa: E501

    def dataset_version_update_api_with_http_info(self, dataset_id, dataset_version_hash, **kwargs):  # noqa: E501
        """dataset_version_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.dataset_version_update_api_with_http_info(dataset_id, dataset_version_hash, async_req=True)
        >>> result = thread.get()

        :param dataset_id: (required)
        :type dataset_id: int
        :param dataset_version_hash: (required)
        :type dataset_version_hash: str
        :param dataset_version_update_api_input:
        :type dataset_version_update_api_input: DatasetVersionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetVersionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'dataset_id',
            'dataset_version_hash',
            'dataset_version_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dataset_version_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'dataset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_id` when calling `dataset_version_update_api`")  # noqa: E501
        # verify the required parameter 'dataset_version_hash' is set
        if self.api_client.client_side_validation and local_var_params.get('dataset_version_hash') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `dataset_version_hash` when calling `dataset_version_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dataset_id' in local_var_params:
            path_params['datasetID'] = local_var_params['dataset_id']  # noqa: E501
        if 'dataset_version_hash' in local_var_params:
            path_params['datasetVersionHash'] = local_var_params['dataset_version_hash']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dataset_version_update_api_input' in local_var_params:
            body_params = local_var_params['dataset_version_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetVersionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/datasets/{datasetID}/versions/{datasetVersionHash}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def datasets_public_list_api(self, **kwargs):  # noqa: E501
        """datasets_public_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_public_list_api(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.datasets_public_list_api_with_http_info(**kwargs)  # noqa: E501

    def datasets_public_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """datasets_public_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.datasets_public_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method datasets_public_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/datasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def delegable_cluster_list_api(self, **kwargs):  # noqa: E501
        """delegable_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delegable_cluster_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterDelegableClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.delegable_cluster_list_api_with_http_info(**kwargs)  # noqa: E501

    def delegable_cluster_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """delegable_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delegable_cluster_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterDelegableClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delegable_cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterDelegableClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/delegable_cluster', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def delegable_organization_list_api(self, **kwargs):  # noqa: E501
        """delegable_organization_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delegable_organization_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationDelegableOrganizationListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.delegable_organization_list_api_with_http_info(**kwargs)  # noqa: E501

    def delegable_organization_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """delegable_organization_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delegable_organization_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationDelegableOrganizationListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delegable_organization_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationDelegableOrganizationListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/delegable_organizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_experiment_create_api_input:
        :type distributed_experiment_create_api_input: DistributedExperimentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_experiment_create_api_input:
        :type distributed_experiment_create_api_input: DistributedExperimentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'distributed_experiment_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'distributed_experiment_create_api_input' in local_var_params:
            body_params = local_var_params['distributed_experiment_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_full_logs_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_full_logs_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_number:
        :type distributed_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_full_logs_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_full_logs_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_full_logs_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_number:
        :type distributed_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'distributed_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `distributed_experiment_full_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_full_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('distributed_number') is not None:  # noqa: E501
            query_params.append(('distributed_number', local_var_params['distributed_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments/{experimentNumber}/logs/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_logs_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_logs_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param distributed_number:
        :type distributed_number: int
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DistributedExperimentDistributedExperimentLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_logs_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_logs_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_logs_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param distributed_number:
        :type distributed_number: int
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DistributedExperimentDistributedExperimentLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'after',
            'before',
            'distributed_number',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `distributed_experiment_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('distributed_number') is not None:  # noqa: E501
            query_params.append(('distributed_number', local_var_params['distributed_number']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DistributedExperimentDistributedExperimentLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments/{experimentNumber}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_logs_raw_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_logs_raw_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_number:
        :type distributed_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_logs_raw_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_logs_raw_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_logs_raw_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param distributed_number:
        :type distributed_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'distributed_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_logs_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `distributed_experiment_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_logs_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('distributed_number') is not None:  # noqa: E501
            query_params.append(('distributed_number', local_var_params['distributed_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments/{experimentNumber}/logs/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_plots_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_plots_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DistributedExperimentDistributedExperimentPlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_plots_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_plots_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_plots_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DistributedExperimentDistributedExperimentPlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `distributed_experiment_plots_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DistributedExperimentDistributedExperimentPlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments/{experimentNumber}/plots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def distributed_experiment_system_metrics_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_system_metrics_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param distributed_number:
        :type distributed_number: int
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DistributedExperimentDistributedExperimentSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.distributed_experiment_system_metrics_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def distributed_experiment_system_metrics_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """distributed_experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.distributed_experiment_system_metrics_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param distributed_number:
        :type distributed_number: int
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DistributedExperimentDistributedExperimentSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'after',
            'before',
            'distributed_number',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distributed_experiment_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `distributed_experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `distributed_experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `distributed_experiment_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('distributed_number') is not None:  # noqa: E501
            query_params.append(('distributed_number', local_var_params['distributed_number']))  # noqa: E501
        if local_var_params.get('metrics') is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501
            collection_formats['metrics'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "DistributedExperimentDistributedExperimentSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/distributed_experiments/{experimentNumber}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_add_tag_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_add_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_add_tag_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_add_tag_api_input:
        :type experiment_add_tag_api_input: ExperimentAddTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_add_tag_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_add_tag_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_add_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_add_tag_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_add_tag_api_input:
        :type experiment_add_tag_api_input: ExperimentAddTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_add_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_add_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_add_tag_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_add_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_add_tag_api_input' in local_var_params:
            body_params = local_var_params['experiment_add_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_bulk_delete_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_delete_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_delete_api_input:
        :type experiment_bulk_delete_api_input: ExperimentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_bulk_delete_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_bulk_delete_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_delete_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_delete_api_input:
        :type experiment_bulk_delete_api_input: ExperimentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_bulk_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_bulk_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_bulk_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_bulk_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_bulk_delete_api_input' in local_var_params:
            body_params = local_var_params['experiment_bulk_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_bulk_star_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_star_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_star_api_input:
        :type experiment_bulk_star_api_input: ExperimentBulkStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_bulk_star_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_bulk_star_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_star_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_star_api_input:
        :type experiment_bulk_star_api_input: ExperimentBulkStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_bulk_star_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_bulk_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_bulk_star_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_bulk_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_bulk_star_api_input' in local_var_params:
            body_params = local_var_params['experiment_bulk_star_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_bulk_terminate_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_terminate_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_terminate_api_input:
        :type experiment_bulk_terminate_api_input: ExperimentBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_bulk_terminate_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_bulk_terminate_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_terminate_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_terminate_api_input:
        :type experiment_bulk_terminate_api_input: ExperimentBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_bulk_terminate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_bulk_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_bulk_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_bulk_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_bulk_terminate_api_input' in local_var_params:
            body_params = local_var_params['experiment_bulk_terminate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_bulk_unstar_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_unstar_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_unstar_api_input:
        :type experiment_bulk_unstar_api_input: ExperimentBulkUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_bulk_unstar_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_bulk_unstar_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_bulk_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_bulk_unstar_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_bulk_unstar_api_input:
        :type experiment_bulk_unstar_api_input: ExperimentBulkUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_bulk_unstar_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_bulk_unstar_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_bulk_unstar_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_bulk_unstar_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_bulk_unstar_api_input' in local_var_params:
            body_params = local_var_params['experiment_bulk_unstar_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_unstar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_create_api_input:
        :type experiment_create_api_input: ExperimentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_create_api_input:
        :type experiment_create_api_input: ExperimentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_create_api_input' in local_var_params:
            body_params = local_var_params['experiment_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_delete_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_delete_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_delete_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_delete_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_delete_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_full_logs_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_full_logs_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_full_logs_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_full_logs_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_full_logs_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_full_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_full_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/logs/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param exclude_local:
        :type exclude_local: bool
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param exclude_local:
        :type exclude_local: bool
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'exclude_local',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'starred',
            'statuses'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('exclude_local') is not None:  # noqa: E501
            query_params.append(('exclude_local', local_var_params['exclude_local']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('starred') is not None:  # noqa: E501
            query_params.append(('starred', local_var_params['starred']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_logs_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_logs_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_logs_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_logs_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_logs_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_logs_raw_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_logs_raw_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_logs_raw_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_logs_raw_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_logs_raw_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_logs_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_logs_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/logs/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_metrics_update_api(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_metrics_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_metrics_update_api(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param experiment_metrics_update_api_input:
        :type experiment_metrics_update_api_input: ExperimentMetricsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentMetricsUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_metrics_update_api_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def experiment_metrics_update_api_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_metrics_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_metrics_update_api_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param experiment_metrics_update_api_input:
        :type experiment_metrics_update_api_input: ExperimentMetricsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentMetricsUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id',
            'experiment_metrics_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_metrics_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `experiment_metrics_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_metrics_update_api_input' in local_var_params:
            body_params = local_var_params['experiment_metrics_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentMetricsUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}/metrics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_parameter_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_parameter_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_parameter_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentParameterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_parameter_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_parameter_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_parameter_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_parameter_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentParameterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_parameter_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_parameter_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_parameter_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentParameterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiment_parameters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_plots_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_plots_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentPlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_plots_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_plots_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_plots_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentPlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_plots_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentPlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/plots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_plots_metrics_raw_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_plots_metrics_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_plots_metrics_raw_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_plots_metrics_raw_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_plots_metrics_raw_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_plots_metrics_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_plots_metrics_raw_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_plots_metrics_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_plots_metrics_raw_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_plots_metrics_raw_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_plots_metrics_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/plots/metrics/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_progress_update_api(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_progress_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_progress_update_api(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param experiment_progress_update_api_input:
        :type experiment_progress_update_api_input: ExperimentProgressUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_progress_update_api_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def experiment_progress_update_api_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_progress_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_progress_update_api_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param experiment_progress_update_api_input:
        :type experiment_progress_update_api_input: ExperimentProgressUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id',
            'experiment_progress_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_progress_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `experiment_progress_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_progress_update_api_input' in local_var_params:
            body_params = local_var_params['experiment_progress_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}/progress', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_read_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_read_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_read_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_read_by_idapi(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_by_idapi(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_read_by_idapi_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def experiment_read_by_idapi_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_read_by_idapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_read_by_idapi_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_read_by_idapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `experiment_read_by_idapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_remove_tag_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_remove_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_remove_tag_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_remove_tag_api_input:
        :type experiment_remove_tag_api_input: ExperimentRemoveTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_remove_tag_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_remove_tag_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_remove_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_remove_tag_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_remove_tag_api_input:
        :type experiment_remove_tag_api_input: ExperimentRemoveTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'experiment_remove_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_remove_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_remove_tag_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_remove_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_remove_tag_api_input' in local_var_params:
            body_params = local_var_params['experiment_remove_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments_remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_status_idle_api(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_status_idle_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_status_idle_api(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentStatusIdleResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_status_idle_api_with_http_info(experiment_id, **kwargs)  # noqa: E501

    def experiment_status_idle_api_with_http_info(self, experiment_id, **kwargs):  # noqa: E501
        """experiment_status_idle_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_status_idle_api_with_http_info(experiment_id, async_req=True)
        >>> result = thread.get()

        :param experiment_id: (required)
        :type experiment_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentStatusIdleResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_status_idle_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_id' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `experiment_status_idle_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentStatusIdleResponse",
        }

        return self.api_client.call_api(
            '/api/v1/experiments/{experimentID}/idle', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_system_metrics_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_system_metrics_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExperimentExperimentSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_system_metrics_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_system_metrics_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_system_metrics_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExperimentExperimentSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'after',
            'before',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('metrics') is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501
            collection_formats['metrics'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExperimentExperimentSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_terminate_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_terminate_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_terminate_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_terminate_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_terminate_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_terminate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_update_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_update_api_input:
        :type experiment_update_api_input: ExperimentUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_update_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_update_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_update_api_input:
        :type experiment_update_api_input: ExperimentUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'experiment_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_update_api_input' in local_var_params:
            body_params = local_var_params['experiment_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def experiment_update_hyperparameters_api(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_update_hyperparameters_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_hyperparameters_api(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_update_hyperparameters_api_input:
        :type experiment_update_hyperparameters_api_input: ExperimentUpdateHyperparametersAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseExperimentInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.experiment_update_hyperparameters_api_with_http_info(experiment_number, organization_name, project_name, **kwargs)  # noqa: E501

    def experiment_update_hyperparameters_api_with_http_info(self, experiment_number, organization_name, project_name, **kwargs):  # noqa: E501
        """experiment_update_hyperparameters_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.experiment_update_hyperparameters_api_with_http_info(experiment_number, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param experiment_number: (required)
        :type experiment_number: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param experiment_update_hyperparameters_api_input:
        :type experiment_update_hyperparameters_api_input: ExperimentUpdateHyperparametersAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseExperimentInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'experiment_number',
            'organization_name',
            'project_name',
            'experiment_update_hyperparameters_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method experiment_update_hyperparameters_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'experiment_number' is set
        if self.api_client.client_side_validation and local_var_params.get('experiment_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `experiment_number` when calling `experiment_update_hyperparameters_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `experiment_update_hyperparameters_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `experiment_update_hyperparameters_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'experiment_number' in local_var_params:
            path_params['experimentNumber'] = local_var_params['experiment_number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_update_hyperparameters_api_input' in local_var_params:
            body_params = local_var_params['experiment_update_hyperparameters_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseExperimentInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/experiments/{experimentNumber}/hyperparameters', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def finish_run_execution_onboarding_api(self, **kwargs):  # noqa: E501
        """finish_run_execution_onboarding_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.finish_run_execution_onboarding_api(async_req=True)
        >>> result = thread.get()

        :param finish_run_execution_onboarding_api_input:
        :type finish_run_execution_onboarding_api_input: FinishRunExecutionOnboardingAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OnboardingFinishRunExecutionOnboardingResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.finish_run_execution_onboarding_api_with_http_info(**kwargs)  # noqa: E501

    def finish_run_execution_onboarding_api_with_http_info(self, **kwargs):  # noqa: E501
        """finish_run_execution_onboarding_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.finish_run_execution_onboarding_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param finish_run_execution_onboarding_api_input:
        :type finish_run_execution_onboarding_api_input: FinishRunExecutionOnboardingAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OnboardingFinishRunExecutionOnboardingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'finish_run_execution_onboarding_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finish_run_execution_onboarding_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'finish_run_execution_onboarding_api_input' in local_var_params:
            body_params = local_var_params['finish_run_execution_onboarding_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OnboardingFinishRunExecutionOnboardingResponse",
        }

        return self.api_client.call_api(
            '/api/v1/onboardings/run_execution', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def frontend_config_api(self, **kwargs):  # noqa: E501
        """frontend_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.frontend_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClientconfigFrontendConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.frontend_config_api_with_http_info(**kwargs)  # noqa: E501

    def frontend_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """frontend_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.frontend_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClientconfigFrontendConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method frontend_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClientconfigFrontendConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/config/frontend', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def g_s_dataset_create_api(self, organization_name, **kwargs):  # noqa: E501
        """g_s_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.g_s_dataset_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param gs_dataset_create_api_input:
        :type gs_dataset_create_api_input: GSDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.g_s_dataset_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def g_s_dataset_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """g_s_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.g_s_dataset_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param gs_dataset_create_api_input:
        :type gs_dataset_create_api_input: GSDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'gs_dataset_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method g_s_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `g_s_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'gs_dataset_create_api_input' in local_var_params:
            body_params = local_var_params['gs_dataset_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets_gs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_my_user_info_api(self, **kwargs):  # noqa: E501
        """get_my_user_info_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_user_info_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.get_my_user_info_api_with_http_info(**kwargs)  # noqa: E501

    def get_my_user_info_api_with_http_info(self, **kwargs):  # noqa: E501
        """get_my_user_info_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_user_info_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_my_user_info_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/me', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_my_workload_list_api(self, **kwargs):  # noqa: E501
        """get_my_workload_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_workload_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountGetMyWorkloadListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_my_workload_list_api_with_http_info(**kwargs)  # noqa: E501

    def get_my_workload_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """get_my_workload_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_my_workload_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountGetMyWorkloadListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_my_workload_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountGetMyWorkloadListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/me/workloads', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_branch_list_api(self, git_owner, git_provider, git_repo, **kwargs):  # noqa: E501
        """git_branch_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_branch_list_api(git_owner, git_provider, git_repo, async_req=True)
        >>> result = thread.get()

        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitBranchListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_branch_list_api_with_http_info(git_owner, git_provider, git_repo, **kwargs)  # noqa: E501

    def git_branch_list_api_with_http_info(self, git_owner, git_provider, git_repo, **kwargs):  # noqa: E501
        """git_branch_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_branch_list_api_with_http_info(git_owner, git_provider, git_repo, async_req=True)
        >>> result = thread.get()

        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitBranchListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'git_owner',
            'git_provider',
            'git_repo',
            'organization_credentials_id',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_branch_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'git_owner' is set
        if self.api_client.client_side_validation and local_var_params.get('git_owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_owner` when calling `git_branch_list_api`")  # noqa: E501
        # verify the required parameter 'git_provider' is set
        if self.api_client.client_side_validation and local_var_params.get('git_provider') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_provider` when calling `git_branch_list_api`")  # noqa: E501
        # verify the required parameter 'git_repo' is set
        if self.api_client.client_side_validation and local_var_params.get('git_repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_repo` when calling `git_branch_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'git_owner' in local_var_params:
            path_params['gitOwner'] = local_var_params['git_owner']  # noqa: E501
        if 'git_provider' in local_var_params:
            path_params['gitProvider'] = local_var_params['git_provider']  # noqa: E501
        if 'git_repo' in local_var_params:
            path_params['gitRepo'] = local_var_params['git_repo']  # noqa: E501

        query_params = []
        if local_var_params.get('organization_credentials_id') is not None:  # noqa: E501
            query_params.append(('organization_credentials_id', local_var_params['organization_credentials_id']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitBranchListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/git/provider/{gitProvider}/owner/{gitOwner}/repo/{gitRepo}/branches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_branch_list_v2_api(self, organization_name, **kwargs):  # noqa: E501
        """git_branch_list_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_branch_list_v2_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param git_branch_list_v2_api_input:
        :type git_branch_list_v2_api_input: GitBranchListV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitBranchListV2Response
        """
        kwargs['_return_http_data_only'] = True
        return self.git_branch_list_v2_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def git_branch_list_v2_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """git_branch_list_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_branch_list_v2_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param git_branch_list_v2_api_input:
        :type git_branch_list_v2_api_input: GitBranchListV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitBranchListV2Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'git_branch_list_v2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_branch_list_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `git_branch_list_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_branch_list_v2_api_input' in local_var_params:
            body_params = local_var_params['git_branch_list_v2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitBranchListV2Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/external_integrations/git/query_branch_list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_commit_list_api(self, branch, git_owner, git_provider, git_repo, **kwargs):  # noqa: E501
        """git_commit_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_list_api(branch, git_owner, git_provider, git_repo, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: str
        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitCommitListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_commit_list_api_with_http_info(branch, git_owner, git_provider, git_repo, **kwargs)  # noqa: E501

    def git_commit_list_api_with_http_info(self, branch, git_owner, git_provider, git_repo, **kwargs):  # noqa: E501
        """git_commit_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_list_api_with_http_info(branch, git_owner, git_provider, git_repo, async_req=True)
        >>> result = thread.get()

        :param branch: (required)
        :type branch: str
        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitCommitListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'branch',
            'git_owner',
            'git_provider',
            'git_repo',
            'organization_credentials_id',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_commit_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'branch' is set
        if self.api_client.client_side_validation and local_var_params.get('branch') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `branch` when calling `git_commit_list_api`")  # noqa: E501
        # verify the required parameter 'git_owner' is set
        if self.api_client.client_side_validation and local_var_params.get('git_owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_owner` when calling `git_commit_list_api`")  # noqa: E501
        # verify the required parameter 'git_provider' is set
        if self.api_client.client_side_validation and local_var_params.get('git_provider') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_provider` when calling `git_commit_list_api`")  # noqa: E501
        # verify the required parameter 'git_repo' is set
        if self.api_client.client_side_validation and local_var_params.get('git_repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_repo` when calling `git_commit_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'branch' in local_var_params:
            path_params['branch'] = local_var_params['branch']  # noqa: E501
        if 'git_owner' in local_var_params:
            path_params['gitOwner'] = local_var_params['git_owner']  # noqa: E501
        if 'git_provider' in local_var_params:
            path_params['gitProvider'] = local_var_params['git_provider']  # noqa: E501
        if 'git_repo' in local_var_params:
            path_params['gitRepo'] = local_var_params['git_repo']  # noqa: E501

        query_params = []
        if local_var_params.get('organization_credentials_id') is not None:  # noqa: E501
            query_params.append(('organization_credentials_id', local_var_params['organization_credentials_id']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitCommitListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/git/provider/{gitProvider}/owner/{gitOwner}/repo/{gitRepo}/branches/{branch}/commits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_commit_list_v2_api(self, organization_name, **kwargs):  # noqa: E501
        """git_commit_list_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_list_v2_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param page:
        :type page: int
        :param git_commit_list_v2_api_input:
        :type git_commit_list_v2_api_input: GitCommitListV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitCommitListV2Response
        """
        kwargs['_return_http_data_only'] = True
        return self.git_commit_list_v2_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def git_commit_list_v2_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """git_commit_list_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_list_v2_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param page:
        :type page: int
        :param git_commit_list_v2_api_input:
        :type git_commit_list_v2_api_input: GitCommitListV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitCommitListV2Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'page',
            'git_commit_list_v2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_commit_list_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `git_commit_list_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_commit_list_v2_api_input' in local_var_params:
            body_params = local_var_params['git_commit_list_v2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitCommitListV2Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/external_integrations/git/query_commit_list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_commit_read_api(self, git_owner, git_provider, git_repo, sha, **kwargs):  # noqa: E501
        """git_commit_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_read_api(git_owner, git_provider, git_repo, sha, async_req=True)
        >>> result = thread.get()

        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param sha: (required)
        :type sha: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoCommit
        """
        kwargs['_return_http_data_only'] = True
        return self.git_commit_read_api_with_http_info(git_owner, git_provider, git_repo, sha, **kwargs)  # noqa: E501

    def git_commit_read_api_with_http_info(self, git_owner, git_provider, git_repo, sha, **kwargs):  # noqa: E501
        """git_commit_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_read_api_with_http_info(git_owner, git_provider, git_repo, sha, async_req=True)
        >>> result = thread.get()

        :param git_owner: (required)
        :type git_owner: str
        :param git_provider: (required)
        :type git_provider: str
        :param git_repo: (required)
        :type git_repo: str
        :param sha: (required)
        :type sha: str
        :param organization_credentials_id:
        :type organization_credentials_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoCommit, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'git_owner',
            'git_provider',
            'git_repo',
            'sha',
            'organization_credentials_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_commit_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'git_owner' is set
        if self.api_client.client_side_validation and local_var_params.get('git_owner') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_owner` when calling `git_commit_read_api`")  # noqa: E501
        # verify the required parameter 'git_provider' is set
        if self.api_client.client_side_validation and local_var_params.get('git_provider') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_provider` when calling `git_commit_read_api`")  # noqa: E501
        # verify the required parameter 'git_repo' is set
        if self.api_client.client_side_validation and local_var_params.get('git_repo') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `git_repo` when calling `git_commit_read_api`")  # noqa: E501
        # verify the required parameter 'sha' is set
        if self.api_client.client_side_validation and local_var_params.get('sha') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sha` when calling `git_commit_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'git_owner' in local_var_params:
            path_params['gitOwner'] = local_var_params['git_owner']  # noqa: E501
        if 'git_provider' in local_var_params:
            path_params['gitProvider'] = local_var_params['git_provider']  # noqa: E501
        if 'git_repo' in local_var_params:
            path_params['gitRepo'] = local_var_params['git_repo']  # noqa: E501
        if 'sha' in local_var_params:
            path_params['sha'] = local_var_params['sha']  # noqa: E501

        query_params = []
        if local_var_params.get('organization_credentials_id') is not None:  # noqa: E501
            query_params.append(('organization_credentials_id', local_var_params['organization_credentials_id']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoCommit",
        }

        return self.api_client.call_api(
            '/api/v1/git/provider/{gitProvider}/owner/{gitOwner}/repo/{gitRepo}/commits/{sha}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_commit_read_v2_api(self, organization_name, **kwargs):  # noqa: E501
        """git_commit_read_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_read_v2_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param git_commit_read_v2_api_input:
        :type git_commit_read_v2_api_input: GitCommitReadV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseGitCommit
        """
        kwargs['_return_http_data_only'] = True
        return self.git_commit_read_v2_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def git_commit_read_v2_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """git_commit_read_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_commit_read_v2_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param git_commit_read_v2_api_input:
        :type git_commit_read_v2_api_input: GitCommitReadV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseGitCommit, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'git_commit_read_v2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_commit_read_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `git_commit_read_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_commit_read_v2_api_input' in local_var_params:
            body_params = local_var_params['git_commit_read_v2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseGitCommit",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/external_integrations/git/query_commit_read', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_hub_code_refs_api(self, workload_id, **kwargs):  # noqa: E501
        """git_hub_code_refs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_code_refs_api(workload_id, async_req=True)
        >>> result = thread.get()

        :param workload_id: (required)
        :type workload_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitHubCodeRefsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_hub_code_refs_api_with_http_info(workload_id, **kwargs)  # noqa: E501

    def git_hub_code_refs_api_with_http_info(self, workload_id, **kwargs):  # noqa: E501
        """git_hub_code_refs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_code_refs_api_with_http_info(workload_id, async_req=True)
        >>> result = thread.get()

        :param workload_id: (required)
        :type workload_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitHubCodeRefsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workload_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_hub_code_refs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workload_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workload_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workload_id` when calling `git_hub_code_refs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workload_id' in local_var_params:
            path_params['workloadID'] = local_var_params['workload_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitHubCodeRefsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workloads/{workloadID}/github_code_refs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_hub_config_api(self, **kwargs):  # noqa: E501
        """git_hub_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitHubConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_hub_config_api_with_http_info(**kwargs)  # noqa: E501

    def git_hub_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_hub_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_hub_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitHubConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_hub_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitHubConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/github/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_lab_config_api(self, **kwargs):  # noqa: E501
        """git_lab_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitLabConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_lab_config_api_with_http_info(**kwargs)  # noqa: E501

    def git_lab_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_lab_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitLabConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_lab_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitLabConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/gitlab/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_lab_o_auth_authorize_api(self, **kwargs):  # noqa: E501
        """git_lab_o_auth_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_o_auth_authorize_api(async_req=True)
        >>> result = thread.get()

        :param git_lab_o_auth_authorize_api_input:
        :type git_lab_o_auth_authorize_api_input: GitLabOAuthAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.git_lab_o_auth_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def git_lab_o_auth_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_lab_o_auth_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_o_auth_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param git_lab_o_auth_authorize_api_input:
        :type git_lab_o_auth_authorize_api_input: GitLabOAuthAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'git_lab_o_auth_authorize_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_lab_o_auth_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_lab_o_auth_authorize_api_input' in local_var_params:
            body_params = local_var_params['git_lab_o_auth_authorize_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/gitlab/authorize/oauth', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_lab_token_authorize_api(self, **kwargs):  # noqa: E501
        """git_lab_token_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_token_authorize_api(async_req=True)
        >>> result = thread.get()

        :param git_lab_token_authorize_api_input:
        :type git_lab_token_authorize_api_input: GitLabTokenAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.git_lab_token_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def git_lab_token_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """git_lab_token_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_lab_token_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param git_lab_token_authorize_api_input:
        :type git_lab_token_authorize_api_input: GitLabTokenAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'git_lab_token_authorize_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_lab_token_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'git_lab_token_authorize_api_input' in local_var_params:
            body_params = local_var_params['git_lab_token_authorize_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/gitlab/authorize/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def git_repository_list_api(self, credentials_id, **kwargs):  # noqa: E501
        """git_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_repository_list_api(credentials_id, async_req=True)
        >>> result = thread.get()

        :param credentials_id: (required)
        :type credentials_id: int
        :param keyword:
        :type keyword: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGitRepositoryListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.git_repository_list_api_with_http_info(credentials_id, **kwargs)  # noqa: E501

    def git_repository_list_api_with_http_info(self, credentials_id, **kwargs):  # noqa: E501
        """git_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.git_repository_list_api_with_http_info(credentials_id, async_req=True)
        >>> result = thread.get()

        :param credentials_id: (required)
        :type credentials_id: int
        :param keyword:
        :type keyword: str
        :param page:
        :type page: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGitRepositoryListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'credentials_id',
            'keyword',
            'page'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method git_repository_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credentials_id' is set
        if self.api_client.client_side_validation and local_var_params.get('credentials_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `credentials_id` when calling `git_repository_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credentials_id' in local_var_params:
            path_params['credentialsID'] = local_var_params['credentials_id']  # noqa: E501

        query_params = []
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('page') is not None:  # noqa: E501
            query_params.append(('page', local_var_params['page']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGitRepositoryListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/git/credentials/{credentialsID}/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def google_config_api(self, **kwargs):  # noqa: E501
        """google_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalGoogleConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.google_config_api_with_http_info(**kwargs)  # noqa: E501

    def google_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """google_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.google_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalGoogleConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method google_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalGoogleConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/google/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def handle_stripe_webhook_v2_api(self, **kwargs):  # noqa: E501
        """handle_stripe_webhook_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.handle_stripe_webhook_v2_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.handle_stripe_webhook_v2_api_with_http_info(**kwargs)  # noqa: E501

    def handle_stripe_webhook_v2_api_with_http_info(self, **kwargs):  # noqa: E501
        """handle_stripe_webhook_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.handle_stripe_webhook_v2_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method handle_stripe_webhook_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/billing/stripe_webhook_v2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_create_api(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_create_api_input:
        :type hub_model_task_create_api_input: HubModelTaskCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1HubModelTaskSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def hub_model_task_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_create_api_input:
        :type hub_model_task_create_api_input: HubModelTaskCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1HubModelTaskSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'hub_model_task_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_create_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1HubModelTaskSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_delete_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_delete_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_delete_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_delete_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_delete_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_delete_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_history_list_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_history_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_history_list_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HubHubModelTaskHistoryListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_history_list_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_history_list_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_history_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_history_list_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HubHubModelTaskHistoryListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_history_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_history_list_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_history_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "HubHubModelTaskHistoryListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/histories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_list_api(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param category_id:
        :type category_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param scope:
        :type scope: str
        :param status:
        :type status: str
        :param types:
        :type types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HubHubModelTaskListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def hub_model_task_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param category_id:
        :type category_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param scope:
        :type scope: str
        :param status:
        :type status: str
        :param types:
        :type types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HubHubModelTaskListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'category_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'scope',
            'status',
            'types'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('category_id') is not None:  # noqa: E501
            query_params.append(('category_id', local_var_params['category_id']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('scope') is not None:  # noqa: E501
            query_params.append(('scope', local_var_params['scope']))  # noqa: E501
        if local_var_params.get('status') is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if local_var_params.get('types') is not None:  # noqa: E501
            query_params.append(('types', local_var_params['types']))  # noqa: E501
            collection_formats['types'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "HubHubModelTaskListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_spec_inspect_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_inspect_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_inspect_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1SpecInspectionResult
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_spec_inspect_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_spec_inspect_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_inspect_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_inspect_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1SpecInspectionResult, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_spec_inspect_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_spec_inspect_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_spec_inspect_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1SpecInspectionResult",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/inspect', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_spec_read_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_read_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_spec_read_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_spec_read_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_read_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_spec_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_spec_read_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_spec_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_spec_update_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_update_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_spec_update_api_input:
        :type hub_model_task_pipeline_spec_update_api_input: HubModelTaskPipelineSpecUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_spec_update_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_spec_update_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_spec_update_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_spec_update_api_input:
        :type hub_model_task_pipeline_spec_update_api_input: HubModelTaskPipelineSpecUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id',
            'hub_model_task_pipeline_spec_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_spec_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_spec_update_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_spec_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_pipeline_spec_update_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_pipeline_spec_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_create_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_create_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_create_api_input:
        :type hub_model_task_pipeline_step_create_api_input: HubModelTaskPipelineStepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_create_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_create_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_create_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_create_api_input:
        :type hub_model_task_pipeline_step_create_api_input: HubModelTaskPipelineStepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id',
            'hub_model_task_pipeline_step_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_create_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_pipeline_step_create_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_pipeline_step_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/steps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_delete_api(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_delete_api(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_delete_api_with_http_info(organization_name, step_id, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_delete_api_with_http_info(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_delete_api_with_http_info(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'step_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_delete_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `hub_model_task_pipeline_step_delete_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/steps/{stepID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_dependency_add_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_dependency_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_dependency_add_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_dependency_add_api_input:
        :type hub_model_task_pipeline_step_dependency_add_api_input: HubModelTaskPipelineStepDependencyAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_dependency_add_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_dependency_add_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_dependency_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_dependency_add_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_dependency_add_api_input:
        :type hub_model_task_pipeline_step_dependency_add_api_input: HubModelTaskPipelineStepDependencyAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id',
            'hub_model_task_pipeline_step_dependency_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_dependency_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_dependency_add_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_dependency_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_pipeline_step_dependency_add_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_pipeline_step_dependency_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/step_dependency_add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_dependency_remove_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_dependency_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_dependency_remove_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_dependency_remove_api_input:
        :type hub_model_task_pipeline_step_dependency_remove_api_input: HubModelTaskPipelineStepDependencyRemoveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_dependency_remove_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_dependency_remove_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_dependency_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_dependency_remove_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_dependency_remove_api_input:
        :type hub_model_task_pipeline_step_dependency_remove_api_input: HubModelTaskPipelineStepDependencyRemoveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id',
            'hub_model_task_pipeline_step_dependency_remove_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_dependency_remove_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_dependency_remove_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_dependency_remove_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_pipeline_step_dependency_remove_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_pipeline_step_dependency_remove_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/step_dependency_remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_read_api(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_read_api(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_read_api_with_http_info(organization_name, step_id, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_read_api_with_http_info(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_read_api_with_http_info(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'step_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_read_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `hub_model_task_pipeline_step_read_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/steps/{stepID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_pipeline_step_update_api(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_update_api(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_update_api_input:
        :type hub_model_task_pipeline_step_update_api_input: HubModelTaskPipelineStepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_pipeline_step_update_api_with_http_info(organization_name, step_id, task_id, **kwargs)  # noqa: E501

    def hub_model_task_pipeline_step_update_api_with_http_info(self, organization_name, step_id, task_id, **kwargs):  # noqa: E501
        """hub_model_task_pipeline_step_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_pipeline_step_update_api_with_http_info(organization_name, step_id, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_id: (required)
        :type step_id: int
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_pipeline_step_update_api_input:
        :type hub_model_task_pipeline_step_update_api_input: HubModelTaskPipelineStepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'step_id',
            'task_id',
            'hub_model_task_pipeline_step_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_pipeline_step_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_pipeline_step_update_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `hub_model_task_pipeline_step_update_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_pipeline_step_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_pipeline_step_update_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_pipeline_step_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}/pipelines/spec/steps/{stepID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_read_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_read_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1HubModelTaskSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_read_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_read_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_read_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1HubModelTaskSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_read_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1HubModelTaskSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_tag_create_api(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_tag_create_api_input:
        :type hub_model_task_tag_create_api_input: HubModelTaskTagCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_tag_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def hub_model_task_tag_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_tag_create_api_input:
        :type hub_model_task_tag_create_api_input: HubModelTaskTagCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'hub_model_task_tag_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_tag_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_tag_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_tag_create_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_tag_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_tag_delete_api(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_delete_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_tag_delete_api_input:
        :type hub_model_task_tag_delete_api_input: HubModelTaskTagDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_tag_delete_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def hub_model_task_tag_delete_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_delete_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param hub_model_task_tag_delete_api_input:
        :type hub_model_task_tag_delete_api_input: HubModelTaskTagDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'hub_model_task_tag_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_tag_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_tag_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_tag_delete_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_tag_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_tag_list_api(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id:
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HubHubModelTaskTagListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_tag_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def hub_model_task_tag_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """hub_model_task_tag_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_tag_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id:
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HubHubModelTaskTagListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_tag_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_tag_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('task_id') is not None:  # noqa: E501
            query_params.append(('task_id', local_var_params['task_id']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "HubHubModelTaskTagListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def hub_model_task_update_api(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_update_api(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_update_api_input:
        :type hub_model_task_update_api_input: HubModelTaskUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1HubModelTaskSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.hub_model_task_update_api_with_http_info(organization_name, task_id, **kwargs)  # noqa: E501

    def hub_model_task_update_api_with_http_info(self, organization_name, task_id, **kwargs):  # noqa: E501
        """hub_model_task_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hub_model_task_update_api_with_http_info(organization_name, task_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param task_id: (required)
        :type task_id: int
        :param hub_model_task_update_api_input:
        :type hub_model_task_update_api_input: HubModelTaskUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1HubModelTaskSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'task_id',
            'hub_model_task_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hub_model_task_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `hub_model_task_update_api`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `hub_model_task_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'hub_model_task_update_api_input' in local_var_params:
            body_params = local_var_params['hub_model_task_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PUT', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1HubModelTaskSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/hub/model_tasks/{taskID}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def invitation_token_validate_api(self, **kwargs):  # noqa: E501
        """invitation_token_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.invitation_token_validate_api(async_req=True)
        >>> result = thread.get()

        :param invitation_token_validate_api_input:
        :type invitation_token_validate_api_input: InvitationTokenValidateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountInvitationTokenValidateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.invitation_token_validate_api_with_http_info(**kwargs)  # noqa: E501

    def invitation_token_validate_api_with_http_info(self, **kwargs):  # noqa: E501
        """invitation_token_validate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.invitation_token_validate_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param invitation_token_validate_api_input:
        :type invitation_token_validate_api_input: InvitationTokenValidateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountInvitationTokenValidateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'invitation_token_validate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invitation_token_validate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invitation_token_validate_api_input' in local_var_params:
            body_params = local_var_params['invitation_token_validate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountInvitationTokenValidateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/invitation_token/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_image_list_api(self, organization_name, **kwargs):  # noqa: E501
        """kernel_image_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param processor_type:
        :type processor_type: str
        :param resource_id:
        :type resource_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: KernelKernelImageListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_image_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def kernel_image_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """kernel_image_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param processor_type:
        :type processor_type: str
        :param resource_id:
        :type resource_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(KernelKernelImageListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'processor_type',
            'resource_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_image_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_image_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('processor_type') is not None:  # noqa: E501
            query_params.append(('processor_type', local_var_params['processor_type']))  # noqa: E501
        if local_var_params.get('resource_id') is not None:  # noqa: E501
            query_params.append(('resource_id', local_var_params['resource_id']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "KernelKernelImageListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/kernels/images', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_image_publish_new_managed_image_api(self, **kwargs):  # noqa: E501
        """kernel_image_publish_new_managed_image_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_publish_new_managed_image_api(async_req=True)
        >>> result = thread.get()

        :param kernel_image_publish_new_managed_image_api_input:
        :type kernel_image_publish_new_managed_image_api_input: KernelImagePublishNewManagedImageAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_image_publish_new_managed_image_api_with_http_info(**kwargs)  # noqa: E501

    def kernel_image_publish_new_managed_image_api_with_http_info(self, **kwargs):  # noqa: E501
        """kernel_image_publish_new_managed_image_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_publish_new_managed_image_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param kernel_image_publish_new_managed_image_api_input:
        :type kernel_image_publish_new_managed_image_api_input: KernelImagePublishNewManagedImageAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'kernel_image_publish_new_managed_image_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_image_publish_new_managed_image_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'kernel_image_publish_new_managed_image_api_input' in local_var_params:
            body_params = local_var_params['kernel_image_publish_new_managed_image_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/kernels_images/publish_new_managed_image', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_image_read_api(self, image_id, **kwargs):  # noqa: E501
        """kernel_image_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_read_api(image_id, async_req=True)
        >>> result = thread.get()

        :param image_id: (required)
        :type image_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelImage
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_image_read_api_with_http_info(image_id, **kwargs)  # noqa: E501

    def kernel_image_read_api_with_http_info(self, image_id, **kwargs):  # noqa: E501
        """kernel_image_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_image_read_api_with_http_info(image_id, async_req=True)
        >>> result = thread.get()

        :param image_id: (required)
        :type image_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelImage, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'image_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_image_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'image_id' is set
        if self.api_client.client_side_validation and local_var_params.get('image_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `image_id` when calling `kernel_image_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'image_id' in local_var_params:
            path_params['imageID'] = local_var_params['image_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelImage",
        }

        return self.api_client.call_api(
            '/api/v1/kernels_images/{imageID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_create_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_create_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param kernel_resource_spec_create_api_input:
        :type kernel_resource_spec_create_api_input: KernelResourceSpecCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelResourceSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_create_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def kernel_resource_spec_create_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_create_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param kernel_resource_spec_create_api_input:
        :type kernel_resource_spec_create_api_input: KernelResourceSpecCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelResourceSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'kernel_resource_spec_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `kernel_resource_spec_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_resource_spec_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'kernel_resource_spec_create_api_input' in local_var_params:
            body_params = local_var_params['kernel_resource_spec_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelResourceSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/resource_specs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_delete_api(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_delete_api(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_delete_api_with_http_info(cluster_id, organization_name, resource_spec_id, **kwargs)  # noqa: E501

    def kernel_resource_spec_delete_api_with_http_info(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_delete_api_with_http_info(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'resource_spec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `kernel_resource_spec_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_resource_spec_delete_api`")  # noqa: E501
        # verify the required parameter 'resource_spec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('resource_spec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_spec_id` when calling `kernel_resource_spec_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'resource_spec_id' in local_var_params:
            path_params['resourceSpecID'] = local_var_params['resource_spec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/resource_specs/{resourceSpecID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_list_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_list_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param show_deleted:
        :type show_deleted: bool
        :param show_unusable:
        :type show_unusable: bool
        :param type_filter:
        :type type_filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: KernelKernelResourceSpecListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_list_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def kernel_resource_spec_list_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """kernel_resource_spec_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_list_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param show_deleted:
        :type show_deleted: bool
        :param show_unusable:
        :type show_unusable: bool
        :param type_filter:
        :type type_filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(KernelKernelResourceSpecListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'show_deleted',
            'show_unusable',
            'type_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `kernel_resource_spec_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_resource_spec_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('show_deleted') is not None:  # noqa: E501
            query_params.append(('show_deleted', local_var_params['show_deleted']))  # noqa: E501
        if local_var_params.get('show_unusable') is not None:  # noqa: E501
            query_params.append(('show_unusable', local_var_params['show_unusable']))  # noqa: E501
        if local_var_params.get('type_filter') is not None:  # noqa: E501
            query_params.append(('type_filter', local_var_params['type_filter']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "KernelKernelResourceSpecListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/resource_specs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_read_api(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_read_api(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelResourceSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_read_api_with_http_info(cluster_id, organization_name, resource_spec_id, **kwargs)  # noqa: E501

    def kernel_resource_spec_read_api_with_http_info(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_read_api_with_http_info(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelResourceSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'resource_spec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `kernel_resource_spec_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_resource_spec_read_api`")  # noqa: E501
        # verify the required parameter 'resource_spec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('resource_spec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_spec_id` when calling `kernel_resource_spec_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'resource_spec_id' in local_var_params:
            path_params['resourceSpecID'] = local_var_params['resource_spec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelResourceSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/resource_specs/{resourceSpecID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def kernel_resource_spec_update_api(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_update_api(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param kernel_resource_spec_update_api_input:
        :type kernel_resource_spec_update_api_input: KernelResourceSpecUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelResourceSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.kernel_resource_spec_update_api_with_http_info(cluster_id, organization_name, resource_spec_id, **kwargs)  # noqa: E501

    def kernel_resource_spec_update_api_with_http_info(self, cluster_id, organization_name, resource_spec_id, **kwargs):  # noqa: E501
        """kernel_resource_spec_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.kernel_resource_spec_update_api_with_http_info(cluster_id, organization_name, resource_spec_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param resource_spec_id: (required)
        :type resource_spec_id: int
        :param kernel_resource_spec_update_api_input:
        :type kernel_resource_spec_update_api_input: KernelResourceSpecUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelResourceSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name',
            'resource_spec_id',
            'kernel_resource_spec_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method kernel_resource_spec_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `kernel_resource_spec_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `kernel_resource_spec_update_api`")  # noqa: E501
        # verify the required parameter 'resource_spec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('resource_spec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `resource_spec_id` when calling `kernel_resource_spec_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'resource_spec_id' in local_var_params:
            path_params['resourceSpecID'] = local_var_params['resource_spec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'kernel_resource_spec_update_api_input' in local_var_params:
            body_params = local_var_params['kernel_resource_spec_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelResourceSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/clusters/{clusterID}/resource_specs/{resourceSpecID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_bulk_delete_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_bulk_delete_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_bulk_delete_api_input:
        :type llm_document_bulk_delete_api_input: LLMDocumentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_bulk_delete_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_bulk_delete_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_bulk_delete_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_bulk_delete_api_input:
        :type llm_document_bulk_delete_api_input: LLMDocumentBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'llm_document_bulk_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_bulk_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_bulk_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_bulk_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_document_bulk_delete_api_input' in local_var_params:
            body_params = local_var_params['llm_document_bulk_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/documents', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_create_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_create_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_create_api_input:
        :type llm_document_create_api_input: LLMDocumentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMDocumentCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_create_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_create_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_create_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_create_api_input:
        :type llm_document_create_api_input: LLMDocumentCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMDocumentCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'llm_document_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_document_create_api_input' in local_var_params:
            body_params = local_var_params['llm_document_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMDocumentCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/document', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_delete_api(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_delete_api(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_delete_api_with_http_info(document_id, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_delete_api_with_http_info(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_delete_api_with_http_info(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'document_id',
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'document_id' is set
        if self.api_client.client_side_validation and local_var_params.get('document_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `document_id` when calling `l_lm_document_delete_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in local_var_params:
            path_params['documentID'] = local_var_params['document_id']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/documents/{documentID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_list_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_list_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMDocumentListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_list_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_list_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_list_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMDocumentListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMDocumentListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/documents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_read_api(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_read_api(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMDocumentReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_read_api_with_http_info(document_id, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_read_api_with_http_info(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_read_api_with_http_info(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMDocumentReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'document_id',
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'document_id' is set
        if self.api_client.client_side_validation and local_var_params.get('document_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `document_id` when calling `l_lm_document_read_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in local_var_params:
            path_params['documentID'] = local_var_params['document_id']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMDocumentReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/document/{documentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_document_update_api(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_update_api(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_update_api_input:
        :type llm_document_update_api_input: LLMDocumentUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_document_update_api_with_http_info(document_id, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_document_update_api_with_http_info(self, document_id, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_document_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_document_update_api_with_http_info(document_id, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param document_id: (required)
        :type document_id: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_document_update_api_input:
        :type llm_document_update_api_input: LLMDocumentUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'document_id',
            'knowledge_name',
            'organization_name',
            'llm_document_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_document_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'document_id' is set
        if self.api_client.client_side_validation and local_var_params.get('document_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `document_id` when calling `l_lm_document_update_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_document_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_document_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in local_var_params:
            path_params['documentId'] = local_var_params['document_id']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_document_update_api_input' in local_var_params:
            body_params = local_var_params['llm_document_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/document/{documentId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_create_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_create_api_input:
        :type llm_knowledge_create_api_input: LLMKnowledgeCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_create_api_input:
        :type llm_knowledge_create_api_input: LLMKnowledgeCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'llm_knowledge_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_create_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_delete_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_delete_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_delete_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_delete_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_delete_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeDeleteResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_ingestion_job_create_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_create_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_ingestion_job_create_api_input:
        :type llm_knowledge_ingestion_job_create_api_input: LLMKnowledgeIngestionJobCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeIngestionJobCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_ingestion_job_create_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_ingestion_job_create_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_create_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_ingestion_job_create_api_input:
        :type llm_knowledge_ingestion_job_create_api_input: LLMKnowledgeIngestionJobCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeIngestionJobCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'llm_knowledge_ingestion_job_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_ingestion_job_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_ingestion_job_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_ingestion_job_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_ingestion_job_create_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_ingestion_job_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeIngestionJobCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/ingestion/job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_ingestion_job_read_api(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_read_api(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeIngestionJobReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_ingestion_job_read_api_with_http_info(job_number, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_ingestion_job_read_api_with_http_info(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_read_api_with_http_info(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeIngestionJobReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'job_number',
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_ingestion_job_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_number' is set
        if self.api_client.client_side_validation and local_var_params.get('job_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_number` when calling `l_lm_knowledge_ingestion_job_read_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_ingestion_job_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_ingestion_job_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_number' in local_var_params:
            path_params['jobNumber'] = local_var_params['job_number']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeIngestionJobReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/ingestion/job/{jobNumber}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_ingestion_job_status_update_api(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_status_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_status_update_api(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_ingestion_job_status_update_api_input:
        :type llm_knowledge_ingestion_job_status_update_api_input: LLMKnowledgeIngestionJobStatusUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeIngestionJobStatusUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_ingestion_job_status_update_api_with_http_info(job_number, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_ingestion_job_status_update_api_with_http_info(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_ingestion_job_status_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_ingestion_job_status_update_api_with_http_info(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_ingestion_job_status_update_api_input:
        :type llm_knowledge_ingestion_job_status_update_api_input: LLMKnowledgeIngestionJobStatusUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeIngestionJobStatusUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'job_number',
            'knowledge_name',
            'organization_name',
            'llm_knowledge_ingestion_job_status_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_ingestion_job_status_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_number' is set
        if self.api_client.client_side_validation and local_var_params.get('job_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_number` when calling `l_lm_knowledge_ingestion_job_status_update_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_ingestion_job_status_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_ingestion_job_status_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_number' in local_var_params:
            path_params['jobNumber'] = local_var_params['job_number']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_ingestion_job_status_update_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_ingestion_job_status_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeIngestionJobStatusUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/llm/knowledge/{knowledgeName}/ingestion/job/{jobNumber}/status', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_list_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_read_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_read_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_read_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_read_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_read_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_retriever_job_create_or_read_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_create_or_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_create_or_read_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeRetrieverJobCreateOrReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_retriever_job_create_or_read_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_retriever_job_create_or_read_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_create_or_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_create_or_read_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeRetrieverJobCreateOrReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_retriever_job_create_or_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_retriever_job_create_or_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_retriever_job_create_or_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeRetrieverJobCreateOrReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/retriever/job', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_retriever_job_read_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_read_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeRetrieverJobReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_retriever_job_read_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_retriever_job_read_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_read_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeRetrieverJobReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_retriever_job_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_retriever_job_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_retriever_job_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeRetrieverJobReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/retriever/job', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_retriever_job_status_update_api(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_status_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_status_update_api(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_retriever_job_status_update_api_input:
        :type llm_knowledge_retriever_job_status_update_api_input: LLMKnowledgeRetrieverJobStatusUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeRetrieverJobStatusUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_retriever_job_status_update_api_with_http_info(job_number, knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_retriever_job_status_update_api_with_http_info(self, job_number, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_job_status_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_job_status_update_api_with_http_info(job_number, knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param job_number: (required)
        :type job_number: int
        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_retriever_job_status_update_api_input:
        :type llm_knowledge_retriever_job_status_update_api_input: LLMKnowledgeRetrieverJobStatusUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeRetrieverJobStatusUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'job_number',
            'knowledge_name',
            'organization_name',
            'llm_knowledge_retriever_job_status_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_retriever_job_status_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_number' is set
        if self.api_client.client_side_validation and local_var_params.get('job_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `job_number` when calling `l_lm_knowledge_retriever_job_status_update_api`")  # noqa: E501
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_retriever_job_status_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_retriever_job_status_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_number' in local_var_params:
            path_params['jobNumber'] = local_var_params['job_number']  # noqa: E501
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_retriever_job_status_update_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_retriever_job_status_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeRetrieverJobStatusUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/llm/knowledge/{knowledgeName}/retriever/job/{jobNumber}/status', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_retriever_query_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_query_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_query_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_retriever_query_api_input:
        :type llm_knowledge_retriever_query_api_input: LLMKnowledgeRetrieverQueryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeRetrieverQueryResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_retriever_query_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_retriever_query_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_retriever_query_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_retriever_query_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_retriever_query_api_input:
        :type llm_knowledge_retriever_query_api_input: LLMKnowledgeRetrieverQueryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeRetrieverQueryResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'llm_knowledge_retriever_query_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_retriever_query_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_retriever_query_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_retriever_query_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_retriever_query_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_retriever_query_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeRetrieverQueryResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}/retriever/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_knowledge_update_api(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_update_api(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_update_api_input:
        :type llm_knowledge_update_api_input: LLMKnowledgeUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMKnowledgeUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_knowledge_update_api_with_http_info(knowledge_name, organization_name, **kwargs)  # noqa: E501

    def l_lm_knowledge_update_api_with_http_info(self, knowledge_name, organization_name, **kwargs):  # noqa: E501
        """l_lm_knowledge_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_knowledge_update_api_with_http_info(knowledge_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param knowledge_name: (required)
        :type knowledge_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param llm_knowledge_update_api_input:
        :type llm_knowledge_update_api_input: LLMKnowledgeUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMKnowledgeUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'knowledge_name',
            'organization_name',
            'llm_knowledge_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_knowledge_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'knowledge_name' is set
        if self.api_client.client_side_validation and local_var_params.get('knowledge_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `knowledge_name` when calling `l_lm_knowledge_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_knowledge_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'knowledge_name' in local_var_params:
            path_params['knowledgeName'] = local_var_params['knowledge_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_knowledge_update_api_input' in local_var_params:
            body_params = local_var_params['llm_knowledge_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMKnowledgeUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/knowledge/{knowledgeName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_connection_create_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_connection_create_api_input:
        :type llm_model_connection_create_api_input: LLMModelConnectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelConnCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_connection_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_model_connection_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_connection_create_api_input:
        :type llm_model_connection_create_api_input: LLMModelConnectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelConnCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'llm_model_connection_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_connection_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_connection_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_connection_create_api_input' in local_var_params:
            body_params = local_var_params['llm_model_connection_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelConnCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_connection_delete_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_delete_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelConnDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_connection_delete_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_connection_delete_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_delete_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelConnDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_connection_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_connection_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_connection_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelConnDeleteResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_connection_list_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelConnListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_connection_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_model_connection_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelConnListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_connection_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_connection_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('type') is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelConnListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_connection_read_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_read_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelConnReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_connection_read_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_connection_read_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_read_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelConnReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_connection_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_connection_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_connection_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelConnReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_connection_update_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_update_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_connection_update_api_input:
        :type llm_model_connection_update_api_input: LLMModelConnectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelConnUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_connection_update_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_connection_update_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_connection_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_connection_update_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_connection_update_api_input:
        :type llm_model_connection_update_api_input: LLMModelConnectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelConnUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'llm_model_connection_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_connection_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_connection_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_connection_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_connection_update_api_input' in local_var_params:
            body_params = local_var_params['llm_model_connection_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelConnUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_definition_create_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_create_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_parameter_definition_create_api_input:
        :type llm_model_parameter_definition_create_api_input: LLMModelParameterDefinitionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMModelParameterDefinition
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_definition_create_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_parameter_definition_create_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_create_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_parameter_definition_create_api_input:
        :type llm_model_parameter_definition_create_api_input: LLMModelParameterDefinitionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMModelParameterDefinition, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'llm_model_parameter_definition_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_definition_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_definition_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_definition_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_parameter_definition_create_api_input' in local_var_params:
            body_params = local_var_params['llm_model_parameter_definition_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMModelParameterDefinition",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/definitions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_definition_delete_api(self, connection_id, organization_name, parameter_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_delete_api(connection_id, organization_name, parameter_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param parameter_id: (required)
        :type parameter_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_definition_delete_api_with_http_info(connection_id, organization_name, parameter_id, **kwargs)  # noqa: E501

    def l_lm_model_parameter_definition_delete_api_with_http_info(self, connection_id, organization_name, parameter_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_delete_api_with_http_info(connection_id, organization_name, parameter_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param parameter_id: (required)
        :type parameter_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'parameter_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_definition_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_definition_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_definition_delete_api`")  # noqa: E501
        # verify the required parameter 'parameter_id' is set
        if self.api_client.client_side_validation and local_var_params.get('parameter_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `parameter_id` when calling `l_lm_model_parameter_definition_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'parameter_id' in local_var_params:
            path_params['parameterID'] = local_var_params['parameter_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/definitions/{parameterID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_definition_list_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_list_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelParameterDefinitionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_definition_list_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_parameter_definition_list_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_list_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelParameterDefinitionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_definition_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_definition_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_definition_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelParameterDefinitionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/definitions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_definition_update_api(self, connection_id, organization_name, parameter_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_update_api(connection_id, organization_name, parameter_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param parameter_id: (required)
        :type parameter_id: int
        :param llm_model_parameter_definition_update_api_input:
        :type llm_model_parameter_definition_update_api_input: LLMModelParameterDefinitionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMModelParameterDefinition
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_definition_update_api_with_http_info(connection_id, organization_name, parameter_id, **kwargs)  # noqa: E501

    def l_lm_model_parameter_definition_update_api_with_http_info(self, connection_id, organization_name, parameter_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_definition_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_definition_update_api_with_http_info(connection_id, organization_name, parameter_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param parameter_id: (required)
        :type parameter_id: int
        :param llm_model_parameter_definition_update_api_input:
        :type llm_model_parameter_definition_update_api_input: LLMModelParameterDefinitionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMModelParameterDefinition, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'parameter_id',
            'llm_model_parameter_definition_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_definition_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_definition_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_definition_update_api`")  # noqa: E501
        # verify the required parameter 'parameter_id' is set
        if self.api_client.client_side_validation and local_var_params.get('parameter_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `parameter_id` when calling `l_lm_model_parameter_definition_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'parameter_id' in local_var_params:
            path_params['parameterID'] = local_var_params['parameter_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_parameter_definition_update_api_input' in local_var_params:
            body_params = local_var_params['llm_model_parameter_definition_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMModelParameterDefinition",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/definitions/{parameterID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_preset_create_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_create_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_parameter_preset_create_api_input:
        :type llm_model_parameter_preset_create_api_input: LLMModelParameterPresetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMModelParameterPreset
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_preset_create_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_parameter_preset_create_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_create_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_model_parameter_preset_create_api_input:
        :type llm_model_parameter_preset_create_api_input: LLMModelParameterPresetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMModelParameterPreset, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'llm_model_parameter_preset_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_preset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_preset_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_preset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_parameter_preset_create_api_input' in local_var_params:
            body_params = local_var_params['llm_model_parameter_preset_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMModelParameterPreset",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/presets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_preset_delete_api(self, connection_id, organization_name, preset_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_delete_api(connection_id, organization_name, preset_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param preset_id: (required)
        :type preset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_preset_delete_api_with_http_info(connection_id, organization_name, preset_id, **kwargs)  # noqa: E501

    def l_lm_model_parameter_preset_delete_api_with_http_info(self, connection_id, organization_name, preset_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_delete_api_with_http_info(connection_id, organization_name, preset_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param preset_id: (required)
        :type preset_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'preset_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_preset_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_preset_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_preset_delete_api`")  # noqa: E501
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('preset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `preset_id` when calling `l_lm_model_parameter_preset_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'preset_id' in local_var_params:
            path_params['presetID'] = local_var_params['preset_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/presets/{presetID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_preset_list_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_list_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMModelParameterPresetListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_preset_list_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_model_parameter_preset_list_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_list_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMModelParameterPresetListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_preset_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_preset_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_preset_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMModelParameterPresetListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/presets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_model_parameter_preset_update_api(self, connection_id, organization_name, preset_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_update_api(connection_id, organization_name, preset_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param preset_id: (required)
        :type preset_id: int
        :param llm_model_parameter_preset_update_api_input:
        :type llm_model_parameter_preset_update_api_input: LLMModelParameterPresetUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMModelParameterPreset
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_model_parameter_preset_update_api_with_http_info(connection_id, organization_name, preset_id, **kwargs)  # noqa: E501

    def l_lm_model_parameter_preset_update_api_with_http_info(self, connection_id, organization_name, preset_id, **kwargs):  # noqa: E501
        """l_lm_model_parameter_preset_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_model_parameter_preset_update_api_with_http_info(connection_id, organization_name, preset_id, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param preset_id: (required)
        :type preset_id: int
        :param llm_model_parameter_preset_update_api_input:
        :type llm_model_parameter_preset_update_api_input: LLMModelParameterPresetUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMModelParameterPreset, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'preset_id',
            'llm_model_parameter_preset_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_model_parameter_preset_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_model_parameter_preset_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_model_parameter_preset_update_api`")  # noqa: E501
        # verify the required parameter 'preset_id' is set
        if self.api_client.client_side_validation and local_var_params.get('preset_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `preset_id` when calling `l_lm_model_parameter_preset_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'preset_id' in local_var_params:
            path_params['presetID'] = local_var_params['preset_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_model_parameter_preset_update_api_input' in local_var_params:
            body_params = local_var_params['llm_model_parameter_preset_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMModelParameterPreset",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/model/{connectionID}/parameters/presets/{presetID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_user_group_create_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_user_group_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_user_group_create_api_input:
        :type llm_user_group_create_api_input: LLMUserGroupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMUserGroup
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_user_group_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_user_group_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_user_group_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_user_group_create_api_input:
        :type llm_user_group_create_api_input: LLMUserGroupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMUserGroup, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'llm_user_group_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_user_group_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_user_group_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_user_group_create_api_input' in local_var_params:
            body_params = local_var_params['llm_user_group_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMUserGroup",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_user_group_delete_api(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_delete_api(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_user_group_delete_api_with_http_info(organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lm_user_group_delete_api_with_http_info(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_delete_api_with_http_info(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_user_group_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_user_group_delete_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lm_user_group_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_user_group_list_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_user_group_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMUserGroupListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_user_group_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_user_group_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_user_group_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMUserGroupListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_user_group_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_user_group_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMUserGroupListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_user_group_read_api(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_read_api(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMUserGroup
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_user_group_read_api_with_http_info(organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lm_user_group_read_api_with_http_info(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_read_api_with_http_info(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMUserGroup, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_user_group_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_user_group_read_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lm_user_group_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMUserGroup",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_user_group_update_api(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_update_api(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llm_user_group_update_api_input:
        :type llm_user_group_update_api_input: LLMUserGroupUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMUserGroup
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_user_group_update_api_with_http_info(organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lm_user_group_update_api_with_http_info(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lm_user_group_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_user_group_update_api_with_http_info(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llm_user_group_update_api_input:
        :type llm_user_group_update_api_input: LLMUserGroupUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMUserGroup, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_name',
            'llm_user_group_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_user_group_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_user_group_update_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lm_user_group_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_user_group_update_api_input' in local_var_params:
            body_params = local_var_params['llm_user_group_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMUserGroup",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_vector_db_connection_create_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_vector_db_connection_create_api_input:
        :type llm_vector_db_connection_create_api_input: LLMVectorDBConnectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMVectorDBConnCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_vector_db_connection_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_vector_db_connection_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_vector_db_connection_create_api_input:
        :type llm_vector_db_connection_create_api_input: LLMVectorDBConnectionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMVectorDBConnCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'llm_vector_db_connection_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_vector_db_connection_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_vector_db_connection_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_vector_db_connection_create_api_input' in local_var_params:
            body_params = local_var_params['llm_vector_db_connection_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMVectorDBConnCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/vectordb_connection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_vector_db_connection_delete_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_delete_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMVectorDBConnDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_vector_db_connection_delete_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_vector_db_connection_delete_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_delete_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMVectorDBConnDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_vector_db_connection_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_vector_db_connection_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_vector_db_connection_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMVectorDBConnDeleteResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/vectordb_connection/{connectionID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_vector_db_connection_list_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMVectorDBConnListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_vector_db_connection_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_vector_db_connection_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMVectorDBConnListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_vector_db_connection_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_vector_db_connection_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMVectorDBConnListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/vectordb_connection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_vector_db_connection_read_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_read_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMVectorDBConnReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_vector_db_connection_read_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_vector_db_connection_read_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_read_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMVectorDBConnReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_vector_db_connection_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_vector_db_connection_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_vector_db_connection_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMVectorDBConnReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/vectordb_connection/{connectionID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_vector_db_connection_update_api(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_update_api(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_vector_db_connection_update_api_input:
        :type llm_vector_db_connection_update_api_input: LLMVectorDBConnectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMVectorDBConnUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_vector_db_connection_update_api_with_http_info(connection_id, organization_name, **kwargs)  # noqa: E501

    def l_lm_vector_db_connection_update_api_with_http_info(self, connection_id, organization_name, **kwargs):  # noqa: E501
        """l_lm_vector_db_connection_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_vector_db_connection_update_api_with_http_info(connection_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param connection_id: (required)
        :type connection_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param llm_vector_db_connection_update_api_input:
        :type llm_vector_db_connection_update_api_input: LLMVectorDBConnectionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMVectorDBConnUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'connection_id',
            'organization_name',
            'llm_vector_db_connection_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_vector_db_connection_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'connection_id' is set
        if self.api_client.client_side_validation and local_var_params.get('connection_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `connection_id` when calling `l_lm_vector_db_connection_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_vector_db_connection_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connection_id' in local_var_params:
            path_params['connectionID'] = local_var_params['connection_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_vector_db_connection_update_api_input' in local_var_params:
            body_params = local_var_params['llm_vector_db_connection_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMVectorDBConnUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/vectordb_connection/{connectionID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_create_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_workflow_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_workflow_create_api_input:
        :type llm_workflow_create_api_input: LLMWorkflowCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_workflow_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_workflow_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param llm_workflow_create_api_input:
        :type llm_workflow_create_api_input: LLMWorkflowCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'llm_workflow_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_create_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_create_test_session_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_create_test_session_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_create_test_session_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_create_test_session_api_input:
        :type llm_workflow_create_test_session_api_input: LLMWorkflowCreateTestSessionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowCreateTestSessionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_create_test_session_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_create_test_session_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_create_test_session_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_create_test_session_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_create_test_session_api_input:
        :type llm_workflow_create_test_session_api_input: LLMWorkflowCreateTestSessionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowCreateTestSessionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name',
            'llm_workflow_create_test_session_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_create_test_session_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_create_test_session_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_create_test_session_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_create_test_session_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_create_test_session_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowCreateTestSessionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/test_session', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_delete_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_delete_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_delete_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_delete_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_delete_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_delete_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_deploy_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_deploy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_deploy_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_deploy_api_input:
        :type llm_workflow_deploy_api_input: LLMWorkflowDeployAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_deploy_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_deploy_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_deploy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_deploy_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_deploy_api_input:
        :type llm_workflow_deploy_api_input: LLMWorkflowDeployAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name',
            'llm_workflow_deploy_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_deploy_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_deploy_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_deploy_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_deploy_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_deploy_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/deploy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_list_api(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_workflow_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def l_lm_workflow_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """l_lm_workflow_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_read_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_read_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_read_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_read_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_read_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_read_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_read_test_session_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_read_test_session_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_read_test_session_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowReadTestSessionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_read_test_session_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_read_test_session_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_read_test_session_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_read_test_session_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowReadTestSessionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_read_test_session_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_read_test_session_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_read_test_session_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowReadTestSessionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/test_session', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_add_tags_api(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_add_tags_api(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_add_tags_api_input:
        :type llm_workflow_revision_add_tags_api_input: LLMWorkflowRevisionAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_add_tags_api_with_http_info(number, organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_add_tags_api_with_http_info(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_add_tags_api_with_http_info(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_add_tags_api_input:
        :type llm_workflow_revision_add_tags_api_input: LLMWorkflowRevisionAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'workflow_name',
            'llm_workflow_revision_add_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_add_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `l_lm_workflow_revision_add_tags_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_add_tags_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_add_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_revision_add_tags_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_revision_add_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/{number}/add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_create_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_create_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_create_api_input:
        :type llm_workflow_revision_create_api_input: LLMWorkflowRevisionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowRevisionCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_create_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_create_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_create_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_create_api_input:
        :type llm_workflow_revision_create_api_input: LLMWorkflowRevisionCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowRevisionCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name',
            'llm_workflow_revision_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_create_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_revision_create_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_revision_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowRevisionCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_delete_api(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_delete_api(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_delete_api_with_http_info(number, organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_delete_api_with_http_info(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_delete_api_with_http_info(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `l_lm_workflow_revision_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_delete_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/{number}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_list_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_list_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param message_contains:
        :type message_contains: str
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred_only:
        :type starred_only: bool
        :param with_tags:
        :type with_tags: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowRevisionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_list_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_list_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_list_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param limit:
        :type limit: int
        :param message_contains:
        :type message_contains: str
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred_only:
        :type starred_only: bool
        :param with_tags:
        :type with_tags: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowRevisionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name',
            'cursor_end_id',
            'cursor_start_id',
            'limit',
            'message_contains',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'starred_only',
            'with_tags'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_list_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('message_contains') is not None:  # noqa: E501
            query_params.append(('message_contains', local_var_params['message_contains']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('starred_only') is not None:  # noqa: E501
            query_params.append(('starred_only', local_var_params['starred_only']))  # noqa: E501
        if local_var_params.get('with_tags') is not None:  # noqa: E501
            query_params.append(('with_tags', local_var_params['with_tags']))  # noqa: E501
            collection_formats['with_tags'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowRevisionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_read_api(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_read_api(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowRevisionReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_read_api_with_http_info(number, organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_read_api_with_http_info(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_read_api_with_http_info(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowRevisionReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `l_lm_workflow_revision_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_read_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowRevisionReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/{number}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_read_latest_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_read_latest_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_read_latest_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowRevisionReadLatestResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_read_latest_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_read_latest_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_read_latest_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_read_latest_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowRevisionReadLatestResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_read_latest_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_read_latest_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_read_latest_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowRevisionReadLatestResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_remove_tags_api(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_remove_tags_api(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_remove_tags_api_input:
        :type llm_workflow_revision_remove_tags_api_input: LLMWorkflowRevisionRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_remove_tags_api_with_http_info(number, organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_remove_tags_api_with_http_info(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_remove_tags_api_with_http_info(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_remove_tags_api_input:
        :type llm_workflow_revision_remove_tags_api_input: LLMWorkflowRevisionRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'workflow_name',
            'llm_workflow_revision_remove_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_remove_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `l_lm_workflow_revision_remove_tags_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_remove_tags_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_remove_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_revision_remove_tags_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_revision_remove_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/{number}/remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_revision_update_star_api(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_update_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_update_star_api(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_update_star_api_input:
        :type llm_workflow_revision_update_star_api_input: LLMWorkflowRevisionUpdateStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_revision_update_star_api_with_http_info(number, organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_revision_update_star_api_with_http_info(self, number, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_revision_update_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_revision_update_star_api_with_http_info(number, organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_revision_update_star_api_input:
        :type llm_workflow_revision_update_star_api_input: LLMWorkflowRevisionUpdateStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'workflow_name',
            'llm_workflow_revision_update_star_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_revision_update_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `l_lm_workflow_revision_update_star_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_revision_update_star_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_revision_update_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_revision_update_star_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_revision_update_star_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/revision/{number}/star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_terminate_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_terminate_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_terminate_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_terminate_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_terminate_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_terminate_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lm_workflow_update_settings_api(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_update_settings_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_update_settings_api(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_update_settings_api_input:
        :type llm_workflow_update_settings_api_input: LLMWorkflowUpdateSettingsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMWorkflowUpdateSettingsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lm_workflow_update_settings_api_with_http_info(organization_name, workflow_name, **kwargs)  # noqa: E501

    def l_lm_workflow_update_settings_api_with_http_info(self, organization_name, workflow_name, **kwargs):  # noqa: E501
        """l_lm_workflow_update_settings_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lm_workflow_update_settings_api_with_http_info(organization_name, workflow_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workflow_name: (required)
        :type workflow_name: str
        :param llm_workflow_update_settings_api_input:
        :type llm_workflow_update_settings_api_input: LLMWorkflowUpdateSettingsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMWorkflowUpdateSettingsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workflow_name',
            'llm_workflow_update_settings_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lm_workflow_update_settings_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lm_workflow_update_settings_api`")  # noqa: E501
        # verify the required parameter 'workflow_name' is set
        if self.api_client.client_side_validation and local_var_params.get('workflow_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workflow_name` when calling `l_lm_workflow_update_settings_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workflow_name' in local_var_params:
            path_params['workflowName'] = local_var_params['workflow_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llm_workflow_update_settings_api_input' in local_var_params:
            body_params = local_var_params['llm_workflow_update_settings_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMWorkflowUpdateSettingsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/workflow/{workflowName}/settings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lmapi_key_create_api(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_create_api(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llmapi_key_create_api_input:
        :type llmapi_key_create_api_input: LLMAPIKeyCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMAPIKey
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lmapi_key_create_api_with_http_info(organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lmapi_key_create_api_with_http_info(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_create_api_with_http_info(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llmapi_key_create_api_input:
        :type llmapi_key_create_api_input: LLMAPIKeyCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMAPIKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_name',
            'llmapi_key_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lmapi_key_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lmapi_key_create_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lmapi_key_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llmapi_key_create_api_input' in local_var_params:
            body_params = local_var_params['llmapi_key_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMAPIKey",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}/apikey', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lmapi_key_delete_api(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_delete_api(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMAPIKey
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lmapi_key_delete_api_with_http_info(api_key_name, organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lmapi_key_delete_api_with_http_info(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_delete_api_with_http_info(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMAPIKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'api_key_name',
            'organization_name',
            'user_group_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lmapi_key_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_name' is set
        if self.api_client.client_side_validation and local_var_params.get('api_key_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_name` when calling `l_lmapi_key_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lmapi_key_delete_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lmapi_key_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key_name' in local_var_params:
            path_params['apiKeyName'] = local_var_params['api_key_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMAPIKey",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}/apikey/{apiKeyName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lmapi_key_list_api(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_list_api(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: LlmLLMAPIKeyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lmapi_key_list_api_with_http_info(organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lmapi_key_list_api_with_http_info(self, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_list_api_with_http_info(organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param cursor_end_id:
        :type cursor_end_id: int
        :param cursor_start_id:
        :type cursor_start_id: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(LlmLLMAPIKeyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_name',
            'cursor_end_id',
            'cursor_start_id',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lmapi_key_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lmapi_key_list_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lmapi_key_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_end_id') is not None:  # noqa: E501
            query_params.append(('cursor_end_id', local_var_params['cursor_end_id']))  # noqa: E501
        if local_var_params.get('cursor_start_id') is not None:  # noqa: E501
            query_params.append(('cursor_start_id', local_var_params['cursor_start_id']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "LlmLLMAPIKeyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}/apikey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lmapi_key_read_api(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_read_api(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMAPIKey
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lmapi_key_read_api_with_http_info(api_key_name, organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lmapi_key_read_api_with_http_info(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_read_api_with_http_info(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMAPIKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'api_key_name',
            'organization_name',
            'user_group_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lmapi_key_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_name' is set
        if self.api_client.client_side_validation and local_var_params.get('api_key_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_name` when calling `l_lmapi_key_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lmapi_key_read_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lmapi_key_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key_name' in local_var_params:
            path_params['apiKeyName'] = local_var_params['api_key_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMAPIKey",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}/apikey/{apiKeyName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def l_lmapi_key_update_api(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_update_api(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llmapi_key_update_api_input:
        :type llmapi_key_update_api_input: LLMAPIKeyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProtoLLMAPIKey
        """
        kwargs['_return_http_data_only'] = True
        return self.l_lmapi_key_update_api_with_http_info(api_key_name, organization_name, user_group_name, **kwargs)  # noqa: E501

    def l_lmapi_key_update_api_with_http_info(self, api_key_name, organization_name, user_group_name, **kwargs):  # noqa: E501
        """l_lmapi_key_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.l_lmapi_key_update_api_with_http_info(api_key_name, organization_name, user_group_name, async_req=True)
        >>> result = thread.get()

        :param api_key_name: (required)
        :type api_key_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param user_group_name: (required)
        :type user_group_name: str
        :param llmapi_key_update_api_input:
        :type llmapi_key_update_api_input: LLMAPIKeyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProtoLLMAPIKey, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'api_key_name',
            'organization_name',
            'user_group_name',
            'llmapi_key_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method l_lmapi_key_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key_name' is set
        if self.api_client.client_side_validation and local_var_params.get('api_key_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `api_key_name` when calling `l_lmapi_key_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `l_lmapi_key_update_api`")  # noqa: E501
        # verify the required parameter 'user_group_name' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_name` when calling `l_lmapi_key_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key_name' in local_var_params:
            path_params['apiKeyName'] = local_var_params['api_key_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_name' in local_var_params:
            path_params['userGroupName'] = local_var_params['user_group_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'llmapi_key_update_api_input' in local_var_params:
            body_params = local_var_params['llmapi_key_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProtoLLMAPIKey",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/llm/settings/usergroup/{userGroupName}/apikey/{apiKeyName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def list_run_tracking_fields(self, organization_name, project_name, **kwargs):  # noqa: E501
        """list_run_tracking_fields  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_run_tracking_fields(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TrackingListRunTrackingFieldsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.list_run_tracking_fields_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def list_run_tracking_fields_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """list_run_tracking_fields  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_run_tracking_fields_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TrackingListRunTrackingFieldsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_run_tracking_fields" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `list_run_tracking_fields`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `list_run_tracking_fields`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TrackingListRunTrackingFieldsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/fields', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def managed_cluster_list_api(self, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterManagedClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.managed_cluster_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def managed_cluster_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterManagedClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method managed_cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `managed_cluster_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterManagedClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/managed_clusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def managed_cluster_register_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_register_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_register_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseKernelClusterInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.managed_cluster_register_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def managed_cluster_register_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_register_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_register_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseKernelClusterInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method managed_cluster_register_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `managed_cluster_register_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `managed_cluster_register_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseKernelClusterInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/managed_clusters/{clusterID}/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def managed_cluster_unregister_api(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_unregister_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_unregister_api(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.managed_cluster_unregister_api_with_http_info(cluster_id, organization_name, **kwargs)  # noqa: E501

    def managed_cluster_unregister_api_with_http_info(self, cluster_id, organization_name, **kwargs):  # noqa: E501
        """managed_cluster_unregister_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.managed_cluster_unregister_api_with_http_info(cluster_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: (required)
        :type cluster_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cluster_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method managed_cluster_unregister_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if self.api_client.client_side_validation and local_var_params.get('cluster_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cluster_id` when calling `managed_cluster_unregister_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `managed_cluster_unregister_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in local_var_params:
            path_params['clusterID'] = local_var_params['cluster_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/managed_clusters/{clusterID}/unregister', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def manual_top_up_api(self, organization_name, amount, **kwargs):  # noqa: E501
        """manual_top_up_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manual_top_up_api(organization_name, amount, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param amount: (required)
        :type amount: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BillingManualTopUpResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.manual_top_up_api_with_http_info(organization_name, amount, **kwargs)  # noqa: E501

    def manual_top_up_api_with_http_info(self, organization_name, amount, **kwargs):  # noqa: E501
        """manual_top_up_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manual_top_up_api_with_http_info(organization_name, amount, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param amount: (required)
        :type amount: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BillingManualTopUpResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'amount'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manual_top_up_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `manual_top_up_api`")  # noqa: E501
        # verify the required parameter 'amount' is set
        if self.api_client.client_side_validation and local_var_params.get('amount') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `amount` when calling `manual_top_up_api`")  # noqa: E501

        if self.api_client.client_side_validation and 'amount' in local_var_params and local_var_params['amount'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `amount` when calling `manual_top_up_api`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'amount' in local_var_params and local_var_params['amount'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `amount` when calling `manual_top_up_api`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('amount') is not None:  # noqa: E501
            query_params.append(('amount', local_var_params['amount']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "BillingManualTopUpResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/manual_top_up', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_add_tags_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_add_tags_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_add_tags_api_input:
        :type model_add_tags_api_input: ModelAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelModelAddTagResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_add_tags_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_add_tags_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_add_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_add_tags_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_add_tags_api_input:
        :type model_add_tags_api_input: ModelAddTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelModelAddTagResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name',
            'model_add_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_add_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_add_tags_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_add_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_add_tags_api_input' in local_var_params:
            body_params = local_var_params['model_add_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelModelAddTagResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models_add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_archive_api(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_archive_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_archive_api(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_archive_api_with_http_info(number, organization_name, repository_name, **kwargs)  # noqa: E501

    def model_archive_api_with_http_info(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_archive_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_archive_api_with_http_info(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_archive_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `model_archive_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_archive_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_archive_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models/{number}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_create_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_create_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_create_api_input:
        :type model_create_api_input: ModelCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_create_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_create_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_create_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_create_api_input:
        :type model_create_api_input: ModelCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name',
            'model_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_create_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_create_api_input' in local_var_params:
            body_params = local_var_params['model_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_delete_api(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_delete_api(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_delete_api_with_http_info(number, organization_name, repository_name, **kwargs)  # noqa: E501

    def model_delete_api_with_http_info(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_delete_api_with_http_info(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `model_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_delete_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models/{number}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_list_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_list_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.model_list_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_list_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_list_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_list_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_read_api(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_read_api(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_read_api_with_http_info(number, organization_name, repository_name, **kwargs)  # noqa: E501

    def model_read_api_with_http_info(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_read_api_with_http_info(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `model_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_read_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models/{number}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_remove_tags_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_remove_tags_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_remove_tags_api_input:
        :type model_remove_tags_api_input: ModelRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelModelRemoveTagResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_remove_tags_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_remove_tags_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_remove_tags_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_remove_tags_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_remove_tags_api_input:
        :type model_remove_tags_api_input: ModelRemoveTagsAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelModelRemoveTagResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name',
            'model_remove_tags_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_remove_tags_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_remove_tags_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_remove_tags_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_remove_tags_api_input' in local_var_params:
            body_params = local_var_params['model_remove_tags_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelModelRemoveTagResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models_remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_repository_create_api(self, organization_name, **kwargs):  # noqa: E501
        """model_repository_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_repository_create_api_input:
        :type model_repository_create_api_input: ModelRepositoryCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelRepositoryDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_repository_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_repository_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_repository_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_repository_create_api_input:
        :type model_repository_create_api_input: ModelRepositoryCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelRepositoryDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'model_repository_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_repository_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_repository_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_repository_create_api_input' in local_var_params:
            body_params = local_var_params['model_repository_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelRepositoryDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_repository_delete_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_delete_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_repository_delete_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_repository_delete_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_delete_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_repository_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_repository_delete_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_repository_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_repository_list_api(self, organization_name, **kwargs):  # noqa: E501
        """model_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelRepositoryList
        """
        kwargs['_return_http_data_only'] = True
        return self.model_repository_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_repository_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_repository_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelRepositoryList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_repository_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_repository_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelRepositoryList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_repository_read_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_read_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelRepositoryDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_repository_read_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_repository_read_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_read_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelRepositoryDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_repository_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_repository_read_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_repository_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelRepositoryDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_repository_update_api(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_update_api(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_repository_update_api_input:
        :type model_repository_update_api_input: ModelRepositoryUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelRepositoryDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_repository_update_api_with_http_info(organization_name, repository_name, **kwargs)  # noqa: E501

    def model_repository_update_api_with_http_info(self, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_repository_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_repository_update_api_with_http_info(organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_repository_update_api_input:
        :type model_repository_update_api_input: ModelRepositoryUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelRepositoryDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'repository_name',
            'model_repository_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_repository_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_repository_update_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_repository_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_repository_update_api_input' in local_var_params:
            body_params = local_var_params['model_repository_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelRepositoryDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_create_api(self, organization_name, **kwargs):  # noqa: E501
        """model_service_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_create_api_input:
        :type model_service_create_api_input: ModelServiceCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_service_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_service_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_create_api_input:
        :type model_service_create_api_input: ModelServiceCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'model_service_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_create_api_input' in local_var_params:
            body_params = local_var_params['model_service_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_delete_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_delete_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_delete_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_delete_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_delete_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_gateway_update_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_gateway_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_gateway_update_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_gateway_update_api_input:
        :type model_service_gateway_update_api_input: ModelServiceGatewayUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceGatewayInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_gateway_update_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_gateway_update_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_gateway_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_gateway_update_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_gateway_update_api_input:
        :type model_service_gateway_update_api_input: ModelServiceGatewayUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceGatewayInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_gateway_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_gateway_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_gateway_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_gateway_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_gateway_update_api_input' in local_var_params:
            body_params = local_var_params['model_service_gateway_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceGatewayInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/gateway', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_link_secret_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_link_secret_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_link_secret_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_link_secret_api_input:
        :type model_service_link_secret_api_input: ModelServiceLinkSecretAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_link_secret_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_link_secret_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_link_secret_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_link_secret_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_link_secret_api_input:
        :type model_service_link_secret_api_input: ModelServiceLinkSecretAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_link_secret_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_link_secret_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_link_secret_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_link_secret_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_link_secret_api_input' in local_var_params:
            body_params = local_var_params['model_service_link_secret_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/secret', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_list_api(self, organization_name, **kwargs):  # noqa: E501
        """model_service_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param status:
        :type status: str
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_service_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_service_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param status:
        :type status: str
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'status',
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('status') is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if local_var_params.get('type') is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_logs_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_logs_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_logs_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_logs_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_logs_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'after',
            'before',
            'limit',
            'pod_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('pod_name') is not None:  # noqa: E501
            query_params.append(('pod_name', local_var_params['pod_name']))  # noqa: E501
        if local_var_params.get('revision_number') is not None:  # noqa: E501
            query_params.append(('revision_number', local_var_params['revision_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_read_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_read_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_read_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_read_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_read_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_create_from_yamlapi(self, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_create_from_yamlapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_create_from_yamlapi(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_create_from_yamlapi_input:
        :type model_service_revision_create_from_yamlapi_input: ModelServiceRevisionCreateFromYAMLAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRevision
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_create_from_yamlapi_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_service_revision_create_from_yamlapi_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_create_from_yamlapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_create_from_yamlapi_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_create_from_yamlapi_input:
        :type model_service_revision_create_from_yamlapi_input: ModelServiceRevisionCreateFromYAMLAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRevision, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'model_service_revision_create_from_yamlapi_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_create_from_yamlapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_create_from_yamlapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_create_from_yamlapi_input' in local_var_params:
            body_params = local_var_params['model_service_revision_create_from_yamlapi_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRevision",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/create_revisions_from_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_create_from_yamlv2_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_create_from_yamlv2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_create_from_yamlv2_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_create_from_yamlv2_api_input:
        :type model_service_revision_create_from_yamlv2_api_input: ModelServiceRevisionCreateFromYAMLV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRevision
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_create_from_yamlv2_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_revision_create_from_yamlv2_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_create_from_yamlv2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_create_from_yamlv2_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_create_from_yamlv2_api_input:
        :type model_service_revision_create_from_yamlv2_api_input: ModelServiceRevisionCreateFromYAMLV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRevision, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_revision_create_from_yamlv2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_create_from_yamlv2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_create_from_yamlv2_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_create_from_yamlv2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_create_from_yamlv2_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_create_from_yamlv2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRevision",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/create_with_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_delete_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_delete_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_delete_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_delete_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_delete_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_delete_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_form_sync_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_form_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_form_sync_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_form_sync_api_input:
        :type model_service_revision_form_sync_api_input: ModelServiceRevisionFormSyncAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceRevisionFormSyncResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_form_sync_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_revision_form_sync_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_form_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_form_sync_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_form_sync_api_input:
        :type model_service_revision_form_sync_api_input: ModelServiceRevisionFormSyncAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceRevisionFormSyncResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_revision_form_sync_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_form_sync_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_form_sync_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_form_sync_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_form_sync_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_form_sync_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceRevisionFormSyncResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/sync_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_form_sync_v2_api(self, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_form_sync_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_form_sync_v2_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_form_sync_v2_api_input:
        :type model_service_revision_form_sync_v2_api_input: ModelServiceRevisionFormSyncV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceRevisionFormSyncV2Response
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_form_sync_v2_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def model_service_revision_form_sync_v2_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_form_sync_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_form_sync_v2_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_form_sync_v2_api_input:
        :type model_service_revision_form_sync_v2_api_input: ModelServiceRevisionFormSyncV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceRevisionFormSyncV2Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'model_service_revision_form_sync_v2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_form_sync_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_form_sync_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_form_sync_v2_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_form_sync_v2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceRevisionFormSyncV2Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/revisions/sync_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_launch_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_launch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_launch_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_launch_api_input:
        :type model_service_revision_launch_api_input: ModelServiceRevisionLaunchAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_launch_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_launch_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_launch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_launch_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_launch_api_input:
        :type model_service_revision_launch_api_input: ModelServiceRevisionLaunchAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number',
            'model_service_revision_launch_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_launch_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_launch_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_launch_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_launch_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_launch_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_launch_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}/launch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_list_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_list_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceRevisionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_list_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_revision_list_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_list_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceRevisionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'statuses'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceRevisionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_read_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_read_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRevision
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_read_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_read_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_read_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRevision, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_read_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRevision",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_serverless_upsert_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_serverless_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_serverless_upsert_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_serverless_upsert_api_input:
        :type model_service_revision_serverless_upsert_api_input: ModelServiceRevisionServerlessUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_serverless_upsert_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_revision_serverless_upsert_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_revision_serverless_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_serverless_upsert_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_revision_serverless_upsert_api_input:
        :type model_service_revision_serverless_upsert_api_input: ModelServiceRevisionServerlessUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_revision_serverless_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_serverless_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_serverless_upsert_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_serverless_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_serverless_upsert_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_serverless_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/update_spec_from_yaml', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_terminate_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_terminate_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRolloutInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_terminate_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_terminate_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_terminate_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRolloutInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_terminate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_terminate_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRolloutInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_terminate_replica_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_terminate_replica_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_terminate_replica_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_terminate_replica_api_input:
        :type model_service_revision_terminate_replica_api_input: ModelServiceRevisionTerminateReplicaAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_terminate_replica_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_terminate_replica_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_terminate_replica_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_terminate_replica_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_terminate_replica_api_input:
        :type model_service_revision_terminate_replica_api_input: ModelServiceRevisionTerminateReplicaAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number',
            'model_service_revision_terminate_replica_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_terminate_replica_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_terminate_replica_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_terminate_replica_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_terminate_replica_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_terminate_replica_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_terminate_replica_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}/terminate_replica', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_revision_update_api(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_update_api(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_update_api_input:
        :type model_service_revision_update_api_input: ModelServiceRevisionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRevision
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_revision_update_api_with_http_info(model_service_name, organization_name, revision_number, **kwargs)  # noqa: E501

    def model_service_revision_update_api_with_http_info(self, model_service_name, organization_name, revision_number, **kwargs):  # noqa: E501
        """model_service_revision_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_revision_update_api_with_http_info(model_service_name, organization_name, revision_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number: (required)
        :type revision_number: int
        :param model_service_revision_update_api_input:
        :type model_service_revision_update_api_input: ModelServiceRevisionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRevision, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number',
            'model_service_revision_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_revision_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_revision_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_revision_update_api`")  # noqa: E501
        # verify the required parameter 'revision_number' is set
        if self.api_client.client_side_validation and local_var_params.get('revision_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_number` when calling `model_service_revision_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'revision_number' in local_var_params:
            path_params['revisionNumber'] = local_var_params['revision_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_revision_update_api_input' in local_var_params:
            body_params = local_var_params['model_service_revision_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRevision",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/revisions/{revisionNumber}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_rollout_abort_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_abort_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_abort_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceRolloutAbortResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_rollout_abort_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_rollout_abort_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_abort_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_abort_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceRolloutAbortResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_rollout_abort_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_rollout_abort_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_rollout_abort_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceRolloutAbortResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/rollouts/abort', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_rollout_create_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_create_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_rollout_create_api_input:
        :type model_service_rollout_create_api_input: ModelServiceRolloutCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRolloutInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_rollout_create_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_rollout_create_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_create_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_rollout_create_api_input:
        :type model_service_rollout_create_api_input: ModelServiceRolloutCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRolloutInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_rollout_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_rollout_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_rollout_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_rollout_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_rollout_create_api_input' in local_var_params:
            body_params = local_var_params['model_service_rollout_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRolloutInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/rollouts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_rollout_list_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_list_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRolloutList
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_rollout_list_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_rollout_list_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_rollout_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_list_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRolloutList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_rollout_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_rollout_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_rollout_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRolloutList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/rollouts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_rollout_read_api(self, model_service_name, organization_name, rollout_number, **kwargs):  # noqa: E501
        """model_service_rollout_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_read_api(model_service_name, organization_name, rollout_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param rollout_number: (required)
        :type rollout_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRolloutInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_rollout_read_api_with_http_info(model_service_name, organization_name, rollout_number, **kwargs)  # noqa: E501

    def model_service_rollout_read_api_with_http_info(self, model_service_name, organization_name, rollout_number, **kwargs):  # noqa: E501
        """model_service_rollout_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_read_api_with_http_info(model_service_name, organization_name, rollout_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param rollout_number: (required)
        :type rollout_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRolloutInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'rollout_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_rollout_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_rollout_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_rollout_read_api`")  # noqa: E501
        # verify the required parameter 'rollout_number' is set
        if self.api_client.client_side_validation and local_var_params.get('rollout_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `rollout_number` when calling `model_service_rollout_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'rollout_number' in local_var_params:
            path_params['rolloutNumber'] = local_var_params['rollout_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRolloutInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/rollouts/{rolloutNumber}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_rollout_update_status_api(self, model_service_name, organization_name, rollout_number, **kwargs):  # noqa: E501
        """model_service_rollout_update_status_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_update_status_api(model_service_name, organization_name, rollout_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param rollout_number: (required)
        :type rollout_number: int
        :param model_service_rollout_update_status_api_input:
        :type model_service_rollout_update_status_api_input: ModelServiceRolloutUpdateStatusAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceRolloutInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_rollout_update_status_api_with_http_info(model_service_name, organization_name, rollout_number, **kwargs)  # noqa: E501

    def model_service_rollout_update_status_api_with_http_info(self, model_service_name, organization_name, rollout_number, **kwargs):  # noqa: E501
        """model_service_rollout_update_status_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_rollout_update_status_api_with_http_info(model_service_name, organization_name, rollout_number, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param rollout_number: (required)
        :type rollout_number: int
        :param model_service_rollout_update_status_api_input:
        :type model_service_rollout_update_status_api_input: ModelServiceRolloutUpdateStatusAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceRolloutInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'rollout_number',
            'model_service_rollout_update_status_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_rollout_update_status_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_rollout_update_status_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_rollout_update_status_api`")  # noqa: E501
        # verify the required parameter 'rollout_number' is set
        if self.api_client.client_side_validation and local_var_params.get('rollout_number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `rollout_number` when calling `model_service_rollout_update_status_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'rollout_number' in local_var_params:
            path_params['rolloutNumber'] = local_var_params['rollout_number']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_rollout_update_status_api_input' in local_var_params:
            body_params = local_var_params['model_service_rollout_update_status_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceRolloutInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/rollouts/{rolloutNumber}/status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_serverless_launch_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_launch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_launch_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_serverless_launch_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_serverless_launch_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_launch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_launch_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_serverless_launch_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_serverless_launch_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_serverless_launch_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/serverless/launch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_serverless_metrics_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_metrics_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceServerlessMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_serverless_metrics_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_serverless_metrics_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_metrics_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceServerlessMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_serverless_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_serverless_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_serverless_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceServerlessMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/serverless/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_serverless_terminate_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_terminate_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_serverless_terminate_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_serverless_terminate_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serverless_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serverless_terminate_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_serverless_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_serverless_terminate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_serverless_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/serverless/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_serving_metrics_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serving_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serving_metrics_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceServingMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_serving_metrics_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_serving_metrics_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serving_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serving_metrics_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceServingMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'after',
            'before',
            'pod_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_serving_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_serving_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_serving_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('pod_name') is not None:  # noqa: E501
            query_params.append(('pod_name', local_var_params['pod_name']))  # noqa: E501
        if local_var_params.get('revision_number') is not None:  # noqa: E501
            query_params.append(('revision_number', local_var_params['revision_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceServingMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/serving_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_serving_metrics_v2_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serving_metrics_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serving_metrics_v2_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceServingMetricsV2Response
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_serving_metrics_v2_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_serving_metrics_v2_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_serving_metrics_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_serving_metrics_v2_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceServingMetricsV2Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'after',
            'before'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_serving_metrics_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_serving_metrics_v2_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_serving_metrics_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceServingMetricsV2Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/serving_metrics_v2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_system_metrics_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_system_metrics_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_system_metrics_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_system_metrics_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_system_metrics_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param pod_name:
        :type pod_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'after',
            'before',
            'pod_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('pod_name') is not None:  # noqa: E501
            query_params.append(('pod_name', local_var_params['pod_name']))  # noqa: E501
        if local_var_params.get('revision_number') is not None:  # noqa: E501
            query_params.append(('revision_number', local_var_params['revision_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_update_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_update_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_update_api_input:
        :type model_service_update_api_input: ModelServiceUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelServiceInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_update_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_update_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_update_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param model_service_update_api_input:
        :type model_service_update_api_input: ModelServiceUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelServiceInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'model_service_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_service_update_api_input' in local_var_params:
            body_params = local_var_params['model_service_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelServiceInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_service_workload_list_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_workload_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_workload_list_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ModelserviceModelServiceWorkloadListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.model_service_workload_list_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def model_service_workload_list_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """model_service_workload_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_service_workload_list_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param revision_number:
        :type revision_number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ModelserviceModelServiceWorkloadListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'revision_number'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_service_workload_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `model_service_workload_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_service_workload_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('revision_number') is not None:  # noqa: E501
            query_params.append(('revision_number', local_var_params['revision_number']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ModelserviceModelServiceWorkloadListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/workloads', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_unarchive_api(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_unarchive_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_unarchive_api(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_unarchive_api_with_http_info(number, organization_name, repository_name, **kwargs)  # noqa: E501

    def model_unarchive_api_with_http_info(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_unarchive_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_unarchive_api_with_http_info(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'repository_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_unarchive_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `model_unarchive_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_unarchive_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_unarchive_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models/{number}/unarchive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def model_update_api(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_update_api(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_update_api_input:
        :type model_update_api_input: ModelUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseModelDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.model_update_api_with_http_info(number, organization_name, repository_name, **kwargs)  # noqa: E501

    def model_update_api_with_http_info(self, number, organization_name, repository_name, **kwargs):  # noqa: E501
        """model_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.model_update_api_with_http_info(number, organization_name, repository_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param repository_name: (required)
        :type repository_name: str
        :param model_update_api_input:
        :type model_update_api_input: ModelUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseModelDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'repository_name',
            'model_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `model_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `model_update_api`")  # noqa: E501
        # verify the required parameter 'repository_name' is set
        if self.api_client.client_side_validation and local_var_params.get('repository_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `repository_name` when calling `model_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'repository_name' in local_var_params:
            path_params['repositoryName'] = local_var_params['repository_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_update_api_input' in local_var_params:
            body_params = local_var_params['model_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseModelDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_repositories/{repositoryName}/models/{number}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def on_premise_dataset_create_api(self, organization_name, **kwargs):  # noqa: E501
        """on_premise_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.on_premise_dataset_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param on_premise_dataset_create_api_input:
        :type on_premise_dataset_create_api_input: OnPremiseDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.on_premise_dataset_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def on_premise_dataset_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """on_premise_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.on_premise_dataset_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param on_premise_dataset_create_api_input:
        :type on_premise_dataset_create_api_input: OnPremiseDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'on_premise_dataset_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method on_premise_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `on_premise_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'on_premise_dataset_create_api_input' in local_var_params:
            body_params = local_var_params['on_premise_dataset_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets_on_premise', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_activities_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_activities_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_activities_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationActivities
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_activities_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_activities_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_activities_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_activities_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationActivities, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_activities_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_activities_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationActivities",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/activities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_artifactory_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_artifactory_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_artifactory_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_artifactory_credentials_add_api_input:
        :type organization_artifactory_credentials_add_api_input: OrganizationArtifactoryCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_artifactory_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_artifactory_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_artifactory_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_artifactory_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_artifactory_credentials_add_api_input:
        :type organization_artifactory_credentials_add_api_input: OrganizationArtifactoryCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_artifactory_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_artifactory_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_artifactory_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_artifactory_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_artifactory_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_artifactory', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_assets_federate_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_assets_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_assets_federate_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_assets_federate_api_input:
        :type organization_assets_federate_api_input: OrganizationAssetsFederateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationAssetsFederationResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_assets_federate_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_assets_federate_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_assets_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_assets_federate_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_assets_federate_api_input:
        :type organization_assets_federate_api_input: OrganizationAssetsFederateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationAssetsFederationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_assets_federate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_assets_federate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_assets_federate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_assets_federate_api_input' in local_var_params:
            body_params = local_var_params['organization_assets_federate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationAssetsFederationResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/assets/federate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_aws_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_aws_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_aws_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_aws_credentials_add_api_input:
        :type organization_aws_credentials_add_api_input: OrganizationAWSCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_aws_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_aws_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_aws_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_aws_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_aws_credentials_add_api_input:
        :type organization_aws_credentials_add_api_input: OrganizationAWSCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_aws_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_aws_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_aws_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_aws_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_aws_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_aws', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_billing_config_read_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_billing_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_billing_config_read_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationBillingConfigReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_billing_config_read_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_billing_config_read_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_billing_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_billing_config_read_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationBillingConfigReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_billing_config_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_billing_config_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationBillingConfigReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/billing/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_create_api(self, **kwargs):  # noqa: E501
        """organization_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_create_api(async_req=True)
        >>> result = thread.get()

        :param organization_create_api_input:
        :type organization_create_api_input: OrganizationCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_create_api_with_http_info(**kwargs)  # noqa: E501

    def organization_create_api_with_http_info(self, **kwargs):  # noqa: E501
        """organization_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_create_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param organization_create_api_input:
        :type organization_create_api_input: OrganizationCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_create_api_input' in local_var_params:
            body_params = local_var_params['organization_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credential_provider_list_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_credential_provider_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credential_provider_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param kinds:
        :type kinds: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCredentialProviderListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credential_provider_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_credential_provider_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_credential_provider_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credential_provider_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param kinds:
        :type kinds: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCredentialProviderListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'kinds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credential_provider_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credential_provider_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('kinds') is not None:  # noqa: E501
            query_params.append(('kinds', local_var_params['kinds']))  # noqa: E501
            collection_formats['kinds'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCredentialProviderListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credential_providers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credentials_delete_api(self, credentials_id, organization_name, **kwargs):  # noqa: E501
        """organization_credentials_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credentials_delete_api(credentials_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param credentials_id: (required)
        :type credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credentials_delete_api_with_http_info(credentials_id, organization_name, **kwargs)  # noqa: E501

    def organization_credentials_delete_api_with_http_info(self, credentials_id, organization_name, **kwargs):  # noqa: E501
        """organization_credentials_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credentials_delete_api_with_http_info(credentials_id, organization_name, async_req=True)
        >>> result = thread.get()

        :param credentials_id: (required)
        :type credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'credentials_id',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credentials_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credentials_id' is set
        if self.api_client.client_side_validation and local_var_params.get('credentials_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `credentials_id` when calling `organization_credentials_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credentials_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credentials_id' in local_var_params:
            path_params['credentialsID'] = local_var_params['credentials_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials/{credentialsID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credentials_list_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_credentials_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credentials_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param components:
        :type components: list[str]
        :param types:
        :type types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfoList
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credentials_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_credentials_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_credentials_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credentials_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param components:
        :type components: list[str]
        :param types:
        :type types: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfoList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'components',
            'types'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credentials_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credentials_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('components') is not None:  # noqa: E501
            query_params.append(('components', local_var_params['components']))  # noqa: E501
            collection_formats['components'] = 'multi'  # noqa: E501
        if local_var_params.get('types') is not None:  # noqa: E501
            query_params.append(('types', local_var_params['types']))  # noqa: E501
            collection_formats['types'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfoList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_top_up_history_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_credit_top_up_history_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_top_up_history_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditTopUpHistoryResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_top_up_history_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_credit_top_up_history_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_credit_top_up_history_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_top_up_history_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param month:
        :type month: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param year:
        :type year: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditTopUpHistoryResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'month',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'year'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_top_up_history_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_top_up_history_api`")  # noqa: E501

        if self.api_client.client_side_validation and 'month' in local_var_params and local_var_params['month'] > 12:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `month` when calling `organization_credit_top_up_history_api`, must be a value less than or equal to `12`")  # noqa: E501
        if self.api_client.client_side_validation and 'month' in local_var_params and local_var_params['month'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `month` when calling `organization_credit_top_up_history_api`, must be a value greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'year' in local_var_params and local_var_params['year'] > 2050:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `year` when calling `organization_credit_top_up_history_api`, must be a value less than or equal to `2050`")  # noqa: E501
        if self.api_client.client_side_validation and 'year' in local_var_params and local_var_params['year'] < 2020:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `year` when calling `organization_credit_top_up_history_api`, must be a value greater than or equal to `2020`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('month') is not None:  # noqa: E501
            query_params.append(('month', local_var_params['month']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('year') is not None:  # noqa: E501
            query_params.append(('year', local_var_params['year']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditTopUpHistoryResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_top_up_history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_csvapi(self, organization_name, date_from, date_to, **kwargs):  # noqa: E501
        """organization_credit_usage_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_csvapi(organization_name, date_from, date_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param date_from: (required)
        :type date_from: str
        :param date_to: (required)
        :type date_to: str
        :param cluster_id:
        :type cluster_id: int
        :param resource_type:
        :type resource_type: str
        :param tz_offset:
        :type tz_offset: int
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_csvapi_with_http_info(organization_name, date_from, date_to, **kwargs)  # noqa: E501

    def organization_credit_usage_csvapi_with_http_info(self, organization_name, date_from, date_to, **kwargs):  # noqa: E501
        """organization_credit_usage_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_csvapi_with_http_info(organization_name, date_from, date_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param date_from: (required)
        :type date_from: str
        :param date_to: (required)
        :type date_to: str
        :param cluster_id:
        :type cluster_id: int
        :param resource_type:
        :type resource_type: str
        :param tz_offset:
        :type tz_offset: int
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'date_from',
            'date_to',
            'cluster_id',
            'resource_type',
            'tz_offset',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_csvapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_csvapi`")  # noqa: E501
        # verify the required parameter 'date_from' is set
        if self.api_client.client_side_validation and local_var_params.get('date_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `date_from` when calling `organization_credit_usage_csvapi`")  # noqa: E501
        # verify the required parameter 'date_to' is set
        if self.api_client.client_side_validation and local_var_params.get('date_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `date_to` when calling `organization_credit_usage_csvapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cluster_id') is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if local_var_params.get('date_from') is not None:  # noqa: E501
            query_params.append(('date_from', local_var_params['date_from']))  # noqa: E501
        if local_var_params.get('date_to') is not None:  # noqa: E501
            query_params.append(('date_to', local_var_params['date_to']))  # noqa: E501
        if local_var_params.get('resource_type') is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if local_var_params.get('tz_offset') is not None:  # noqa: E501
            query_params.append(('tz_offset', local_var_params['tz_offset']))  # noqa: E501
        if local_var_params.get('username') is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_graph_api(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_graph_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_graph_api(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param resource_type:
        :type resource_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditUsageGraphResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_graph_api_with_http_info(organization_name, timestamp_from, timestamp_to, **kwargs)  # noqa: E501

    def organization_credit_usage_graph_api_with_http_info(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_graph_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_graph_api_with_http_info(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param resource_type:
        :type resource_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditUsageGraphResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'timestamp_from',
            'timestamp_to',
            'cluster_id',
            'resource_type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_graph_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_graph_api`")  # noqa: E501
        # verify the required parameter 'timestamp_from' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_from` when calling `organization_credit_usage_graph_api`")  # noqa: E501
        # verify the required parameter 'timestamp_to' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_to` when calling `organization_credit_usage_graph_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cluster_id') is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if local_var_params.get('resource_type') is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if local_var_params.get('timestamp_from') is not None:  # noqa: E501
            query_params.append(('timestamp_from', local_var_params['timestamp_from']))  # noqa: E501
        if local_var_params.get('timestamp_to') is not None:  # noqa: E501
            query_params.append(('timestamp_to', local_var_params['timestamp_to']))  # noqa: E501
        if local_var_params.get('username') is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditUsageGraphResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/graph', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_node_list_api(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_node_list_api(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditUsageNodeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_node_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, **kwargs)  # noqa: E501

    def organization_credit_usage_node_list_api_with_http_info(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_node_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_node_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditUsageNodeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'timestamp_from',
            'timestamp_to',
            'cluster_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_node_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_node_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_from' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_from` when calling `organization_credit_usage_node_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_to' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_to` when calling `organization_credit_usage_node_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cluster_id') is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('timestamp_from') is not None:  # noqa: E501
            query_params.append(('timestamp_from', local_var_params['timestamp_from']))  # noqa: E501
        if local_var_params.get('timestamp_to') is not None:  # noqa: E501
            query_params.append(('timestamp_to', local_var_params['timestamp_to']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditUsageNodeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/node', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_others_list_api(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_others_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_others_list_api(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditUsageOthersListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_others_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, **kwargs)  # noqa: E501

    def organization_credit_usage_others_list_api_with_http_info(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_others_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_others_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditUsageOthersListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'timestamp_from',
            'timestamp_to',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_others_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_others_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_from' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_from` when calling `organization_credit_usage_others_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_to' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_to` when calling `organization_credit_usage_others_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('timestamp_from') is not None:  # noqa: E501
            query_params.append(('timestamp_from', local_var_params['timestamp_from']))  # noqa: E501
        if local_var_params.get('timestamp_to') is not None:  # noqa: E501
            query_params.append(('timestamp_to', local_var_params['timestamp_to']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditUsageOthersListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/others', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_run_list_api(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_run_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_run_list_api(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param resource_type:
        :type resource_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditUsageRunListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_run_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, **kwargs)  # noqa: E501

    def organization_credit_usage_run_list_api_with_http_info(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_run_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_run_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cluster_id:
        :type cluster_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param resource_type:
        :type resource_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditUsageRunListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'timestamp_from',
            'timestamp_to',
            'cluster_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'resource_type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_run_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_run_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_from' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_from` when calling `organization_credit_usage_run_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_to' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_to` when calling `organization_credit_usage_run_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cluster_id') is not None:  # noqa: E501
            query_params.append(('cluster_id', local_var_params['cluster_id']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('resource_type') is not None:  # noqa: E501
            query_params.append(('resource_type', local_var_params['resource_type']))  # noqa: E501
        if local_var_params.get('timestamp_from') is not None:  # noqa: E501
            query_params.append(('timestamp_from', local_var_params['timestamp_from']))  # noqa: E501
        if local_var_params.get('timestamp_to') is not None:  # noqa: E501
            query_params.append(('timestamp_to', local_var_params['timestamp_to']))  # noqa: E501
        if local_var_params.get('username') is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditUsageRunListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/runs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_credit_usage_storage_list_api(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_storage_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_storage_list_api(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationCreditUsageStorageListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_credit_usage_storage_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, **kwargs)  # noqa: E501

    def organization_credit_usage_storage_list_api_with_http_info(self, organization_name, timestamp_from, timestamp_to, **kwargs):  # noqa: E501
        """organization_credit_usage_storage_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_credit_usage_storage_list_api_with_http_info(organization_name, timestamp_from, timestamp_to, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param timestamp_from: (required)
        :type timestamp_from: float
        :param timestamp_to: (required)
        :type timestamp_to: float
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationCreditUsageStorageListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'timestamp_from',
            'timestamp_to',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_credit_usage_storage_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_credit_usage_storage_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_from' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_from') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_from` when calling `organization_credit_usage_storage_list_api`")  # noqa: E501
        # verify the required parameter 'timestamp_to' is set
        if self.api_client.client_side_validation and local_var_params.get('timestamp_to') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `timestamp_to` when calling `organization_credit_usage_storage_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('timestamp_from') is not None:  # noqa: E501
            query_params.append(('timestamp_from', local_var_params['timestamp_from']))  # noqa: E501
        if local_var_params.get('timestamp_to') is not None:  # noqa: E501
            query_params.append(('timestamp_to', local_var_params['timestamp_to']))  # noqa: E501
        if local_var_params.get('username') is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationCreditUsageStorageListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credit_usage/storage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_delegate_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_delegate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_delegate_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_delegate_api_input:
        :type organization_delegate_api_input: OrganizationDelegateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_delegate_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_delegate_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_delegate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_delegate_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_delegate_api_input:
        :type organization_delegate_api_input: OrganizationDelegateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_delegate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_delegate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_delegate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_delegate_api_input' in local_var_params:
            body_params = local_var_params['organization_delegate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/delegate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_delete_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_delete_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_delete_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_delete_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_delete_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_docker_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_docker_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_docker_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_docker_credentials_add_api_input:
        :type organization_docker_credentials_add_api_input: OrganizationDockerCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_docker_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_docker_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_docker_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_docker_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_docker_credentials_add_api_input:
        :type organization_docker_credentials_add_api_input: OrganizationDockerCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_docker_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_docker_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_docker_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_docker_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_docker_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_docker', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_feature_access_read_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_feature_access_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_feature_access_read_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationFeatureAccess
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_feature_access_read_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_feature_access_read_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_feature_access_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_feature_access_read_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationFeatureAccess, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_feature_access_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_feature_access_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationFeatureAccess",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/feature_access', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_git_hub_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_git_hub_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_git_hub_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_git_hub_credentials_add_api_input:
        :type organization_git_hub_credentials_add_api_input: OrganizationGitHubCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_git_hub_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_git_hub_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_git_hub_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_git_hub_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_git_hub_credentials_add_api_input:
        :type organization_git_hub_credentials_add_api_input: OrganizationGitHubCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_git_hub_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_git_hub_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_git_hub_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_git_hub_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_git_hub_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_github', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_git_lab_credential_provider_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_git_lab_credential_provider_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_git_lab_credential_provider_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_git_lab_credential_provider_add_api_input:
        :type organization_git_lab_credential_provider_add_api_input: OrganizationGitLabCredentialProviderAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialProviderInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_git_lab_credential_provider_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_git_lab_credential_provider_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_git_lab_credential_provider_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_git_lab_credential_provider_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_git_lab_credential_provider_add_api_input:
        :type organization_git_lab_credential_provider_add_api_input: OrganizationGitLabCredentialProviderAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialProviderInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_git_lab_credential_provider_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_git_lab_credential_provider_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_git_lab_credential_provider_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_git_lab_credential_provider_add_api_input' in local_var_params:
            body_params = local_var_params['organization_git_lab_credential_provider_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialProviderInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credential_providers/gitlab', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_google_artifact_repository_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_google_artifact_repository_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_google_artifact_repository_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_google_artifact_repository_credentials_add_api_input:
        :type organization_google_artifact_repository_credentials_add_api_input: OrganizationGoogleArtifactRepositoryCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_google_artifact_repository_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_google_artifact_repository_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_google_artifact_repository_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_google_artifact_repository_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_google_artifact_repository_credentials_add_api_input:
        :type organization_google_artifact_repository_credentials_add_api_input: OrganizationGoogleArtifactRepositoryCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_google_artifact_repository_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_google_artifact_repository_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_google_artifact_repository_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_google_artifact_repository_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_google_artifact_repository_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_google_artifact_repository', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_history_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_history_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_history_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_history_add_api_input:
        :type organization_history_add_api_input: OrganizationHistoryAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_history_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_history_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_history_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_history_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_history_add_api_input:
        :type organization_history_add_api_input: OrganizationHistoryAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_history_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_history_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_history_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_history_add_api_input' in local_var_params:
            body_params = local_var_params['organization_history_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/history', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_history_read_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_history_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_history_read_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationHistory
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_history_read_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_history_read_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_history_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_history_read_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationHistory, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_history_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_history_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationHistory",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_list_api(self, **kwargs):  # noqa: E501
        """organization_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_list_api(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_list_api_with_http_info(**kwargs)  # noqa: E501

    def organization_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """organization_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_me_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_me_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_me_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationMeResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_me_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_me_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_me_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_me_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationMeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_me_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_me_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationMeResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/me', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_member_add_api_input:
        :type organization_member_add_api_input: OrganizationMemberAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationMember
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_member_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_member_add_api_input:
        :type organization_member_add_api_input: OrganizationMemberAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationMember, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_member_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_member_add_api_input' in local_var_params:
            body_params = local_var_params['organization_member_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationMember",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_bulk_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_bulk_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_bulk_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_member_bulk_add_api_input:
        :type organization_member_bulk_add_api_input: OrganizationMemberBulkAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationMemberBulkAddAPI200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_bulk_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_member_bulk_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_bulk_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_bulk_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_member_bulk_add_api_input:
        :type organization_member_bulk_add_api_input: OrganizationMemberBulkAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationMemberBulkAddAPI200Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_member_bulk_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_bulk_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_bulk_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_member_bulk_add_api_input' in local_var_params:
            body_params = local_var_params['organization_member_bulk_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationMemberBulkAddAPI200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/members_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_delegate_owner_api(self, organization_name, target_user_name, **kwargs):  # noqa: E501
        """organization_member_delegate_owner_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_delegate_owner_api(organization_name, target_user_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param target_user_name: (required)
        :type target_user_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_delegate_owner_api_with_http_info(organization_name, target_user_name, **kwargs)  # noqa: E501

    def organization_member_delegate_owner_api_with_http_info(self, organization_name, target_user_name, **kwargs):  # noqa: E501
        """organization_member_delegate_owner_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_delegate_owner_api_with_http_info(organization_name, target_user_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param target_user_name: (required)
        :type target_user_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'target_user_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_delegate_owner_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_delegate_owner_api`")  # noqa: E501
        # verify the required parameter 'target_user_name' is set
        if self.api_client.client_side_validation and local_var_params.get('target_user_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `target_user_name` when calling `organization_member_delegate_owner_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'target_user_name' in local_var_params:
            path_params['targetUserName'] = local_var_params['target_user_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/target_user/{targetUserName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_list_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param excluded_user_group:
        :type excluded_user_group: int
        :param included_user_group:
        :type included_user_group: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationMemberListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_member_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param excluded_user_group:
        :type excluded_user_group: int
        :param included_user_group:
        :type included_user_group: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationMemberListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'excluded_user_group',
            'included_user_group',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('excluded_user_group') is not None:  # noqa: E501
            query_params.append(('excluded_user_group', local_var_params['excluded_user_group']))  # noqa: E501
        if local_var_params.get('included_user_group') is not None:  # noqa: E501
            query_params.append(('included_user_group', local_var_params['included_user_group']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationMemberListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_remove_api(self, organization_name, username, **kwargs):  # noqa: E501
        """organization_member_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_remove_api(organization_name, username, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param username: (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_remove_api_with_http_info(organization_name, username, **kwargs)  # noqa: E501

    def organization_member_remove_api_with_http_info(self, organization_name, username, **kwargs):  # noqa: E501
        """organization_member_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_remove_api_with_http_info(organization_name, username, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param username: (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_remove_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_remove_api`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and local_var_params.get('username') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `organization_member_remove_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/members/{username}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_member_update_permission_api(self, organization_name, username, **kwargs):  # noqa: E501
        """organization_member_update_permission_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_update_permission_api(organization_name, username, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param username: (required)
        :type username: str
        :param organization_member_update_permission_api_input:
        :type organization_member_update_permission_api_input: OrganizationMemberUpdatePermissionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationMemberUpdatePermissionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_member_update_permission_api_with_http_info(organization_name, username, **kwargs)  # noqa: E501

    def organization_member_update_permission_api_with_http_info(self, organization_name, username, **kwargs):  # noqa: E501
        """organization_member_update_permission_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_member_update_permission_api_with_http_info(organization_name, username, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param username: (required)
        :type username: str
        :param organization_member_update_permission_api_input:
        :type organization_member_update_permission_api_input: OrganizationMemberUpdatePermissionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationMemberUpdatePermissionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'username',
            'organization_member_update_permission_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_member_update_permission_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_member_update_permission_api`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and local_var_params.get('username') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `organization_member_update_permission_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'username' in local_var_params:
            path_params['username'] = local_var_params['username']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_member_update_permission_api_input' in local_var_params:
            body_params = local_var_params['organization_member_update_permission_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationMemberUpdatePermissionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/members/{username}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_payment_setup_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_payment_setup_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_payment_setup_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_payment_setup_api_input:
        :type organization_payment_setup_api_input: OrganizationPaymentSetupAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationPaymentSetupResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_payment_setup_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_payment_setup_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_payment_setup_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_payment_setup_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_payment_setup_api_input:
        :type organization_payment_setup_api_input: OrganizationPaymentSetupAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationPaymentSetupResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_payment_setup_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_payment_setup_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_payment_setup_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_payment_setup_api_input' in local_var_params:
            body_params = local_var_params['organization_payment_setup_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationPaymentSetupResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/payment_setup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_policy_list_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_policy_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacOrganizationPolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_policy_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_policy_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_policy_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacOrganizationPolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacOrganizationPolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_policy_update_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_policy_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_policy_update_api_input:
        :type organization_policy_update_api_input: OrganizationPolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_policy_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_policy_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_policy_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_policy_update_api_input:
        :type organization_policy_update_api_input: OrganizationPolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_policy_update_api_input' in local_var_params:
            body_params = local_var_params['organization_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_read_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_read_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_read_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_read_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_read_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_slack_credentials_add_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_slack_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_slack_credentials_add_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_slack_credentials_add_api_input:
        :type organization_slack_credentials_add_api_input: OrganizationSlackCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationCredentialsInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_slack_credentials_add_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_slack_credentials_add_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_slack_credentials_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_slack_credentials_add_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_slack_credentials_add_api_input:
        :type organization_slack_credentials_add_api_input: OrganizationSlackCredentialsAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationCredentialsInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_slack_credentials_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_slack_credentials_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_slack_credentials_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_slack_credentials_add_api_input' in local_var_params:
            body_params = local_var_params['organization_slack_credentials_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationCredentialsInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/credentials_slack', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_subscription_cancel_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_subscription_cancel_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_subscription_cancel_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_subscription_cancel_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_subscription_cancel_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_subscription_cancel_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_subscription_cancel_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_subscription_cancel_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_subscription_cancel_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/subscriptions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_subscription_update_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_subscription_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_subscription_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_subscription_update_api_input:
        :type organization_subscription_update_api_input: OrganizationSubscriptionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OrganizationOrganizationSubscriptionUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_subscription_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_subscription_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_subscription_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_subscription_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_subscription_update_api_input:
        :type organization_subscription_update_api_input: OrganizationSubscriptionUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OrganizationOrganizationSubscriptionUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_subscription_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_subscription_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_subscription_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_subscription_update_api_input' in local_var_params:
            body_params = local_var_params['organization_subscription_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "OrganizationOrganizationSubscriptionUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/subscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def organization_update_api(self, organization_name, **kwargs):  # noqa: E501
        """organization_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_update_api_input:
        :type organization_update_api_input: OrganizationUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganizationInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.organization_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def organization_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """organization_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.organization_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param organization_update_api_input:
        :type organization_update_api_input: OrganizationUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganizationInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'organization_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method organization_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `organization_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'organization_update_api_input' in local_var_params:
            body_params = local_var_params['organization_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganizationInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def page_accessibility_api(self, **kwargs):  # noqa: E501
        """page_accessibility_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.page_accessibility_api(async_req=True)
        >>> result = thread.get()

        :param page_accessibility_api_input:
        :type page_accessibility_api_input: PageAccessibilityAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacPageAccessibilityResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.page_accessibility_api_with_http_info(**kwargs)  # noqa: E501

    def page_accessibility_api_with_http_info(self, **kwargs):  # noqa: E501
        """page_accessibility_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.page_accessibility_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param page_accessibility_api_input:
        :type page_accessibility_api_input: PageAccessibilityAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacPageAccessibilityResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'page_accessibility_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method page_accessibility_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'page_accessibility_api_input' in local_var_params:
            body_params = local_var_params['page_accessibility_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacPageAccessibilityResponse",
        }

        return self.api_client.call_api(
            '/api/v1/rbac/page_accessibility', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def persistent_artifact_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param persistent_artifact_create_api_input:
        :type persistent_artifact_create_api_input: PersistentArtifactCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseArtifact
        """
        kwargs['_return_http_data_only'] = True
        return self.persistent_artifact_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def persistent_artifact_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param persistent_artifact_create_api_input:
        :type persistent_artifact_create_api_input: PersistentArtifactCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseArtifact, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'persistent_artifact_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method persistent_artifact_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `persistent_artifact_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `persistent_artifact_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'persistent_artifact_create_api_input' in local_var_params:
            body_params = local_var_params['persistent_artifact_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseArtifact",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/persistent_artifacts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def persistent_artifact_delete_api(self, artifact_id, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_delete_api(artifact_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.persistent_artifact_delete_api_with_http_info(artifact_id, organization_name, project_name, **kwargs)  # noqa: E501

    def persistent_artifact_delete_api_with_http_info(self, artifact_id, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_delete_api_with_http_info(artifact_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param artifact_id: (required)
        :type artifact_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'artifact_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method persistent_artifact_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'artifact_id' is set
        if self.api_client.client_side_validation and local_var_params.get('artifact_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `artifact_id` when calling `persistent_artifact_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `persistent_artifact_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `persistent_artifact_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'artifact_id' in local_var_params:
            path_params['artifactID'] = local_var_params['artifact_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/persistent_artifacts/{artifactID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def persistent_artifact_find_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_find_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_find_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param id:
        :type id: int
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseArtifact
        """
        kwargs['_return_http_data_only'] = True
        return self.persistent_artifact_find_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def persistent_artifact_find_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_find_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_find_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param id:
        :type id: int
        :param name:
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseArtifact, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'id',
            'name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method persistent_artifact_find_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `persistent_artifact_find_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `persistent_artifact_find_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('id') is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
        if local_var_params.get('name') is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseArtifact",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/persistent_artifacts/find', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def persistent_artifact_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactPersistentArtifactListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.persistent_artifact_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def persistent_artifact_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """persistent_artifact_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.persistent_artifact_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactPersistentArtifactListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method persistent_artifact_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `persistent_artifact_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `persistent_artifact_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ArtifactPersistentArtifactListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/persistent_artifacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def ping_api(self, **kwargs):  # noqa: E501
        """ping_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ping_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.ping_api_with_http_info(**kwargs)  # noqa: E501

    def ping_api_with_http_info(self, **kwargs):  # noqa: E501
        """ping_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ping_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/ping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_availabe_variables_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_availabe_variables_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_availabe_variables_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineAvailabeVariablesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_availabe_variables_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_availabe_variables_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_availabe_variables_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_availabe_variables_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineAvailabeVariablesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_availabe_variables_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_availabe_variables_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_availabe_variables_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineAvailabeVariablesResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/available_variables', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_create_api(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_create_api_input:
        :type pipeline_create_api_input: PipelineCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipeline
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def pipeline_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_create_api_input:
        :type pipeline_create_api_input: PipelineCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipeline, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_create_api_input' in local_var_params:
            body_params = local_var_params['pipeline_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipeline",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_delete_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_delete_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_delete_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_delete_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_delete_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_delete_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_execution_abort_api(self, number, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_abort_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_abort_api(number, organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineExecution
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_execution_abort_api_with_http_info(number, organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_execution_abort_api_with_http_info(self, number, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_abort_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_abort_api_with_http_info(number, organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineExecution, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_execution_abort_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_execution_abort_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_execution_abort_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_execution_abort_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineExecution",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/abort', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_execution_list_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_list_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param assignee_ids:
        :type assignee_ids: list[int]
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param variable_filters:
        :type variable_filters: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineExecutionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_execution_list_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_execution_list_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_list_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param assignee_ids:
        :type assignee_ids: list[int]
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param variable_filters:
        :type variable_filters: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineExecutionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'assignee_ids',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'statuses',
            'variable_filters'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_execution_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_execution_list_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_execution_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []
        if local_var_params.get('assignee_ids') is not None:  # noqa: E501
            query_params.append(('assignee_ids', local_var_params['assignee_ids']))  # noqa: E501
            collection_formats['assignee_ids'] = 'multi'  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if local_var_params.get('variable_filters') is not None:  # noqa: E501
            query_params.append(('variable_filters', local_var_params['variable_filters']))  # noqa: E501
            collection_formats['variable_filters'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineExecutionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_execution_read_api(self, number, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_read_api(number, organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineExecution
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_execution_read_api_with_http_info(number, organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_execution_read_api_with_http_info(self, number, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_execution_read_api_with_http_info(number, organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineExecution, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_execution_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_execution_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_execution_read_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_execution_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineExecution",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_list_api(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param filter_favorite:
        :type filter_favorite: bool
        :param filter_name:
        :type filter_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def pipeline_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param filter_favorite:
        :type filter_favorite: bool
        :param filter_name:
        :type filter_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'filter_favorite',
            'filter_name',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('filter_favorite') is not None:  # noqa: E501
            query_params.append(('filter_favorite', local_var_params['filter_favorite']))  # noqa: E501
        if local_var_params.get('filter_name') is not None:  # noqa: E501
            query_params.append(('filter_name', local_var_params['filter_name']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_list_paused_steps_api(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_list_paused_steps_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_list_paused_steps_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelineListPausedStepsAPI200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_list_paused_steps_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def pipeline_list_paused_steps_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_list_paused_steps_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_list_paused_steps_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelineListPausedStepsAPI200Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_list_paused_steps_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_list_paused_steps_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelineListPausedStepsAPI200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/paused_steps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_overview_api(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_overview_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_overview_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineOverviewResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_overview_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def pipeline_overview_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_overview_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_overview_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineOverviewResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_overview_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_overview_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineOverviewResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/overview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_policy_list_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_policy_list_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacPipelinePolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_policy_list_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_policy_list_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_policy_list_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacPipelinePolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_policy_list_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacPipelinePolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_policy_update_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_policy_update_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_policy_update_api_input:
        :type pipeline_policy_update_api_input: PipelinePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_policy_update_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_policy_update_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_policy_update_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_policy_update_api_input:
        :type pipeline_policy_update_api_input: PipelinePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_policy_update_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_policy_update_api_input' in local_var_params:
            body_params = local_var_params['pipeline_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_read_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_read_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipeline
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_read_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_read_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_read_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipeline, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_read_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipeline",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_set_favorite_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_set_favorite_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_set_favorite_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_set_favorite_api_input:
        :type pipeline_set_favorite_api_input: PipelineSetFavoriteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_set_favorite_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_set_favorite_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_set_favorite_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_set_favorite_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_set_favorite_api_input:
        :type pipeline_set_favorite_api_input: PipelineSetFavoriteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_set_favorite_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_set_favorite_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_set_favorite_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_set_favorite_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_set_favorite_api_input' in local_var_params:
            body_params = local_var_params['pipeline_set_favorite_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/favorite', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_archive_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_archive_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_archive_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_archive_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_archive_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_archive_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_archive_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_archive_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_archive_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_archive_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_archive_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_create_revision_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_create_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_create_revision_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_spec_create_revision_api_input:
        :type pipeline_spec_create_revision_api_input: PipelineSpecCreateRevisionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineSpecCreateRevisionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_create_revision_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_spec_create_revision_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_create_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_create_revision_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_spec_create_revision_api_input:
        :type pipeline_spec_create_revision_api_input: PipelineSpecCreateRevisionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineSpecCreateRevisionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_spec_create_revision_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_create_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_create_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_create_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_spec_create_revision_api_input' in local_var_params:
            body_params = local_var_params['pipeline_spec_create_revision_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineSpecCreateRevisionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_export_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_export_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_export_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param mode:
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_export_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_export_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_export_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_export_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param mode:
        :type mode: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'mode'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_export_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_export_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_export_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_export_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []
        if local_var_params.get('mode') is not None:  # noqa: E501
            query_params.append(('mode', local_var_params['mode']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_get_latest_published_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_get_latest_published_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_get_latest_published_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_get_latest_published_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_spec_get_latest_published_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_get_latest_published_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_get_latest_published_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_get_latest_published_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_get_latest_published_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_get_latest_published_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/latest_published', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_inspect_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_inspect_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_inspect_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1SpecInspectionResult
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_inspect_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_inspect_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_inspect_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_inspect_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1SpecInspectionResult, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_inspect_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_inspect_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_inspect_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_inspect_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1SpecInspectionResult",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/inspect', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_list_revision_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_list_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_list_revision_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelineSpecListRevisionAPI200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_list_revision_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_spec_list_revision_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_spec_list_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_list_revision_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelineSpecListRevisionAPI200Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_list_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_list_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_list_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelineSpecListRevisionAPI200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_publish_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_publish_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_publish_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_publish_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_publish_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_publish_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_publish_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_publish_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_publish_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_publish_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_publish_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_read_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_read_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_read_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_read_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_read_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_read_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_read_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_read_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_read_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_read_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_read_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_update_revision_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_update_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_update_revision_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_spec_update_revision_api_input:
        :type pipeline_spec_update_revision_api_input: PipelineSpecUpdateRevisionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_update_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_update_revision_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_update_revision_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_update_revision_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_spec_update_revision_api_input:
        :type pipeline_spec_update_revision_api_input: PipelineSpecUpdateRevisionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'pipeline_spec_update_revision_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_update_revision_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_update_revision_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_update_revision_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_update_revision_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_spec_update_revision_api_input' in local_var_params:
            body_params = local_var_params['pipeline_spec_update_revision_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_spec_update_revision_message_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_update_revision_message_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_update_revision_message_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_spec_update_revision_message_api_input:
        :type pipeline_spec_update_revision_message_api_input: PipelineSpecUpdateRevisionMessageAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_spec_update_revision_message_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_spec_update_revision_message_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_spec_update_revision_message_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_spec_update_revision_message_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_spec_update_revision_message_api_input:
        :type pipeline_spec_update_revision_message_api_input: PipelineSpecUpdateRevisionMessageAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'pipeline_spec_update_revision_message_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_spec_update_revision_message_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_spec_update_revision_message_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_spec_update_revision_message_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_spec_update_revision_message_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_spec_update_revision_message_api_input' in local_var_params:
            body_params = local_var_params['pipeline_spec_update_revision_message_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/message', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_create_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_create_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_create_api_input:
        :type pipeline_step_create_api_input: PipelineStepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_create_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_step_create_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_create_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_create_api_input:
        :type pipeline_step_create_api_input: PipelineStepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'pipeline_step_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_create_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_create_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_create_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/steps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_delete_api(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_delete_api(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_delete_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, **kwargs)  # noqa: E501

    def pipeline_step_delete_api_with_http_info(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_delete_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'step_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_delete_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_delete_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_delete_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `pipeline_step_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/steps/{stepID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_dependency_add_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_dependency_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_dependency_add_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_dependency_add_api_input:
        :type pipeline_step_dependency_add_api_input: PipelineStepDependencyAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_dependency_add_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_step_dependency_add_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_dependency_add_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_dependency_add_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_dependency_add_api_input:
        :type pipeline_step_dependency_add_api_input: PipelineStepDependencyAddAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'pipeline_step_dependency_add_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_dependency_add_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_dependency_add_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_dependency_add_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_dependency_add_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_dependency_add_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_dependency_add_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/step_dependency_add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_dependency_remove_api(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_dependency_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_dependency_remove_api(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_dependency_remove_api_input:
        :type pipeline_step_dependency_remove_api_input: PipelineStepDependencyRemoveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_dependency_remove_api_with_http_info(organization_name, pipeline_name, spec_revision, **kwargs)  # noqa: E501

    def pipeline_step_dependency_remove_api_with_http_info(self, organization_name, pipeline_name, spec_revision, **kwargs):  # noqa: E501
        """pipeline_step_dependency_remove_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_dependency_remove_api_with_http_info(organization_name, pipeline_name, spec_revision, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param pipeline_step_dependency_remove_api_input:
        :type pipeline_step_dependency_remove_api_input: PipelineStepDependencyRemoveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'pipeline_step_dependency_remove_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_dependency_remove_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_dependency_remove_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_dependency_remove_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_dependency_remove_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_dependency_remove_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_dependency_remove_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/step_dependency_remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_full_logs_api(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_full_logs_api(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_full_logs_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_full_logs_api_with_http_info(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_full_logs_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name',
            'step_exec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_step_execution_full_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_full_logs_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_execution_full_logs_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/{stepExecID}/logs/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_inject_sshapi(self, organization_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_inject_sshapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_inject_sshapi(organization_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_inject_sshapi_with_http_info(organization_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_inject_sshapi_with_http_info(self, organization_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_inject_sshapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_inject_sshapi_with_http_info(organization_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'step_exec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_inject_sshapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_inject_sshapi`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_inject_sshapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/{stepExecID}/inject_ssh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_logs_api(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_logs_api(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_logs_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_logs_api_with_http_info(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_logs_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name',
            'step_exec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_step_execution_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_logs_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_execution_logs_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/{stepExecID}/logs/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_read_api(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_read_api(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param log_after:
        :type log_after: float
        :param log_before:
        :type log_before: float
        :param log_limit:
        :type log_limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStepExecution
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_read_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_read_api_with_http_info(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_read_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param log_after:
        :type log_after: float
        :param log_before:
        :type log_before: float
        :param log_limit:
        :type log_limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStepExecution, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name',
            'step_exec_id',
            'log_after',
            'log_before',
            'log_limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_step_execution_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_read_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_execution_read_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []
        if local_var_params.get('log_after') is not None:  # noqa: E501
            query_params.append(('log_after', local_var_params['log_after']))  # noqa: E501
        if local_var_params.get('log_before') is not None:  # noqa: E501
            query_params.append(('log_before', local_var_params['log_before']))  # noqa: E501
        if local_var_params.get('log_limit') is not None:  # noqa: E501
            query_params.append(('log_limit', local_var_params['log_limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStepExecution",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/{stepExecID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_reassign_api(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_reassign_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_reassign_api(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param pipeline_step_execution_reassign_api_input:
        :type pipeline_step_execution_reassign_api_input: PipelineStepExecutionReassignAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_reassign_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_reassign_api_with_http_info(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_reassign_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_reassign_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param pipeline_step_execution_reassign_api_input:
        :type pipeline_step_execution_reassign_api_input: PipelineStepExecutionReassignAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name',
            'step_exec_id',
            'pipeline_step_execution_reassign_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_reassign_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_step_execution_reassign_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_reassign_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_execution_reassign_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_reassign_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_execution_reassign_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_execution_reassign_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/{stepExecID}/reassign', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_resume_api(self, organization_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_resume_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_resume_api(organization_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_resume_api_with_http_info(organization_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_resume_api_with_http_info(self, organization_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_resume_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_resume_api_with_http_info(organization_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'step_exec_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_resume_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_resume_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_resume_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/{stepExecID}/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_execution_variable_update_api(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_variable_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_variable_update_api(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param pipeline_step_execution_variable_update_api_input:
        :type pipeline_step_execution_variable_update_api_input: PipelineStepExecutionVariableUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStepExecution
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_execution_variable_update_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, **kwargs)  # noqa: E501

    def pipeline_step_execution_variable_update_api_with_http_info(self, number, organization_name, pipeline_name, step_exec_id, **kwargs):  # noqa: E501
        """pipeline_step_execution_variable_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_execution_variable_update_api_with_http_info(number, organization_name, pipeline_name, step_exec_id, async_req=True)
        >>> result = thread.get()

        :param number: (required)
        :type number: int
        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param step_exec_id: (required)
        :type step_exec_id: int
        :param pipeline_step_execution_variable_update_api_input:
        :type pipeline_step_execution_variable_update_api_input: PipelineStepExecutionVariableUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStepExecution, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'number',
            'organization_name',
            'pipeline_name',
            'step_exec_id',
            'pipeline_step_execution_variable_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_execution_variable_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'number' is set
        if self.api_client.client_side_validation and local_var_params.get('number') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `number` when calling `pipeline_step_execution_variable_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_execution_variable_update_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_execution_variable_update_api`")  # noqa: E501
        # verify the required parameter 'step_exec_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_exec_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_exec_id` when calling `pipeline_step_execution_variable_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'number' in local_var_params:
            path_params['number'] = local_var_params['number']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'step_exec_id' in local_var_params:
            path_params['stepExecID'] = local_var_params['step_exec_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_execution_variable_update_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_execution_variable_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStepExecution",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/executions/{number}/{stepExecID}/variables', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_read_api(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_read_api(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_read_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, **kwargs)  # noqa: E501

    def pipeline_step_read_api_with_http_info(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_read_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'step_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_read_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_read_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_read_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `pipeline_step_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/steps/{stepID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_type_list_api(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_step_type_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_type_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PipelinePipelineStepTypeListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_type_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def pipeline_step_type_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """pipeline_step_type_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_type_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PipelinePipelineStepTypeListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_type_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_type_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PipelinePipelineStepTypeListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipeline_step_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_step_update_api(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_update_api(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param pipeline_step_update_api_input:
        :type pipeline_step_update_api_input: PipelineStepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineStep
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_step_update_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, **kwargs)  # noqa: E501

    def pipeline_step_update_api_with_http_info(self, organization_name, pipeline_name, spec_revision, step_id, **kwargs):  # noqa: E501
        """pipeline_step_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_step_update_api_with_http_info(organization_name, pipeline_name, spec_revision, step_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param spec_revision: (required)
        :type spec_revision: int
        :param step_id: (required)
        :type step_id: int
        :param pipeline_step_update_api_input:
        :type pipeline_step_update_api_input: PipelineStepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineStep, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'spec_revision',
            'step_id',
            'pipeline_step_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_step_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_step_update_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_step_update_api`")  # noqa: E501
        # verify the required parameter 'spec_revision' is set
        if self.api_client.client_side_validation and local_var_params.get('spec_revision') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `spec_revision` when calling `pipeline_step_update_api`")  # noqa: E501
        # verify the required parameter 'step_id' is set
        if self.api_client.client_side_validation and local_var_params.get('step_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `step_id` when calling `pipeline_step_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'spec_revision' in local_var_params:
            path_params['specRevision'] = local_var_params['spec_revision']  # noqa: E501
        if 'step_id' in local_var_params:
            path_params['stepID'] = local_var_params['step_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_step_update_api_input' in local_var_params:
            body_params = local_var_params['pipeline_step_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineStep",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/spec/{specRevision}/steps/{stepID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_create_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_create_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_trigger_create_api_input:
        :type pipeline_trigger_create_api_input: PipelineTriggerCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineTrigger
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_create_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_trigger_create_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_create_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_trigger_create_api_input:
        :type pipeline_trigger_create_api_input: PipelineTriggerCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineTrigger, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_trigger_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_create_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_trigger_create_api_input' in local_var_params:
            body_params = local_var_params['pipeline_trigger_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineTrigger",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_delete_api(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_delete_api(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_delete_api_with_http_info(organization_name, pipeline_name, trigger_id, **kwargs)  # noqa: E501

    def pipeline_trigger_delete_api_with_http_info(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_delete_api_with_http_info(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'trigger_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_delete_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_delete_api`")  # noqa: E501
        # verify the required parameter 'trigger_id' is set
        if self.api_client.client_side_validation and local_var_params.get('trigger_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `trigger_id` when calling `pipeline_trigger_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'trigger_id' in local_var_params:
            path_params['triggerID'] = local_var_params['trigger_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers/{triggerID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_dispatch_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_dispatch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_dispatch_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_trigger_dispatch_api_input:
        :type pipeline_trigger_dispatch_api_input: PipelineTriggerDispatchAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseReducedPipelineExecution
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_dispatch_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_trigger_dispatch_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_dispatch_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_dispatch_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_trigger_dispatch_api_input:
        :type pipeline_trigger_dispatch_api_input: PipelineTriggerDispatchAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseReducedPipelineExecution, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_trigger_dispatch_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_dispatch_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_dispatch_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_dispatch_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_trigger_dispatch_api_input' in local_var_params:
            body_params = local_var_params['pipeline_trigger_dispatch_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseReducedPipelineExecution",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers/dispatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_list_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_list_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: list[ResponsePipelineTrigger]
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_list_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_trigger_list_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_trigger_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_list_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(list[ResponsePipelineTrigger], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_list_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "list[ResponsePipelineTrigger]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_toggle_enabled_api(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_toggle_enabled_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_toggle_enabled_api(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param pipeline_trigger_toggle_enabled_api_input:
        :type pipeline_trigger_toggle_enabled_api_input: PipelineTriggerToggleEnabledAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineTrigger
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_toggle_enabled_api_with_http_info(organization_name, pipeline_name, trigger_id, **kwargs)  # noqa: E501

    def pipeline_trigger_toggle_enabled_api_with_http_info(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_toggle_enabled_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_toggle_enabled_api_with_http_info(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param pipeline_trigger_toggle_enabled_api_input:
        :type pipeline_trigger_toggle_enabled_api_input: PipelineTriggerToggleEnabledAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineTrigger, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'trigger_id',
            'pipeline_trigger_toggle_enabled_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_toggle_enabled_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_toggle_enabled_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_toggle_enabled_api`")  # noqa: E501
        # verify the required parameter 'trigger_id' is set
        if self.api_client.client_side_validation and local_var_params.get('trigger_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `trigger_id` when calling `pipeline_trigger_toggle_enabled_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'trigger_id' in local_var_params:
            path_params['triggerID'] = local_var_params['trigger_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_trigger_toggle_enabled_api_input' in local_var_params:
            body_params = local_var_params['pipeline_trigger_toggle_enabled_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineTrigger",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers/{triggerID}/toggle_enabled', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_trigger_update_api(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_update_api(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param pipeline_trigger_update_api_input:
        :type pipeline_trigger_update_api_input: PipelineTriggerUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineTrigger
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_trigger_update_api_with_http_info(organization_name, pipeline_name, trigger_id, **kwargs)  # noqa: E501

    def pipeline_trigger_update_api_with_http_info(self, organization_name, pipeline_name, trigger_id, **kwargs):  # noqa: E501
        """pipeline_trigger_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_trigger_update_api_with_http_info(organization_name, pipeline_name, trigger_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param trigger_id: (required)
        :type trigger_id: int
        :param pipeline_trigger_update_api_input:
        :type pipeline_trigger_update_api_input: PipelineTriggerUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineTrigger, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'trigger_id',
            'pipeline_trigger_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_trigger_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_trigger_update_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_trigger_update_api`")  # noqa: E501
        # verify the required parameter 'trigger_id' is set
        if self.api_client.client_side_validation and local_var_params.get('trigger_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `trigger_id` when calling `pipeline_trigger_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501
        if 'trigger_id' in local_var_params:
            path_params['triggerID'] = local_var_params['trigger_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_trigger_update_api_input' in local_var_params:
            body_params = local_var_params['pipeline_trigger_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineTrigger",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}/triggers/{triggerID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def pipeline_update_api(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_update_api(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_update_api_input:
        :type pipeline_update_api_input: PipelineUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipeline
        """
        kwargs['_return_http_data_only'] = True
        return self.pipeline_update_api_with_http_info(organization_name, pipeline_name, **kwargs)  # noqa: E501

    def pipeline_update_api_with_http_info(self, organization_name, pipeline_name, **kwargs):  # noqa: E501
        """pipeline_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.pipeline_update_api_with_http_info(organization_name, pipeline_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param pipeline_name: (required)
        :type pipeline_name: str
        :param pipeline_update_api_input:
        :type pipeline_update_api_input: PipelineUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipeline, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'pipeline_name',
            'pipeline_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipeline_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `pipeline_update_api`")  # noqa: E501
        # verify the required parameter 'pipeline_name' is set
        if self.api_client.client_side_validation and local_var_params.get('pipeline_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `pipeline_name` when calling `pipeline_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'pipeline_name' in local_var_params:
            path_params['pipelineName'] = local_var_params['pipeline_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pipeline_update_api_input' in local_var_params:
            body_params = local_var_params['pipeline_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipeline",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/{pipelineName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_add_project_dataset_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_add_project_dataset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_add_project_dataset_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_add_project_dataset_api_input:
        :type project_add_project_dataset_api_input: ProjectAddProjectDatasetAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_add_project_dataset_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_add_project_dataset_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_add_project_dataset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_add_project_dataset_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_add_project_dataset_api_input:
        :type project_add_project_dataset_api_input: ProjectAddProjectDatasetAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_add_project_dataset_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_add_project_dataset_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_add_project_dataset_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_add_project_dataset_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_add_project_dataset_api_input' in local_var_params:
            body_params = local_var_params['project_add_project_dataset_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/project_datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_add_project_repository_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_add_project_repository_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_add_project_repository_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_add_project_repository_api_input:
        :type project_add_project_repository_api_input: ProjectAddProjectRepositoryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_add_project_repository_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_add_project_repository_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_add_project_repository_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_add_project_repository_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_add_project_repository_api_input:
        :type project_add_project_repository_api_input: ProjectAddProjectRepositoryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_add_project_repository_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_add_project_repository_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_add_project_repository_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_add_project_repository_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_add_project_repository_api_input' in local_var_params:
            body_params = local_var_params['project_add_project_repository_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/project_repositories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_create_api(self, organization_name, **kwargs):  # noqa: E501
        """project_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_create_api_input:
        :type project_create_api_input: ProjectCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def project_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """project_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_create_api_input:
        :type project_create_api_input: ProjectCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_create_api_input' in local_var_params:
            body_params = local_var_params['project_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_delete_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_delete_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.project_delete_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_delete_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_delete_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_get_key_metrics_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_get_key_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_get_key_metrics_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param force_refresh:
        :type force_refresh: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectKeyMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.project_get_key_metrics_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_get_key_metrics_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_get_key_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_get_key_metrics_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param force_refresh:
        :type force_refresh: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectKeyMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'force_refresh'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_get_key_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_get_key_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_get_key_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('force_refresh') is not None:  # noqa: E501
            query_params.append(('force_refresh', local_var_params['force_refresh']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectKeyMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/key_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_list_api(self, organization_name, **kwargs):  # noqa: E501
        """project_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param show_only_run_manage_allowed:
        :type show_only_run_manage_allowed: bool
        :param starred:
        :type starred: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def project_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """project_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param show_only_run_manage_allowed:
        :type show_only_run_manage_allowed: bool
        :param starred:
        :type starred: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'show_only_run_manage_allowed',
            'starred'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('show_only_run_manage_allowed') is not None:  # noqa: E501
            query_params.append(('show_only_run_manage_allowed', local_var_params['show_only_run_manage_allowed']))  # noqa: E501
        if local_var_params.get('starred') is not None:  # noqa: E501
            query_params.append(('starred', local_var_params['starred']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_notification_settings_create_api(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_create_api(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_notification_settings_create_api_input:
        :type project_notification_settings_create_api_input: ProjectNotificationSettingsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectNotificationSettingsCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_notification_settings_create_api_with_http_info(organization_credentials_id, organization_name, project_name, **kwargs)  # noqa: E501

    def project_notification_settings_create_api_with_http_info(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_create_api_with_http_info(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_notification_settings_create_api_input:
        :type project_notification_settings_create_api_input: ProjectNotificationSettingsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectNotificationSettingsCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_credentials_id',
            'organization_name',
            'project_name',
            'project_notification_settings_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_notification_settings_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_credentials_id' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_credentials_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_credentials_id` when calling `project_notification_settings_create_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_notification_settings_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_notification_settings_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_credentials_id' in local_var_params:
            path_params['organizationCredentialsID'] = local_var_params['organization_credentials_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_notification_settings_create_api_input' in local_var_params:
            body_params = local_var_params['project_notification_settings_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProjectProjectNotificationSettingsCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/notification_settings/{organizationCredentialsID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_notification_settings_delete_api(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_delete_api(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectNotificationSettingsDeleteResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_notification_settings_delete_api_with_http_info(organization_credentials_id, organization_name, project_name, **kwargs)  # noqa: E501

    def project_notification_settings_delete_api_with_http_info(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_delete_api_with_http_info(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectNotificationSettingsDeleteResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_credentials_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_notification_settings_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_credentials_id' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_credentials_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_credentials_id` when calling `project_notification_settings_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_notification_settings_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_notification_settings_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_credentials_id' in local_var_params:
            path_params['organizationCredentialsID'] = local_var_params['organization_credentials_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProjectProjectNotificationSettingsDeleteResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/notification_settings/{organizationCredentialsID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_notification_settings_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectNotificationSettingsListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_notification_settings_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_notification_settings_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectNotificationSettingsListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_notification_settings_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_notification_settings_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_notification_settings_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProjectProjectNotificationSettingsListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/notification_settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_notification_settings_update_api(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_update_api(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_notification_settings_update_api_input:
        :type project_notification_settings_update_api_input: ProjectNotificationSettingsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProjectProjectNotificationSettingsUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_notification_settings_update_api_with_http_info(organization_credentials_id, organization_name, project_name, **kwargs)  # noqa: E501

    def project_notification_settings_update_api_with_http_info(self, organization_credentials_id, organization_name, project_name, **kwargs):  # noqa: E501
        """project_notification_settings_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_notification_settings_update_api_with_http_info(organization_credentials_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_credentials_id: (required)
        :type organization_credentials_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_notification_settings_update_api_input:
        :type project_notification_settings_update_api_input: ProjectNotificationSettingsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProjectProjectNotificationSettingsUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_credentials_id',
            'organization_name',
            'project_name',
            'project_notification_settings_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_notification_settings_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_credentials_id' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_credentials_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_credentials_id` when calling `project_notification_settings_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_notification_settings_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_notification_settings_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_credentials_id' in local_var_params:
            path_params['organizationCredentialsID'] = local_var_params['organization_credentials_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_notification_settings_update_api_input' in local_var_params:
            body_params = local_var_params['project_notification_settings_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ProjectProjectNotificationSettingsUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/notification_settings/{organizationCredentialsID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_policy_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_policy_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacProjectPolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.project_policy_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_policy_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_policy_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacProjectPolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_policy_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacProjectPolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_policy_update_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_policy_update_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_policy_update_api_input:
        :type project_policy_update_api_input: ProjectPolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.project_policy_update_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_policy_update_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_policy_update_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_policy_update_api_input:
        :type project_policy_update_api_input: ProjectPolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_policy_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_policy_update_api_input' in local_var_params:
            body_params = local_var_params['project_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_read_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_read_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_read_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_read_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_remove_project_dataset_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_remove_project_dataset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_remove_project_dataset_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_remove_project_dataset_api_input:
        :type project_remove_project_dataset_api_input: ProjectRemoveProjectDatasetAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_remove_project_dataset_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_remove_project_dataset_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_remove_project_dataset_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_remove_project_dataset_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_remove_project_dataset_api_input:
        :type project_remove_project_dataset_api_input: ProjectRemoveProjectDatasetAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_remove_project_dataset_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_remove_project_dataset_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_remove_project_dataset_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_remove_project_dataset_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_remove_project_dataset_api_input' in local_var_params:
            body_params = local_var_params['project_remove_project_dataset_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/project_datasets', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_remove_project_repository_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_remove_project_repository_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_remove_project_repository_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_remove_project_repository_api_input:
        :type project_remove_project_repository_api_input: ProjectRemoveProjectRepositoryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_remove_project_repository_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_remove_project_repository_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_remove_project_repository_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_remove_project_repository_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_remove_project_repository_api_input:
        :type project_remove_project_repository_api_input: ProjectRemoveProjectRepositoryAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_remove_project_repository_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_remove_project_repository_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_remove_project_repository_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_remove_project_repository_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_remove_project_repository_api_input' in local_var_params:
            body_params = local_var_params['project_remove_project_repository_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/project_repositories', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_star_api(self, organization_name, **kwargs):  # noqa: E501
        """project_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_star_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_star_api_input:
        :type project_star_api_input: ProjectStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.project_star_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def project_star_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """project_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_star_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_star_api_input:
        :type project_star_api_input: ProjectStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_star_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_star_api_input' in local_var_params:
            body_params = local_var_params['project_star_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_unstar_api(self, organization_name, **kwargs):  # noqa: E501
        """project_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_unstar_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_unstar_api_input:
        :type project_unstar_api_input: ProjectUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.project_unstar_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def project_unstar_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """project_unstar_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_unstar_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_unstar_api_input:
        :type project_unstar_api_input: ProjectUnstarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_unstar_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_unstar_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_unstar_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_unstar_api_input' in local_var_params:
            body_params = local_var_params['project_unstar_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/unstar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def project_update_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_update_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_update_api_input:
        :type project_update_api_input: ProjectUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseProjectInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.project_update_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def project_update_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """project_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.project_update_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param project_update_api_input:
        :type project_update_api_input: ProjectUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseProjectInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'project_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method project_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `project_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `project_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'project_update_api_input' in local_var_params:
            body_params = local_var_params['project_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseProjectInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_cluster_list_api(self, organization_name, **kwargs):  # noqa: E501
        """public_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_cluster_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterPublicClusterListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.public_cluster_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def public_cluster_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """public_cluster_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_cluster_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterPublicClusterListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_cluster_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `public_cluster_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ClusterPublicClusterListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/public_clusters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_injects_read_by_key_api(self, key, **kwargs):  # noqa: E501
        """public_hub_model_injects_read_by_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_injects_read_by_key_api(key, async_req=True)
        >>> result = thread.get()

        :param key: (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PublicHubModelInjectsReadByKeyAPI200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_injects_read_by_key_api_with_http_info(key, **kwargs)  # noqa: E501

    def public_hub_model_injects_read_by_key_api_with_http_info(self, key, **kwargs):  # noqa: E501
        """public_hub_model_injects_read_by_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_injects_read_by_key_api_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PublicHubModelInjectsReadByKeyAPI200Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_injects_read_by_key_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and local_var_params.get('key') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `public_hub_model_injects_read_by_key_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('key') is not None:  # noqa: E501
            query_params.append(('key', local_var_params['key']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "PublicHubModelInjectsReadByKeyAPI200Response",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks/key/injects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_task_category_list_api(self, **kwargs):  # noqa: E501
        """public_hub_model_task_category_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_category_list_api(async_req=True)
        >>> result = thread.get()

        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HubPublicHubModelTaskCategoryListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_task_category_list_api_with_http_info(**kwargs)  # noqa: E501

    def public_hub_model_task_category_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """public_hub_model_task_category_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_category_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HubPublicHubModelTaskCategoryListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_task_category_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('type') is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "HubPublicHubModelTaskCategoryListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_task_list_api(self, **kwargs):  # noqa: E501
        """public_hub_model_task_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_list_api(async_req=True)
        >>> result = thread.get()

        :param category_id:
        :type category_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param tag_match:
        :type tag_match: str
        :param type_match:
        :type type_match: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseHubModelTaskListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_task_list_api_with_http_info(**kwargs)  # noqa: E501

    def public_hub_model_task_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """public_hub_model_task_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param category_id:
        :type category_id: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param tag_match:
        :type tag_match: str
        :param type_match:
        :type type_match: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseHubModelTaskListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'category_id',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'tag_match',
            'type_match'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_task_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('category_id') is not None:  # noqa: E501
            query_params.append(('category_id', local_var_params['category_id']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('tag_match') is not None:  # noqa: E501
            query_params.append(('tag_match', local_var_params['tag_match']))  # noqa: E501
        if local_var_params.get('type_match') is not None:  # noqa: E501
            query_params.append(('type_match', local_var_params['type_match']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseHubModelTaskListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_task_pipeline_spec_read_api(self, task_key, **kwargs):  # noqa: E501
        """public_hub_model_task_pipeline_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_pipeline_spec_read_api(task_key, async_req=True)
        >>> result = thread.get()

        :param task_key: (required)
        :type task_key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponsePipelineSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_task_pipeline_spec_read_api_with_http_info(task_key, **kwargs)  # noqa: E501

    def public_hub_model_task_pipeline_spec_read_api_with_http_info(self, task_key, **kwargs):  # noqa: E501
        """public_hub_model_task_pipeline_spec_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_pipeline_spec_read_api_with_http_info(task_key, async_req=True)
        >>> result = thread.get()

        :param task_key: (required)
        :type task_key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponsePipelineSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'task_key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_task_pipeline_spec_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'task_key' is set
        if self.api_client.client_side_validation and local_var_params.get('task_key') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_key` when calling `public_hub_model_task_pipeline_spec_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_key' in local_var_params:
            path_params['taskKey'] = local_var_params['task_key']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponsePipelineSpec",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks/key/{taskKey}/pipelines/spec', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_task_read_api(self, task_id, **kwargs):  # noqa: E501
        """public_hub_model_task_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_read_api(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1HubModelTaskSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_task_read_api_with_http_info(task_id, **kwargs)  # noqa: E501

    def public_hub_model_task_read_api_with_http_info(self, task_id, **kwargs):  # noqa: E501
        """public_hub_model_task_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_read_api_with_http_info(task_id, async_req=True)
        >>> result = thread.get()

        :param task_id: (required)
        :type task_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1HubModelTaskSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_task_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and local_var_params.get('task_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `public_hub_model_task_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in local_var_params:
            path_params['taskID'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1HubModelTaskSpec",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks/{taskID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def public_hub_model_task_read_by_key_api(self, key, **kwargs):  # noqa: E501
        """public_hub_model_task_read_by_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_read_by_key_api(key, async_req=True)
        >>> result = thread.get()

        :param key: (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: V1HubModelTaskSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.public_hub_model_task_read_by_key_api_with_http_info(key, **kwargs)  # noqa: E501

    def public_hub_model_task_read_by_key_api_with_http_info(self, key, **kwargs):  # noqa: E501
        """public_hub_model_task_read_by_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.public_hub_model_task_read_by_key_api_with_http_info(key, async_req=True)
        >>> result = thread.get()

        :param key: (required)
        :type key: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(V1HubModelTaskSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method public_hub_model_task_read_by_key_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and local_var_params.get('key') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `public_hub_model_task_read_by_key_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('key') is not None:  # noqa: E501
            query_params.append(('key', local_var_params['key']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "V1HubModelTaskSpec",
        }

        return self.api_client.call_api(
            '/api/v1/hub/model_tasks/key', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def remove_git_ssh_key_api(self, **kwargs):  # noqa: E501
        """remove_git_ssh_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_git_ssh_key_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_git_ssh_key_api_with_http_info(**kwargs)  # noqa: E501

    def remove_git_ssh_key_api_with_http_info(self, **kwargs):  # noqa: E501
        """remove_git_ssh_key_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_git_ssh_key_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_git_ssh_key_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/git_ssh_keys', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def resend_verify_email_api(self, **kwargs):  # noqa: E501
        """resend_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.resend_verify_email_api(async_req=True)
        >>> result = thread.get()

        :param resend_verify_email_api_input:
        :type resend_verify_email_api_input: ResendVerifyEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.resend_verify_email_api_with_http_info(**kwargs)  # noqa: E501

    def resend_verify_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """resend_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.resend_verify_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param resend_verify_email_api_input:
        :type resend_verify_email_api_input: ResendVerifyEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'resend_verify_email_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resend_verify_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resend_verify_email_api_input' in local_var_params:
            body_params = local_var_params['resend_verify_email_api_input']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/verify_email/resend', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def reset_password_token_generate_api(self, email, **kwargs):  # noqa: E501
        """reset_password_token_generate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reset_password_token_generate_api(email, async_req=True)
        >>> result = thread.get()

        :param email: (required)
        :type email: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_token_generate_api_with_http_info(email, **kwargs)  # noqa: E501

    def reset_password_token_generate_api_with_http_info(self, email, **kwargs):  # noqa: E501
        """reset_password_token_generate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reset_password_token_generate_api_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param email: (required)
        :type email: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'email'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password_token_generate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and local_var_params.get('email') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `reset_password_token_generate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('email') is not None:  # noqa: E501
            query_params.append(('email', local_var_params['email']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/reset_password/generate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def reset_password_token_redeem_api(self, **kwargs):  # noqa: E501
        """reset_password_token_redeem_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reset_password_token_redeem_api(async_req=True)
        >>> result = thread.get()

        :param reset_password_token_redeem_api_input:
        :type reset_password_token_redeem_api_input: ResetPasswordTokenRedeemAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_token_redeem_api_with_http_info(**kwargs)  # noqa: E501

    def reset_password_token_redeem_api_with_http_info(self, **kwargs):  # noqa: E501
        """reset_password_token_redeem_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reset_password_token_redeem_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param reset_password_token_redeem_api_input:
        :type reset_password_token_redeem_api_input: ResetPasswordTokenRedeemAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'reset_password_token_redeem_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password_token_redeem_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reset_password_token_redeem_api_input' in local_var_params:
            body_params = local_var_params['reset_password_token_redeem_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/reset_password/redeem', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_exec_interactive_check_extendable_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_exec_interactive_check_extendable_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_exec_interactive_check_extendable_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionInteractiveExtendableResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_exec_interactive_check_extendable_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_exec_interactive_check_extendable_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_exec_interactive_check_extendable_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_exec_interactive_check_extendable_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionInteractiveExtendableResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_exec_interactive_check_extendable_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_exec_interactive_check_extendable_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_exec_interactive_check_extendable_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_exec_interactive_check_extendable_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionInteractiveExtendableResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/check_extendable', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_add_tag_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_add_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_add_tag_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_add_tag_api_input:
        :type run_execution_add_tag_api_input: RunExecutionAddTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_add_tag_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_add_tag_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_add_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_add_tag_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_add_tag_api_input:
        :type run_execution_add_tag_api_input: RunExecutionAddTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_add_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_add_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_add_tag_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_add_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_add_tag_api_input' in local_var_params:
            body_params = local_var_params['run_execution_add_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/add_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_bulk_delete_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_bulk_delete_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_bulk_delete_api_input:
        :type run_execution_bulk_delete_api_input: RunExecutionBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_bulk_delete_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_bulk_delete_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_bulk_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_bulk_delete_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_bulk_delete_api_input:
        :type run_execution_bulk_delete_api_input: RunExecutionBulkDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_bulk_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_bulk_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_bulk_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_bulk_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_bulk_delete_api_input' in local_var_params:
            body_params = local_var_params['run_execution_bulk_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions_delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_bulk_terminate_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_bulk_terminate_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_bulk_terminate_api_input:
        :type run_execution_bulk_terminate_api_input: RunExecutionBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_bulk_terminate_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_bulk_terminate_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_bulk_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_bulk_terminate_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_bulk_terminate_api_input:
        :type run_execution_bulk_terminate_api_input: RunExecutionBulkTerminateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_bulk_terminate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_bulk_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_bulk_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_bulk_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_bulk_terminate_api_input' in local_var_params:
            body_params = local_var_params['run_execution_bulk_terminate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions_terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_delete_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_delete_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_delete_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_delete_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_delete_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_delete_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_edit_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_edit_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_edit_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_edit_api_input:
        :type run_execution_edit_api_input: RunExecutionEditAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunExecutionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_edit_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_edit_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_edit_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_edit_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_edit_api_input:
        :type run_execution_edit_api_input: RunExecutionEditAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunExecutionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name',
            'run_execution_edit_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_edit_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_edit_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_edit_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_edit_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_edit_api_input' in local_var_params:
            body_params = local_var_params['run_execution_edit_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunExecutionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_extend_interactive_running_time_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_extend_interactive_running_time_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_extend_interactive_running_time_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_extend_interactive_running_time_api_input:
        :type run_execution_extend_interactive_running_time_api_input: RunExecutionExtendInteractiveRunningTimeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunExecutionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_extend_interactive_running_time_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_extend_interactive_running_time_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_extend_interactive_running_time_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_extend_interactive_running_time_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_extend_interactive_running_time_api_input:
        :type run_execution_extend_interactive_running_time_api_input: RunExecutionExtendInteractiveRunningTimeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunExecutionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name',
            'run_execution_extend_interactive_running_time_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_extend_interactive_running_time_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_extend_interactive_running_time_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_extend_interactive_running_time_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_extend_interactive_running_time_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_extend_interactive_running_time_api_input' in local_var_params:
            body_params = local_var_params['run_execution_extend_interactive_running_time_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunExecutionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/extend_runningtime', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_full_logs_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_full_logs_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_full_logs_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_full_logs_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_full_logs_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_full_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_full_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunExecutionListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param type:
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunExecutionListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'starred',
            'statuses',
            'type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('starred') is not None:  # noqa: E501
            query_params.append(('starred', local_var_params['starred']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if local_var_params.get('type') is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunExecutionListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_list_count_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_list_count_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_list_count_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param keyword:
        :type keyword: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionListCountResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_list_count_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_list_count_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_list_count_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_list_count_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param keyword:
        :type keyword: str
        :param starred:
        :type starred: bool
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionListCountResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'keyword',
            'starred',
            'statuses'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_list_count_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_list_count_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_list_count_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('starred') is not None:  # noqa: E501
            query_params.append(('starred', local_var_params['starred']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionListCountResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_logs_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_logs_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param log_end:
        :type log_end: float
        :param log_limit:
        :type log_limit: int
        :param log_start:
        :type log_start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_logs_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_logs_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_logs_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param log_end:
        :type log_end: float
        :param log_limit:
        :type log_limit: int
        :param log_start:
        :type log_start: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name',
            'log_end',
            'log_limit',
            'log_start'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_logs_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('log_end') is not None:  # noqa: E501
            query_params.append(('log_end', local_var_params['log_end']))  # noqa: E501
        if local_var_params.get('log_limit') is not None:  # noqa: E501
            query_params.append(('log_limit', local_var_params['log_limit']))  # noqa: E501
        if local_var_params.get('log_start') is not None:  # noqa: E501
            query_params.append(('log_start', local_var_params['log_start']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_read_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunExecutionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_read_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_read_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunExecutionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_read_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunExecutionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_read_plots_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_plots_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionReadPlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_read_plots_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_read_plots_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_plots_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionReadPlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_read_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_read_plots_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_read_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_read_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionReadPlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/plots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_read_plots_as_csvapi(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_plots_as_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_plots_as_csvapi(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_read_plots_as_csvapi_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_read_plots_as_csvapi_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_read_plots_as_csvapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_read_plots_as_csvapi_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_read_plots_as_csvapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_read_plots_as_csvapi`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_read_plots_as_csvapi`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_read_plots_as_csvapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/plots/csv', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_recent_list_api(self, organization_name, **kwargs):  # noqa: E501
        """run_execution_recent_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_recent_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionRecentListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_recent_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def run_execution_recent_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """run_execution_recent_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_recent_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionRecentListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_recent_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_recent_list_api`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 10:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `run_execution_recent_list_api`, must be a value less than or equal to `10`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionRecentListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/run_executions/recent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_remove_tag_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_remove_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_remove_tag_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_remove_tag_api_input:
        :type run_execution_remove_tag_api_input: RunExecutionRemoveTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_remove_tag_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_remove_tag_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_remove_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_remove_tag_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_remove_tag_api_input:
        :type run_execution_remove_tag_api_input: RunExecutionRemoveTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_remove_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_remove_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_remove_tag_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_remove_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_remove_tag_api_input' in local_var_params:
            body_params = local_var_params['run_execution_remove_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/remove_tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_star_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_star_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_star_api_input:
        :type run_execution_star_api_input: RunExecutionStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_star_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_star_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_star_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_star_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_star_api_input:
        :type run_execution_star_api_input: RunExecutionStarAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_star_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_star_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_star_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_star_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_execution_star_api_input' in local_var_params:
            body_params = local_var_params['run_execution_star_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/update_star', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_system_metrics_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_system_metrics_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunExecutionSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_system_metrics_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_system_metrics_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_system_metrics_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunExecutionSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name',
            'after',
            'before'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunExecutionSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_execution_terminate_api(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_terminate_api(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunExecutionInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.run_execution_terminate_api_with_http_info(execution_id, organization_name, project_name, **kwargs)  # noqa: E501

    def run_execution_terminate_api_with_http_info(self, execution_id, organization_name, project_name, **kwargs):  # noqa: E501
        """run_execution_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_execution_terminate_api_with_http_info(execution_id, organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param execution_id: (required)
        :type execution_id: int
        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunExecutionInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'execution_id',
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_execution_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'execution_id' is set
        if self.api_client.client_side_validation and local_var_params.get('execution_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `execution_id` when calling `run_execution_terminate_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_execution_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_execution_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'execution_id' in local_var_params:
            path_params['executionID'] = local_var_params['execution_id']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunExecutionInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run_executions/{executionID}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_spec_create_for_pipeline_api(self, organization_name, **kwargs):  # noqa: E501
        """run_spec_create_for_pipeline_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_create_for_pipeline_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param run_spec_create_for_pipeline_api_input:
        :type run_spec_create_for_pipeline_api_input: RunSpecCreateForPipelineAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseRunSpec
        """
        kwargs['_return_http_data_only'] = True
        return self.run_spec_create_for_pipeline_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def run_spec_create_for_pipeline_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """run_spec_create_for_pipeline_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_create_for_pipeline_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param run_spec_create_for_pipeline_api_input:
        :type run_spec_create_for_pipeline_api_input: RunSpecCreateForPipelineAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseRunSpec, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'run_spec_create_for_pipeline_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_spec_create_for_pipeline_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_spec_create_for_pipeline_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_spec_create_for_pipeline_api_input' in local_var_params:
            body_params = local_var_params['run_spec_create_for_pipeline_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseRunSpec",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/pipelines/run/spec', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_spec_create_from_yamlapi(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_spec_create_from_yamlapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_create_from_yamlapi(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_spec_create_from_yamlapi_input:
        :type run_spec_create_from_yamlapi_input: RunSpecCreateFromYAMLAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunSpecCreateFromYAMLResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_spec_create_from_yamlapi_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_spec_create_from_yamlapi_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_spec_create_from_yamlapi  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_create_from_yamlapi_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_spec_create_from_yamlapi_input:
        :type run_spec_create_from_yamlapi_input: RunSpecCreateFromYAMLAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunSpecCreateFromYAMLResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_spec_create_from_yamlapi_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_spec_create_from_yamlapi" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_spec_create_from_yamlapi`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_spec_create_from_yamlapi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_spec_create_from_yamlapi_input' in local_var_params:
            body_params = local_var_params['run_spec_create_from_yamlapi_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunSpecCreateFromYAMLResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run/spec/create_from_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_spec_form_sync_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_spec_form_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_form_sync_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_spec_form_sync_api_input:
        :type run_spec_form_sync_api_input: RunSpecFormSyncAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunSpecFormSyncResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.run_spec_form_sync_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def run_spec_form_sync_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """run_spec_form_sync_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_form_sync_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_spec_form_sync_api_input:
        :type run_spec_form_sync_api_input: RunSpecFormSyncAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunSpecFormSyncResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_spec_form_sync_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_spec_form_sync_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_spec_form_sync_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `run_spec_form_sync_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_spec_form_sync_api_input' in local_var_params:
            body_params = local_var_params['run_spec_form_sync_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunSpecFormSyncResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/run/spec/sync_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def run_spec_form_sync_v2_api(self, organization_name, **kwargs):  # noqa: E501
        """run_spec_form_sync_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_form_sync_v2_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param run_spec_form_sync_v2_api_input:
        :type run_spec_form_sync_v2_api_input: RunSpecFormSyncV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RunRunSpecFormSyncV2Response
        """
        kwargs['_return_http_data_only'] = True
        return self.run_spec_form_sync_v2_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def run_spec_form_sync_v2_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """run_spec_form_sync_v2_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.run_spec_form_sync_v2_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param run_spec_form_sync_v2_api_input:
        :type run_spec_form_sync_v2_api_input: RunSpecFormSyncV2APIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RunRunSpecFormSyncV2Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'run_spec_form_sync_v2_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_spec_form_sync_v2_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `run_spec_form_sync_v2_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'run_spec_form_sync_v2_api_input' in local_var_params:
            body_params = local_var_params['run_spec_form_sync_v2_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RunRunSpecFormSyncV2Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/run/spec/sync_yaml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s3_dataset_create_api(self, organization_name, **kwargs):  # noqa: E501
        """s3_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s3_dataset_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param s3_dataset_create_api_input:
        :type s3_dataset_create_api_input: S3DatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.s3_dataset_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def s3_dataset_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """s3_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s3_dataset_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param s3_dataset_create_api_input:
        :type s3_dataset_create_api_input: S3DatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            's3_dataset_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s3_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `s3_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 's3_dataset_create_api_input' in local_var_params:
            body_params = local_var_params['s3_dataset_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets_s3', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s_sh_key_create_api(self, **kwargs):  # noqa: E501
        """s_sh_key_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_create_api(async_req=True)
        >>> result = thread.get()

        :param ssh_key_create_api_input:
        :type ssh_key_create_api_input: SSHKeyCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSSHKeyInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.s_sh_key_create_api_with_http_info(**kwargs)  # noqa: E501

    def s_sh_key_create_api_with_http_info(self, **kwargs):  # noqa: E501
        """s_sh_key_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_create_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param ssh_key_create_api_input:
        :type ssh_key_create_api_input: SSHKeyCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSSHKeyInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ssh_key_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s_sh_key_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ssh_key_create_api_input' in local_var_params:
            body_params = local_var_params['ssh_key_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSSHKeyInfo",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/ssh_keys', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s_sh_key_delete_api(self, ssh_key_id, **kwargs):  # noqa: E501
        """s_sh_key_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_delete_api(ssh_key_id, async_req=True)
        >>> result = thread.get()

        :param ssh_key_id: (required)
        :type ssh_key_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.s_sh_key_delete_api_with_http_info(ssh_key_id, **kwargs)  # noqa: E501

    def s_sh_key_delete_api_with_http_info(self, ssh_key_id, **kwargs):  # noqa: E501
        """s_sh_key_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_delete_api_with_http_info(ssh_key_id, async_req=True)
        >>> result = thread.get()

        :param ssh_key_id: (required)
        :type ssh_key_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'ssh_key_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s_sh_key_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ssh_key_id' is set
        if self.api_client.client_side_validation and local_var_params.get('ssh_key_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `ssh_key_id` when calling `s_sh_key_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ssh_key_id' in local_var_params:
            path_params['sshKeyID'] = local_var_params['ssh_key_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/ssh_keys/{sshKeyID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s_sh_key_list_api(self, **kwargs):  # noqa: E501
        """s_sh_key_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountSSHKeyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.s_sh_key_list_api_with_http_info(**kwargs)  # noqa: E501

    def s_sh_key_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """s_sh_key_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sh_key_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountSSHKeyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s_sh_key_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountSSHKeyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/ssh_keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s_so_config_read_api(self, organization_name, **kwargs):  # noqa: E501
        """s_so_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_so_config_read_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SsoSSOConfigReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.s_so_config_read_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def s_so_config_read_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """s_so_config_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_so_config_read_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SsoSSOConfigReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s_so_config_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `s_so_config_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "SsoSSOConfigReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/sso/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def s_sosamlidp_config_update_api(self, organization_name, **kwargs):  # noqa: E501
        """s_sosamlidp_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sosamlidp_config_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param ssosamlidp_config_update_api_input:
        :type ssosamlidp_config_update_api_input: SSOSAMLIDPConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.s_sosamlidp_config_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def s_sosamlidp_config_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """s_sosamlidp_config_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.s_sosamlidp_config_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param ssosamlidp_config_update_api_input:
        :type ssosamlidp_config_update_api_input: SSOSAMLIDPConfigUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'ssosamlidp_config_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method s_sosamlidp_config_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `s_sosamlidp_config_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'ssosamlidp_config_update_api_input' in local_var_params:
            body_params = local_var_params['ssosamlidp_config_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/sso/config/saml', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def schedule_withdraw_api(self, **kwargs):  # noqa: E501
        """schedule_withdraw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.schedule_withdraw_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.schedule_withdraw_api_with_http_info(**kwargs)  # noqa: E501

    def schedule_withdraw_api_with_http_info(self, **kwargs):  # noqa: E501
        """schedule_withdraw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.schedule_withdraw_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_withdraw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/withdraw', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_aws_credentials_create_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_aws_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_aws_credentials_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_aws_credentials_create_api_input:
        :type secret_aws_credentials_create_api_input: SecretAWSCredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_aws_credentials_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_aws_credentials_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_aws_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_aws_credentials_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_aws_credentials_create_api_input:
        :type secret_aws_credentials_create_api_input: SecretAWSCredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_aws_credentials_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_aws_credentials_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_aws_credentials_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_aws_credentials_create_api_input' in local_var_params:
            body_params = local_var_params['secret_aws_credentials_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/aws', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_delete_secret_api(self, organization_name, secret_id, kind, **kwargs):  # noqa: E501
        """secret_delete_secret_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_delete_secret_api(organization_name, secret_id, kind, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param kind: (required)
        :type kind: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_delete_secret_api_with_http_info(organization_name, secret_id, kind, **kwargs)  # noqa: E501

    def secret_delete_secret_api_with_http_info(self, organization_name, secret_id, kind, **kwargs):  # noqa: E501
        """secret_delete_secret_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_delete_secret_api_with_http_info(organization_name, secret_id, kind, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param kind: (required)
        :type kind: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_id',
            'kind'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_delete_secret_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_delete_secret_api`")  # noqa: E501
        # verify the required parameter 'secret_id' is set
        if self.api_client.client_side_validation and local_var_params.get('secret_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `secret_id` when calling `secret_delete_secret_api`")  # noqa: E501
        # verify the required parameter 'kind' is set
        if self.api_client.client_side_validation and local_var_params.get('kind') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `kind` when calling `secret_delete_secret_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'secret_id' in local_var_params:
            path_params['secretID'] = local_var_params['secret_id']  # noqa: E501

        query_params = []
        if local_var_params.get('kind') is not None:  # noqa: E501
            query_params.append(('kind', local_var_params['kind']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/by_id/v2/{secretID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_gcp_credentials_create_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_gcp_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_gcp_credentials_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_gcp_credentials_create_api_input:
        :type secret_gcp_credentials_create_api_input: SecretGCPCredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_gcp_credentials_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_gcp_credentials_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_gcp_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_gcp_credentials_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_gcp_credentials_create_api_input:
        :type secret_gcp_credentials_create_api_input: SecretGCPCredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_gcp_credentials_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_gcp_credentials_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_gcp_credentials_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_gcp_credentials_create_api_input' in local_var_params:
            body_params = local_var_params['secret_gcp_credentials_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/gcp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_generic_secret_create_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_create_api_input:
        :type secret_generic_secret_create_api_input: SecretGenericSecretCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_generic_secret_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_generic_secret_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_create_api_input:
        :type secret_generic_secret_create_api_input: SecretGenericSecretCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_generic_secret_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_generic_secret_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_generic_secret_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_generic_secret_create_api_input' in local_var_params:
            body_params = local_var_params['secret_generic_secret_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/v2/generic_secret', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_generic_secret_delete_api(self, organization_name, secret_id, **kwargs):  # noqa: E501
        """secret_generic_secret_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_delete_api(organization_name, secret_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_generic_secret_delete_api_with_http_info(organization_name, secret_id, **kwargs)  # noqa: E501

    def secret_generic_secret_delete_api_with_http_info(self, organization_name, secret_id, **kwargs):  # noqa: E501
        """secret_generic_secret_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_delete_api_with_http_info(organization_name, secret_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_generic_secret_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_generic_secret_delete_api`")  # noqa: E501
        # verify the required parameter 'secret_id' is set
        if self.api_client.client_side_validation and local_var_params.get('secret_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `secret_id` when calling `secret_generic_secret_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'secret_id' in local_var_params:
            path_params['secretID'] = local_var_params['secret_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/by_id/{secretID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_generic_secret_update_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_update_api_input:
        :type secret_generic_secret_update_api_input: SecretGenericSecretUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_generic_secret_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_generic_secret_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_update_api_input:
        :type secret_generic_secret_update_api_input: SecretGenericSecretUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_generic_secret_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_generic_secret_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_generic_secret_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_generic_secret_update_api_input' in local_var_params:
            body_params = local_var_params['secret_generic_secret_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/v2/generic_secret', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_generic_secret_upsert_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_upsert_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_upsert_api_input:
        :type secret_generic_secret_upsert_api_input: SecretGenericSecretUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_generic_secret_upsert_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_generic_secret_upsert_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_generic_secret_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_generic_secret_upsert_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_generic_secret_upsert_api_input:
        :type secret_generic_secret_upsert_api_input: SecretGenericSecretUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_generic_secret_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_generic_secret_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_generic_secret_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_generic_secret_upsert_api_input' in local_var_params:
            body_params = local_var_params['secret_generic_secret_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/generic_secret', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_list_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param kind:
        :type kind: str
        :param kinds:
        :type kinds: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecretList
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param kind:
        :type kind: str
        :param kinds:
        :type kinds: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecretList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'kind',
            'kinds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('kind') is not None:  # noqa: E501
            query_params.append(('kind', local_var_params['kind']))  # noqa: E501
        if local_var_params.get('kinds') is not None:  # noqa: E501
            query_params.append(('kinds', local_var_params['kinds']))  # noqa: E501
            collection_formats['kinds'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecretList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_open_ai_credentials_create_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_create_api_input:
        :type secret_open_ai_credentials_create_api_input: SecretOpenAICredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_open_ai_credentials_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_open_ai_credentials_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_create_api_input:
        :type secret_open_ai_credentials_create_api_input: SecretOpenAICredentialsCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_open_ai_credentials_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_open_ai_credentials_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_open_ai_credentials_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_open_ai_credentials_create_api_input' in local_var_params:
            body_params = local_var_params['secret_open_ai_credentials_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/v2/openai', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_open_ai_credentials_update_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_update_api_input:
        :type secret_open_ai_credentials_update_api_input: SecretOpenAICredentialsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_open_ai_credentials_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_open_ai_credentials_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_update_api_input:
        :type secret_open_ai_credentials_update_api_input: SecretOpenAICredentialsUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_open_ai_credentials_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_open_ai_credentials_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_open_ai_credentials_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_open_ai_credentials_update_api_input' in local_var_params:
            body_params = local_var_params['secret_open_ai_credentials_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/v2/openai', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_open_ai_credentials_upsert_api(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_upsert_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_upsert_api_input:
        :type secret_open_ai_credentials_upsert_api_input: SecretOpenAICredentialsUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_open_ai_credentials_upsert_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def secret_open_ai_credentials_upsert_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """secret_open_ai_credentials_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_open_ai_credentials_upsert_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_open_ai_credentials_upsert_api_input:
        :type secret_open_ai_credentials_upsert_api_input: SecretOpenAICredentialsUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_open_ai_credentials_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_open_ai_credentials_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_open_ai_credentials_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'secret_open_ai_credentials_upsert_api_input' in local_var_params:
            body_params = local_var_params['secret_open_ai_credentials_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/openai', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_read_api(self, organization_name, secret_id, **kwargs):  # noqa: E501
        """secret_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_read_api(organization_name, secret_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_read_api_with_http_info(organization_name, secret_id, **kwargs)  # noqa: E501

    def secret_read_api_with_http_info(self, organization_name, secret_id, **kwargs):  # noqa: E501
        """secret_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_read_api_with_http_info(organization_name, secret_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param secret_id: (required)
        :type secret_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'secret_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_read_api`")  # noqa: E501
        # verify the required parameter 'secret_id' is set
        if self.api_client.client_side_validation and local_var_params.get('secret_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `secret_id` when calling `secret_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'secret_id' in local_var_params:
            path_params['secretID'] = local_var_params['secret_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/by_id/{secretID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def secret_read_by_kind_name_api(self, kind, organization_name, secret_name, **kwargs):  # noqa: E501
        """secret_read_by_kind_name_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_read_by_kind_name_api(kind, organization_name, secret_name, async_req=True)
        >>> result = thread.get()

        :param kind: (required)
        :type kind: str
        :param organization_name: (required)
        :type organization_name: str
        :param secret_name: (required)
        :type secret_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSecret
        """
        kwargs['_return_http_data_only'] = True
        return self.secret_read_by_kind_name_api_with_http_info(kind, organization_name, secret_name, **kwargs)  # noqa: E501

    def secret_read_by_kind_name_api_with_http_info(self, kind, organization_name, secret_name, **kwargs):  # noqa: E501
        """secret_read_by_kind_name_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.secret_read_by_kind_name_api_with_http_info(kind, organization_name, secret_name, async_req=True)
        >>> result = thread.get()

        :param kind: (required)
        :type kind: str
        :param organization_name: (required)
        :type organization_name: str
        :param secret_name: (required)
        :type secret_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSecret, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'kind',
            'organization_name',
            'secret_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_read_by_kind_name_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'kind' is set
        if self.api_client.client_side_validation and local_var_params.get('kind') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `kind` when calling `secret_read_by_kind_name_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `secret_read_by_kind_name_api`")  # noqa: E501
        # verify the required parameter 'secret_name' is set
        if self.api_client.client_side_validation and local_var_params.get('secret_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `secret_name` when calling `secret_read_by_kind_name_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'kind' in local_var_params:
            path_params['kind'] = local_var_params['kind']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'secret_name' in local_var_params:
            path_params['secretName'] = local_var_params['secret_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSecret",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/secrets/by_kind/{kind}/{secretName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def send_verify_email_api(self, **kwargs):  # noqa: E501
        """send_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_verify_email_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.send_verify_email_api_with_http_info(**kwargs)  # noqa: E501

    def send_verify_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """send_verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_verify_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_verify_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/verify_email/send', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def send_withdrawal_code_email_api(self, **kwargs):  # noqa: E501
        """send_withdrawal_code_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_withdrawal_code_email_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.send_withdrawal_code_email_api_with_http_info(**kwargs)  # noqa: E501

    def send_withdrawal_code_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """send_withdrawal_code_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_withdrawal_code_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_withdrawal_code_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/withdraw/send_code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_policy_list_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """service_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_policy_list_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacServicePolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.service_policy_list_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def service_policy_list_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """service_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_policy_list_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacServicePolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `service_policy_list_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `service_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacServicePolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def service_policy_update_api(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """service_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_policy_update_api(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param service_policy_update_api_input:
        :type service_policy_update_api_input: ServicePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.service_policy_update_api_with_http_info(model_service_name, organization_name, **kwargs)  # noqa: E501

    def service_policy_update_api_with_http_info(self, model_service_name, organization_name, **kwargs):  # noqa: E501
        """service_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.service_policy_update_api_with_http_info(model_service_name, organization_name, async_req=True)
        >>> result = thread.get()

        :param model_service_name: (required)
        :type model_service_name: str
        :param organization_name: (required)
        :type organization_name: str
        :param service_policy_update_api_input:
        :type service_policy_update_api_input: ServicePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'model_service_name',
            'organization_name',
            'service_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method service_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_service_name' is set
        if self.api_client.client_side_validation and local_var_params.get('model_service_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_service_name` when calling `service_policy_update_api`")  # noqa: E501
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `service_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_service_name' in local_var_params:
            path_params['modelServiceName'] = local_var_params['model_service_name']  # noqa: E501
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'service_policy_update_api_input' in local_var_params:
            body_params = local_var_params['service_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/model_services/{modelServiceName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_api(self, **kwargs):  # noqa: E501
        """sign_in_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_api_input:
        :type sign_in_api_input: SignInAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_api_input:
        :type sign_in_api_input: SignInAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_api_input' in local_var_params:
            body_params = local_var_params['sign_in_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_check_api(self, cli_token, **kwargs):  # noqa: E501
        """sign_in_cli_check_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_check_api(cli_token, async_req=True)
        >>> result = thread.get()

        :param cli_token: (required)
        :type cli_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountSignInCliCheckResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_check_api_with_http_info(cli_token, **kwargs)  # noqa: E501

    def sign_in_cli_check_api_with_http_info(self, cli_token, **kwargs):  # noqa: E501
        """sign_in_cli_check_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_check_api_with_http_info(cli_token, async_req=True)
        >>> result = thread.get()

        :param cli_token: (required)
        :type cli_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountSignInCliCheckResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'cli_token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_check_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'cli_token' is set
        if self.api_client.client_side_validation and local_var_params.get('cli_token') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `cli_token` when calling `sign_in_cli_check_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if local_var_params.get('cli_token') is not None:  # noqa: E501
            query_params.append(('cli_token', local_var_params['cli_token']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountSignInCliCheckResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/check', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_confirm_api(self, **kwargs):  # noqa: E501
        """sign_in_cli_confirm_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_confirm_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_cli_confirm_api_input:
        :type sign_in_cli_confirm_api_input: SignInCliConfirmAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_confirm_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_cli_confirm_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_cli_confirm_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_confirm_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_cli_confirm_api_input:
        :type sign_in_cli_confirm_api_input: SignInCliConfirmAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_cli_confirm_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_confirm_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_cli_confirm_api_input' in local_var_params:
            body_params = local_var_params['sign_in_cli_confirm_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/confirm', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_cli_token_api(self, **kwargs):  # noqa: E501
        """sign_in_cli_token_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_token_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountSignInCliTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_cli_token_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_cli_token_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_cli_token_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_cli_token_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountSignInCliTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_cli_token_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountSignInCliTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/cli/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_in_google_api(self, **kwargs):  # noqa: E501
        """sign_in_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_google_api(async_req=True)
        >>> result = thread.get()

        :param sign_in_google_api_input:
        :type sign_in_google_api_input: SignInGoogleAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_in_google_api_with_http_info(**kwargs)  # noqa: E501

    def sign_in_google_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_in_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_in_google_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_in_google_api_input:
        :type sign_in_google_api_input: SignInGoogleAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_in_google_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_in_google_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_in_google_api_input' in local_var_params:
            body_params = local_var_params['sign_in_google_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signin/google', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_google_api(self, **kwargs):  # noqa: E501
        """sign_up_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_google_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_google_api_input:
        :type sign_up_google_api_input: SignUpGoogleAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_google_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_google_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_google_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_google_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_google_api_input:
        :type sign_up_google_api_input: SignUpGoogleAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_up_google_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_google_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_google_api_input' in local_var_params:
            body_params = local_var_params['sign_up_google_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signup/google', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_pending_user_api(self, **kwargs):  # noqa: E501
        """sign_up_pending_user_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_pending_user_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_pending_user_api_input:
        :type sign_up_pending_user_api_input: SignUpPendingUserAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_pending_user_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_pending_user_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_pending_user_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_pending_user_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_pending_user_api_input:
        :type sign_up_pending_user_api_input: SignUpPendingUserAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_up_pending_user_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_pending_user_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_pending_user_api_input' in local_var_params:
            body_params = local_var_params['sign_up_pending_user_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signup', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_pending_user_resolve_api(self, **kwargs):  # noqa: E501
        """sign_up_pending_user_resolve_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_pending_user_resolve_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_pending_user_resolve_api_input:
        :type sign_up_pending_user_resolve_api_input: SignUpPendingUserResolveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_pending_user_resolve_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_pending_user_resolve_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_pending_user_resolve_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_pending_user_resolve_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_pending_user_resolve_api_input:
        :type sign_up_pending_user_resolve_api_input: SignUpPendingUserResolveAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'sign_up_pending_user_resolve_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_pending_user_resolve_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_pending_user_resolve_api_input' in local_var_params:
            body_params = local_var_params['sign_up_pending_user_resolve_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/signup/resolve', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_validate_email_api(self, **kwargs):  # noqa: E501
        """sign_up_validate_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_email_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_email_api_input:
        :type sign_up_validate_email_api_input: SignUpValidateEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_validate_email_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_validate_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_validate_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_email_api_input:
        :type sign_up_validate_email_api_input: SignUpValidateEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'sign_up_validate_email_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_validate_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_validate_email_api_input' in local_var_params:
            body_params = local_var_params['sign_up_validate_email_api_input']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/signup/validate/email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sign_up_validate_username_api(self, **kwargs):  # noqa: E501
        """sign_up_validate_username_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_username_api(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_username_api_input:
        :type sign_up_validate_username_api_input: SignUpValidateUsernameAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.sign_up_validate_username_api_with_http_info(**kwargs)  # noqa: E501

    def sign_up_validate_username_api_with_http_info(self, **kwargs):  # noqa: E501
        """sign_up_validate_username_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sign_up_validate_username_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param sign_up_validate_username_api_input:
        :type sign_up_validate_username_api_input: SignUpValidateUsernameAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'sign_up_validate_username_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sign_up_validate_username_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sign_up_validate_username_api_input' in local_var_params:
            body_params = local_var_params['sign_up_validate_username_api_input']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/signup/validate/username', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def slack_authorize_api(self, **kwargs):  # noqa: E501
        """slack_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_authorize_api(async_req=True)
        >>> result = thread.get()

        :param slack_authorize_api_input:
        :type slack_authorize_api_input: SlackAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.slack_authorize_api_with_http_info(**kwargs)  # noqa: E501

    def slack_authorize_api_with_http_info(self, **kwargs):  # noqa: E501
        """slack_authorize_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_authorize_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param slack_authorize_api_input:
        :type slack_authorize_api_input: SlackAuthorizeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'slack_authorize_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method slack_authorize_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'slack_authorize_api_input' in local_var_params:
            body_params = local_var_params['slack_authorize_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/slack/authorize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def slack_config_api(self, **kwargs):  # noqa: E501
        """slack_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_config_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ExternalSlackConfigResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.slack_config_api_with_http_info(**kwargs)  # noqa: E501

    def slack_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """slack_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slack_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ExternalSlackConfigResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method slack_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ExternalSlackConfigResponse",
        }

        return self.api_client.call_api(
            '/api/v1/slack/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_create_api(self, organization_name, **kwargs):  # noqa: E501
        """storage_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_create_api_input:
        :type storage_create_api_input: StorageCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseStorageV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def storage_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """storage_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_create_api_input:
        :type storage_create_api_input: StorageCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseStorageV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'storage_create_api_input' in local_var_params:
            body_params = local_var_params['storage_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseStorageV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_delete_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_delete_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def storage_delete_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_delete_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_delete_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `storage_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_list_api(self, organization_name, **kwargs):  # noqa: E501
        """storage_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param filter_name:
        :type filter_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageStorageListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def storage_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """storage_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param filter_name:
        :type filter_name: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageStorageListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'filter_name',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('filter_name') is not None:  # noqa: E501
            query_params.append(('filter_name', local_var_params['filter_name']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageStorageListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_policy_list_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_policy_list_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacStoragePolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_policy_list_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def storage_policy_list_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_policy_list_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacStoragePolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_policy_list_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `storage_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacStoragePolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_policy_update_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_policy_update_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param storage_policy_update_api_input:
        :type storage_policy_update_api_input: StoragePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_policy_update_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def storage_policy_update_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_policy_update_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param storage_policy_update_api_input:
        :type storage_policy_update_api_input: StoragePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'storage_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_policy_update_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `storage_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'storage_policy_update_api_input' in local_var_params:
            body_params = local_var_params['storage_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_read_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_read_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseStorageV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_read_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def storage_read_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_read_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseStorageV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_read_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `storage_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseStorageV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_update_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_update_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param storage_update_api_input:
        :type storage_update_api_input: StorageUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseStorageV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_update_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def storage_update_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """storage_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_update_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param storage_update_api_input:
        :type storage_update_api_input: StorageUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseStorageV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'storage_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_update_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `storage_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'storage_update_api_input' in local_var_params:
            body_params = local_var_params['storage_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseStorageV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def storage_validate_connection_api(self, organization_name, **kwargs):  # noqa: E501
        """storage_validate_connection_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_validate_connection_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_validate_connection_api_input:
        :type storage_validate_connection_api_input: StorageValidateConnectionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageStorageValidateConnectionResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.storage_validate_connection_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def storage_validate_connection_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """storage_validate_connection_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.storage_validate_connection_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_validate_connection_api_input:
        :type storage_validate_connection_api_input: StorageValidateConnectionAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageStorageValidateConnectionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_validate_connection_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method storage_validate_connection_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `storage_validate_connection_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'storage_validate_connection_api_input' in local_var_params:
            body_params = local_var_params['storage_validate_connection_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageStorageValidateConnectionResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/connection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """sweep_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep_create_api_input:
        :type sweep_create_api_input: SweepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSweepInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def sweep_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """sweep_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep_create_api_input:
        :type sweep_create_api_input: SweepCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSweepInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sweep_create_api_input' in local_var_params:
            body_params = local_var_params['sweep_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSweepInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_delete_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_delete_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_delete_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_delete_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_delete_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_delete_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_full_logs_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_full_logs_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_full_logs_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_full_logs_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_full_logs_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_full_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_full_logs_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/logs/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """sweep_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SweepSweepListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def sweep_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """sweep_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param created_by:
        :type created_by: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SweepSweepListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'created_by',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'statuses'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('created_by') is not None:  # noqa: E501
            query_params.append(('created_by', local_var_params['created_by']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "SweepSweepListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_logs_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_logs_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SweepSweepLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_logs_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_logs_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_logs_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SweepSweepLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_logs_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_logs_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "SweepSweepLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_logs_raw_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_logs_raw_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_logs_raw_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_logs_raw_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_logs_raw_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_logs_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_logs_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/logs/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_plots_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_plots_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SweepSweepPlotsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_plots_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_plots_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_plots_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_plots_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SweepSweepPlotsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_plots_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_plots_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_plots_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_plots_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "SweepSweepPlotsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/plots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_plots_metrics_raw_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_plots_metrics_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_plots_metrics_raw_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_plots_metrics_raw_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_plots_metrics_raw_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_plots_metrics_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_plots_metrics_raw_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_plots_metrics_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_plots_metrics_raw_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_plots_metrics_raw_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_plots_metrics_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/plots/metrics.raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_read_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_read_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSweepInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_read_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_read_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_read_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSweepInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_read_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSweepInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_system_metrics_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_system_metrics_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SweepSweepSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_system_metrics_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_system_metrics_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_system_metrics_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SweepSweepSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep',
            'after',
            'before',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('metrics') is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501
            collection_formats['metrics'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "SweepSweepSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_terminate_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_terminate_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSweepInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_terminate_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_terminate_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_terminate_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSweepInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_terminate_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_terminate_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSweepInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def sweep_update_api(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_update_api(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param sweep_update_api_input:
        :type sweep_update_api_input: SweepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseSweepInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.sweep_update_api_with_http_info(organization_name, project_name, sweep, **kwargs)  # noqa: E501

    def sweep_update_api_with_http_info(self, organization_name, project_name, sweep, **kwargs):  # noqa: E501
        """sweep_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.sweep_update_api_with_http_info(organization_name, project_name, sweep, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param sweep: (required)
        :type sweep: str
        :param sweep_update_api_input:
        :type sweep_update_api_input: SweepUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseSweepInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'sweep',
            'sweep_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sweep_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `sweep_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `sweep_update_api`")  # noqa: E501
        # verify the required parameter 'sweep' is set
        if self.api_client.client_side_validation and local_var_params.get('sweep') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `sweep` when calling `sweep_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'sweep' in local_var_params:
            path_params['sweep'] = local_var_params['sweep']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sweep_update_api_input' in local_var_params:
            body_params = local_var_params['sweep_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseSweepInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/sweeps/{sweep}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tag_create_api(self, organization_name, owner_id, **kwargs):  # noqa: E501
        """tag_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_create_api(organization_name, owner_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param owner_id: (required)
        :type owner_id: int
        :param tag_create_api_input:
        :type tag_create_api_input: TagCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTagResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tag_create_api_with_http_info(organization_name, owner_id, **kwargs)  # noqa: E501

    def tag_create_api_with_http_info(self, organization_name, owner_id, **kwargs):  # noqa: E501
        """tag_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_create_api_with_http_info(organization_name, owner_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param owner_id: (required)
        :type owner_id: int
        :param tag_create_api_input:
        :type tag_create_api_input: TagCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTagResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'owner_id',
            'tag_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tag_create_api`")  # noqa: E501
        # verify the required parameter 'owner_id' is set
        if self.api_client.client_side_validation and local_var_params.get('owner_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner_id` when calling `tag_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'owner_id' in local_var_params:
            path_params['ownerID'] = local_var_params['owner_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag_create_api_input' in local_var_params:
            body_params = local_var_params['tag_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTagResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/tag_group_owners/{ownerID}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tag_delete_api(self, tag_id, **kwargs):  # noqa: E501
        """tag_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_delete_api(tag_id, async_req=True)
        >>> result = thread.get()

        :param tag_id: (required)
        :type tag_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.tag_delete_api_with_http_info(tag_id, **kwargs)  # noqa: E501

    def tag_delete_api_with_http_info(self, tag_id, **kwargs):  # noqa: E501
        """tag_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_delete_api_with_http_info(tag_id, async_req=True)
        >>> result = thread.get()

        :param tag_id: (required)
        :type tag_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'tag_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tag_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tag_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag_id` when calling `tag_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tag_id' in local_var_params:
            path_params['tagID'] = local_var_params['tag_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/tags/{tagID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tag_list_api(self, organization_name, owner_id, **kwargs):  # noqa: E501
        """tag_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_list_api(organization_name, owner_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param owner_id: (required)
        :type owner_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TagTagListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tag_list_api_with_http_info(organization_name, owner_id, **kwargs)  # noqa: E501

    def tag_list_api_with_http_info(self, organization_name, owner_id, **kwargs):  # noqa: E501
        """tag_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_list_api_with_http_info(organization_name, owner_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param owner_id: (required)
        :type owner_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TagTagListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'owner_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tag_list_api`")  # noqa: E501
        # verify the required parameter 'owner_id' is set
        if self.api_client.client_side_validation and local_var_params.get('owner_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `owner_id` when calling `tag_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'owner_id' in local_var_params:
            path_params['ownerID'] = local_var_params['owner_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "TagTagListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/tag_group_owners/{ownerID}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tag_update_api(self, tag_id, **kwargs):  # noqa: E501
        """tag_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_update_api(tag_id, async_req=True)
        >>> result = thread.get()

        :param tag_id: (required)
        :type tag_id: int
        :param tag_update_api_input:
        :type tag_update_api_input: TagUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTagResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tag_update_api_with_http_info(tag_id, **kwargs)  # noqa: E501

    def tag_update_api_with_http_info(self, tag_id, **kwargs):  # noqa: E501
        """tag_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tag_update_api_with_http_info(tag_id, async_req=True)
        >>> result = thread.get()

        :param tag_id: (required)
        :type tag_id: int
        :param tag_update_api_input:
        :type tag_update_api_input: TagUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTagResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'tag_id',
            'tag_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tag_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'tag_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tag_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tag_id` when calling `tag_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tag_id' in local_var_params:
            path_params['tagID'] = local_var_params['tag_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tag_update_api_input' in local_var_params:
            body_params = local_var_params['tag_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTagResponse",
        }

        return self.api_client.call_api(
            '/api/v1/tags/{tagID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_clone_api(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_clone_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_clone_api(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param tracking_dashboard_clone_api_input:
        :type tracking_dashboard_clone_api_input: TrackingDashboardCloneAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboard
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_clone_api_with_http_info(organization_name, project_name, tracking_dashboard_id, **kwargs)  # noqa: E501

    def tracking_dashboard_clone_api_with_http_info(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_clone_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_clone_api_with_http_info(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param tracking_dashboard_clone_api_input:
        :type tracking_dashboard_clone_api_input: TrackingDashboardCloneAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboard, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'tracking_dashboard_id',
            'tracking_dashboard_clone_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_clone_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_clone_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_clone_api`")  # noqa: E501
        # verify the required parameter 'tracking_dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tracking_dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tracking_dashboard_id` when calling `tracking_dashboard_clone_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'tracking_dashboard_id' in local_var_params:
            path_params['trackingDashboardID'] = local_var_params['tracking_dashboard_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_dashboard_clone_api_input' in local_var_params:
            body_params = local_var_params['tracking_dashboard_clone_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboard",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards/{trackingDashboardID}/clone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_create_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_dashboard_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_create_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_create_api_input:
        :type tracking_dashboard_create_api_input: TrackingDashboardCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboard
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_create_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def tracking_dashboard_create_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_dashboard_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_create_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_create_api_input:
        :type tracking_dashboard_create_api_input: TrackingDashboardCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboard, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'tracking_dashboard_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_create_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_dashboard_create_api_input' in local_var_params:
            body_params = local_var_params['tracking_dashboard_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboard",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_delete_api(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_delete_api(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_delete_api_with_http_info(organization_name, project_name, tracking_dashboard_id, **kwargs)  # noqa: E501

    def tracking_dashboard_delete_api_with_http_info(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_delete_api_with_http_info(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'tracking_dashboard_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_delete_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_delete_api`")  # noqa: E501
        # verify the required parameter 'tracking_dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tracking_dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tracking_dashboard_id` when calling `tracking_dashboard_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'tracking_dashboard_id' in local_var_params:
            path_params['trackingDashboardID'] = local_var_params['tracking_dashboard_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards/{trackingDashboardID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_list_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_dashboard_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_list_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboardList
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_list_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def tracking_dashboard_list_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_dashboard_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_list_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboardList, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_list_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboardList",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_read_api(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_read_api(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboard
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_read_api_with_http_info(organization_name, project_name, tracking_dashboard_id, **kwargs)  # noqa: E501

    def tracking_dashboard_read_api_with_http_info(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_read_api_with_http_info(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboard, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'tracking_dashboard_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_read_api`")  # noqa: E501
        # verify the required parameter 'tracking_dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tracking_dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tracking_dashboard_id` when calling `tracking_dashboard_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'tracking_dashboard_id' in local_var_params:
            path_params['trackingDashboardID'] = local_var_params['tracking_dashboard_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboard",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards/{trackingDashboardID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_dashboard_update_api(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_update_api(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param tracking_dashboard_update_api_input:
        :type tracking_dashboard_update_api_input: TrackingDashboardUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboard
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_dashboard_update_api_with_http_info(organization_name, project_name, tracking_dashboard_id, **kwargs)  # noqa: E501

    def tracking_dashboard_update_api_with_http_info(self, organization_name, project_name, tracking_dashboard_id, **kwargs):  # noqa: E501
        """tracking_dashboard_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_dashboard_update_api_with_http_info(organization_name, project_name, tracking_dashboard_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param tracking_dashboard_id: (required)
        :type tracking_dashboard_id: int
        :param tracking_dashboard_update_api_input:
        :type tracking_dashboard_update_api_input: TrackingDashboardUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboard, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'tracking_dashboard_id',
            'tracking_dashboard_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_dashboard_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_dashboard_update_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_dashboard_update_api`")  # noqa: E501
        # verify the required parameter 'tracking_dashboard_id' is set
        if self.api_client.client_side_validation and local_var_params.get('tracking_dashboard_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `tracking_dashboard_id` when calling `tracking_dashboard_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501
        if 'tracking_dashboard_id' in local_var_params:
            path_params['trackingDashboardID'] = local_var_params['tracking_dashboard_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tracking_dashboard_update_api_input' in local_var_params:
            body_params = local_var_params['tracking_dashboard_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboard",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards/{trackingDashboardID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_default_dashboard_read_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_default_dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_default_dashboard_read_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingDashboard
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_default_dashboard_read_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def tracking_default_dashboard_read_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_default_dashboard_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_default_dashboard_read_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingDashboard, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_default_dashboard_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_default_dashboard_read_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_default_dashboard_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingDashboard",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/dashboards/default', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_query_custom_metrics_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_query_custom_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_query_custom_metrics_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_ids:
        :type run_execution_ids: list[int]
        :param tracking_field_names:
        :type tracking_field_names: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_query_custom_metrics_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def tracking_query_custom_metrics_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_query_custom_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_query_custom_metrics_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_ids:
        :type run_execution_ids: list[int]
        :param tracking_field_names:
        :type tracking_field_names: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_ids',
            'tracking_field_names'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_query_custom_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_query_custom_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_query_custom_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('run_execution_ids') is not None:  # noqa: E501
            query_params.append(('run_execution_ids', local_var_params['run_execution_ids']))  # noqa: E501
            collection_formats['run_execution_ids'] = 'multi'  # noqa: E501
        if local_var_params.get('tracking_field_names') is not None:  # noqa: E501
            query_params.append(('tracking_field_names', local_var_params['tracking_field_names']))  # noqa: E501
            collection_formats['tracking_field_names'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/metrics/query/custom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tracking_query_system_metrics_api(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_query_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_query_system_metrics_api(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_ids:
        :type run_execution_ids: list[int]
        :param series:
        :type series: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTrackingMetrics
        """
        kwargs['_return_http_data_only'] = True
        return self.tracking_query_system_metrics_api_with_http_info(organization_name, project_name, **kwargs)  # noqa: E501

    def tracking_query_system_metrics_api_with_http_info(self, organization_name, project_name, **kwargs):  # noqa: E501
        """tracking_query_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tracking_query_system_metrics_api_with_http_info(organization_name, project_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param project_name: (required)
        :type project_name: str
        :param run_execution_ids:
        :type run_execution_ids: list[int]
        :param series:
        :type series: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTrackingMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'project_name',
            'run_execution_ids',
            'series'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tracking_query_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tracking_query_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if self.api_client.client_side_validation and local_var_params.get('project_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_name` when calling `tracking_query_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'project_name' in local_var_params:
            path_params['projectName'] = local_var_params['project_name']  # noqa: E501

        query_params = []
        if local_var_params.get('run_execution_ids') is not None:  # noqa: E501
            query_params.append(('run_execution_ids', local_var_params['run_execution_ids']))  # noqa: E501
            collection_formats['run_execution_ids'] = 'multi'  # noqa: E501
        if local_var_params.get('series') is not None:  # noqa: E501
            query_params.append(('series', local_var_params['series']))  # noqa: E501
            collection_formats['series'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTrackingMetrics",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/projects/{projectName}/tracking/metrics/query/system', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tutorial_hide_api(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_hide_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_hide_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganization
        """
        kwargs['_return_http_data_only'] = True
        return self.tutorial_hide_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def tutorial_hide_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_hide_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_hide_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganization, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tutorial_hide_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tutorial_hide_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganization",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/tutorial_hide', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tutorial_show_api(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_show_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_show_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseOrganization
        """
        kwargs['_return_http_data_only'] = True
        return self.tutorial_show_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def tutorial_show_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_show_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_show_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseOrganization, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tutorial_show_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tutorial_show_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseOrganization",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/tutorial_show', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def tutorial_update_api(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_update_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param tutorial_update_api_input:
        :type tutorial_update_api_input: TutorialUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseTutorialResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.tutorial_update_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def tutorial_update_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """tutorial_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tutorial_update_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param tutorial_update_api_input:
        :type tutorial_update_api_input: TutorialUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseTutorialResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'tutorial_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tutorial_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `tutorial_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'tutorial_update_api_input' in local_var_params:
            body_params = local_var_params['tutorial_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseTutorialResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/tutorial', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_notification_config_api(self, **kwargs):  # noqa: E501
        """update_notification_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_notification_config_api(async_req=True)
        >>> result = thread.get()

        :param update_notification_config_api_input:
        :type update_notification_config_api_input: UpdateNotificationConfigAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseMyUser
        """
        kwargs['_return_http_data_only'] = True
        return self.update_notification_config_api_with_http_info(**kwargs)  # noqa: E501

    def update_notification_config_api_with_http_info(self, **kwargs):  # noqa: E501
        """update_notification_config_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_notification_config_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param update_notification_config_api_input:
        :type update_notification_config_api_input: UpdateNotificationConfigAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseMyUser, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'update_notification_config_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_notification_config_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_notification_config_api_input' in local_var_params:
            body_params = local_var_params['update_notification_config_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseMyUser",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/notification', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_extra_info_read_api(self, **kwargs):  # noqa: E501
        """user_extra_info_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_extra_info_read_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AccountUserExtraInfoReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_extra_info_read_api_with_http_info(**kwargs)  # noqa: E501

    def user_extra_info_read_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_extra_info_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_extra_info_read_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AccountUserExtraInfoReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_extra_info_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "AccountUserExtraInfoReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/extra_info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_extra_info_update_api(self, **kwargs):  # noqa: E501
        """user_extra_info_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_extra_info_update_api(async_req=True)
        >>> result = thread.get()

        :param user_extra_info_update_api_input:
        :type user_extra_info_update_api_input: UserExtraInfoUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_extra_info_update_api_with_http_info(**kwargs)  # noqa: E501

    def user_extra_info_update_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_extra_info_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_extra_info_update_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param user_extra_info_update_api_input:
        :type user_extra_info_update_api_input: UserExtraInfoUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_extra_info_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_extra_info_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_extra_info_update_api_input' in local_var_params:
            body_params = local_var_params['user_extra_info_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/extra_info', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_create_api(self, organization_name, **kwargs):  # noqa: E501
        """user_group_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_create_api_input:
        :type user_group_create_api_input: UserGroupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacUserGroupCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def user_group_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """user_group_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_create_api_input:
        :type user_group_create_api_input: UserGroupCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacUserGroupCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_group_create_api_input' in local_var_params:
            body_params = local_var_params['user_group_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacUserGroupCreateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_delete_api(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_delete_api(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_delete_api_with_http_info(organization_name, user_group_id, **kwargs)  # noqa: E501

    def user_group_delete_api_with_http_info(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_delete_api_with_http_info(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_delete_api`")  # noqa: E501
        # verify the required parameter 'user_group_id' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_id` when calling `user_group_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_id' in local_var_params:
            path_params['userGroupID'] = local_var_params['user_group_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups/{userGroupID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_list_api(self, organization_name, **kwargs):  # noqa: E501
        """user_group_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param filter_member:
        :type filter_member: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacUserGroupListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def user_group_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """user_group_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param filter_member:
        :type filter_member: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacUserGroupListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'filter_member'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('filter_member') is not None:  # noqa: E501
            query_params.append(('filter_member', local_var_params['filter_member']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacUserGroupListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_member_add_bulk_api(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_add_bulk_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_add_bulk_api(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_member_add_bulk_api_input:
        :type user_group_member_add_bulk_api_input: UserGroupMemberAddBulkAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_member_add_bulk_api_with_http_info(organization_name, user_group_id, **kwargs)  # noqa: E501

    def user_group_member_add_bulk_api_with_http_info(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_add_bulk_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_add_bulk_api_with_http_info(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_member_add_bulk_api_input:
        :type user_group_member_add_bulk_api_input: UserGroupMemberAddBulkAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_id',
            'user_group_member_add_bulk_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_member_add_bulk_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_member_add_bulk_api`")  # noqa: E501
        # verify the required parameter 'user_group_id' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_id` when calling `user_group_member_add_bulk_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_id' in local_var_params:
            path_params['userGroupID'] = local_var_params['user_group_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_group_member_add_bulk_api_input' in local_var_params:
            body_params = local_var_params['user_group_member_add_bulk_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups/{userGroupID}/members/add_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_member_list_api(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_list_api(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacUserGroupMemberListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_member_list_api_with_http_info(organization_name, user_group_id, **kwargs)  # noqa: E501

    def user_group_member_list_api_with_http_info(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_list_api_with_http_info(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacUserGroupMemberListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_member_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_member_list_api`")  # noqa: E501
        # verify the required parameter 'user_group_id' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_id` when calling `user_group_member_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_id' in local_var_params:
            path_params['userGroupID'] = local_var_params['user_group_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacUserGroupMemberListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups/{userGroupID}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_member_remove_bulk_api(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_remove_bulk_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_remove_bulk_api(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_member_remove_bulk_api_input:
        :type user_group_member_remove_bulk_api_input: UserGroupMemberRemoveBulkAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_member_remove_bulk_api_with_http_info(organization_name, user_group_id, **kwargs)  # noqa: E501

    def user_group_member_remove_bulk_api_with_http_info(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_member_remove_bulk_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_remove_bulk_api_with_http_info(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_member_remove_bulk_api_input:
        :type user_group_member_remove_bulk_api_input: UserGroupMemberRemoveBulkAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_id',
            'user_group_member_remove_bulk_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_member_remove_bulk_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_member_remove_bulk_api`")  # noqa: E501
        # verify the required parameter 'user_group_id' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_id` when calling `user_group_member_remove_bulk_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_id' in local_var_params:
            path_params['userGroupID'] = local_var_params['user_group_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_group_member_remove_bulk_api_input' in local_var_params:
            body_params = local_var_params['user_group_member_remove_bulk_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups/{userGroupID}/members/remove_bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_member_update_for_user_api(self, **kwargs):  # noqa: E501
        """user_group_member_update_for_user_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_update_for_user_api(async_req=True)
        >>> result = thread.get()

        :param user_group_member_update_for_user_api_input:
        :type user_group_member_update_for_user_api_input: UserGroupMemberUpdateForUserAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_member_update_for_user_api_with_http_info(**kwargs)  # noqa: E501

    def user_group_member_update_for_user_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_group_member_update_for_user_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_member_update_for_user_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param user_group_member_update_for_user_api_input:
        :type user_group_member_update_for_user_api_input: UserGroupMemberUpdateForUserAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_group_member_update_for_user_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_member_update_for_user_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_group_member_update_for_user_api_input' in local_var_params:
            body_params = local_var_params['user_group_member_update_for_user_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/rbac/user_group_update_for_user', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_group_update_api(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_update_api(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_update_api_input:
        :type user_group_update_api_input: UserGroupUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacUserGroupUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_group_update_api_with_http_info(organization_name, user_group_id, **kwargs)  # noqa: E501

    def user_group_update_api_with_http_info(self, organization_name, user_group_id, **kwargs):  # noqa: E501
        """user_group_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_group_update_api_with_http_info(organization_name, user_group_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param user_group_id: (required)
        :type user_group_id: int
        :param user_group_update_api_input:
        :type user_group_update_api_input: UserGroupUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacUserGroupUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'user_group_id',
            'user_group_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_group_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `user_group_update_api`")  # noqa: E501
        # verify the required parameter 'user_group_id' is set
        if self.api_client.client_side_validation and local_var_params.get('user_group_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_group_id` when calling `user_group_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'user_group_id' in local_var_params:
            path_params['userGroupID'] = local_var_params['user_group_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_group_update_api_input' in local_var_params:
            body_params = local_var_params['user_group_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacUserGroupUpdateResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/user_groups/{userGroupID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_history_delete_api(self, **kwargs):  # noqa: E501
        """user_history_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_delete_api(async_req=True)
        >>> result = thread.get()

        :param user_history_delete_api_input:
        :type user_history_delete_api_input: UserHistoryDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_history_delete_api_with_http_info(**kwargs)  # noqa: E501

    def user_history_delete_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_history_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_delete_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param user_history_delete_api_input:
        :type user_history_delete_api_input: UserHistoryDeleteAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_history_delete_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_history_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_history_delete_api_input' in local_var_params:
            body_params = local_var_params['user_history_delete_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/user/history', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_history_list_api(self, **kwargs):  # noqa: E501
        """user_history_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_list_api(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UserUserHistoryListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.user_history_list_api_with_http_info(**kwargs)  # noqa: E501

    def user_history_list_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_history_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_list_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserUserHistoryListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_history_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "UserUserHistoryListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/user/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def user_history_upsert_api(self, **kwargs):  # noqa: E501
        """user_history_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_upsert_api(async_req=True)
        >>> result = thread.get()

        :param user_history_upsert_api_input:
        :type user_history_upsert_api_input: UserHistoryUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.user_history_upsert_api_with_http_info(**kwargs)  # noqa: E501

    def user_history_upsert_api_with_http_info(self, **kwargs):  # noqa: E501
        """user_history_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.user_history_upsert_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param user_history_upsert_api_input:
        :type user_history_upsert_api_input: UserHistoryUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_history_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_history_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_history_upsert_api_input' in local_var_params:
            body_params = local_var_params['user_history_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/user/history', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def v_essl_dataset_create_api(self, organization_name, **kwargs):  # noqa: E501
        """v_essl_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v_essl_dataset_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param vessl_dataset_create_api_input:
        :type vessl_dataset_create_api_input: VESSLDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseDatasetInfoDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.v_essl_dataset_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def v_essl_dataset_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """v_essl_dataset_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v_essl_dataset_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param vessl_dataset_create_api_input:
        :type vessl_dataset_create_api_input: VESSLDatasetCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseDatasetInfoDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'vessl_dataset_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v_essl_dataset_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `v_essl_dataset_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vessl_dataset_create_api_input' in local_var_params:
            body_params = local_var_params['vessl_dataset_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseDatasetInfoDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/datasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def validate_password_api(self, **kwargs):  # noqa: E501
        """validate_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_password_api(async_req=True)
        >>> result = thread.get()

        :param validate_password_api_input:
        :type validate_password_api_input: ValidatePasswordAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_password_api_with_http_info(**kwargs)  # noqa: E501

    def validate_password_api_with_http_info(self, **kwargs):  # noqa: E501
        """validate_password_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_password_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param validate_password_api_input:
        :type validate_password_api_input: ValidatePasswordAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'validate_password_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_password_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'validate_password_api_input' in local_var_params:
            body_params = local_var_params['validate_password_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/validate_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def verify_email_api(self, **kwargs):  # noqa: E501
        """verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_email_api(async_req=True)
        >>> result = thread.get()

        :param verify_email_api_input:
        :type verify_email_api_input: VerifyEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseUserWithTokenResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_email_api_with_http_info(**kwargs)  # noqa: E501

    def verify_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """verify_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param verify_email_api_input:
        :type verify_email_api_input: VerifyEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseUserWithTokenResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'verify_email_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'verify_email_api_input' in local_var_params:
            body_params = local_var_params['verify_email_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseUserWithTokenResponse",
        }

        return self.api_client.call_api(
            '/api/v1/accounts/verify_email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def verify_withdrawal_code_email_api(self, **kwargs):  # noqa: E501
        """verify_withdrawal_code_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_withdrawal_code_email_api(async_req=True)
        >>> result = thread.get()

        :param verify_withdrawal_code_email_api_input:
        :type verify_withdrawal_code_email_api_input: VerifyWithdrawalCodeEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.verify_withdrawal_code_email_api_with_http_info(**kwargs)  # noqa: E501

    def verify_withdrawal_code_email_api_with_http_info(self, **kwargs):  # noqa: E501
        """verify_withdrawal_code_email_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.verify_withdrawal_code_email_api_with_http_info(async_req=True)
        >>> result = thread.get()

        :param verify_withdrawal_code_email_api_input:
        :type verify_withdrawal_code_email_api_input: VerifyWithdrawalCodeEmailAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'verify_withdrawal_code_email_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_withdrawal_code_email_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'verify_withdrawal_code_email_api_input' in local_var_params:
            body_params = local_var_params['verify_withdrawal_code_email_api_input']
        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/accounts/withdraw/verify_code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_federate_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_federate_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeFederateAPI200Response
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_federate_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_federate_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_federate_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeFederateAPI200Response, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_federate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_federate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "VolumeFederateAPI200Response",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/federate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_copy_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_copy_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_copy_api_input:
        :type volume_file_copy_api_input: VolumeFileCopyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeVolumeFileCopyResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_copy_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_copy_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_copy_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_copy_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_copy_api_input:
        :type volume_file_copy_api_input: VolumeFileCopyAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeVolumeFileCopyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'volume_file_copy_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_copy_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_copy_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_file_copy_api_input' in local_var_params:
            body_params = local_var_params['volume_file_copy_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "VolumeVolumeFileCopyResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_create_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_create_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_create_api_input:
        :type volume_file_create_api_input: VolumeFileCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageFile
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_create_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_create_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_create_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param volume_file_create_api_input:
        :type volume_file_create_api_input: VolumeFileCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageFile, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'volume_file_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_file_create_api_input' in local_var_params:
            body_params = local_var_params['volume_file_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageFile",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_delete_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_delete_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_delete_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_delete_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_delete_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if local_var_params.get('path') is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/delete', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_list_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_list_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param need_download_url:
        :type need_download_url: bool
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VolumeVolumeFileListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_list_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_list_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_list_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param need_download_url:
        :type need_download_url: bool
        :param path:
        :type path: str
        :param recursive:
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VolumeVolumeFileListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'need_download_url',
            'path',
            'recursive'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if local_var_params.get('need_download_url') is not None:  # noqa: E501
            query_params.append(('need_download_url', local_var_params['need_download_url']))  # noqa: E501
        if local_var_params.get('path') is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if local_var_params.get('recursive') is not None:  # noqa: E501
            query_params.append(('recursive', local_var_params['recursive']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "VolumeVolumeFileListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_read_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_read_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageFile
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_read_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_read_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_read_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageFile, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if local_var_params.get('path') is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageFile",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/read', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_file_uploaded_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_uploaded_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_uploaded_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageFile
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_file_uploaded_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_file_uploaded_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_file_uploaded_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_file_uploaded_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageFile, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_file_uploaded_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_file_uploaded_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []
        if local_var_params.get('path') is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageFile",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/files/uploaded', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_policy_list_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_policy_list_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacVolumePolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_policy_list_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_policy_list_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_policy_list_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacVolumePolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_policy_list_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_policy_list_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacVolumePolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_policy_update_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_policy_update_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_policy_update_api_input:
        :type volume_policy_update_api_input: VolumePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_policy_update_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_policy_update_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_policy_update_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_policy_update_api_input:
        :type volume_policy_update_api_input: VolumePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name',
            'volume_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_policy_update_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_policy_update_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_policy_update_api_input' in local_var_params:
            body_params = local_var_params['volume_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_read_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_read_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolume
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_read_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_read_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_read_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolume, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseVolume",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_total_size_api(self, volume_id, **kwargs):  # noqa: E501
        """volume_total_size_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_total_size_api(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StorageTotalSize
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_total_size_api_with_http_info(volume_id, **kwargs)  # noqa: E501

    def volume_total_size_api_with_http_info(self, volume_id, **kwargs):  # noqa: E501
        """volume_total_size_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_total_size_api_with_http_info(volume_id, async_req=True)
        >>> result = thread.get()

        :param volume_id: (required)
        :type volume_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StorageTotalSize, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'volume_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_total_size_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'volume_id' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_id` when calling `volume_total_size_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'volume_id' in local_var_params:
            path_params['volumeID'] = local_var_params['volume_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "StorageTotalSize",
        }

        return self.api_client.call_api(
            '/api/v1/volumes/{volumeID}/total_size', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_create_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_create_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_create_api_input:
        :type volume_v2_create_api_input: VolumeV2CreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolumeV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_create_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def volume_v2_create_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_create_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_create_api_input:
        :type volume_v2_create_api_input: VolumeV2CreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolumeV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_v2_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_create_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_create_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseVolumeV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_create_tag_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_create_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_create_tag_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_create_tag_api_input:
        :type volume_v2_create_tag_api_input: VolumeV2CreateTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_create_tag_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def volume_v2_create_tag_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_create_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_create_tag_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_create_tag_api_input:
        :type volume_v2_create_tag_api_input: VolumeV2CreateTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_v2_create_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_create_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_create_tag_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_create_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_create_tag_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_create_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/tags/create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_delete_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_delete_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_delete_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_delete_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_delete_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_delete_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_delete_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_delete_tag_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_delete_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_delete_tag_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_delete_tag_api_input:
        :type volume_v2_delete_tag_api_input: VolumeV2DeleteTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_delete_tag_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def volume_v2_delete_tag_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_delete_tag_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_delete_tag_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_v2_delete_tag_api_input:
        :type volume_v2_delete_tag_api_input: VolumeV2DeleteTagAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_v2_delete_tag_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_delete_tag_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_delete_tag_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_delete_tag_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_delete_tag_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_delete_tag_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/tags/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_federate_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_federate_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_federate_api_input:
        :type volume_v2_federate_api_input: VolumeV2FederateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolumeV2FederateInfo
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_federate_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_federate_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_federate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_federate_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_federate_api_input:
        :type volume_v2_federate_api_input: VolumeV2FederateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolumeV2FederateInfo, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name',
            'volume_v2_federate_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_federate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_federate_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_federate_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_federate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_federate_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_federate_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseVolumeV2FederateInfo",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}/federate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_list_api(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_list_api(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param is_auto_created:
        :type is_auto_created: bool
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Volumev2VolumeV2ListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_list_api_with_http_info(organization_name, storage_name, **kwargs)  # noqa: E501

    def volume_v2_list_api_with_http_info(self, organization_name, storage_name, **kwargs):  # noqa: E501
        """volume_v2_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_list_api_with_http_info(organization_name, storage_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param is_auto_created:
        :type is_auto_created: bool
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Volumev2VolumeV2ListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'is_auto_created',
            'keyword',
            'limit',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_list_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('is_auto_created') is not None:  # noqa: E501
            query_params.append(('is_auto_created', local_var_params['is_auto_created']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "Volumev2VolumeV2ListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_overview_read_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_overview_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_overview_read_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Volumev2VolumeV2OverviewReadResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_overview_read_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_overview_read_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_overview_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_overview_read_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Volumev2VolumeV2OverviewReadResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_overview_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_overview_read_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_overview_read_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_overview_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "Volumev2VolumeV2OverviewReadResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}/overview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_overview_upsert_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_overview_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_overview_upsert_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_overview_upsert_api_input:
        :type volume_v2_overview_upsert_api_input: VolumeV2OverviewUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Volumev2VolumeV2OverviewUpsertResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_overview_upsert_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_overview_upsert_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_overview_upsert_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_overview_upsert_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_overview_upsert_api_input:
        :type volume_v2_overview_upsert_api_input: VolumeV2OverviewUpsertAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Volumev2VolumeV2OverviewUpsertResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name',
            'volume_v2_overview_upsert_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_overview_upsert_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_overview_upsert_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_overview_upsert_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_overview_upsert_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_overview_upsert_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_overview_upsert_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "Volumev2VolumeV2OverviewUpsertResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}/overview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_read_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_read_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolumeV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_read_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_read_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_read_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolumeV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_read_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_read_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseVolumeV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def volume_v2_update_api(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_update_api(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_update_api_input:
        :type volume_v2_update_api_input: VolumeV2UpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseVolumeV2Info
        """
        kwargs['_return_http_data_only'] = True
        return self.volume_v2_update_api_with_http_info(organization_name, storage_name, volume_name, **kwargs)  # noqa: E501

    def volume_v2_update_api_with_http_info(self, organization_name, storage_name, volume_name, **kwargs):  # noqa: E501
        """volume_v2_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.volume_v2_update_api_with_http_info(organization_name, storage_name, volume_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param storage_name: (required)
        :type storage_name: str
        :param volume_name: (required)
        :type volume_name: str
        :param volume_v2_update_api_input:
        :type volume_v2_update_api_input: VolumeV2UpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseVolumeV2Info, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'storage_name',
            'volume_name',
            'volume_v2_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method volume_v2_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `volume_v2_update_api`")  # noqa: E501
        # verify the required parameter 'storage_name' is set
        if self.api_client.client_side_validation and local_var_params.get('storage_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `storage_name` when calling `volume_v2_update_api`")  # noqa: E501
        # verify the required parameter 'volume_name' is set
        if self.api_client.client_side_validation and local_var_params.get('volume_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `volume_name` when calling `volume_v2_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'storage_name' in local_var_params:
            path_params['storageName'] = local_var_params['storage_name']  # noqa: E501
        if 'volume_name' in local_var_params:
            path_params['volumeName'] = local_var_params['volume_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'volume_v2_update_api_input' in local_var_params:
            body_params = local_var_params['volume_v2_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseVolumeV2Info",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/storages/{storageName}/volumes/{volumeName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_check_extendable_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_check_extendable_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_check_extendable_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceExtendableResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_check_extendable_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_check_extendable_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_check_extendable_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_check_extendable_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceExtendableResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_check_extendable_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_check_extendable_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_check_extendable_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "WorkspaceWorkspaceExtendableResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/check_extendable', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_create_api(self, organization_name, **kwargs):  # noqa: E501
        """workspace_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_create_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_create_api_input:
        :type workspace_create_api_input: WorkspaceCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_create_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def workspace_create_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """workspace_create_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_create_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_create_api_input:
        :type workspace_create_api_input: WorkspaceCreateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_create_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_create_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_create_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_create_api_input' in local_var_params:
            body_params = local_var_params['workspace_create_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_delete_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_delete_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_delete_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_delete_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_delete_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_delete_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_delete_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_delete_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_delete_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_extend_running_time_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_extend_running_time_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_extend_running_time_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_extend_running_time_api_input:
        :type workspace_extend_running_time_api_input: WorkspaceExtendRunningTimeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_extend_running_time_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_extend_running_time_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_extend_running_time_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_extend_running_time_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_extend_running_time_api_input:
        :type workspace_extend_running_time_api_input: WorkspaceExtendRunningTimeAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'workspace_extend_running_time_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_extend_running_time_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_extend_running_time_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_extend_running_time_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_extend_running_time_api_input' in local_var_params:
            body_params = local_var_params['workspace_extend_running_time_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/extend_runningtime', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_full_logs_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_full_logs_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: dict[str, str]
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_full_logs_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_full_logs_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_full_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_full_logs_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(dict[str, str], status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_full_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_full_logs_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_full_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "dict[str, str]",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/logs/full_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_list_api(self, organization_name, **kwargs):  # noqa: E501
        """workspace_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_list_api(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cluster:
        :type cluster: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param mine:
        :type mine: bool
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_list_api_with_http_info(organization_name, **kwargs)  # noqa: E501

    def workspace_list_api_with_http_info(self, organization_name, **kwargs):  # noqa: E501
        """workspace_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_list_api_with_http_info(organization_name, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param cluster:
        :type cluster: int
        :param cursor_after_id:
        :type cursor_after_id: int
        :param cursor_after_value:
        :type cursor_after_value: str
        :param cursor_before_id:
        :type cursor_before_id: int
        :param cursor_before_value:
        :type cursor_before_value: str
        :param cursor_first:
        :type cursor_first: int
        :param cursor_last:
        :type cursor_last: int
        :param keyword:
        :type keyword: str
        :param limit:
        :type limit: int
        :param mine:
        :type mine: bool
        :param offset:
        :type offset: int
        :param order_direction:
        :type order_direction: str
        :param order_field:
        :type order_field: str
        :param paginate_type:
        :type paginate_type: str
        :param statuses:
        :type statuses: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'cluster',
            'cursor_after_id',
            'cursor_after_value',
            'cursor_before_id',
            'cursor_before_value',
            'cursor_first',
            'cursor_last',
            'keyword',
            'limit',
            'mine',
            'offset',
            'order_direction',
            'order_field',
            'paginate_type',
            'statuses'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501

        query_params = []
        if local_var_params.get('cluster') is not None:  # noqa: E501
            query_params.append(('cluster', local_var_params['cluster']))  # noqa: E501
        if local_var_params.get('cursor_after_id') is not None:  # noqa: E501
            query_params.append(('cursor_after_id', local_var_params['cursor_after_id']))  # noqa: E501
        if local_var_params.get('cursor_after_value') is not None:  # noqa: E501
            query_params.append(('cursor_after_value', local_var_params['cursor_after_value']))  # noqa: E501
        if local_var_params.get('cursor_before_id') is not None:  # noqa: E501
            query_params.append(('cursor_before_id', local_var_params['cursor_before_id']))  # noqa: E501
        if local_var_params.get('cursor_before_value') is not None:  # noqa: E501
            query_params.append(('cursor_before_value', local_var_params['cursor_before_value']))  # noqa: E501
        if local_var_params.get('cursor_first') is not None:  # noqa: E501
            query_params.append(('cursor_first', local_var_params['cursor_first']))  # noqa: E501
        if local_var_params.get('cursor_last') is not None:  # noqa: E501
            query_params.append(('cursor_last', local_var_params['cursor_last']))  # noqa: E501
        if local_var_params.get('keyword') is not None:  # noqa: E501
            query_params.append(('keyword', local_var_params['keyword']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if local_var_params.get('mine') is not None:  # noqa: E501
            query_params.append(('mine', local_var_params['mine']))  # noqa: E501
        if local_var_params.get('offset') is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if local_var_params.get('order_direction') is not None:  # noqa: E501
            query_params.append(('order_direction', local_var_params['order_direction']))  # noqa: E501
        if local_var_params.get('order_field') is not None:  # noqa: E501
            query_params.append(('order_field', local_var_params['order_field']))  # noqa: E501
        if local_var_params.get('paginate_type') is not None:  # noqa: E501
            query_params.append(('paginate_type', local_var_params['paginate_type']))  # noqa: E501
        if local_var_params.get('statuses') is not None:  # noqa: E501
            query_params.append(('statuses', local_var_params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "WorkspaceWorkspaceListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_logs_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_logs_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceLogsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_logs_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_logs_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_logs_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_logs_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_logs_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_logs_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_logs_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "WorkspaceWorkspaceLogsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_logs_raw_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_logs_raw_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_logs_raw_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_logs_raw_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_logs_raw_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_logs_raw_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'after',
            'before',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_logs_raw_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_logs_raw_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_logs_raw_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('limit') is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "str",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/logs/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_policy_list_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_policy_list_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RbacWorkspacePolicyListResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_policy_list_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_policy_list_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_policy_list_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_policy_list_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RbacWorkspacePolicyListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_policy_list_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_policy_list_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_policy_list_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "RbacWorkspacePolicyListResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_policy_update_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_policy_update_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_policy_update_api_input:
        :type workspace_policy_update_api_input: WorkspacePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_policy_update_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_policy_update_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_policy_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_policy_update_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_policy_update_api_input:
        :type workspace_policy_update_api_input: WorkspacePolicyUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'workspace_policy_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_policy_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_policy_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_policy_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_policy_update_api_input' in local_var_params:
            body_params = local_var_params['workspace_policy_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'POST', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/policy/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_read_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_read_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_read_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_read_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_read_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_read_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_read_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_read_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_read_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_refresh_scheduled_termination_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_refresh_scheduled_termination_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_refresh_scheduled_termination_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_refresh_scheduled_termination_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_refresh_scheduled_termination_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_refresh_scheduled_termination_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_refresh_scheduled_termination_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_refresh_scheduled_termination_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_refresh_scheduled_termination_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_refresh_scheduled_termination_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/scheduled_termination/refresh', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_start_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_start_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_start_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_start_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_start_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_start_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_start_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_start_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_start_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_start_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_status_idle_shutdown_api(self, workspace_id, **kwargs):  # noqa: E501
        """workspace_status_idle_shutdown_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_status_idle_shutdown_api(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_status_idle_shutdown_api_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def workspace_status_idle_shutdown_api_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """workspace_status_idle_shutdown_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_status_idle_shutdown_api_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_status_idle_shutdown_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_status_idle_shutdown_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "object",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceID}/idle_shutdown', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_status_running_api(self, workspace_id, **kwargs):  # noqa: E501
        """workspace_status_running_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_status_running_api(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceStatusRunningResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_status_running_api_with_http_info(workspace_id, **kwargs)  # noqa: E501

    def workspace_status_running_api_with_http_info(self, workspace_id, **kwargs):  # noqa: E501
        """workspace_status_running_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_status_running_api_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceStatusRunningResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_status_running_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_status_running_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "WorkspaceWorkspaceStatusRunningResponse",
        }

        return self.api_client.call_api(
            '/api/v1/workspaces/{workspaceID}/running', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_stop_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_stop_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_stop_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_stop_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_stop_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_stop_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_stop_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_stop_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_stop_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_system_metrics_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_system_metrics_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkspaceWorkspaceSystemMetricsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_system_metrics_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_system_metrics_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_system_metrics_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_system_metrics_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param after:
        :type after: float
        :param before:
        :type before: float
        :param metrics:
        :type metrics: list[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkspaceWorkspaceSystemMetricsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'after',
            'before',
            'metrics'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_system_metrics_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_system_metrics_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_system_metrics_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []
        if local_var_params.get('after') is not None:  # noqa: E501
            query_params.append(('after', local_var_params['after']))  # noqa: E501
        if local_var_params.get('before') is not None:  # noqa: E501
            query_params.append(('before', local_var_params['before']))  # noqa: E501
        if local_var_params.get('metrics') is not None:  # noqa: E501
            query_params.append(('metrics', local_var_params['metrics']))  # noqa: E501
            collection_formats['metrics'] = 'multi'  # noqa: E501

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "WorkspaceWorkspaceSystemMetricsResponse",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/system_metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_terminate_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_terminate_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_terminate_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_terminate_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_terminate_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_terminate_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_terminate_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_terminate_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_terminate_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}/terminate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def workspace_update_api(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_update_api(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_update_api_input:
        :type workspace_update_api_input: WorkspaceUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ResponseWorkspaceDetail
        """
        kwargs['_return_http_data_only'] = True
        return self.workspace_update_api_with_http_info(organization_name, workspace_id, **kwargs)  # noqa: E501

    def workspace_update_api_with_http_info(self, organization_name, workspace_id, **kwargs):  # noqa: E501
        """workspace_update_api  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.workspace_update_api_with_http_info(organization_name, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_name: (required)
        :type organization_name: str
        :param workspace_id: (required)
        :type workspace_id: int
        :param workspace_update_api_input:
        :type workspace_update_api_input: WorkspaceUpdateAPIInput
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ResponseWorkspaceDetail, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'organization_name',
            'workspace_id',
            'workspace_update_api_input'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method workspace_update_api" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'organization_name' is set
        if self.api_client.client_side_validation and local_var_params.get('organization_name') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `organization_name` when calling `workspace_update_api`")  # noqa: E501
        # verify the required parameter 'workspace_id' is set
        if self.api_client.client_side_validation and local_var_params.get('workspace_id') is None:  # noqa: E501
            raise ApiValueError("Missing the required parameter `workspace_id` when calling `workspace_update_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_name' in local_var_params:
            path_params['organizationName'] = local_var_params['organization_name']  # noqa: E501
        if 'workspace_id' in local_var_params:
            path_params['workspaceID'] = local_var_params['workspace_id']  # noqa: E501

        query_params = []

        header_params = dict(local_var_params.get('_headers', {}))

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workspace_update_api_input' in local_var_params:
            body_params = local_var_params['workspace_update_api_input']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        content_types_list = local_var_params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json'],
                'PATCH', body_params))  # noqa: E501
        if content_types_list:
                header_params['Content-Type'] = content_types_list

        # Authentication setting
        auth_settings = []  # noqa: E501

        response_types_map = {
            200: "ResponseWorkspaceDetail",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationName}/workspaces/{workspaceID}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
