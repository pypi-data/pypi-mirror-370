from typing import Dict, List, Any, Union
import pandas as pd
import numpy as np
from pandas import DataFrame

class DatasetCleaner:
    """
    A class to clean a pandas DataFrame based on a validation report.

    This class provides methods to handle common data quality issues like
    missing values, duplicate rows, and data type inconsistencies. The cleaning
    actions are guided by a results dictionary, typically generated by the
    DatasetValidator class.
    """
    
    def __init__(self, df: DataFrame, validation_results: Dict[str, Any]):
        """ 
        Initialise the DatasetCleaner
        
        Args:
            df (DataFrame): The pandas DataFrame to be cleaned.
            validation_results (Dict[str, Any]): A dictionary containing the results from the DatasetValidator checks.
        """
        
        if not isinstance(df, DataFrame):
            raise TypeError("Input df must be a pandas DataFrame.")
        
        self.df = df.copy() # Work on a copy to avoid modifying the original
        self.validation_results = validation_results
        
    def handle_missing_values(self, strategy: str = "mean") -> DataFrame:
        """ 
        Fills missing values in the DataFrame based on a specified strategy.

        This method uses the 'missing_values' report from the validation
        results to identify which columns need filling.

        Args:
            strategy (str): The strategy for filling missing values.
                - 'mean': Fills with the mean of the column (for numeric columns).
                - 'median': Fills with the median (for numeric columns).
                - 'mode': Fills with the mode (for any column type).
                - 'drop': Drops rows with any missing values.
                Defaults to 'mean'.

        Returns:
            DataFrame: The DataFrame with missing values handled.
        """
        
        print(f"Handling missing values using '{strategy}' strategy...")
        missing_info = self.validation_results.get("missing_values", {})
        if not missing_info:
            print("No missing values to handle.")
            return self.df
        
        if strategy == 'drop':
            self.df.dropna(inplace=True)
            return self.df
        
        for col, details in missing_info.items():
            if np.issubdtype(self.df[col].dtype, np.number):
                if strategy == 'mean':
                    fill_value = self.df[col].mean()
                elif strategy == 'median':
                    fill_value = self.df[col].median()
                else: # Default to mode for numeric if strategy is 'mode'
                    fill_value = self.df[col].mode()[0]
            else: # For non-numeric columns, always use mode
                fill_value = self.df[col].mode()[0]
                
            self.df[col].fillna(fill_value, inplace=True)
            print(f"  - Filled {details['count']} missing values in column '{col}' with '{fill_value}'")
        
        return self.df
    
    def handle_duplicate_rows(self) -> DataFrame:
        """
        Removes duplicate rows from the DataFrame.

        Uses the 'duplicate_rows' report to check if there are duplicates
        before attempting to remove them.

        Returns:
            DataFrame: The DataFrame with duplicate rows removed.
        """
        
        duplicate_info = self.validation_results.get("duplicate_rows", {})
        count = duplicate_info.get("count", 0)

        if count > 0:
            print(f"Removing {count} duplicate rows...")
            self.df.drop_duplicates(inplace=True)
        else:
            print("No duplicate rows to handle.")
            
        return self.df
    
    def correct_data_types(self) -> DataFrame:
        """
        Attempts to convert columns of 'object' dtype to numeric types.

        Iterates through columns identified as 'object' and tries to convert
        them to a numeric format. If conversion fails, the column is left as is.

        Returns:
            DataFrame: The DataFrame with corrected data types.
        """
        print("Correcting data types...")
        type_info = self.validation_results.get("data_types", {})
        for col, dtype in type_info.items():
            if dtype == 'object':
                # Attempt to convert to numeric, coercing errors to NaN
                converted_series = pd.to_numeric(self.df[col], errors='coerce')
                
                # If the conversion was successful (didn't make everything NaN)
                if not converted_series.isnull().all():
                    # Check if it can be an integer
                    if (converted_series.dropna() % 1 == 0).all():
                        self.df[col] = pd.to_numeric(self.df[col], errors='coerce', downcast='integer')
                    else:
                        self.df[col] = converted_series
                    print(f"  - Converted column '{col}' to numeric.")
        return self.df
    
    def clean_dataset(self, missing_value_strategy: str = 'mean') -> DataFrame:
        """
        Runs the full cleaning pipeline based on the validation results.

        This is the main method that orchestrates the cleaning process by
        calling the individual `handle_` methods in a logical order.

        Args:
            missing_value_strategy (str): The strategy to use for filling
                missing values ('mean', 'median', 'mode', 'drop').
                Defaults to 'mean'.

        Returns:
            DataFrame: The cleaned pandas DataFrame.
        """
        print("\nStarting dataset cleaning process...")
        
        # Correct types first
        self.correct_data_types()
        
        # Handle duplicates
        self.handle_duplicate_rows()
        
        # Handle missing values
        self.handle_missing_values(strategy=missing_value_strategy)
        
        print("\nDataset cleaning complete.")
        return self.df