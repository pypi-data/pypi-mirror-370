"""
RBY1-SDK
"""
from __future__ import annotations
import datetime
import numpy
import pybind11_stubgen.typing_ext
import typing
from . import dynamics
from . import math
from . import upc
__all__: list[str] = ['ArmCommandBuilder', 'ArmCommandFeedback', 'BatteryInfo', 'BatteryState', 'BodyCommandBuilder', 'BodyCommandFeedback', 'BodyComponentBasedCommandBuilder', 'BodyComponentBasedCommandFeedback', 'CartesianCommandBuilder', 'CartesianCommandFeedback', 'CartesianImpedanceControlCommandBuilder', 'CartesianImpedanceControlCommandFeedback', 'Color', 'CommandFeedback', 'CommandHeaderBuilder', 'CommandHeaderFeedback', 'ComponentBasedCommandBuilder', 'ComponentBasedCommandFeedback', 'ControlManagerState', 'DynamixelBus', 'EMOInfo', 'EMOState', 'FTSensorData', 'Feedback', 'GravityCompensationCommandBuilder', 'GravityCompensationCommandFeedback', 'HeadCommandBuilder', 'HeadCommandFeedback', 'ImpedanceControlCommandBuilder', 'ImpedanceControlCommandFeedback', 'JogCommandBuilder', 'JogCommandFeedback', 'JointGroupPositionCommandBuilder', 'JointGroupPositionCommandFeedback', 'JointImpedanceControlCommandBuilder', 'JointImpedanceControlCommandFeedback', 'JointInfo', 'JointPositionCommandBuilder', 'JointPositionCommandFeedback', 'JointState', 'JointVelocityCommandBuilder', 'JointVelocityCommandFeedback', 'Log', 'MobilityCommandBuilder', 'MobilityCommandFeedback', 'Model_A', 'Model_M', 'Model_T5', 'Model_UB', 'OptimalControlCommandBuilder', 'OptimalControlCommandFeedback', 'PIDGain', 'PowerInfo', 'PowerState', 'RobotCommandBuilder', 'RobotCommandFeedback', 'RobotInfo', 'RobotState_A', 'RobotState_M', 'RobotState_T5', 'RobotState_UB', 'Robot_A', 'Robot_A_CommandHandler', 'Robot_A_CommandStreamHandler', 'Robot_A_ControlInput', 'Robot_A_ControlState', 'Robot_M', 'Robot_M_CommandHandler', 'Robot_M_CommandStreamHandler', 'Robot_M_ControlInput', 'Robot_M_ControlState', 'Robot_T5', 'Robot_T5_CommandHandler', 'Robot_T5_CommandStreamHandler', 'Robot_T5_ControlInput', 'Robot_T5_ControlState', 'Robot_UB', 'Robot_UB_CommandHandler', 'Robot_UB_CommandStreamHandler', 'Robot_UB_ControlInput', 'Robot_UB_ControlState', 'SE2VelocityCommandBuilder', 'SE2VelocityCommandFeedback', 'SerialDevice', 'SerialStream', 'StopCommandBuilder', 'StopCommandFeedback', 'SystemStat', 'ToolFlangeState', 'TorsoCommandBuilder', 'TorsoCommandFeedback', 'WholeBodyCommandBuilder', 'WholeBodyCommandFeedback', 'WifiNetwork', 'WifiStatus', 'create_robot_a', 'create_robot_m', 'create_robot_t5', 'create_robot_ub', 'dynamics', 'math', 'upc']
class ArmCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointPositionCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GravityCompensationCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def set_command(self, joint_position_command_builder: JointPositionCommandBuilder) -> ArmCommandBuilder:
        ...
    @typing.overload
    def set_command(self, gravity_compensation_command_builder: GravityCompensationCommandBuilder) -> ArmCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_command_builder: CartesianCommandBuilder) -> ArmCommandBuilder:
        ...
    @typing.overload
    def set_command(self, impedance_control_command_builder: ImpedanceControlCommandBuilder) -> ArmCommandBuilder:
        ...
    @typing.overload
    def set_command(self, joint_impedance_control_command_builder: JointImpedanceControlCommandBuilder) -> ArmCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_impedance_control_command_builder: CartesianImpedanceControlCommandBuilder) -> ArmCommandBuilder:
        ...
class ArmCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def cartesian_command(self) -> CartesianCommandFeedback:
        ...
    @property
    def cartesian_impedance_control_command(self) -> CartesianImpedanceControlCommandFeedback:
        ...
    @property
    def gravity_compensation_command(self) -> GravityCompensationCommandFeedback:
        ...
    @property
    def impedance_control_command(self) -> ImpedanceControlCommandFeedback:
        ...
    @property
    def joint_impedance_control_command(self) -> JointImpedanceControlCommandFeedback:
        ...
    @property
    def joint_position_command(self) -> JointPositionCommandFeedback:
        ...
class BatteryInfo:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class BatteryState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def current(self) -> float:
        ...
    @property
    def level_percent(self) -> float:
        ...
    @property
    def voltage(self) -> float:
        ...
class BodyCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointPositionCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: OptimalControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GravityCompensationCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: BodyComponentBasedCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def set_command(self, joint_position_command_builder: JointPositionCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, optimal_control_command_builder: OptimalControlCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, gravity_compensation_command_builder: GravityCompensationCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_command_builder: CartesianCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, body_component_based_command_builder: BodyComponentBasedCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, joint_impedance_control_command_builder: JointImpedanceControlCommandBuilder) -> BodyCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_impedance_control_command_builder: CartesianImpedanceControlCommandBuilder) -> BodyCommandBuilder:
        ...
class BodyCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def body_component_based_command(self) -> BodyComponentBasedCommandFeedback:
        ...
    @property
    def cartesian_command(self) -> CartesianCommandFeedback:
        ...
    @property
    def cartesian_impedance_control_command(self) -> CartesianImpedanceControlCommandFeedback:
        ...
    @property
    def gravity_compensation_command(self) -> GravityCompensationCommandFeedback:
        ...
    @property
    def joint_impedance_control_command(self) -> JointImpedanceControlCommandFeedback:
        ...
    @property
    def joint_position_command(self) -> JointPositionCommandFeedback:
        ...
    @property
    def optimal_control_command(self) -> OptimalControlCommandFeedback:
        ...
class BodyComponentBasedCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_left_arm_command(self, arm_command_builder: ArmCommandBuilder) -> BodyComponentBasedCommandBuilder:
        ...
    def set_right_arm_command(self, arm_command_builder: ArmCommandBuilder) -> BodyComponentBasedCommandBuilder:
        ...
    def set_torso_command(self, torso_command_builder: TorsoCommandBuilder) -> BodyComponentBasedCommandBuilder:
        ...
class BodyComponentBasedCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def left_arm_command(self) -> ArmCommandFeedback:
        ...
    @property
    def right_arm_command(self) -> ArmCommandFeedback:
        ...
    @property
    def torso_command(self) -> TorsoCommandFeedback:
        ...
class CartesianCommandBuilder:
    def __init__(self) -> None:
        ...
    def add_joint_position_target(self, joint_name: str, target_position: float, velocity_limit: float | None = None, acceleration_limit: float | None = None) -> CartesianCommandBuilder:
        ...
    def add_target(self, ref_link_name: str, link_name: str, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]], linear_velocity_limit: float, angular_velocity_limit: float, acceleration_limit_scaling: float) -> CartesianCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> CartesianCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> CartesianCommandBuilder:
        ...
    def set_stop_joint_position_tracking_error(self, stop_joint_position_tracking_error: float) -> CartesianCommandBuilder:
        ...
    def set_stop_orientation_tracking_error(self, stop_orientation_tracking_error: float) -> CartesianCommandBuilder:
        ...
    def set_stop_position_tracking_error(self, stop_position_tracking_error: float) -> CartesianCommandBuilder:
        ...
class CartesianCommandFeedback(CommandFeedback):
    class TrackingError:
        def __init__(self) -> None:
            ...
        @property
        def orientation_error(self) -> float:
            ...
        @property
        def position_error(self) -> float:
            ...
    def __init__(self) -> None:
        ...
    @property
    def joint_position_tracking_errors(self) -> list[float]:
        ...
    @property
    def manipulability(self) -> float:
        ...
    @property
    def remain_time(self) -> float:
        ...
    @property
    def se3_pose_tracking_errors(self) -> list[CartesianCommandFeedback.TrackingError]:
        ...
class CartesianImpedanceControlCommandBuilder:
    def __init__(self) -> None:
        ...
    def add_joint_limit(self, joint_name: str, lower: float, upper: float) -> CartesianImpedanceControlCommandBuilder:
        ...
    def add_joint_position_target(self, joint_name: str, target_position: float, velocity_limit: float | None = None, acceleration_limit: float | None = None) -> CartesianImpedanceControlCommandBuilder:
        ...
    def add_target(self, ref_link_name: str, link_name: str, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]], linear_velocity_limit: float | None = None, angular_velocity_limit: float | None = None, linear_acceleration_limit: float | None = None, angular_acceleration_limit: float | None = None) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_joint_damping_ratio(self, damping_ratio: float) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_joint_stiffness(self, stiffness: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_joint_torque_limit(self, torque_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_reset_reference(self, reset_reference: bool) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_stop_joint_position_tracking_error(self, stop_joint_position_tracking_error: float) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_stop_orientation_tracking_error(self, stop_orientation_tracking_error: float) -> CartesianImpedanceControlCommandBuilder:
        ...
    def set_stop_position_tracking_error(self, stop_position_tracking_error: float) -> CartesianImpedanceControlCommandBuilder:
        ...
class CartesianImpedanceControlCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def manipulability(self) -> float:
        ...
    @property
    def remain_time(self) -> float:
        ...
    @property
    def set_position(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Color:
    b: int
    g: int
    r: int
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, r: int, g: int, b: int) -> None:
        ...
class CommandFeedback(Feedback):
    def __init__(self) -> None:
        ...
    @property
    def command_header(self) -> CommandHeaderFeedback:
        ...
class CommandHeaderBuilder:
    def __init__(self) -> None:
        ...
    def set_control_hold_time(self, control_hold_time: float) -> CommandHeaderBuilder:
        ...
class CommandHeaderFeedback(Feedback):
    def __init__(self) -> None:
        ...
    @property
    def finished(self) -> bool:
        ...
class ComponentBasedCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_body_command(self, body_command_builder: BodyCommandBuilder) -> ComponentBasedCommandBuilder:
        ...
    def set_head_command(self, head_command_builder: HeadCommandBuilder) -> ComponentBasedCommandBuilder:
        ...
    def set_mobility_command(self, mobility_command_builder: MobilityCommandBuilder) -> ComponentBasedCommandBuilder:
        ...
class ComponentBasedCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def body_command(self) -> BodyCommandFeedback:
        ...
    @property
    def head_command(self) -> HeadCommandFeedback:
        ...
    @property
    def mobility_command(self) -> MobilityCommandFeedback:
        ...
class ControlManagerState:
    class ControlState:
        """
        Members:
        
          Unknown
        
          Idle
        
          Executing
        
          Switching
        """
        Executing: typing.ClassVar[ControlManagerState.ControlState]  # value = <ControlState.Executing: 2>
        Idle: typing.ClassVar[ControlManagerState.ControlState]  # value = <ControlState.Idle: 1>
        Switching: typing.ClassVar[ControlManagerState.ControlState]  # value = <ControlState.Switching: 3>
        Unknown: typing.ClassVar[ControlManagerState.ControlState]  # value = <ControlState.Unknown: 0>
        __members__: typing.ClassVar[dict[str, ControlManagerState.ControlState]]  # value = {'Unknown': <ControlState.Unknown: 0>, 'Idle': <ControlState.Idle: 1>, 'Executing': <ControlState.Executing: 2>, 'Switching': <ControlState.Switching: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class State:
        """
        Members:
        
          Unknown
        
          Idle
        
          Enabled
        
          MinorFault
        
          MajorFault
        """
        Enabled: typing.ClassVar[ControlManagerState.State]  # value = <State.Enabled: 2>
        Idle: typing.ClassVar[ControlManagerState.State]  # value = <State.Idle: 1>
        MajorFault: typing.ClassVar[ControlManagerState.State]  # value = <State.MajorFault: 4>
        MinorFault: typing.ClassVar[ControlManagerState.State]  # value = <State.MinorFault: 3>
        Unknown: typing.ClassVar[ControlManagerState.State]  # value = <State.Unknown: 0>
        __members__: typing.ClassVar[dict[str, ControlManagerState.State]]  # value = {'Unknown': <State.Unknown: 0>, 'Idle': <State.Idle: 1>, 'Enabled': <State.Enabled: 2>, 'MinorFault': <State.MinorFault: 3>, 'MajorFault': <State.MajorFault: 4>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def control_state(self) -> ControlManagerState.ControlState:
        ...
    @property
    def enabled_joint_idx(self) -> list[int]:
        ...
    @property
    def state(self) -> ControlManagerState.State:
        ...
    @property
    def time_scale(self) -> float:
        ...
    @property
    def unlimited_mode_enabled(self) -> bool:
        ...
class DynamixelBus:
    class ButtonState:
        def __init__(self) -> None:
            ...
        @property
        def button(self) -> int:
            ...
        @property
        def trigger(self) -> int:
            ...
    class MotorState:
        def __init__(self) -> None:
            ...
        @property
        def current(self) -> float:
            ...
        @property
        def position(self) -> float:
            ...
        @property
        def temperature(self) -> int:
            ...
        @property
        def torque(self) -> float:
            ...
        @property
        def torque_enable(self) -> bool:
            ...
        @property
        def velocity(self) -> float:
            ...
    class PIDGain:
        d_gain: int
        i_gain: int
        p_gain: int
        def __init__(self) -> None:
            ...
    AddrCurrentTemperature: typing.ClassVar[int] = 146
    AddrGoalCurrent: typing.ClassVar[int] = 102
    AddrGoalPosition: typing.ClassVar[int] = 116
    AddrGoalVibrationLevel: typing.ClassVar[int] = 102
    AddrOperatingMode: typing.ClassVar[int] = 11
    AddrPositionDGain: typing.ClassVar[int] = 80
    AddrPositionIGain: typing.ClassVar[int] = 82
    AddrPositionPGain: typing.ClassVar[int] = 84
    AddrPresentButtonState: typing.ClassVar[int] = 132
    AddrPresentCurrent: typing.ClassVar[int] = 126
    AddrPresentPosition: typing.ClassVar[int] = 132
    AddrPresentVelocity: typing.ClassVar[int] = 128
    AddrTorqueEnable: typing.ClassVar[int] = 64
    CurrentBasedPositionControlMode: typing.ClassVar[int] = 5
    CurrentControlMode: typing.ClassVar[int] = 0
    DefaultBaudrate: typing.ClassVar[int] = 2000000
    ProtocolVersion: typing.ClassVar[float] = 2.0
    TorqueDisable: typing.ClassVar[int] = 0
    TorqueEnable: typing.ClassVar[int] = 1
    def __init__(self, dev_name: str) -> None:
        ...
    def get_motor_states(self, arg0: list[int]) -> list[tuple[int, DynamixelBus.MotorState]] | None:
        ...
    def get_position_d_gain(self, arg0: int) -> int | None:
        ...
    def get_position_i_gain(self, arg0: int) -> int | None:
        ...
    def get_position_p_gain(self, arg0: int) -> int | None:
        ...
    def get_position_pid_gain(self, arg0: int) -> DynamixelBus.PIDGain | None:
        ...
    def group_fast_sync_read(self, arg0: list[int], arg1: int, arg2: int) -> list[tuple[int, int]] | None:
        ...
    def group_fast_sync_read_encoder(self, arg0: list[int]) -> list[tuple[int, float]] | None:
        ...
    def group_fast_sync_read_operating_mode(self, arg0: list[int], arg1: bool) -> list[tuple[int, int]] | None:
        ...
    def group_fast_sync_read_torque_enable(self, arg0: list[int]) -> list[tuple[int, int]] | None:
        ...
    def group_sync_write_operating_mode(self, arg0: list[tuple[int, int]]) -> None:
        ...
    def group_sync_write_send_position(self, arg0: list[tuple[int, float]]) -> None:
        ...
    def group_sync_write_send_torque(self, arg0: list[tuple[int, float]]) -> None:
        ...
    @typing.overload
    def group_sync_write_torque_enable(self, arg0: list[tuple[int, int]]) -> None:
        ...
    @typing.overload
    def group_sync_write_torque_enable(self, arg0: list[int], arg1: int) -> None:
        ...
    def open_port(self) -> bool:
        ...
    def ping(self, arg0: int) -> bool:
        ...
    def read_button_status(self, arg0: int) -> tuple[int, DynamixelBus.ButtonState] | None:
        ...
    def read_encoder(self, arg0: int) -> float | None:
        ...
    def read_operating_mode(self, arg0: int, arg1: bool) -> int | None:
        ...
    def read_temperature(self, arg0: int) -> int | None:
        ...
    def read_torque_enable(self, arg0: int) -> int | None:
        ...
    def send_current(self, arg0: int, arg1: float) -> None:
        ...
    def send_goal_position(self, arg0: int, arg1: int) -> None:
        ...
    def send_operating_mode(self, arg0: int, arg1: int) -> bool:
        ...
    def send_torque(self, arg0: int, arg1: float) -> None:
        ...
    def send_torque_enable(self, arg0: int, arg1: int) -> None:
        ...
    def send_vibration(self, arg0: int, arg1: int) -> None:
        ...
    def set_baud_rate(self, arg0: int) -> bool:
        ...
    def set_position_d_gain(self, arg0: int, arg1: int) -> None:
        ...
    def set_position_i_gain(self, arg0: int, arg1: int) -> None:
        ...
    def set_position_p_gain(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def set_position_pid_gain(self, arg0: int, arg1: int | None, arg2: int | None, arg3: int | None) -> None:
        ...
    @typing.overload
    def set_position_pid_gain(self, arg0: int, arg1: DynamixelBus.PIDGain) -> None:
        ...
    def set_torque_constant(self, arg0: list[float]) -> None:
        ...
class EMOInfo:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
class EMOState:
    class State:
        """
        Members:
        
          Released
        
          Pressed
        """
        Pressed: typing.ClassVar[EMOState.State]  # value = <State.Pressed: 1>
        Released: typing.ClassVar[EMOState.State]  # value = <State.Released: 0>
        __members__: typing.ClassVar[dict[str, EMOState.State]]  # value = {'Released': <State.Released: 0>, 'Pressed': <State.Pressed: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def state(self) -> EMOState.State:
        ...
class FTSensorData:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def force(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def time_since_last_update(self) -> datetime.timedelta:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Feedback:
    def __init__(self) -> None:
        ...
    @property
    def valid(self) -> bool:
        ...
class GravityCompensationCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_command_header(self, gravity_compensation_command_builder: CommandHeaderBuilder) -> GravityCompensationCommandBuilder:
        ...
    def set_on(self, on: bool) -> GravityCompensationCommandBuilder:
        ...
class GravityCompensationCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
class HeadCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointPositionCommandBuilder) -> None:
        ...
    def set_command(self, joint_position_command_builder: JointPositionCommandBuilder) -> HeadCommandBuilder:
        ...
class HeadCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def joint_position_command(self) -> JointPositionCommandFeedback:
        ...
class ImpedanceControlCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> ImpedanceControlCommandBuilder:
        ...
    def set_damping_ratio(self, damping_ratio: float) -> ImpedanceControlCommandBuilder:
        ...
    def set_link_name(self, link_name: str) -> ImpedanceControlCommandBuilder:
        ...
    def set_reference_link_name(self, reference_link_name: str) -> ImpedanceControlCommandBuilder:
        ...
    def set_rotation_weight(self, weight: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> ImpedanceControlCommandBuilder:
        ...
    def set_transformation(self, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]]) -> ImpedanceControlCommandBuilder:
        ...
    def set_translation_weight(self, weight: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> ImpedanceControlCommandBuilder:
        ...
class ImpedanceControlCommandFeedback(CommandFeedback):
    class TrackingError:
        def __init__(self) -> None:
            ...
        @property
        def position_error(self) -> float:
            ...
        @property
        def rotation_error(self) -> float:
            ...
    def __init__(self) -> None:
        ...
    @property
    def tracking_error(self) -> ImpedanceControlCommandFeedback.TrackingError:
        ...
class JogCommandBuilder:
    class AbsolutePosition:
        def __init__(self, arg0: float) -> None:
            ...
        def value(self) -> float:
            ...
    class OneStep:
        def __init__(self, arg0: float) -> None:
            ...
        def value(self) -> bool:
            ...
    class RelativePosition:
        def __init__(self, arg0: float) -> None:
            ...
        def value(self) -> float:
            ...
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, acceleration_limit: float) -> JogCommandBuilder:
        ...
    @typing.overload
    def set_command(self, absolute_position: JogCommandBuilder.AbsolutePosition) -> JogCommandBuilder:
        ...
    @typing.overload
    def set_command(self, relative_position: JogCommandBuilder.RelativePosition) -> JogCommandBuilder:
        ...
    @typing.overload
    def set_command(self, one_step: JogCommandBuilder.OneStep) -> JogCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> JogCommandBuilder:
        ...
    def set_joint_name(self, joint_name: str) -> JogCommandBuilder:
        ...
    def set_velocity_limit(self, velocity_limite: float) -> JogCommandBuilder:
        ...
class JogCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def target_joint_name(self) -> str:
        ...
class JointGroupPositionCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, acceleration_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointGroupPositionCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> JointGroupPositionCommandBuilder:
        ...
    def set_joint_names(self, joint_names: list[str]) -> JointGroupPositionCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> JointGroupPositionCommandBuilder:
        ...
    def set_position(self, position: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointGroupPositionCommandBuilder:
        ...
    def set_velocity_limit(self, velocity_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointGroupPositionCommandBuilder:
        ...
class JointGroupPositionCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def joint_indices(self) -> list[int]:
        ...
    @property
    def position_based_progress(self) -> float:
        ...
    @property
    def time_based_progress(self) -> float:
        ...
class JointImpedanceControlCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, acceleration_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointImpedanceControlCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> JointImpedanceControlCommandBuilder:
        ...
    def set_damping_ratio(self, damping_ratio: float) -> JointImpedanceControlCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> JointImpedanceControlCommandBuilder:
        ...
    def set_position(self, position: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointImpedanceControlCommandBuilder:
        ...
    def set_stiffness(self, stiffness: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointImpedanceControlCommandBuilder:
        ...
    def set_torque_limit(self, torque_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointImpedanceControlCommandBuilder:
        ...
    def set_velocity_limit(self, velocity_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointImpedanceControlCommandBuilder:
        ...
class JointImpedanceControlCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def error(self) -> list[float]:
        ...
    @property
    def set_position(self) -> list[float]:
        ...
class JointInfo:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def firmware_version(self) -> str:
        ...
    @property
    def has_brake(self) -> bool:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def product_name(self) -> str:
        ...
class JointPositionCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, acceleration_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointPositionCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> JointPositionCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> JointPositionCommandBuilder:
        ...
    def set_position(self, position: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointPositionCommandBuilder:
        ...
    def set_velocity_limit(self, velocity_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointPositionCommandBuilder:
        ...
class JointPositionCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def position_based_progress(self) -> float:
        ...
    @property
    def time_based_progress(self) -> float:
        ...
class JointState:
    class FETState:
        """
        Members:
        
          Unknown
        
          On
        
          Off
        """
        Off: typing.ClassVar[JointState.FETState]  # value = <FETState.Off: 2>
        On: typing.ClassVar[JointState.FETState]  # value = <FETState.On: 1>
        Unknown: typing.ClassVar[JointState.FETState]  # value = <FETState.Unknown: 0>
        __members__: typing.ClassVar[dict[str, JointState.FETState]]  # value = {'Unknown': <FETState.Unknown: 0>, 'On': <FETState.On: 1>, 'Off': <FETState.Off: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class InitializationState:
        """
        Members:
        
          Unknown
        
          Initialized
        
          Uninitialized
        """
        Initialized: typing.ClassVar[JointState.InitializationState]  # value = <InitializationState.Initialized: 1>
        Uninitialized: typing.ClassVar[JointState.InitializationState]  # value = <InitializationState.Uninitialized: 2>
        Unknown: typing.ClassVar[JointState.InitializationState]  # value = <InitializationState.Unknown: 0>
        __members__: typing.ClassVar[dict[str, JointState.InitializationState]]  # value = {'Unknown': <InitializationState.Unknown: 0>, 'Initialized': <InitializationState.Initialized: 1>, 'Uninitialized': <InitializationState.Uninitialized: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class RunState:
        """
        Members:
        
          Unknown
        
          ControlOn
        
          ControlOff
        """
        ControlOff: typing.ClassVar[JointState.RunState]  # value = <RunState.ControlOff: 2>
        ControlOn: typing.ClassVar[JointState.RunState]  # value = <RunState.ControlOn: 1>
        Unknown: typing.ClassVar[JointState.RunState]  # value = <RunState.Unknown: 0>
        __members__: typing.ClassVar[dict[str, JointState.RunState]]  # value = {'Unknown': <RunState.Unknown: 0>, 'ControlOn': <RunState.ControlOn: 1>, 'ControlOff': <RunState.ControlOff: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def current(self) -> float:
        ...
    @property
    def fet_state(self) -> JointState.FETState:
        ...
    @property
    def init_state(self) -> JointState.InitializationState:
        ...
    @property
    def is_ready(self) -> bool:
        ...
    @property
    def motor_state(self) -> int:
        ...
    @property
    def motor_type(self) -> int:
        ...
    @property
    def position(self) -> float:
        ...
    @property
    def power_on(self) -> bool:
        ...
    @property
    def run_state(self) -> JointState.RunState:
        ...
    @property
    def target_feedback_gain(self) -> int:
        ...
    @property
    def target_feedforward_torque(self) -> float:
        ...
    @property
    def target_position(self) -> float:
        ...
    @property
    def target_velocity(self) -> float:
        ...
    @property
    def temperature(self) -> int:
        ...
    @property
    def time_since_last_update(self) -> datetime.timedelta:
        ...
    @property
    def torque(self) -> float:
        ...
    @property
    def velocity(self) -> float:
        ...
class JointVelocityCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, acceleration_limit: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointVelocityCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> JointVelocityCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> JointVelocityCommandBuilder:
        ...
    def set_velocity(self, velocity: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float64]]) -> JointVelocityCommandBuilder:
        ...
class JointVelocityCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
class Log:
    class Level:
        """
        Members:
        
          Trace
        
          Debug
        
          Info
        
          Warn
        
          Error
        
          Critical
        """
        Critical: typing.ClassVar[Log.Level]  # value = <Level.Critical: 5>
        Debug: typing.ClassVar[Log.Level]  # value = <Level.Debug: 1>
        Error: typing.ClassVar[Log.Level]  # value = <Level.Error: 4>
        Info: typing.ClassVar[Log.Level]  # value = <Level.Info: 2>
        Trace: typing.ClassVar[Log.Level]  # value = <Level.Trace: 0>
        Warn: typing.ClassVar[Log.Level]  # value = <Level.Warn: 3>
        __members__: typing.ClassVar[dict[str, Log.Level]]  # value = {'Trace': <Level.Trace: 0>, 'Debug': <Level.Debug: 1>, 'Info': <Level.Info: 2>, 'Warn': <Level.Warn: 3>, 'Error': <Level.Error: 4>, 'Critical': <Level.Critical: 5>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def level(self) -> Log.Level:
        ...
    @property
    def message(self) -> str:
        ...
    @property
    def robot_system_timestamp(self) -> datetime.datetime:
        ...
    @property
    def timestamp(self) -> datetime.datetime:
        ...
class MobilityCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointVelocityCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SE2VelocityCommandBuilder) -> None:
        ...
    @typing.overload
    def set_command(self, joint_velocity_command_builder: JointVelocityCommandBuilder) -> MobilityCommandBuilder:
        ...
    @typing.overload
    def set_command(self, se2_velocity_command_builder: SE2VelocityCommandBuilder) -> MobilityCommandBuilder:
        ...
class MobilityCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def joint_velocity_command(self) -> JointVelocityCommandFeedback:
        ...
    @property
    def se2_velocity_command(self) -> SE2VelocityCommandFeedback:
        ...
class Model_A:
    def __init__(self) -> None:
        ...
    @property
    def body_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(20)]:
        ...
    @property
    def control_period(self) -> float:
        ...
    @property
    def head_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def left_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def mobility_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def model_name(self) -> str:
        ...
    @property
    def right_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def robot_dof(self) -> int:
        ...
    @property
    def robot_joint_names(self) -> typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(24)]:
        ...
    @property
    def torso_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def velocity_estimation_required_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(20)]:
        ...
class Model_M:
    def __init__(self) -> None:
        ...
    @property
    def body_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(20)]:
        ...
    @property
    def control_period(self) -> float:
        ...
    @property
    def head_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def left_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def mobility_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    @property
    def model_name(self) -> str:
        ...
    @property
    def right_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def robot_dof(self) -> int:
        ...
    @property
    def robot_joint_names(self) -> typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(26)]:
        ...
    @property
    def torso_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def velocity_estimation_required_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(20)]:
        ...
class Model_T5:
    def __init__(self) -> None:
        ...
    @property
    def body_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(19)]:
        ...
    @property
    def control_period(self) -> float:
        ...
    @property
    def head_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def left_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def mobility_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def model_name(self) -> str:
        ...
    @property
    def right_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def robot_dof(self) -> int:
        ...
    @property
    def robot_joint_names(self) -> typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(23)]:
        ...
    @property
    def torso_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(5)]:
        ...
    @property
    def velocity_estimation_required_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(19)]:
        ...
class Model_UB:
    def __init__(self) -> None:
        ...
    @property
    def body_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def control_period(self) -> float:
        ...
    @property
    def head_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def left_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def mobility_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]:
        ...
    @property
    def model_name(self) -> str:
        ...
    @property
    def right_arm_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def robot_dof(self) -> int:
        ...
    @property
    def robot_joint_names(self) -> typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(18)]:
        ...
    @property
    def torso_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def velocity_estimation_required_idx(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
class OptimalControlCommandBuilder:
    def __init__(self) -> None:
        ...
    def add_cartesian_target(self, ref_link_name: str, link_name: str, T: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[4]], numpy.dtype[numpy.float64]], translation_weight: float, rotation_weight: float) -> OptimalControlCommandBuilder:
        ...
    def add_joint_position_target(self, joint_name: str, target_position: float, weight: float) -> OptimalControlCommandBuilder:
        ...
    def set_acceleration_limit_scaling(self, acceleration_limit_scaling: float) -> OptimalControlCommandBuilder:
        ...
    def set_center_of_mass_target(self, ref_link_name: str, pose: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]], weight: float) -> OptimalControlCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> OptimalControlCommandBuilder:
        ...
    def set_error_scaling(self, error_scaling: float) -> OptimalControlCommandBuilder:
        ...
    def set_min_delta_cost(self, min_delta_cost: float) -> OptimalControlCommandBuilder:
        ...
    def set_patience(self, patience: int) -> OptimalControlCommandBuilder:
        ...
    def set_stop_cost(self, stop_cost: float) -> OptimalControlCommandBuilder:
        ...
    def set_velocity_limit_scaling(self, velocity_limit_scaling: float) -> OptimalControlCommandBuilder:
        ...
class OptimalControlCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def cartesian_costs(self) -> list[float]:
        ...
    @property
    def center_of_mass_cost(self) -> float:
        ...
    @property
    def joint_position_costs(self) -> list[float]:
        ...
    @property
    def total_cost(self) -> float:
        ...
class PIDGain:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: int) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def d_gain(self) -> int:
        ...
    @property
    def i_gain(self) -> int:
        ...
    @property
    def p_gain(self) -> int:
        ...
class PowerInfo:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
class PowerState:
    class State:
        """
        Members:
        
          Unknown
        
          PowerOff
        
          PowerOn
        """
        PowerOff: typing.ClassVar[PowerState.State]  # value = <State.PowerOff: 2>
        PowerOn: typing.ClassVar[PowerState.State]  # value = <State.PowerOn: 1>
        Unknown: typing.ClassVar[PowerState.State]  # value = <State.Unknown: 0>
        __members__: typing.ClassVar[dict[str, PowerState.State]]  # value = {'Unknown': <State.Unknown: 0>, 'PowerOff': <State.PowerOff: 2>, 'PowerOn': <State.PowerOn: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def state(self) -> PowerState.State:
        ...
    @property
    def voltage(self) -> float:
        ...
class RobotCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: WholeBodyCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ComponentBasedCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JogCommandBuilder) -> None:
        ...
    @typing.overload
    def set_command(self, whole_body_command_builder: WholeBodyCommandBuilder) -> RobotCommandBuilder:
        ...
    @typing.overload
    def set_command(self, component_based_command_builder: ComponentBasedCommandBuilder) -> RobotCommandBuilder:
        ...
    @typing.overload
    def set_command(self, jog_command_builder: JogCommandBuilder) -> RobotCommandBuilder:
        ...
class RobotCommandFeedback(CommandFeedback):
    class FinishCode:
        """
        Members:
        
          Unknown
        
          Ok
        
          Canceled
        
          Preempted
        
          InitializationFailed
        
          ControlManagerIdle
        
          ControlManagerFault
        
          UnexpectedState
        """
        Canceled: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.Canceled: 2>
        ControlManagerFault: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.ControlManagerFault: 6>
        ControlManagerIdle: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.ControlManagerIdle: 5>
        InitializationFailed: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.InitializationFailed: 4>
        Ok: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.Ok: 1>
        Preempted: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.Preempted: 3>
        UnexpectedState: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.UnexpectedState: 7>
        Unknown: typing.ClassVar[RobotCommandFeedback.FinishCode]  # value = <FinishCode.Unknown: 0>
        __members__: typing.ClassVar[dict[str, RobotCommandFeedback.FinishCode]]  # value = {'Unknown': <FinishCode.Unknown: 0>, 'Ok': <FinishCode.Ok: 1>, 'Canceled': <FinishCode.Canceled: 2>, 'Preempted': <FinishCode.Preempted: 3>, 'InitializationFailed': <FinishCode.InitializationFailed: 4>, 'ControlManagerIdle': <FinishCode.ControlManagerIdle: 5>, 'ControlManagerFault': <FinishCode.ControlManagerFault: 6>, 'UnexpectedState': <FinishCode.UnexpectedState: 7>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class Status:
        """
        Members:
        
          Idle
        
          Initializing
        
          Running
        
          Finished
        """
        Finished: typing.ClassVar[RobotCommandFeedback.Status]  # value = <Status.Finished: 3>
        Idle: typing.ClassVar[RobotCommandFeedback.Status]  # value = <Status.Idle: 0>
        Initializing: typing.ClassVar[RobotCommandFeedback.Status]  # value = <Status.Initializing: 1>
        Running: typing.ClassVar[RobotCommandFeedback.Status]  # value = <Status.Running: 2>
        __members__: typing.ClassVar[dict[str, RobotCommandFeedback.Status]]  # value = {'Idle': <Status.Idle: 0>, 'Initializing': <Status.Initializing: 1>, 'Running': <Status.Running: 2>, 'Finished': <Status.Finished: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    def __init__(self) -> None:
        ...
    @property
    def component_based_command(self) -> ComponentBasedCommandFeedback:
        ...
    @property
    def finish_code(self) -> RobotCommandFeedback.FinishCode:
        ...
    @property
    def jog_command(self) -> JogCommandFeedback:
        ...
    @property
    def status(self) -> RobotCommandFeedback.Status:
        ...
    @property
    def whole_body_command(self) -> WholeBodyCommandFeedback:
        ...
class RobotInfo:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def battery_info(self) -> BatteryInfo:
        ...
    @property
    def body_joint_idx(self) -> list[int]:
        ...
    @property
    def degree_of_freedom(self) -> int:
        ...
    @property
    def emo_infos(self) -> list[EMOInfo]:
        ...
    @property
    def head_joint_idx(self) -> list[int]:
        ...
    @property
    def joint_infos(self) -> list[JointInfo]:
        ...
    @property
    def left_arm_joint_idx(self) -> list[int]:
        ...
    @property
    def mobility_joint_idx(self) -> list[int]:
        ...
    @property
    def power_infos(self) -> list[PowerInfo]:
        ...
    @property
    def right_arm_joint_idx(self) -> list[int]:
        ...
    @property
    def robot_model_name(self) -> str:
        ...
    @property
    def robot_model_version(self) -> str:
        ...
    @property
    def robot_version(self) -> str:
        ...
    @property
    def sdk_commit_id(self) -> str:
        ...
    @property
    def sdk_version(self) -> str:
        ...
    @property
    def torso_joint_idx(self) -> list[int]:
        ...
    @property
    def version(self) -> str:
        ...
class RobotState_A:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def battery_state(self) -> BatteryState:
        ...
    @property
    def center_of_mass(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def collisions(self) -> list[dynamics.CollisionResult]:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def emo_states(self) -> list[EMOState]:
        ...
    @property
    def ft_sensor_left(self) -> FTSensorData:
        ...
    @property
    def ft_sensor_right(self) -> FTSensorData:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def joint_states(self) -> typing.Annotated[list[JointState], pybind11_stubgen.typing_ext.FixedSize(24)]:
        ...
    @property
    def odometry(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def power_states(self) -> list[PowerState]:
        ...
    @property
    def system_stat(self) -> SystemStat:
        ...
    @property
    def target_feedback_gain(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.uint32]]:
        ...
    @property
    def target_feedforward_torque(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_position(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_velocity(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def temperature(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.int32]]:
        ...
    @property
    def timestamp(self) -> datetime.datetime:
        ...
    @property
    def tool_flange_left(self) -> ToolFlangeState:
        ...
    @property
    def tool_flange_right(self) -> ToolFlangeState:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class RobotState_M:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def battery_state(self) -> BatteryState:
        ...
    @property
    def center_of_mass(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def collisions(self) -> list[dynamics.CollisionResult]:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def emo_states(self) -> list[EMOState]:
        ...
    @property
    def ft_sensor_left(self) -> FTSensorData:
        ...
    @property
    def ft_sensor_right(self) -> FTSensorData:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def joint_states(self) -> typing.Annotated[list[JointState], pybind11_stubgen.typing_ext.FixedSize(26)]:
        ...
    @property
    def odometry(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def power_states(self) -> list[PowerState]:
        ...
    @property
    def system_stat(self) -> SystemStat:
        ...
    @property
    def target_feedback_gain(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.uint32]]:
        ...
    @property
    def target_feedforward_torque(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_position(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_velocity(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def temperature(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.int32]]:
        ...
    @property
    def timestamp(self) -> datetime.datetime:
        ...
    @property
    def tool_flange_left(self) -> ToolFlangeState:
        ...
    @property
    def tool_flange_right(self) -> ToolFlangeState:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class RobotState_T5:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def battery_state(self) -> BatteryState:
        ...
    @property
    def center_of_mass(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def collisions(self) -> list[dynamics.CollisionResult]:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def emo_states(self) -> list[EMOState]:
        ...
    @property
    def ft_sensor_left(self) -> FTSensorData:
        ...
    @property
    def ft_sensor_right(self) -> FTSensorData:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def joint_states(self) -> typing.Annotated[list[JointState], pybind11_stubgen.typing_ext.FixedSize(23)]:
        ...
    @property
    def odometry(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def power_states(self) -> list[PowerState]:
        ...
    @property
    def system_stat(self) -> SystemStat:
        ...
    @property
    def target_feedback_gain(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.uint32]]:
        ...
    @property
    def target_feedforward_torque(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_position(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_velocity(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def temperature(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.int32]]:
        ...
    @property
    def timestamp(self) -> datetime.datetime:
        ...
    @property
    def tool_flange_left(self) -> ToolFlangeState:
        ...
    @property
    def tool_flange_right(self) -> ToolFlangeState:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class RobotState_UB:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def battery_state(self) -> BatteryState:
        ...
    @property
    def center_of_mass(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def collisions(self) -> list[dynamics.CollisionResult]:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def emo_states(self) -> list[EMOState]:
        ...
    @property
    def ft_sensor_left(self) -> FTSensorData:
        ...
    @property
    def ft_sensor_right(self) -> FTSensorData:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def joint_states(self) -> typing.Annotated[list[JointState], pybind11_stubgen.typing_ext.FixedSize(18)]:
        ...
    @property
    def odometry(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[3]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def power_states(self) -> list[PowerState]:
        ...
    @property
    def system_stat(self) -> SystemStat:
        ...
    @property
    def target_feedback_gain(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.uint32]]:
        ...
    @property
    def target_feedforward_torque(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_position(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def target_velocity(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def temperature(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.int32]]:
        ...
    @property
    def timestamp(self) -> datetime.datetime:
        ...
    @property
    def tool_flange_left(self) -> ToolFlangeState:
        ...
    @property
    def tool_flange_right(self) -> ToolFlangeState:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Robot_A:
    @staticmethod
    def create(address: str) -> Robot_A:
        ...
    @staticmethod
    def model() -> Model_A:
        ...
    def break_engage(self, dev_name: str) -> bool:
        ...
    def break_release(self, dev_name: str) -> bool:
        ...
    def cancel_control(self) -> bool:
        ...
    def connect(self, max_retries: int = 5, timeout_ms: int = 1000) -> bool:
        """
        connect(max_retries=5, timeout_ms=1000)
        
        Attempts to establish a connection with the robot.
        
        Parameters
        ----------
        max_retries : int, optional
            Maximum number of retries to connect. Default is 5.
        timeout_ms : int, optional
            Timeout in milliseconds for each connection attempt. Default is 1000.
        
        Returns
        -------
        bool
            True if the connection was successful, false otherwise.
        """
    def connect_wifi(self, ssid: str, password: str = '', use_dhcp: bool = True, ip_address: str = '', gateway: str = '', dns: list[str] = []) -> bool:
        ...
    def control(self, control: typing.Callable[[Robot_A_ControlState], Robot_A_ControlInput], port: int = 0, priority: int = 1) -> bool:
        ...
    def create_command_stream(self, priority: int = 1) -> Robot_A_CommandStreamHandler:
        ...
    def disable_control_manager(self) -> bool:
        ...
    def disconnect(self) -> None:
        """
        disconnect()
        
        Disconnects from the robot.
        """
    def disconnect_wifi(self) -> bool:
        ...
    def download_file(self, path: str, file_like: typing.Any) -> bool:
        """
        download_file(path, file_like)
        
        Downloads a file from the robot and writes it into a file-like object.
        
        Parameters
        ----------
        path : str
            Relative path to the file on the robot's file system.
            The base directory is defined by the `RBY1_HOME` environment variable (default: `/root/.rby1`).
        file_like : file-like object
            Any object with a `.write(bytes)` method (e.g., `io.BytesIO`, a real file).
        
        Returns
        -------
        bool
            True if the file was downloaded successfully.
        
        Raises
        ------
        RuntimeError
            If the gRPC call fails (e.g., network issue, file not found, internal error).
        """
    def enable_control_manager(self, unlimited_mode_enabled: bool = False) -> bool:
        ...
    def factory_reset_all_parameters(self) -> None:
        ...
    def factory_reset_parameter(self, name: str) -> bool:
        ...
    def get_control_manager_state(self) -> ControlManagerState:
        ...
    def get_dynamics(self, urdf_model: str = '') -> dynamics.Robot_24:
        ...
    def get_fault_log_list(self) -> list[str]:
        ...
    def get_head_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_last_log(self, count: int) -> list[Log]:
        ...
    def get_left_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_parameter(self, name: str) -> str:
        ...
    def get_parameter_list(self) -> list[tuple[str, int]]:
        ...
    def get_position_pid_gain(self, dev_name: str) -> PIDGain:
        ...
    def get_right_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_robot_info(self) -> RobotInfo:
        """
        get_robot_info()
        
        Retrieves static information about the robot, such as model name, SDK version, and joint configuration.
        
        Returns
        -------
        RobotInfo
            Structured metadata including joint details, device names, and robot model information.
        """
    def get_robot_model(self) -> str:
        ...
    def get_serial_device_list(self) -> list[SerialDevice]:
        ...
    def get_state(self) -> RobotState_A:
        ...
    def get_system_time(self) -> tuple[typing.Any, str]:
        ...
    def get_time_scale(self) -> float:
        ...
    def get_torso_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_wifi_status(self) -> WifiStatus | None:
        ...
    def has_established_time_sync(self) -> bool:
        ...
    def home_offset_reset(self, dev_name: str) -> bool:
        ...
    def import_robot_model(self, name: str, model: str) -> bool:
        ...
    def is_connected(self) -> bool:
        """
        is_connected()
        
        Checks whether the robot is currently connected.
        
        Returns
        -------
        bool
            True if the robot is connected to the robot, False otherwise.
        """
    def is_power_on(self, dev_name: str) -> bool:
        ...
    def is_servo_on(self, dev_name: str) -> bool:
        ...
    def open_serial_stream(self, device_path: str, baudrate: int, bytesize: int = 8, parity: str = 'N', stopbits: int = 1) -> SerialStream:
        ...
    def power_off(self, dev_name: str) -> bool:
        ...
    def power_on(self, dev_name: str) -> bool:
        ...
    def reset_all_parameters(self) -> None:
        ...
    def reset_all_parameters_to_default(self) -> None:
        ...
    def reset_battery_config(self) -> bool:
        ...
    def reset_fault_control_manager(self) -> bool:
        ...
    def reset_network_setting(self) -> bool:
        ...
    def reset_odometry(self, angle: float, position: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> bool:
        ...
    def reset_parameter(self, name: str) -> bool:
        ...
    def reset_parameter_to_default(self, name: str) -> bool:
        ...
    def scan_wifi(self) -> list[WifiNetwork]:
        ...
    def send_command(self, builder: RobotCommandBuilder, priority: int = 1) -> Robot_A_CommandHandler:
        ...
    def servo_off(self, dev_name: str) -> bool:
        ...
    def servo_on(self, dev_name: str) -> bool:
        ...
    def set_battery_config(self, arg0: float, arg1: float, arg2: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]) -> bool:
        ...
    def set_battery_level(self, arg0: float) -> bool:
        ...
    def set_led_color(self, color: Color, duration: float = 1, transition_time: float = 0, blinking: bool = False, blinking_freq: float = 1) -> bool:
        ...
    def set_parameter(self, name: str, value: str, write_db: bool = True) -> bool:
        ...
    def set_position_d_gain(self, dev_name: str, d_gain: int) -> bool:
        ...
    def set_position_i_gain(self, dev_name: str, i_gain: int) -> bool:
        ...
    def set_position_p_gain(self, dev_name: str, p_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, p_gain: int, i_gain: int, d_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, pid_gain: PIDGain) -> bool:
        ...
    def set_preset_position(self, joint_name: str) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any, time_zone: str) -> bool:
        ...
    def set_time_scale(self, time_scale: float) -> float:
        ...
    def set_tool_flange_digital_output(self, name: str, channel: int, duty: bool) -> bool:
        ...
    def set_tool_flange_digital_output_dual(self, name: str, duty_0: bool, duty_1: bool) -> bool:
        ...
    def set_tool_flange_output_voltage(self, arg0: str, arg1: int) -> bool:
        ...
    def start_log_stream(self, cb: typing.Callable[[list[Log]], None], rate: float) -> None:
        ...
    def start_state_update(self, cb: typing.Callable, rate: float) -> None:
        ...
    def start_time_sync(self, period_sec: int) -> bool:
        ...
    def stop_log_stream(self) -> None:
        ...
    def stop_state_update(self) -> None:
        ...
    def stop_time_sync(self) -> bool:
        ...
    def sync_time(self) -> bool:
        ...
    def wait_for_control_ready(self, timeout_ms: int) -> bool:
        ...
class Robot_A_CommandHandler:
    def cancel(self) -> None:
        ...
    def get(self) -> RobotCommandFeedback:
        ...
    def get_status(self) -> bool:
        ...
    def is_done(self) -> bool:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_A_CommandStreamHandler:
    def cancel(self) -> None:
        ...
    def is_done(self) -> bool:
        ...
    def request_feedback(self, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def send_command(self, builder: RobotCommandBuilder, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_A_ControlInput:
    feedback_gain: numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.uint32]]
    feedforward_torque: numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]
    finish: bool
    mode: numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.bool_]]
    target: numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]
    def __init__(self) -> None:
        ...
class Robot_A_ControlState:
    def __init__(self) -> None:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def t(self) -> float:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[24], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Robot_M:
    @staticmethod
    def create(address: str) -> Robot_M:
        ...
    @staticmethod
    def model() -> Model_M:
        ...
    def break_engage(self, dev_name: str) -> bool:
        ...
    def break_release(self, dev_name: str) -> bool:
        ...
    def cancel_control(self) -> bool:
        ...
    def connect(self, max_retries: int = 5, timeout_ms: int = 1000) -> bool:
        """
        connect(max_retries=5, timeout_ms=1000)
        
        Attempts to establish a connection with the robot.
        
        Parameters
        ----------
        max_retries : int, optional
            Maximum number of retries to connect. Default is 5.
        timeout_ms : int, optional
            Timeout in milliseconds for each connection attempt. Default is 1000.
        
        Returns
        -------
        bool
            True if the connection was successful, false otherwise.
        """
    def connect_wifi(self, ssid: str, password: str = '', use_dhcp: bool = True, ip_address: str = '', gateway: str = '', dns: list[str] = []) -> bool:
        ...
    def control(self, control: typing.Callable[[Robot_M_ControlState], Robot_M_ControlInput], port: int = 0, priority: int = 1) -> bool:
        ...
    def create_command_stream(self, priority: int = 1) -> Robot_M_CommandStreamHandler:
        ...
    def disable_control_manager(self) -> bool:
        ...
    def disconnect(self) -> None:
        """
        disconnect()
        
        Disconnects from the robot.
        """
    def disconnect_wifi(self) -> bool:
        ...
    def download_file(self, path: str, file_like: typing.Any) -> bool:
        """
        download_file(path, file_like)
        
        Downloads a file from the robot and writes it into a file-like object.
        
        Parameters
        ----------
        path : str
            Relative path to the file on the robot's file system.
            The base directory is defined by the `RBY1_HOME` environment variable (default: `/root/.rby1`).
        file_like : file-like object
            Any object with a `.write(bytes)` method (e.g., `io.BytesIO`, a real file).
        
        Returns
        -------
        bool
            True if the file was downloaded successfully.
        
        Raises
        ------
        RuntimeError
            If the gRPC call fails (e.g., network issue, file not found, internal error).
        """
    def enable_control_manager(self, unlimited_mode_enabled: bool = False) -> bool:
        ...
    def factory_reset_all_parameters(self) -> None:
        ...
    def factory_reset_parameter(self, name: str) -> bool:
        ...
    def get_control_manager_state(self) -> ControlManagerState:
        ...
    def get_dynamics(self, urdf_model: str = '') -> dynamics.Robot_26:
        ...
    def get_fault_log_list(self) -> list[str]:
        ...
    def get_head_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_last_log(self, count: int) -> list[Log]:
        ...
    def get_left_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_parameter(self, name: str) -> str:
        ...
    def get_parameter_list(self) -> list[tuple[str, int]]:
        ...
    def get_position_pid_gain(self, dev_name: str) -> PIDGain:
        ...
    def get_right_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_robot_info(self) -> RobotInfo:
        """
        get_robot_info()
        
        Retrieves static information about the robot, such as model name, SDK version, and joint configuration.
        
        Returns
        -------
        RobotInfo
            Structured metadata including joint details, device names, and robot model information.
        """
    def get_robot_model(self) -> str:
        ...
    def get_serial_device_list(self) -> list[SerialDevice]:
        ...
    def get_state(self) -> RobotState_M:
        ...
    def get_system_time(self) -> tuple[typing.Any, str]:
        ...
    def get_time_scale(self) -> float:
        ...
    def get_torso_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_wifi_status(self) -> WifiStatus | None:
        ...
    def has_established_time_sync(self) -> bool:
        ...
    def home_offset_reset(self, dev_name: str) -> bool:
        ...
    def import_robot_model(self, name: str, model: str) -> bool:
        ...
    def is_connected(self) -> bool:
        """
        is_connected()
        
        Checks whether the robot is currently connected.
        
        Returns
        -------
        bool
            True if the robot is connected to the robot, False otherwise.
        """
    def is_power_on(self, dev_name: str) -> bool:
        ...
    def is_servo_on(self, dev_name: str) -> bool:
        ...
    def open_serial_stream(self, device_path: str, baudrate: int, bytesize: int = 8, parity: str = 'N', stopbits: int = 1) -> SerialStream:
        ...
    def power_off(self, dev_name: str) -> bool:
        ...
    def power_on(self, dev_name: str) -> bool:
        ...
    def reset_all_parameters(self) -> None:
        ...
    def reset_all_parameters_to_default(self) -> None:
        ...
    def reset_battery_config(self) -> bool:
        ...
    def reset_fault_control_manager(self) -> bool:
        ...
    def reset_network_setting(self) -> bool:
        ...
    def reset_odometry(self, angle: float, position: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> bool:
        ...
    def reset_parameter(self, name: str) -> bool:
        ...
    def reset_parameter_to_default(self, name: str) -> bool:
        ...
    def scan_wifi(self) -> list[WifiNetwork]:
        ...
    def send_command(self, builder: RobotCommandBuilder, priority: int = 1) -> Robot_M_CommandHandler:
        ...
    def servo_off(self, dev_name: str) -> bool:
        ...
    def servo_on(self, dev_name: str) -> bool:
        ...
    def set_battery_config(self, arg0: float, arg1: float, arg2: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]) -> bool:
        ...
    def set_battery_level(self, arg0: float) -> bool:
        ...
    def set_led_color(self, color: Color, duration: float = 1, transition_time: float = 0, blinking: bool = False, blinking_freq: float = 1) -> bool:
        ...
    def set_parameter(self, name: str, value: str, write_db: bool = True) -> bool:
        ...
    def set_position_d_gain(self, dev_name: str, d_gain: int) -> bool:
        ...
    def set_position_i_gain(self, dev_name: str, i_gain: int) -> bool:
        ...
    def set_position_p_gain(self, dev_name: str, p_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, p_gain: int, i_gain: int, d_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, pid_gain: PIDGain) -> bool:
        ...
    def set_preset_position(self, joint_name: str) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any, time_zone: str) -> bool:
        ...
    def set_time_scale(self, time_scale: float) -> float:
        ...
    def set_tool_flange_digital_output(self, name: str, channel: int, duty: bool) -> bool:
        ...
    def set_tool_flange_digital_output_dual(self, name: str, duty_0: bool, duty_1: bool) -> bool:
        ...
    def set_tool_flange_output_voltage(self, arg0: str, arg1: int) -> bool:
        ...
    def start_log_stream(self, cb: typing.Callable[[list[Log]], None], rate: float) -> None:
        ...
    def start_state_update(self, cb: typing.Callable, rate: float) -> None:
        ...
    def start_time_sync(self, period_sec: int) -> bool:
        ...
    def stop_log_stream(self) -> None:
        ...
    def stop_state_update(self) -> None:
        ...
    def stop_time_sync(self) -> bool:
        ...
    def sync_time(self) -> bool:
        ...
    def wait_for_control_ready(self, timeout_ms: int) -> bool:
        ...
class Robot_M_CommandHandler:
    def cancel(self) -> None:
        ...
    def get(self) -> RobotCommandFeedback:
        ...
    def get_status(self) -> bool:
        ...
    def is_done(self) -> bool:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_M_CommandStreamHandler:
    def cancel(self) -> None:
        ...
    def is_done(self) -> bool:
        ...
    def request_feedback(self, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def send_command(self, builder: RobotCommandBuilder, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_M_ControlInput:
    feedback_gain: numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.uint32]]
    feedforward_torque: numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]
    finish: bool
    mode: numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.bool_]]
    target: numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]
    def __init__(self) -> None:
        ...
class Robot_M_ControlState:
    def __init__(self) -> None:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def t(self) -> float:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[26], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Robot_T5:
    @staticmethod
    def create(address: str) -> Robot_T5:
        ...
    @staticmethod
    def model() -> Model_T5:
        ...
    def break_engage(self, dev_name: str) -> bool:
        ...
    def break_release(self, dev_name: str) -> bool:
        ...
    def cancel_control(self) -> bool:
        ...
    def connect(self, max_retries: int = 5, timeout_ms: int = 1000) -> bool:
        """
        connect(max_retries=5, timeout_ms=1000)
        
        Attempts to establish a connection with the robot.
        
        Parameters
        ----------
        max_retries : int, optional
            Maximum number of retries to connect. Default is 5.
        timeout_ms : int, optional
            Timeout in milliseconds for each connection attempt. Default is 1000.
        
        Returns
        -------
        bool
            True if the connection was successful, false otherwise.
        """
    def connect_wifi(self, ssid: str, password: str = '', use_dhcp: bool = True, ip_address: str = '', gateway: str = '', dns: list[str] = []) -> bool:
        ...
    def control(self, control: typing.Callable[[Robot_T5_ControlState], Robot_T5_ControlInput], port: int = 0, priority: int = 1) -> bool:
        ...
    def create_command_stream(self, priority: int = 1) -> Robot_T5_CommandStreamHandler:
        ...
    def disable_control_manager(self) -> bool:
        ...
    def disconnect(self) -> None:
        """
        disconnect()
        
        Disconnects from the robot.
        """
    def disconnect_wifi(self) -> bool:
        ...
    def download_file(self, path: str, file_like: typing.Any) -> bool:
        """
        download_file(path, file_like)
        
        Downloads a file from the robot and writes it into a file-like object.
        
        Parameters
        ----------
        path : str
            Relative path to the file on the robot's file system.
            The base directory is defined by the `RBY1_HOME` environment variable (default: `/root/.rby1`).
        file_like : file-like object
            Any object with a `.write(bytes)` method (e.g., `io.BytesIO`, a real file).
        
        Returns
        -------
        bool
            True if the file was downloaded successfully.
        
        Raises
        ------
        RuntimeError
            If the gRPC call fails (e.g., network issue, file not found, internal error).
        """
    def enable_control_manager(self, unlimited_mode_enabled: bool = False) -> bool:
        ...
    def factory_reset_all_parameters(self) -> None:
        ...
    def factory_reset_parameter(self, name: str) -> bool:
        ...
    def get_control_manager_state(self) -> ControlManagerState:
        ...
    def get_dynamics(self, urdf_model: str = '') -> dynamics.Robot_23:
        ...
    def get_fault_log_list(self) -> list[str]:
        ...
    def get_head_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_last_log(self, count: int) -> list[Log]:
        ...
    def get_left_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_parameter(self, name: str) -> str:
        ...
    def get_parameter_list(self) -> list[tuple[str, int]]:
        ...
    def get_position_pid_gain(self, dev_name: str) -> PIDGain:
        ...
    def get_right_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_robot_info(self) -> RobotInfo:
        """
        get_robot_info()
        
        Retrieves static information about the robot, such as model name, SDK version, and joint configuration.
        
        Returns
        -------
        RobotInfo
            Structured metadata including joint details, device names, and robot model information.
        """
    def get_robot_model(self) -> str:
        ...
    def get_serial_device_list(self) -> list[SerialDevice]:
        ...
    def get_state(self) -> RobotState_T5:
        ...
    def get_system_time(self) -> tuple[typing.Any, str]:
        ...
    def get_time_scale(self) -> float:
        ...
    def get_torso_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_wifi_status(self) -> WifiStatus | None:
        ...
    def has_established_time_sync(self) -> bool:
        ...
    def home_offset_reset(self, dev_name: str) -> bool:
        ...
    def import_robot_model(self, name: str, model: str) -> bool:
        ...
    def is_connected(self) -> bool:
        """
        is_connected()
        
        Checks whether the robot is currently connected.
        
        Returns
        -------
        bool
            True if the robot is connected to the robot, False otherwise.
        """
    def is_power_on(self, dev_name: str) -> bool:
        ...
    def is_servo_on(self, dev_name: str) -> bool:
        ...
    def open_serial_stream(self, device_path: str, baudrate: int, bytesize: int = 8, parity: str = 'N', stopbits: int = 1) -> SerialStream:
        ...
    def power_off(self, dev_name: str) -> bool:
        ...
    def power_on(self, dev_name: str) -> bool:
        ...
    def reset_all_parameters(self) -> None:
        ...
    def reset_all_parameters_to_default(self) -> None:
        ...
    def reset_battery_config(self) -> bool:
        ...
    def reset_fault_control_manager(self) -> bool:
        ...
    def reset_network_setting(self) -> bool:
        ...
    def reset_odometry(self, angle: float, position: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> bool:
        ...
    def reset_parameter(self, name: str) -> bool:
        ...
    def reset_parameter_to_default(self, name: str) -> bool:
        ...
    def scan_wifi(self) -> list[WifiNetwork]:
        ...
    def send_command(self, builder: RobotCommandBuilder, priority: int = 1) -> Robot_T5_CommandHandler:
        ...
    def servo_off(self, dev_name: str) -> bool:
        ...
    def servo_on(self, dev_name: str) -> bool:
        ...
    def set_battery_config(self, arg0: float, arg1: float, arg2: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]) -> bool:
        ...
    def set_battery_level(self, arg0: float) -> bool:
        ...
    def set_led_color(self, color: Color, duration: float = 1, transition_time: float = 0, blinking: bool = False, blinking_freq: float = 1) -> bool:
        ...
    def set_parameter(self, name: str, value: str, write_db: bool = True) -> bool:
        ...
    def set_position_d_gain(self, dev_name: str, d_gain: int) -> bool:
        ...
    def set_position_i_gain(self, dev_name: str, i_gain: int) -> bool:
        ...
    def set_position_p_gain(self, dev_name: str, p_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, p_gain: int, i_gain: int, d_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, pid_gain: PIDGain) -> bool:
        ...
    def set_preset_position(self, joint_name: str) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any, time_zone: str) -> bool:
        ...
    def set_time_scale(self, time_scale: float) -> float:
        ...
    def set_tool_flange_digital_output(self, name: str, channel: int, duty: bool) -> bool:
        ...
    def set_tool_flange_digital_output_dual(self, name: str, duty_0: bool, duty_1: bool) -> bool:
        ...
    def set_tool_flange_output_voltage(self, arg0: str, arg1: int) -> bool:
        ...
    def start_log_stream(self, cb: typing.Callable[[list[Log]], None], rate: float) -> None:
        ...
    def start_state_update(self, cb: typing.Callable, rate: float) -> None:
        ...
    def start_time_sync(self, period_sec: int) -> bool:
        ...
    def stop_log_stream(self) -> None:
        ...
    def stop_state_update(self) -> None:
        ...
    def stop_time_sync(self) -> bool:
        ...
    def sync_time(self) -> bool:
        ...
    def wait_for_control_ready(self, timeout_ms: int) -> bool:
        ...
class Robot_T5_CommandHandler:
    def cancel(self) -> None:
        ...
    def get(self) -> RobotCommandFeedback:
        ...
    def get_status(self) -> bool:
        ...
    def is_done(self) -> bool:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_T5_CommandStreamHandler:
    def cancel(self) -> None:
        ...
    def is_done(self) -> bool:
        ...
    def request_feedback(self, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def send_command(self, builder: RobotCommandBuilder, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_T5_ControlInput:
    feedback_gain: numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.uint32]]
    feedforward_torque: numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]
    finish: bool
    mode: numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.bool_]]
    target: numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]
    def __init__(self) -> None:
        ...
class Robot_T5_ControlState:
    def __init__(self) -> None:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def t(self) -> float:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[23], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class Robot_UB:
    @staticmethod
    def create(address: str) -> Robot_UB:
        ...
    @staticmethod
    def model() -> Model_UB:
        ...
    def break_engage(self, dev_name: str) -> bool:
        ...
    def break_release(self, dev_name: str) -> bool:
        ...
    def cancel_control(self) -> bool:
        ...
    def connect(self, max_retries: int = 5, timeout_ms: int = 1000) -> bool:
        """
        connect(max_retries=5, timeout_ms=1000)
        
        Attempts to establish a connection with the robot.
        
        Parameters
        ----------
        max_retries : int, optional
            Maximum number of retries to connect. Default is 5.
        timeout_ms : int, optional
            Timeout in milliseconds for each connection attempt. Default is 1000.
        
        Returns
        -------
        bool
            True if the connection was successful, false otherwise.
        """
    def connect_wifi(self, ssid: str, password: str = '', use_dhcp: bool = True, ip_address: str = '', gateway: str = '', dns: list[str] = []) -> bool:
        ...
    def control(self, control: typing.Callable[[Robot_UB_ControlState], Robot_UB_ControlInput], port: int = 0, priority: int = 1) -> bool:
        ...
    def create_command_stream(self, priority: int = 1) -> Robot_UB_CommandStreamHandler:
        ...
    def disable_control_manager(self) -> bool:
        ...
    def disconnect(self) -> None:
        """
        disconnect()
        
        Disconnects from the robot.
        """
    def disconnect_wifi(self) -> bool:
        ...
    def download_file(self, path: str, file_like: typing.Any) -> bool:
        """
        download_file(path, file_like)
        
        Downloads a file from the robot and writes it into a file-like object.
        
        Parameters
        ----------
        path : str
            Relative path to the file on the robot's file system.
            The base directory is defined by the `RBY1_HOME` environment variable (default: `/root/.rby1`).
        file_like : file-like object
            Any object with a `.write(bytes)` method (e.g., `io.BytesIO`, a real file).
        
        Returns
        -------
        bool
            True if the file was downloaded successfully.
        
        Raises
        ------
        RuntimeError
            If the gRPC call fails (e.g., network issue, file not found, internal error).
        """
    def enable_control_manager(self, unlimited_mode_enabled: bool = False) -> bool:
        ...
    def factory_reset_all_parameters(self) -> None:
        ...
    def factory_reset_parameter(self, name: str) -> bool:
        ...
    def get_control_manager_state(self) -> ControlManagerState:
        ...
    def get_dynamics(self, urdf_model: str = '') -> dynamics.Robot_18:
        ...
    def get_fault_log_list(self) -> list[str]:
        ...
    def get_head_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_last_log(self, count: int) -> list[Log]:
        ...
    def get_left_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_parameter(self, name: str) -> str:
        ...
    def get_parameter_list(self) -> list[tuple[str, int]]:
        ...
    def get_position_pid_gain(self, dev_name: str) -> PIDGain:
        ...
    def get_right_arm_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_robot_info(self) -> RobotInfo:
        """
        get_robot_info()
        
        Retrieves static information about the robot, such as model name, SDK version, and joint configuration.
        
        Returns
        -------
        RobotInfo
            Structured metadata including joint details, device names, and robot model information.
        """
    def get_robot_model(self) -> str:
        ...
    def get_serial_device_list(self) -> list[SerialDevice]:
        ...
    def get_state(self) -> RobotState_UB:
        ...
    def get_system_time(self) -> tuple[typing.Any, str]:
        ...
    def get_time_scale(self) -> float:
        ...
    def get_torso_position_pid_gains(self) -> list[PIDGain]:
        ...
    def get_wifi_status(self) -> WifiStatus | None:
        ...
    def has_established_time_sync(self) -> bool:
        ...
    def home_offset_reset(self, dev_name: str) -> bool:
        ...
    def import_robot_model(self, name: str, model: str) -> bool:
        ...
    def is_connected(self) -> bool:
        """
        is_connected()
        
        Checks whether the robot is currently connected.
        
        Returns
        -------
        bool
            True if the robot is connected to the robot, False otherwise.
        """
    def is_power_on(self, dev_name: str) -> bool:
        ...
    def is_servo_on(self, dev_name: str) -> bool:
        ...
    def open_serial_stream(self, device_path: str, baudrate: int, bytesize: int = 8, parity: str = 'N', stopbits: int = 1) -> SerialStream:
        ...
    def power_off(self, dev_name: str) -> bool:
        ...
    def power_on(self, dev_name: str) -> bool:
        ...
    def reset_all_parameters(self) -> None:
        ...
    def reset_all_parameters_to_default(self) -> None:
        ...
    def reset_battery_config(self) -> bool:
        ...
    def reset_fault_control_manager(self) -> bool:
        ...
    def reset_network_setting(self) -> bool:
        ...
    def reset_odometry(self, angle: float, position: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> bool:
        ...
    def reset_parameter(self, name: str) -> bool:
        ...
    def reset_parameter_to_default(self, name: str) -> bool:
        ...
    def scan_wifi(self) -> list[WifiNetwork]:
        ...
    def send_command(self, builder: RobotCommandBuilder, priority: int = 1) -> Robot_UB_CommandHandler:
        ...
    def servo_off(self, dev_name: str) -> bool:
        ...
    def servo_on(self, dev_name: str) -> bool:
        ...
    def set_battery_config(self, arg0: float, arg1: float, arg2: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]) -> bool:
        ...
    def set_battery_level(self, arg0: float) -> bool:
        ...
    def set_led_color(self, color: Color, duration: float = 1, transition_time: float = 0, blinking: bool = False, blinking_freq: float = 1) -> bool:
        ...
    def set_parameter(self, name: str, value: str, write_db: bool = True) -> bool:
        ...
    def set_position_d_gain(self, dev_name: str, d_gain: int) -> bool:
        ...
    def set_position_i_gain(self, dev_name: str, i_gain: int) -> bool:
        ...
    def set_position_p_gain(self, dev_name: str, p_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, p_gain: int, i_gain: int, d_gain: int) -> bool:
        ...
    @typing.overload
    def set_position_pid_gain(self, dev_name: str, pid_gain: PIDGain) -> bool:
        ...
    def set_preset_position(self, joint_name: str) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any) -> bool:
        ...
    @typing.overload
    def set_system_time(self, datetime: typing.Any, time_zone: str) -> bool:
        ...
    def set_time_scale(self, time_scale: float) -> float:
        ...
    def set_tool_flange_digital_output(self, name: str, channel: int, duty: bool) -> bool:
        ...
    def set_tool_flange_digital_output_dual(self, name: str, duty_0: bool, duty_1: bool) -> bool:
        ...
    def set_tool_flange_output_voltage(self, arg0: str, arg1: int) -> bool:
        ...
    def start_log_stream(self, cb: typing.Callable[[list[Log]], None], rate: float) -> None:
        ...
    def start_state_update(self, cb: typing.Callable, rate: float) -> None:
        ...
    def start_time_sync(self, period_sec: int) -> bool:
        ...
    def stop_log_stream(self) -> None:
        ...
    def stop_state_update(self) -> None:
        ...
    def stop_time_sync(self) -> bool:
        ...
    def sync_time(self) -> bool:
        ...
    def wait_for_control_ready(self, timeout_ms: int) -> bool:
        ...
class Robot_UB_CommandHandler:
    def cancel(self) -> None:
        ...
    def get(self) -> RobotCommandFeedback:
        ...
    def get_status(self) -> bool:
        ...
    def is_done(self) -> bool:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_UB_CommandStreamHandler:
    def cancel(self) -> None:
        ...
    def is_done(self) -> bool:
        ...
    def request_feedback(self, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def send_command(self, builder: RobotCommandBuilder, timeout_ms: int = 1000) -> RobotCommandFeedback:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
class Robot_UB_ControlInput:
    feedback_gain: numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.uint32]]
    feedforward_torque: numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]
    finish: bool
    mode: numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.bool_]]
    target: numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]
    def __init__(self) -> None:
        ...
class Robot_UB_ControlState:
    def __init__(self) -> None:
        ...
    @property
    def current(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def is_ready(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.bool_]]:
        ...
    @property
    def position(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def t(self) -> float:
        ...
    @property
    def torque(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[tuple[typing.Literal[18], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
class SE2VelocityCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_acceleration_limit(self, linear: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], angular: float) -> SE2VelocityCommandBuilder:
        ...
    def set_command_header(self, command_header_builder: CommandHeaderBuilder) -> SE2VelocityCommandBuilder:
        ...
    def set_minimum_time(self, minimum_time: float) -> SE2VelocityCommandBuilder:
        ...
    def set_velocity(self, linear: numpy.ndarray[tuple[typing.Literal[2], typing.Literal[1]], numpy.dtype[numpy.float64]], angular: float) -> SE2VelocityCommandBuilder:
        ...
class SE2VelocityCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
class SerialDevice:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def description(self) -> str:
        ...
    @property
    def path(self) -> str:
        ...
class SerialStream:
    def connect(self, verbose: bool) -> bool:
        ...
    def disconnect(self) -> None:
        ...
    def is_cancelled(self) -> bool:
        ...
    def is_done(self) -> bool:
        ...
    def is_opened(self) -> bool:
        ...
    def set_read_callback(self, arg0: typing.Callable[[bytes], None]) -> None:
        ...
    def wait(self) -> None:
        ...
    def wait_for(self, timeout_ms: int) -> bool:
        ...
    @typing.overload
    def write(self, data: str) -> bool:
        ...
    @typing.overload
    def write(self, data: str) -> bool:
        ...
    @typing.overload
    def write(self, data: str, n: int) -> bool:
        ...
    def write_byte(self, ch: str) -> bool:
        ...
class StopCommandBuilder:
    def __init__(self) -> None:
        ...
    def set_command_header(self, stop_command_builder: CommandHeaderBuilder) -> StopCommandBuilder:
        ...
class StopCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
class SystemStat:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def cpu_usage(self) -> float:
        ...
    @property
    def memory_usage(self) -> float:
        ...
    @property
    def program_uptime(self) -> float:
        ...
    @property
    def uptime(self) -> float:
        ...
class ToolFlangeState:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def acceleration(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def digital_input_A(self) -> bool:
        ...
    @property
    def digital_input_B(self) -> bool:
        ...
    @property
    def digital_output_A(self) -> bool:
        ...
    @property
    def digital_output_B(self) -> bool:
        ...
    @property
    def gyro(self) -> numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]:
        ...
    @property
    def output_voltage(self) -> int:
        ...
    @property
    def switch_A(self) -> bool:
        ...
    @property
    def time_since_last_update(self) -> datetime.timedelta:
        ...
class TorsoCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointPositionCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GravityCompensationCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: OptimalControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianImpedanceControlCommandBuilder) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointGroupPositionCommandBuilder) -> None:
        ...
    @typing.overload
    def set_command(self, joint_position_command_builder: JointPositionCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, gravity_compensation_command_builder: GravityCompensationCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_command_builder: CartesianCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, impedance_control_command_builder: ImpedanceControlCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, optimal_control_command_builder: OptimalControlCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, joint_impedance_control_command_builder: JointImpedanceControlCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, cartesian_impedance_control_command_builder: CartesianImpedanceControlCommandBuilder) -> TorsoCommandBuilder:
        ...
    @typing.overload
    def set_command(self, joint_group_position_command_builder: JointGroupPositionCommandBuilder) -> TorsoCommandBuilder:
        ...
class TorsoCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def cartesian_command(self) -> CartesianCommandFeedback:
        ...
    @property
    def cartesian_impedance_control_command(self) -> CartesianImpedanceControlCommandFeedback:
        ...
    @property
    def gravity_compensation_command(self) -> GravityCompensationCommandFeedback:
        ...
    @property
    def impedance_control_command(self) -> ImpedanceControlCommandFeedback:
        ...
    @property
    def joint_group_position_command(self) -> JointGroupPositionCommandFeedback:
        ...
    @property
    def joint_impedance_control_command(self) -> JointImpedanceControlCommandFeedback:
        ...
    @property
    def joint_position_command(self) -> JointPositionCommandFeedback:
        ...
    @property
    def optimal_control_command(self) -> OptimalControlCommandFeedback:
        ...
class WholeBodyCommandBuilder:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: StopCommandBuilder) -> None:
        ...
    def set_command(self, stop_command_builder: StopCommandBuilder) -> WholeBodyCommandBuilder:
        ...
class WholeBodyCommandFeedback(CommandFeedback):
    def __init__(self) -> None:
        ...
    @property
    def stop_command(self) -> StopCommandFeedback:
        ...
class WifiNetwork:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def secured(self) -> bool:
        ...
    @property
    def signal_strength(self) -> int:
        ...
    @property
    def ssid(self) -> str:
        ...
class WifiStatus:
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def connected(self) -> bool:
        ...
    @property
    def dns(self) -> list[str]:
        ...
    @property
    def gateway(self) -> str:
        ...
    @property
    def ip_address(self) -> str:
        ...
    @property
    def ssid(self) -> str:
        ...
def _create_robot(address: str, model: typing.Any = 'a') -> typing.Any:
    """
    Creates a robot based on the provided model and address.
    """
def create_robot_a(address: str) -> Robot_A:
    ...
def create_robot_m(address: str) -> Robot_M:
    ...
def create_robot_t5(address: str) -> Robot_T5:
    ...
def create_robot_ub(address: str) -> Robot_UB:
    ...
__version__: str = '0.8.2'
