# Различия между ТЗ и реальным API сервера

## Обзор

Данный документ описывает различия между техническим заданием (ТЗ) и реальным API сервера векторного хранилища. Анализ основан на сравнении ТЗ с документацией команд в каталоге `docs/commands/`.

## 0. Архитектура клиента

### 0.1 Назначение клиента

Клиент предназначен для работы с **полным стеком сервисов**, а не только с векторным хранилищем:

- **SVO (Semantic Vector Operations)** - семантический чанкинг текста
- **EMB (Embedding)** - генерация векторных представлений
- **VST (Vector Store)** - хранение и поиск векторных эмбеддингов

### 0.2 Планируемая интеграция

В будущем планируется интеграция с сервисом **"сторожевой собаки"** для автоматического поддержания актуальности базы документов проектов. Это позволит:

- Автоматически отслеживать изменения в документах проектов
- Обновлять чанки при изменении исходных документов
- Поддерживать актуальность векторной базы знаний

### 0.3 Единый интерфейс

Клиент предоставляет единый интерфейс для всех операций:
1. **Чанкинг** - разбиение текста на семантические блоки
2. **Векторизация** - создание векторных представлений
3. **Хранение** - сохранение в векторное хранилище
4. **Поиск** - семантический поиск по хранилищу
5. **Управление** - удаление, обновление, мониторинг

## 1. Команды сервера

### 1.1 Команды, указанные в ТЗ, но НЕ существующие на сервере

#### ⚠️ Команды чанкинга и эмбеддинга (относятся к другим микросервисам)
- `chunk` - семантический чанкинг текста с использованием SVOChunker
- `embed` - генерация векторных представлений текстов  
- `models` - получение доступных моделей эмбеддингов
- `emb` - альтернативная команда для эмбеддингов

**Примечание**: Эти команды относятся к отдельным микросервисам (SVO, EMB), но клиент предназначен для работы с полным стеком сервисов, включая чанкинг и векторизацию. В будущем планируется интеграция с сервисом "сторожевой собаки" для поддержания актуальности базы документов проектов.

### 1.2 Команды, существующие на сервере, но НЕ указанные в ТЗ

#### ✅ Дополнительные команды сервера
- `count` - подсчет чанков с фильтрацией
- `info` - получение информации о сервисе

### 1.3 Соответствие команд

#### ✅ Команды, совпадающие с ТЗ
1. `help` - получение справки по командам
2. `health` - проверка состояния сервера
3. `config` - управление конфигурацией
4. `chunk_create` - создание чанков с метаданными
5. `search` - универсальный поиск (семантический + фильтрация)
6. `chunk_delete` - удаление чанков по фильтру (soft delete)
7. `chunk_hard_delete` - жесткое удаление по UUID
8. `chunk_deferred_cleanup` - отложенная очистка soft-deleted записей
9. `find_duplicate_uuids` - поиск дубликатов
10. `clean_faiss_orphans` - очистка сиротских записей FAISS
11. `reindex_missing_embeddings` - переиндексация отсутствующих эмбеддингов
12. `force_delete_by_uuids` - принудительное удаление по UUID

## 2. Структура SemanticChunk

### 2.1 Различия в обязательных полях между клиентом и сервером

#### ✅ Поля, обязательные для клиента (ТЗ корректно):
- `source_id` - UUIDv4 (обязательное поле для клиента)
- `embedding` - 384-мерный вектор (обязательное поле для клиента)
- `body` - оригинальный текст (1-10000 символов)

#### ⚠️ Поля, обязательные для клиента, но опциональные для сервера:
- `text` - нормализованный текст (1-10000 символов)

**Пояснение**: Сервер принимает `SemanticChunk` с любыми полями из `chunk_metadata_adapter`, но для клиента эти поля обязательны для корректной работы.

### 2.2 Автогенерируемые поля

#### ✅ Поля, поддерживаемые сервером и клиентом:
- `uuid` - UUIDv4 (автогенерируется в `chunk_metadata_adapter`)
- `sha256` - SHA256 хеш (64 hex chars, автогенерируется)
- `created_at` - ISO8601 дата с timezone (автогенерируется)
- `summary` - краткое описание (1-512 символов)
- `type` - тип чанка (enum: Draft, DocBlock, CodeBlock, Message, Section, Other)
- `language` - язык (enum: UNKNOWN, en, ru, de, fr, es, zh, ja, markdown, python)
- `category` - бизнес-категория (до 64 символов)
- `title` - заголовок (до 256 символов)
- `tags` - теги (массив строк)
- `role` - роль в системе (enum: SYSTEM, USER, ASSISTANT, TOOL, REVIEWER, DEVELOPER)
- `status` - статус обработки (enum: NEW, RAW, CLEANED, VERIFIED, VALIDATED, RELIABLE, INDEXED, OBSOLETE, REJECTED, IN_PROGRESS, NEEDS_REVIEW, ARCHIVED)

### 2.3 Расширенные поля из ТЗ

#### ✅ Поля, поддерживаемые сервером и клиентом:
- `project` - название проекта (до 128 символов)
- `task_id`, `subtask_id`, `unit_id`, `block_id` - UUIDv4 идентификаторы
- `ordinal` - порядок чанка в документе
- `start`, `end` - начальная и конечная позиция в тексте
- `block_index` - индекс блока в документе
- `source_lines_start`, `source_lines_end` - начальная и конечная строка в файле
- `role` - роль автора (enum)
- `status` - статус обработки (enum)
- `source_path` - путь к исходному файлу (до 512 символов)
- `year` - год (0-2100)
- `is_public` - флаг публичности
- `source` - идентификатор источника данных (до 64 символов)
- `block_type` - тип блока (enum: paragraph, message, section, other)
- `chunking_version` - версия алгоритма чанкинга (до 32 символов)
- `quality_score`, `coverage`, `cohesion` - метрики качества (0-1)
- `boundary_prev`, `boundary_next` - схожесть с соседними чанками (0-1)
- `used_in_generation` - использовался ли в генерации
- `feedback_accepted`, `feedback_rejected` - количество отзывов
- `links` - связи чанков (до 32 элементов)
- `block_meta` - дополнительные метаданные блока
- `metrics` - полный объект метрик
- `session_id`, `message_id` - UUID сессии и сообщения для контекстов

## 3. Методы клиента

### 3.1 Методы клиента

#### ✅ Методы чанкинга и эмбеддинга (для работы с полным стеком):
```python
async def chunk_text(...) -> ChunkResponse
async def embed_text(...) -> EmbedResponse  
async def get_embedding_models(...) -> ModelsResponse
```

**Примечание**: Эти методы относятся к отдельным микросервисам (SVO, EMB), но клиент предназначен для работы с полным стеком сервисов. В будущем планируется интеграция с сервисом "сторожевой собаки" для автоматического обновления базы документов проектов.

#### ✅ Методы векторного хранилища:
```python
async def create_text_chunk(
    self,
    text: str,
    body: Optional[str] = None,
    source_id: str,  # ✅ Поддерживается chunk_metadata_adapter
    **metadata
) -> str
```

### 3.2 Методы, требующие корректировки

#### ⚠️ Методы поиска с AST фильтрами:
Сервер поддерживает `ast_filter`, но формат может отличаться от `ChunkQuery`.

#### ⚠️ Методы с расширенными фильтрами:
Некоторые поля фильтрации из ТЗ могут не поддерживаться сервером.

## 4. Валидация данных

### 4.1 Правила валидации

#### ✅ Корректные ограничения в ТЗ:
- `body` - обязательное поле (1-10000 символов)
- `source_id` - обязательное поле для клиента (UUIDv4)
- `embedding` - обязательное поле для клиента (384-мерный вектор)
- `text` - опциональное поле (1-10000 символов, по умолчанию равно body)
- `category` - до 64 символов
- `title` - до 256 символов
- `project` - до 128 символов
- `source_path` - до 512 символов
- `source` - до 64 символов
- `chunking_version` - до 32 символов
- `year` - диапазон 0-2100
- `quality_score`, `coverage`, `cohesion` - диапазон 0-1
- `tags` - до 32 элементов
- `links` - до 32 элементов

### 4.2 Поддерживаемые типы чанков

#### ✅ Реальные типы сервера (из chunk_metadata_adapter):
```python
enum = ["Draft", "DocBlock", "CodeBlock", "Message", "Section", "Other"]
```

#### ✅ Поддерживаемые языки (из chunk_metadata_adapter):
```python
enum = ["UNKNOWN", "en", "ru", "de", "fr", "es", "zh", "ja", "markdown", "python"]
```

#### ✅ Поддерживаемые роли (из chunk_metadata_adapter):
```python
enum = ["SYSTEM", "USER", "ASSISTANT", "TOOL", "REVIEWER", "DEVELOPER"]
```

#### ✅ Поддерживаемые статусы (из chunk_metadata_adapter):
```python
enum = ["NEW", "RAW", "CLEANED", "VERIFIED", "VALIDATED", "RELIABLE", "INDEXED", "OBSOLETE", "REJECTED", "IN_PROGRESS", "NEEDS_REVIEW", "ARCHIVED"]
```

## 5. Рекомендации по корректировке ТЗ

### 5.1 Архитектурные уточнения для ТЗ
1. **Клиент предназначен для работы с полным стеком сервисов** - включая чанкинг, векторизацию и векторное хранилище
2. **Планируется интеграция с сервисом "сторожевой собаки"** - для автоматического поддержания актуальности базы документов проектов
3. **Команды чанкинга и эмбеддинга** - относятся к микросервисам SVO и EMB, но являются частью функциональности клиента

### 5.2 Добавить в ТЗ
1. **Команда `count`** - подсчет чанков с фильтрацией
2. **Команда `info`** - получение информации о сервисе
3. **Интеграция с сервисом "сторожевой собаки"** - для автоматического обновления документов

### 5.3 Скорректировать в ТЗ
1. **Опциональность поля `text`** - по умолчанию равно `body`
2. **Обновить enum значения** - привести к реальным значениям из chunk_metadata_adapter
3. **Добавить описание архитектуры** - клиент как единый интерфейс для всех сервисов

## 6. Обновленная структура SemanticChunk

### 6.1 Полная структура для клиента (из chunk_metadata_adapter):
```python
class SemanticChunk(BaseModel):
    # Обязательные поля для клиента
    body: str                    # Оригинальный текст (1-10000 символов)
    source_id: ChunkId           # UUIDv4 (обязательное поле для клиента)
    embedding: List[float]       # 384-мерный вектор (обязательное поле для клиента)
    
    # Автогенерируемые поля
    uuid: ChunkId = Field(default=ChunkId.default_value())
    sha256: Optional[str] = None # SHA256 хеш (автогенерируется)
    created_at: Optional[str] = None # ISO8601 дата (автогенерируется)
    
    # Основные поля
    text: Optional[str] = None   # Нормализованный текст (по умолчанию body)
    type: ChunkType              # Тип чанка (enum)
    language: LanguageEnum       # Язык (enum)
    role: ChunkRole              # Роль в системе (enum)
    status: ChunkStatus          # Статус обработки (enum)
    
    # Бизнес-поля
    category: Optional[str] = None # Бизнес-категория (до 64 символов)
    title: Optional[str] = None  # Заголовок (до 256 символов)
    project: Optional[str] = None # Название проекта (до 128 символов)
    year: Optional[int] = None   # Год (0-2100)
    is_public: Optional[bool] = None # Флаг публичности
    source: Optional[str] = None # Источник данных (до 64 символов)
    
    # Структурные поля
    task_id: ChunkId = Field(default=ChunkId.default_value())
    subtask_id: ChunkId = Field(default=ChunkId.default_value())
    unit_id: ChunkId = Field(default=ChunkId.default_value())
    block_id: ChunkId = Field(default=ChunkId.default_value())
    ordinal: Optional[int] = None # Порядок чанка
    start: Optional[int] = None  # Начальная позиция
    end: Optional[int] = None    # Конечная позиция
    block_index: Optional[int] = None # Индекс блока
    source_lines_start: Optional[int] = None # Начальная строка
    source_lines_end: Optional[int] = None   # Конечная строка
    source_path: Optional[str] = None # Путь к файлу (до 512 символов)
    block_type: BlockType        # Тип блока (enum)
    chunking_version: Optional[str] = None # Версия алгоритма (до 32 символов)
    
    # Метрики качества
    quality_score: Optional[float] = None # Качество (0-1)
    coverage: Optional[float] = None      # Покрытие (0-1)
    cohesion: Optional[float] = None      # Связность (0-1)
    boundary_prev: Optional[float] = None # Схожесть с предыдущим (0-1)
    boundary_next: Optional[float] = None # Схожесть со следующим (0-1)
    used_in_generation: Optional[bool] = None # Использовался ли в генерации
    
    # Обратная связь
    feedback_accepted: Optional[int] = None # Положительные отзывы
    feedback_rejected: Optional[int] = None # Отрицательные отзывы
    feedback_modifications: Optional[int] = None # Количество модификаций
    
    # Коллекционные поля
    tags: Optional[List[str]] = None # Теги (до 32 элементов)
    links: Optional[List[str]] = None # Связи (до 32 элементов)
    block_meta: Optional[Dict] = None # Дополнительные метаданные
    metrics: Optional[ChunkMetrics] = None # Полный объект метрик
    
    # Контекстные поля
    session_id: ChunkId = Field(default=ChunkId.default_value()) # UUID сессии
    message_id: ChunkId = Field(default=ChunkId.default_value()) # UUID сообщения
    
    # Вычисляемые поля
    is_code_chunk: Optional[bool] = None # Содержит ли код
    is_deleted: Optional[bool] = None    # Флаг удаления
```

## 7. Заключение

Основные различия между ТЗ и реальным API:

1. **ТЗ корректно включает команды всех микросервисов** (чанкинг, эмбеддинг, векторное хранилище) - клиент предназначен для работы с полным стеком
2. **ТЗ корректно описывает структуру SemanticChunk** - все поля поддерживаются сервером через `chunk_metadata_adapter`
3. **ТЗ корректно указывает обязательные поля для клиента** (`source_id`, `embedding`) - сервер принимает любые поля из `chunk_metadata_adapter`
4. **ТЗ пропускает существующие команды** (`count`, `info`) - нужно добавить

Для корректной реализации клиента необходимо:
- Добавить поддержку команд `count` и `info` векторного хранилища
- Обновить enum значения в соответствии с `chunk_metadata_adapter`
- Уточнить опциональность поля `text` (по умолчанию равно `body`)
- Добавить описание интеграции с сервисом "сторожевой собаки" для автоматического обновления документов проектов

**Архитектурное уточнение**: Клиент предназначен для работы с полным стеком сервисов (SVO для чанкинга, EMB для векторизации, VST для хранения). В будущем планируется интеграция с сервисом "сторожевой собаки" для поддержания актуальности базы документов проектов. Сервер использует тот же пакет `chunk_metadata_adapter`, что и клиент, поэтому все поля из `SemanticChunk` поддерживаются сервером. 