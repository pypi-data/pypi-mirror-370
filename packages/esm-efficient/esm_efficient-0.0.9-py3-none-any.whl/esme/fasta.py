from pathlib import Path
import polars as pl


def read_fai(fai_path):
    '''
    Read a fasta index file (.fai) into a DataFrame. The index file is
    generated by `samtools faidx` command.

    Args:
        fai_path (str): Path to the fasta index file.

    Returns:
        pl.DataFrame: polars DataFrame with the following columns:
            - id: Sequence ID.
            - length: Sequence length.
            - offset: Byte offset of the sequence in the fasta file.
            - line_bases: Number of bases per line.
            - line_width: Number of characters per line.
    '''
    cols = ["id", "length", "offset", "line_bases", "line_width"]
    return pl.read_csv(fai_path, separator="\t", has_header=False, new_columns=cols)


class Fasta:
    '''
    Read a fasta file and provide random access to the sequences.

    Args:
        fasta (str): Path to the fasta file.
        fai (str): Path to the fasta index file. If None, it is assumed to be
            `fasta + '.fai'`.
        max_len (int): Maximum length of the sequences to read.
        k_sample (int): Number of sequences to sample from the fasta file.

    Example:
    >>> fasta = Fasta('seqs.fa')
    >>> fasta[0] # Read the first sequence
    'TMQV...'
    >>> fasta['seq1'] # Read the sequence with ID 'seq1'
    'TMQV...'
    >>> len(fasta)
    1000
    '''

    def __init__(self, fasta, fai=None, max_len=None, k_sample=None):
        self.fasta = fasta

        if not Path(fasta).exists():
            raise FileNotFoundError(f"File not found: {fasta}")

        if fai is None:
            fai = fasta + '.fai'

        try:
            self.fai = read_fai(fai)
        except FileNotFoundError as e:
            raise FileNotFoundError(
                f"Please index the fasta file with samtools faidx: "
                f"`samtools faidx {fasta}`"
            ) from e

        if max_len is not None:
            self.fai = self.fai.filter(pl.col("length") <= max_len)

        if k_sample is not None:
            self.fai = self.fai.sample(k_sample)

        self.fai = self.fai.to_dicts()
        self.proteins = {row['id']: i for i, row in enumerate(self.fai)}

    def __getitem__(self, idx):
        if isinstance(idx, int):
            return self.read_seq(idx)
        elif isinstance(idx, str):
            return self.read_seq(self.proteins[idx])
        else:
            raise ValueError(f"Invalid index: {idx}")

    def read_seq(self, idx):
        row = self.fai[idx]

        with open(self.fasta) as f:
            f.seek(row['offset'])

            lines = list()

            while True:
                line = f.readline()
                if line.startswith('>') or line == '':
                    break
                lines.append(line.strip())

            seq = "".join(lines)
            assert len(seq) == row['length']

        return seq

    def __len__(self):
        return len(self.fai)
