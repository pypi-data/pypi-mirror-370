# Dynamic Versioning in Claude Wrapper

This document explains the dynamic versioning system implemented in Claude Wrapper, which provides automated version management based on git tags and package metadata.

## Overview

Claude Wrapper uses a modern dynamic versioning approach that:

- **Eliminates manual version updates** across multiple files
- **Uses git tags as the single source of truth** for releases
- **Automatically generates development versions** from git metadata
- **Provides runtime version access** for debugging and display
- **Ensures version consistency** across all application components

## How It Works

The versioning system follows this priority hierarchy:

1. **Package Metadata** (highest priority)
   - Used when installed via `pip`, `uv`, or similar
   - Retrieved via `importlib.metadata.version()`
   - Most reliable for production deployments

2. **Git Metadata** (development)
   - Used during development with git repository
   - Generated by `hatch-vcs` from git tags and commits
   - Automatically creates development versions

3. **Fallback Version** (lowest priority)
   - Used when neither source is available
   - Provides warning about static version usage
   - Ensures application still functions

## Usage

### Accessing Version Information

```python
from claude_wrapper import __version__, get_version, get_version_info

# Simple version access
print(f"Version: {__version__}")

# Dynamic version function
current_version = get_version()

# Comprehensive version information
info = get_version_info()
print(f"Version: {info['version']}")
print(f"Source: {info['source']}")
```

### Version Information Structure

The `get_version_info()` function returns:

```python
{
    "version": "0.1.0",              # Current version
    "git_version": "0.1.0",          # Version from git (if available)
    "package_version": None,         # Version from package (if installed)
    "source": "git_metadata"        # Source used for version
}
```

### CLI Version Command

```bash
claude-wrapper version
# Output: Claude Wrapper v0.1.0
#         âœ“ Claude CLI is installed and authenticated
```

### API Version Endpoint

```bash
curl http://localhost:8000/
# Returns: {"message": "Claude Wrapper API", "version": "0.1.0", ...}
```

## Development Workflow

### Setting Up Development Environment

1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd claude-wrapper
   ```

2. **Install in development mode using uv**:
   ```bash
   # Modern uv workflow (recommended)
   uv sync --dev

   # Traditional approach (if needed)
   uv venv
   source .venv/bin/activate  # or .venv\Scripts\activate on Windows
   uv pip install -e ".[dev]"
   ```

3. **Verify version system**:
   ```bash
   # Quick version check
   uv run python -c "from claude_wrapper import __version__; print(__version__)"

   # Comprehensive validation
   uv run python scripts/version_info.py --validate-build

   # Detailed diagnostics
   uv run python scripts/version_info.py --verbose
   ```

### Creating Releases

1. **Create and push a git tag**:
   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```

2. **Build the package**:
   ```bash
   uv build
   ```

3. **The version is automatically determined from the git tag**

### Version Consistency Checking

Use the provided utility script to check version consistency:

```bash
# Check if version information is consistent
uv run python scripts/version_info.py --check

# Comprehensive build validation (recommended before releases)
uv run python scripts/version_info.py --validate-build

# Get detailed version information
uv run python scripts/version_info.py --verbose

# Get JSON output for automation
uv run python scripts/version_info.py --json
```

## uv Integration

Claude Wrapper is optimized for the modern `uv` workflow, providing 10-100x faster installs and builds compared to traditional pip workflows.

### Key uv Commands

```bash
# Install dependencies (replaces pip install -e .)
uv sync --dev

# Run Python with proper environment (replaces python)
uv run python -c "from claude_wrapper import __version__; print(__version__)"

# Build package (replaces python -m build)
uv build

# Run tests with proper environment
uv run pytest

# Run any script with dependencies available
uv run python scripts/version_info.py --validate-build
```

### Performance Benefits

- **Lightning-fast installs**: 10-100x faster than pip
- **Parallel resolution**: Resolves dependencies in parallel
- **Smart caching**: Caches builds and dependencies
- **Consistent environments**: Reproducible across machines

## Configuration

### pyproject.toml Configuration

The dynamic versioning is configured in `pyproject.toml`:

```toml
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[project]
name = "claude-wrapper"
dynamic = ["version"]

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
local_scheme = "no-local-version"
```

### Key Configuration Options

- **`dynamic = ["version"]`**: Tells hatchling to determine version dynamically
- **`source = "vcs"`**: Use version control system (git) as source
- **`local_scheme = "no-local-version"`**: Don't append local version identifiers

## Version Formats

The system generates versions in these formats:

### Released Versions (from git tags)
- `1.0.0` - Clean tag
- `1.0.1` - Patch release
- `2.0.0` - Major release

### Development Versions (between tags)
- `1.0.1.dev3+g1234567` - 3 commits past v1.0.0 tag
- `0.1.0-dev` - Fallback development version

### Pre-release Versions
- `1.0.0a1` - Alpha release
- `1.0.0b2` - Beta release
- `1.0.0rc1` - Release candidate

## Testing

### Automated Tests

The version system includes comprehensive tests:

```bash
# Run version-specific tests
pytest tests/test_version.py -v

# Run all tests including version integration
pytest
```

### Manual Testing

```bash
# Test CLI version access
claude-wrapper version

# Test API version in development
python -m claude_wrapper.api.server &
curl http://localhost:8000/

# Test package version after installation
pip install .
python -c "import claude_wrapper; print(claude_wrapper.__version__)"
```

## Troubleshooting

### Common Issues

1. **"Could not determine version" warning**:
   - Ensure you're in a git repository with tags
   - Install `hatch-vcs`: `uv pip install hatch-vcs`
   - Check git tags: `git tag --list`

2. **Version inconsistency**:
   - Run: `python scripts/version_info.py --check`
   - Reinstall in development mode: `uv pip install -e .`

3. **Import errors**:
   - Ensure `hatchling` and `hatch-vcs` are installed
   - Check Python path includes the project source

### Diagnostic Information

Use the version info script for detailed diagnostics:

```bash
python scripts/version_info.py --verbose
```

This provides information about:
- Git availability and repository status
- Package installation status
- Available version sources
- Configuration file presence

## Best Practices

### For Developers

1. **Never hardcode versions** in source code
2. **Always use git tags** for releases
3. **Test version access** after major changes
4. **Check version consistency** before releases

### For CI/CD

1. **Tag releases** in your CI pipeline
2. **Use `python scripts/version_info.py --check`** in tests
3. **Validate version format** in release workflows
4. **Test both development and installed versions**

### For Deployment

1. **Use specific version tags** for production
2. **Verify version** after deployment
3. **Monitor version consistency** across services
4. **Document version requirements** for dependencies

## Migration Guide

### From Static Versioning

If migrating from static versioning:

1. Remove hardcoded versions from source files
2. Update imports to use dynamic version functions
3. Configure `pyproject.toml` for dynamic versioning
4. Create initial git tag: `git tag v0.1.0`
5. Test version access in all components

### Updating Existing Code

Replace static version references:

```python
# Before
__version__ = "0.1.0"

# After
from claude_wrapper._version import __version__
```

Update version displays:

```python
# Before
print(f"MyApp v0.1.0")

# After
from claude_wrapper import get_version
print(f"MyApp v{get_version()}")
```

## Integration Examples

### FastAPI Application

```python
from fastapi import FastAPI
from claude_wrapper import get_version

app = FastAPI(
    title="My API",
    version=get_version(),  # Dynamic version
)

@app.get("/version")
async def version_info():
    return {"version": get_version()}
```

### CLI Application

```python
import typer
from claude_wrapper import get_version

@typer.main
def main():
    typer.echo(f"MyApp v{get_version()}")
```

### Docker Integration

```dockerfile
# Build stage includes git metadata
FROM python:3.12 as builder
COPY . /app
WORKDIR /app
RUN pip install build && python -m build

# Runtime stage uses built package
FROM python:3.12-slim
COPY --from=builder /app/dist/*.whl /tmp/
RUN pip install /tmp/*.whl
```

This ensures the built package contains the correct version metadata.
